// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.

// This is a specialised implementation of a System module loader.

"use strict";

// @ts-nocheck
/* eslint-disable */
let System, __instantiateAsync, __instantiate;

(() => {
  const r = new Map();

  System = {
    register(id, d, f) {
      r.set(id, { d, f, exp: {} });
    },
  };

  async function dI(mid, src) {
    let id = mid.replace(/\.\w+$/i, "");
    if (id.includes("./")) {
      const [o, ...ia] = id.split("/").reverse(),
        [, ...sa] = src.split("/").reverse(),
        oa = [o];
      let s = 0,
        i;
      while ((i = ia.shift())) {
        if (i === "..") s++;
        else if (i === ".") break;
        else oa.push(i);
      }
      if (s < sa.length) oa.push(...sa.slice(s));
      id = oa.reverse().join("/");
    }
    return r.has(id) ? gExpA(id) : import(mid);
  }

  function gC(id, main) {
    return {
      id,
      import: (m) => dI(m, id),
      meta: { url: id, main },
    };
  }

  function gE(exp) {
    return (id, v) => {
      v = typeof id === "string" ? { [id]: v } : id;
      for (const [id, value] of Object.entries(v)) {
        Object.defineProperty(exp, id, {
          value,
          writable: true,
          enumerable: true,
        });
      }
    };
  }

  function rF(main) {
    for (const [id, m] of r.entries()) {
      const { f, exp } = m;
      const { execute: e, setters: s } = f(gE(exp), gC(id, id === main));
      delete m.f;
      m.e = e;
      m.s = s;
    }
  }

  async function gExpA(id) {
    if (!r.has(id)) return;
    const m = r.get(id);
    if (m.s) {
      const { d, e, s } = m;
      delete m.s;
      delete m.e;
      for (let i = 0; i < s.length; i++) s[i](await gExpA(d[i]));
      const r = e();
      if (r) await r;
    }
    return m.exp;
  }

  function gExp(id) {
    if (!r.has(id)) return;
    const m = r.get(id);
    if (m.s) {
      const { d, e, s } = m;
      delete m.s;
      delete m.e;
      for (let i = 0; i < s.length; i++) s[i](gExp(d[i]));
      e();
    }
    return m.exp;
  }

  __instantiateAsync = async (m) => {
    System = __instantiateAsync = __instantiate = undefined;
    rF(m);
    return gExpA(m);
  };

  __instantiate = (m) => {
    System = __instantiateAsync = __instantiate = undefined;
    rF(m);
    return gExp(m);
  };
})();

// Copyright the Browserify authors. MIT License.
// Ported from https://github.com/browserify/path-browserify/
/** This module is browser compatible. */
System.register("https://deno.land/std@0.57.0/path/_constants", [], function (exports_1, context_1) {
    "use strict";
    var CHAR_UPPERCASE_A, CHAR_LOWERCASE_A, CHAR_UPPERCASE_Z, CHAR_LOWERCASE_Z, CHAR_DOT, CHAR_FORWARD_SLASH, CHAR_BACKWARD_SLASH, CHAR_VERTICAL_LINE, CHAR_COLON, CHAR_QUESTION_MARK, CHAR_UNDERSCORE, CHAR_LINE_FEED, CHAR_CARRIAGE_RETURN, CHAR_TAB, CHAR_FORM_FEED, CHAR_EXCLAMATION_MARK, CHAR_HASH, CHAR_SPACE, CHAR_NO_BREAK_SPACE, CHAR_ZERO_WIDTH_NOBREAK_SPACE, CHAR_LEFT_SQUARE_BRACKET, CHAR_RIGHT_SQUARE_BRACKET, CHAR_LEFT_ANGLE_BRACKET, CHAR_RIGHT_ANGLE_BRACKET, CHAR_LEFT_CURLY_BRACKET, CHAR_RIGHT_CURLY_BRACKET, CHAR_HYPHEN_MINUS, CHAR_PLUS, CHAR_DOUBLE_QUOTE, CHAR_SINGLE_QUOTE, CHAR_PERCENT, CHAR_SEMICOLON, CHAR_CIRCUMFLEX_ACCENT, CHAR_GRAVE_ACCENT, CHAR_AT, CHAR_AMPERSAND, CHAR_EQUAL, CHAR_0, CHAR_9, navigator, isWindows;
    var __moduleName = context_1 && context_1.id;
    return {
        setters: [],
        execute: function () {
            // Alphabet chars.
            exports_1("CHAR_UPPERCASE_A", CHAR_UPPERCASE_A = 65); /* A */
            exports_1("CHAR_LOWERCASE_A", CHAR_LOWERCASE_A = 97); /* a */
            exports_1("CHAR_UPPERCASE_Z", CHAR_UPPERCASE_Z = 90); /* Z */
            exports_1("CHAR_LOWERCASE_Z", CHAR_LOWERCASE_Z = 122); /* z */
            // Non-alphabetic chars.
            exports_1("CHAR_DOT", CHAR_DOT = 46); /* . */
            exports_1("CHAR_FORWARD_SLASH", CHAR_FORWARD_SLASH = 47); /* / */
            exports_1("CHAR_BACKWARD_SLASH", CHAR_BACKWARD_SLASH = 92); /* \ */
            exports_1("CHAR_VERTICAL_LINE", CHAR_VERTICAL_LINE = 124); /* | */
            exports_1("CHAR_COLON", CHAR_COLON = 58); /* : */
            exports_1("CHAR_QUESTION_MARK", CHAR_QUESTION_MARK = 63); /* ? */
            exports_1("CHAR_UNDERSCORE", CHAR_UNDERSCORE = 95); /* _ */
            exports_1("CHAR_LINE_FEED", CHAR_LINE_FEED = 10); /* \n */
            exports_1("CHAR_CARRIAGE_RETURN", CHAR_CARRIAGE_RETURN = 13); /* \r */
            exports_1("CHAR_TAB", CHAR_TAB = 9); /* \t */
            exports_1("CHAR_FORM_FEED", CHAR_FORM_FEED = 12); /* \f */
            exports_1("CHAR_EXCLAMATION_MARK", CHAR_EXCLAMATION_MARK = 33); /* ! */
            exports_1("CHAR_HASH", CHAR_HASH = 35); /* # */
            exports_1("CHAR_SPACE", CHAR_SPACE = 32); /*   */
            exports_1("CHAR_NO_BREAK_SPACE", CHAR_NO_BREAK_SPACE = 160); /* \u00A0 */
            exports_1("CHAR_ZERO_WIDTH_NOBREAK_SPACE", CHAR_ZERO_WIDTH_NOBREAK_SPACE = 65279); /* \uFEFF */
            exports_1("CHAR_LEFT_SQUARE_BRACKET", CHAR_LEFT_SQUARE_BRACKET = 91); /* [ */
            exports_1("CHAR_RIGHT_SQUARE_BRACKET", CHAR_RIGHT_SQUARE_BRACKET = 93); /* ] */
            exports_1("CHAR_LEFT_ANGLE_BRACKET", CHAR_LEFT_ANGLE_BRACKET = 60); /* < */
            exports_1("CHAR_RIGHT_ANGLE_BRACKET", CHAR_RIGHT_ANGLE_BRACKET = 62); /* > */
            exports_1("CHAR_LEFT_CURLY_BRACKET", CHAR_LEFT_CURLY_BRACKET = 123); /* { */
            exports_1("CHAR_RIGHT_CURLY_BRACKET", CHAR_RIGHT_CURLY_BRACKET = 125); /* } */
            exports_1("CHAR_HYPHEN_MINUS", CHAR_HYPHEN_MINUS = 45); /* - */
            exports_1("CHAR_PLUS", CHAR_PLUS = 43); /* + */
            exports_1("CHAR_DOUBLE_QUOTE", CHAR_DOUBLE_QUOTE = 34); /* " */
            exports_1("CHAR_SINGLE_QUOTE", CHAR_SINGLE_QUOTE = 39); /* ' */
            exports_1("CHAR_PERCENT", CHAR_PERCENT = 37); /* % */
            exports_1("CHAR_SEMICOLON", CHAR_SEMICOLON = 59); /* ; */
            exports_1("CHAR_CIRCUMFLEX_ACCENT", CHAR_CIRCUMFLEX_ACCENT = 94); /* ^ */
            exports_1("CHAR_GRAVE_ACCENT", CHAR_GRAVE_ACCENT = 96); /* ` */
            exports_1("CHAR_AT", CHAR_AT = 64); /* @ */
            exports_1("CHAR_AMPERSAND", CHAR_AMPERSAND = 38); /* & */
            exports_1("CHAR_EQUAL", CHAR_EQUAL = 61); /* = */
            // Digits
            exports_1("CHAR_0", CHAR_0 = 48); /* 0 */
            exports_1("CHAR_9", CHAR_9 = 57); /* 9 */
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            navigator = globalThis.navigator;
            isWindows = false;
            exports_1("isWindows", isWindows);
            if (globalThis.Deno != null) {
                exports_1("isWindows", isWindows = Deno.build.os == "windows");
            }
            else if (navigator?.appVersion != null) {
                exports_1("isWindows", isWindows = navigator.appVersion.includes("Win"));
            }
        }
    };
});
/** This module is browser compatible. */
System.register("https://deno.land/std@0.57.0/path/_interface", [], function (exports_2, context_2) {
    "use strict";
    var __moduleName = context_2 && context_2.id;
    return {
        setters: [],
        execute: function () {
        }
    };
});
// Copyright the Browserify authors. MIT License.
// Ported from https://github.com/browserify/path-browserify/
/** This module is browser compatible. */
System.register("https://deno.land/std@0.57.0/path/_util", ["https://deno.land/std@0.57.0/path/_constants"], function (exports_3, context_3) {
    "use strict";
    var _constants_ts_1;
    var __moduleName = context_3 && context_3.id;
    function assertPath(path) {
        if (typeof path !== "string") {
            throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
        }
    }
    exports_3("assertPath", assertPath);
    function isPosixPathSeparator(code) {
        return code === _constants_ts_1.CHAR_FORWARD_SLASH;
    }
    exports_3("isPosixPathSeparator", isPosixPathSeparator);
    function isPathSeparator(code) {
        return isPosixPathSeparator(code) || code === _constants_ts_1.CHAR_BACKWARD_SLASH;
    }
    exports_3("isPathSeparator", isPathSeparator);
    function isWindowsDeviceRoot(code) {
        return ((code >= _constants_ts_1.CHAR_LOWERCASE_A && code <= _constants_ts_1.CHAR_LOWERCASE_Z) ||
            (code >= _constants_ts_1.CHAR_UPPERCASE_A && code <= _constants_ts_1.CHAR_UPPERCASE_Z));
    }
    exports_3("isWindowsDeviceRoot", isWindowsDeviceRoot);
    // Resolves . and .. elements in a path with directory names
    function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
        let res = "";
        let lastSegmentLength = 0;
        let lastSlash = -1;
        let dots = 0;
        let code;
        for (let i = 0, len = path.length; i <= len; ++i) {
            if (i < len)
                code = path.charCodeAt(i);
            else if (isPathSeparator(code))
                break;
            else
                code = _constants_ts_1.CHAR_FORWARD_SLASH;
            if (isPathSeparator(code)) {
                if (lastSlash === i - 1 || dots === 1) {
                    // NOOP
                }
                else if (lastSlash !== i - 1 && dots === 2) {
                    if (res.length < 2 ||
                        lastSegmentLength !== 2 ||
                        res.charCodeAt(res.length - 1) !== _constants_ts_1.CHAR_DOT ||
                        res.charCodeAt(res.length - 2) !== _constants_ts_1.CHAR_DOT) {
                        if (res.length > 2) {
                            const lastSlashIndex = res.lastIndexOf(separator);
                            if (lastSlashIndex === -1) {
                                res = "";
                                lastSegmentLength = 0;
                            }
                            else {
                                res = res.slice(0, lastSlashIndex);
                                lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                            }
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                        else if (res.length === 2 || res.length === 1) {
                            res = "";
                            lastSegmentLength = 0;
                            lastSlash = i;
                            dots = 0;
                            continue;
                        }
                    }
                    if (allowAboveRoot) {
                        if (res.length > 0)
                            res += `${separator}..`;
                        else
                            res = "..";
                        lastSegmentLength = 2;
                    }
                }
                else {
                    if (res.length > 0)
                        res += separator + path.slice(lastSlash + 1, i);
                    else
                        res = path.slice(lastSlash + 1, i);
                    lastSegmentLength = i - lastSlash - 1;
                }
                lastSlash = i;
                dots = 0;
            }
            else if (code === _constants_ts_1.CHAR_DOT && dots !== -1) {
                ++dots;
            }
            else {
                dots = -1;
            }
        }
        return res;
    }
    exports_3("normalizeString", normalizeString);
    function _format(sep, pathObject) {
        const dir = pathObject.dir || pathObject.root;
        const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
        if (!dir)
            return base;
        if (dir === pathObject.root)
            return dir + base;
        return dir + sep + base;
    }
    exports_3("_format", _format);
    return {
        setters: [
            function (_constants_ts_1_1) {
                _constants_ts_1 = _constants_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
System.register("https://deno.land/std@0.57.0/_util/assert", [], function (exports_4, context_4) {
    "use strict";
    var DenoStdInternalError;
    var __moduleName = context_4 && context_4.id;
    /** Make an assertion, if not `true`, then throw. */
    function assert(expr, msg = "") {
        if (!expr) {
            throw new DenoStdInternalError(msg);
        }
    }
    exports_4("assert", assert);
    return {
        setters: [],
        execute: function () {
            DenoStdInternalError = class DenoStdInternalError extends Error {
                constructor(message) {
                    super(message);
                    this.name = "DenoStdInternalError";
                }
            };
            exports_4("DenoStdInternalError", DenoStdInternalError);
        }
    };
});
// Copyright the Browserify authors. MIT License.
// Ported from https://github.com/browserify/path-browserify/
/** This module is browser compatible. */
System.register("https://deno.land/std@0.57.0/path/win32", ["https://deno.land/std@0.57.0/path/_constants", "https://deno.land/std@0.57.0/path/_util", "https://deno.land/std@0.57.0/_util/assert"], function (exports_5, context_5) {
    "use strict";
    var _constants_ts_2, _util_ts_1, assert_ts_1, sep, delimiter;
    var __moduleName = context_5 && context_5.id;
    function resolve(...pathSegments) {
        let resolvedDevice = "";
        let resolvedTail = "";
        let resolvedAbsolute = false;
        for (let i = pathSegments.length - 1; i >= -1; i--) {
            let path;
            if (i >= 0) {
                path = pathSegments[i];
            }
            else if (!resolvedDevice) {
                if (globalThis.Deno == null) {
                    throw new TypeError("Resolved a drive-letter-less path without a CWD.");
                }
                path = Deno.cwd();
            }
            else {
                if (globalThis.Deno == null) {
                    throw new TypeError("Resolved a relative path without a CWD.");
                }
                // Windows has the concept of drive-specific current working
                // directories. If we've resolved a drive letter but not yet an
                // absolute path, get cwd for that drive, or the process cwd if
                // the drive cwd is not available. We're sure the device is not
                // a UNC path at this points, because UNC paths are always absolute.
                path = Deno.env.get(`=${resolvedDevice}`) || Deno.cwd();
                // Verify that a cwd was found and that it actually points
                // to our drive. If not, default to the drive's root.
                if (path === undefined ||
                    path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                    path = `${resolvedDevice}\\`;
                }
            }
            _util_ts_1.assertPath(path);
            const len = path.length;
            // Skip empty entries
            if (len === 0)
                continue;
            let rootEnd = 0;
            let device = "";
            let isAbsolute = false;
            const code = path.charCodeAt(0);
            // Try to match a root
            if (len > 1) {
                if (_util_ts_1.isPathSeparator(code)) {
                    // Possible UNC root
                    // If we started with a separator, we know we at least have an
                    // absolute path of some kind (UNC or otherwise)
                    isAbsolute = true;
                    if (_util_ts_1.isPathSeparator(path.charCodeAt(1))) {
                        // Matched double path separator at beginning
                        let j = 2;
                        let last = j;
                        // Match 1 or more non-path separators
                        for (; j < len; ++j) {
                            if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            const firstPart = path.slice(last, j);
                            // Matched!
                            last = j;
                            // Match 1 or more path separators
                            for (; j < len; ++j) {
                                if (!_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j < len && j !== last) {
                                // Matched!
                                last = j;
                                // Match 1 or more non-path separators
                                for (; j < len; ++j) {
                                    if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                        break;
                                }
                                if (j === len) {
                                    // We matched a UNC root only
                                    device = `\\\\${firstPart}\\${path.slice(last)}`;
                                    rootEnd = j;
                                }
                                else if (j !== last) {
                                    // We matched a UNC root with leftovers
                                    device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                    rootEnd = j;
                                }
                            }
                        }
                    }
                    else {
                        rootEnd = 1;
                    }
                }
                else if (_util_ts_1.isWindowsDeviceRoot(code)) {
                    // Possible device root
                    if (path.charCodeAt(1) === _constants_ts_2.CHAR_COLON) {
                        device = path.slice(0, 2);
                        rootEnd = 2;
                        if (len > 2) {
                            if (_util_ts_1.isPathSeparator(path.charCodeAt(2))) {
                                // Treat separator following drive name as an absolute path
                                // indicator
                                isAbsolute = true;
                                rootEnd = 3;
                            }
                        }
                    }
                }
            }
            else if (_util_ts_1.isPathSeparator(code)) {
                // `path` contains just a path separator
                rootEnd = 1;
                isAbsolute = true;
            }
            if (device.length > 0 &&
                resolvedDevice.length > 0 &&
                device.toLowerCase() !== resolvedDevice.toLowerCase()) {
                // This path points to another device so it is not applicable
                continue;
            }
            if (resolvedDevice.length === 0 && device.length > 0) {
                resolvedDevice = device;
            }
            if (!resolvedAbsolute) {
                resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
                resolvedAbsolute = isAbsolute;
            }
            if (resolvedAbsolute && resolvedDevice.length > 0)
                break;
        }
        // At this point the path should be resolved to a full absolute path,
        // but handle relative paths to be safe (might happen when process.cwd()
        // fails)
        // Normalize the tail path
        resolvedTail = _util_ts_1.normalizeString(resolvedTail, !resolvedAbsolute, "\\", _util_ts_1.isPathSeparator);
        return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
    }
    exports_5("resolve", resolve);
    function normalize(path) {
        _util_ts_1.assertPath(path);
        const len = path.length;
        if (len === 0)
            return ".";
        let rootEnd = 0;
        let device;
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        // Try to match a root
        if (len > 1) {
            if (_util_ts_1.isPathSeparator(code)) {
                // Possible UNC root
                // If we started with a separator, we know we at least have an absolute
                // path of some kind (UNC or otherwise)
                isAbsolute = true;
                if (_util_ts_1.isPathSeparator(path.charCodeAt(1))) {
                    // Matched double path separator at beginning
                    let j = 2;
                    let last = j;
                    // Match 1 or more non-path separators
                    for (; j < len; ++j) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                            break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        // Matched!
                        last = j;
                        // Match 1 or more path separators
                        for (; j < len; ++j) {
                            if (!_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            // Matched!
                            last = j;
                            // Match 1 or more non-path separators
                            for (; j < len; ++j) {
                                if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j === len) {
                                // We matched a UNC root only
                                // Return the normalized version of the UNC root since there
                                // is nothing left to process
                                return `\\\\${firstPart}\\${path.slice(last)}\\`;
                            }
                            else if (j !== last) {
                                // We matched a UNC root with leftovers
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                }
                else {
                    rootEnd = 1;
                }
            }
            else if (_util_ts_1.isWindowsDeviceRoot(code)) {
                // Possible device root
                if (path.charCodeAt(1) === _constants_ts_2.CHAR_COLON) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(2))) {
                            // Treat separator following drive name as an absolute path
                            // indicator
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        }
        else if (_util_ts_1.isPathSeparator(code)) {
            // `path` contains just a path separator, exit early to avoid unnecessary
            // work
            return "\\";
        }
        let tail;
        if (rootEnd < len) {
            tail = _util_ts_1.normalizeString(path.slice(rootEnd), !isAbsolute, "\\", _util_ts_1.isPathSeparator);
        }
        else {
            tail = "";
        }
        if (tail.length === 0 && !isAbsolute)
            tail = ".";
        if (tail.length > 0 && _util_ts_1.isPathSeparator(path.charCodeAt(len - 1))) {
            tail += "\\";
        }
        if (device === undefined) {
            if (isAbsolute) {
                if (tail.length > 0)
                    return `\\${tail}`;
                else
                    return "\\";
            }
            else if (tail.length > 0) {
                return tail;
            }
            else {
                return "";
            }
        }
        else if (isAbsolute) {
            if (tail.length > 0)
                return `${device}\\${tail}`;
            else
                return `${device}\\`;
        }
        else if (tail.length > 0) {
            return device + tail;
        }
        else {
            return device;
        }
    }
    exports_5("normalize", normalize);
    function isAbsolute(path) {
        _util_ts_1.assertPath(path);
        const len = path.length;
        if (len === 0)
            return false;
        const code = path.charCodeAt(0);
        if (_util_ts_1.isPathSeparator(code)) {
            return true;
        }
        else if (_util_ts_1.isWindowsDeviceRoot(code)) {
            // Possible device root
            if (len > 2 && path.charCodeAt(1) === _constants_ts_2.CHAR_COLON) {
                if (_util_ts_1.isPathSeparator(path.charCodeAt(2)))
                    return true;
            }
        }
        return false;
    }
    exports_5("isAbsolute", isAbsolute);
    function join(...paths) {
        const pathsCount = paths.length;
        if (pathsCount === 0)
            return ".";
        let joined;
        let firstPart = null;
        for (let i = 0; i < pathsCount; ++i) {
            const path = paths[i];
            _util_ts_1.assertPath(path);
            if (path.length > 0) {
                if (joined === undefined)
                    joined = firstPart = path;
                else
                    joined += `\\${path}`;
            }
        }
        if (joined === undefined)
            return ".";
        // Make sure that the joined path doesn't start with two slashes, because
        // normalize() will mistake it for an UNC path then.
        //
        // This step is skipped when it is very clear that the user actually
        // intended to point at an UNC path. This is assumed when the first
        // non-empty string arguments starts with exactly two slashes followed by
        // at least one more non-slash character.
        //
        // Note that for normalize() to treat a path as an UNC path it needs to
        // have at least 2 components, so we don't filter for that here.
        // This means that the user can use join to construct UNC paths from
        // a server name and a share name; for example:
        //   path.join('//server', 'share') -> '\\\\server\\share\\')
        let needsReplace = true;
        let slashCount = 0;
        assert_ts_1.assert(firstPart != null);
        if (_util_ts_1.isPathSeparator(firstPart.charCodeAt(0))) {
            ++slashCount;
            const firstLen = firstPart.length;
            if (firstLen > 1) {
                if (_util_ts_1.isPathSeparator(firstPart.charCodeAt(1))) {
                    ++slashCount;
                    if (firstLen > 2) {
                        if (_util_ts_1.isPathSeparator(firstPart.charCodeAt(2)))
                            ++slashCount;
                        else {
                            // We matched a UNC path in the first part
                            needsReplace = false;
                        }
                    }
                }
            }
        }
        if (needsReplace) {
            // Find any more consecutive slashes we need to replace
            for (; slashCount < joined.length; ++slashCount) {
                if (!_util_ts_1.isPathSeparator(joined.charCodeAt(slashCount)))
                    break;
            }
            // Replace the slashes if needed
            if (slashCount >= 2)
                joined = `\\${joined.slice(slashCount)}`;
        }
        return normalize(joined);
    }
    exports_5("join", join);
    // It will solve the relative path from `from` to `to`, for instance:
    //  from = 'C:\\orandea\\test\\aaa'
    //  to = 'C:\\orandea\\impl\\bbb'
    // The output of the function should be: '..\\..\\impl\\bbb'
    function relative(from, to) {
        _util_ts_1.assertPath(from);
        _util_ts_1.assertPath(to);
        if (from === to)
            return "";
        const fromOrig = resolve(from);
        const toOrig = resolve(to);
        if (fromOrig === toOrig)
            return "";
        from = fromOrig.toLowerCase();
        to = toOrig.toLowerCase();
        if (from === to)
            return "";
        // Trim any leading backslashes
        let fromStart = 0;
        let fromEnd = from.length;
        for (; fromStart < fromEnd; ++fromStart) {
            if (from.charCodeAt(fromStart) !== _constants_ts_2.CHAR_BACKWARD_SLASH)
                break;
        }
        // Trim trailing backslashes (applicable to UNC paths only)
        for (; fromEnd - 1 > fromStart; --fromEnd) {
            if (from.charCodeAt(fromEnd - 1) !== _constants_ts_2.CHAR_BACKWARD_SLASH)
                break;
        }
        const fromLen = fromEnd - fromStart;
        // Trim any leading backslashes
        let toStart = 0;
        let toEnd = to.length;
        for (; toStart < toEnd; ++toStart) {
            if (to.charCodeAt(toStart) !== _constants_ts_2.CHAR_BACKWARD_SLASH)
                break;
        }
        // Trim trailing backslashes (applicable to UNC paths only)
        for (; toEnd - 1 > toStart; --toEnd) {
            if (to.charCodeAt(toEnd - 1) !== _constants_ts_2.CHAR_BACKWARD_SLASH)
                break;
        }
        const toLen = toEnd - toStart;
        // Compare paths to find the longest common path from root
        const length = fromLen < toLen ? fromLen : toLen;
        let lastCommonSep = -1;
        let i = 0;
        for (; i <= length; ++i) {
            if (i === length) {
                if (toLen > length) {
                    if (to.charCodeAt(toStart + i) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                        // We get here if `from` is the exact base path for `to`.
                        // For example: from='C:\\foo\\bar'; to='C:\\foo\\bar\\baz'
                        return toOrig.slice(toStart + i + 1);
                    }
                    else if (i === 2) {
                        // We get here if `from` is the device root.
                        // For example: from='C:\\'; to='C:\\foo'
                        return toOrig.slice(toStart + i);
                    }
                }
                if (fromLen > length) {
                    if (from.charCodeAt(fromStart + i) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                        // We get here if `to` is the exact base path for `from`.
                        // For example: from='C:\\foo\\bar'; to='C:\\foo'
                        lastCommonSep = i;
                    }
                    else if (i === 2) {
                        // We get here if `to` is the device root.
                        // For example: from='C:\\foo\\bar'; to='C:\\'
                        lastCommonSep = 3;
                    }
                }
                break;
            }
            const fromCode = from.charCodeAt(fromStart + i);
            const toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode)
                break;
            else if (fromCode === _constants_ts_2.CHAR_BACKWARD_SLASH)
                lastCommonSep = i;
        }
        // We found a mismatch before the first common path separator was seen, so
        // return the original `to`.
        if (i !== length && lastCommonSep === -1) {
            return toOrig;
        }
        let out = "";
        if (lastCommonSep === -1)
            lastCommonSep = 0;
        // Generate the relative path based on the path difference between `to` and
        // `from`
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                if (out.length === 0)
                    out += "..";
                else
                    out += "\\..";
            }
        }
        // Lastly, append the rest of the destination (`to`) path that comes after
        // the common path parts
        if (out.length > 0) {
            return out + toOrig.slice(toStart + lastCommonSep, toEnd);
        }
        else {
            toStart += lastCommonSep;
            if (toOrig.charCodeAt(toStart) === _constants_ts_2.CHAR_BACKWARD_SLASH)
                ++toStart;
            return toOrig.slice(toStart, toEnd);
        }
    }
    exports_5("relative", relative);
    function toNamespacedPath(path) {
        // Note: this will *probably* throw somewhere.
        if (typeof path !== "string")
            return path;
        if (path.length === 0)
            return "";
        const resolvedPath = resolve(path);
        if (resolvedPath.length >= 3) {
            if (resolvedPath.charCodeAt(0) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                // Possible UNC root
                if (resolvedPath.charCodeAt(1) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                    const code = resolvedPath.charCodeAt(2);
                    if (code !== _constants_ts_2.CHAR_QUESTION_MARK && code !== _constants_ts_2.CHAR_DOT) {
                        // Matched non-long UNC root, convert the path to a long UNC path
                        return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                    }
                }
            }
            else if (_util_ts_1.isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
                // Possible device root
                if (resolvedPath.charCodeAt(1) === _constants_ts_2.CHAR_COLON &&
                    resolvedPath.charCodeAt(2) === _constants_ts_2.CHAR_BACKWARD_SLASH) {
                    // Matched device root, convert the path to a long UNC path
                    return `\\\\?\\${resolvedPath}`;
                }
            }
        }
        return path;
    }
    exports_5("toNamespacedPath", toNamespacedPath);
    function dirname(path) {
        _util_ts_1.assertPath(path);
        const len = path.length;
        if (len === 0)
            return ".";
        let rootEnd = -1;
        let end = -1;
        let matchedSlash = true;
        let offset = 0;
        const code = path.charCodeAt(0);
        // Try to match a root
        if (len > 1) {
            if (_util_ts_1.isPathSeparator(code)) {
                // Possible UNC root
                rootEnd = offset = 1;
                if (_util_ts_1.isPathSeparator(path.charCodeAt(1))) {
                    // Matched double path separator at beginning
                    let j = 2;
                    let last = j;
                    // Match 1 or more non-path separators
                    for (; j < len; ++j) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                            break;
                    }
                    if (j < len && j !== last) {
                        // Matched!
                        last = j;
                        // Match 1 or more path separators
                        for (; j < len; ++j) {
                            if (!_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            // Matched!
                            last = j;
                            // Match 1 or more non-path separators
                            for (; j < len; ++j) {
                                if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j === len) {
                                // We matched a UNC root only
                                return path;
                            }
                            if (j !== last) {
                                // We matched a UNC root with leftovers
                                // Offset by 1 to include the separator after the UNC root to
                                // treat it as a "normal root" on top of a (UNC) root
                                rootEnd = offset = j + 1;
                            }
                        }
                    }
                }
            }
            else if (_util_ts_1.isWindowsDeviceRoot(code)) {
                // Possible device root
                if (path.charCodeAt(1) === _constants_ts_2.CHAR_COLON) {
                    rootEnd = offset = 2;
                    if (len > 2) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(2)))
                            rootEnd = offset = 3;
                    }
                }
            }
        }
        else if (_util_ts_1.isPathSeparator(code)) {
            // `path` contains just a path separator, exit early to avoid
            // unnecessary work
            return path;
        }
        for (let i = len - 1; i >= offset; --i) {
            if (_util_ts_1.isPathSeparator(path.charCodeAt(i))) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            }
            else {
                // We saw the first non-path separator
                matchedSlash = false;
            }
        }
        if (end === -1) {
            if (rootEnd === -1)
                return ".";
            else
                end = rootEnd;
        }
        return path.slice(0, end);
    }
    exports_5("dirname", dirname);
    function basename(path, ext = "") {
        if (ext !== undefined && typeof ext !== "string") {
            throw new TypeError('"ext" argument must be a string');
        }
        _util_ts_1.assertPath(path);
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        // Check for a drive letter prefix so as not to mistake the following
        // path separator as an extra separator at the end of the path that can be
        // disregarded
        if (path.length >= 2) {
            const drive = path.charCodeAt(0);
            if (_util_ts_1.isWindowsDeviceRoot(drive)) {
                if (path.charCodeAt(1) === _constants_ts_2.CHAR_COLON)
                    start = 2;
            }
        }
        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
            if (ext.length === path.length && ext === path)
                return "";
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= start; --i) {
                const code = path.charCodeAt(i);
                if (_util_ts_1.isPathSeparator(code)) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else {
                    if (firstNonSlashEnd === -1) {
                        // We saw the first non-path separator, remember this index in case
                        // we need it if the extension ends up not matching
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        // Try to match the explicit extension
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) {
                                // We matched the extension, so mark this as the end of our path
                                // component
                                end = i;
                            }
                        }
                        else {
                            // Extension does not match, so our result is the entire path
                            // component
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end)
                end = firstNonSlashEnd;
            else if (end === -1)
                end = path.length;
            return path.slice(start, end);
        }
        else {
            for (i = path.length - 1; i >= start; --i) {
                if (_util_ts_1.isPathSeparator(path.charCodeAt(i))) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else if (end === -1) {
                    // We saw the first non-path separator, mark this as the end of our
                    // path component
                    matchedSlash = false;
                    end = i + 1;
                }
            }
            if (end === -1)
                return "";
            return path.slice(start, end);
        }
    }
    exports_5("basename", basename);
    function extname(path) {
        _util_ts_1.assertPath(path);
        let start = 0;
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        let preDotState = 0;
        // Check for a drive letter prefix so as not to mistake the following
        // path separator as an extra separator at the end of the path that can be
        // disregarded
        if (path.length >= 2 &&
            path.charCodeAt(1) === _constants_ts_2.CHAR_COLON &&
            _util_ts_1.isWindowsDeviceRoot(path.charCodeAt(0))) {
            start = startPart = 2;
        }
        for (let i = path.length - 1; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (_util_ts_1.isPathSeparator(code)) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_2.CHAR_DOT) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                // We saw a non-dot and non-path separator before our dot, so we should
                // have a good chance at having a non-empty extension
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            // We saw a non-dot character immediately before the dot
            preDotState === 0 ||
            // The (right-most) trimmed path component is exactly '..'
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            return "";
        }
        return path.slice(startDot, end);
    }
    exports_5("extname", extname);
    function format(pathObject) {
        /* eslint-disable max-len */
        if (pathObject === null || typeof pathObject !== "object") {
            throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
        }
        return _util_ts_1._format("\\", pathObject);
    }
    exports_5("format", format);
    function parse(path) {
        _util_ts_1.assertPath(path);
        const ret = { root: "", dir: "", base: "", ext: "", name: "" };
        const len = path.length;
        if (len === 0)
            return ret;
        let rootEnd = 0;
        let code = path.charCodeAt(0);
        // Try to match a root
        if (len > 1) {
            if (_util_ts_1.isPathSeparator(code)) {
                // Possible UNC root
                rootEnd = 1;
                if (_util_ts_1.isPathSeparator(path.charCodeAt(1))) {
                    // Matched double path separator at beginning
                    let j = 2;
                    let last = j;
                    // Match 1 or more non-path separators
                    for (; j < len; ++j) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                            break;
                    }
                    if (j < len && j !== last) {
                        // Matched!
                        last = j;
                        // Match 1 or more path separators
                        for (; j < len; ++j) {
                            if (!_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                break;
                        }
                        if (j < len && j !== last) {
                            // Matched!
                            last = j;
                            // Match 1 or more non-path separators
                            for (; j < len; ++j) {
                                if (_util_ts_1.isPathSeparator(path.charCodeAt(j)))
                                    break;
                            }
                            if (j === len) {
                                // We matched a UNC root only
                                rootEnd = j;
                            }
                            else if (j !== last) {
                                // We matched a UNC root with leftovers
                                rootEnd = j + 1;
                            }
                        }
                    }
                }
            }
            else if (_util_ts_1.isWindowsDeviceRoot(code)) {
                // Possible device root
                if (path.charCodeAt(1) === _constants_ts_2.CHAR_COLON) {
                    rootEnd = 2;
                    if (len > 2) {
                        if (_util_ts_1.isPathSeparator(path.charCodeAt(2))) {
                            if (len === 3) {
                                // `path` contains just a drive root, exit early to avoid
                                // unnecessary work
                                ret.root = ret.dir = path;
                                return ret;
                            }
                            rootEnd = 3;
                        }
                    }
                    else {
                        // `path` contains just a drive root, exit early to avoid
                        // unnecessary work
                        ret.root = ret.dir = path;
                        return ret;
                    }
                }
            }
        }
        else if (_util_ts_1.isPathSeparator(code)) {
            // `path` contains just a path separator, exit early to avoid
            // unnecessary work
            ret.root = ret.dir = path;
            return ret;
        }
        if (rootEnd > 0)
            ret.root = path.slice(0, rootEnd);
        let startDot = -1;
        let startPart = rootEnd;
        let end = -1;
        let matchedSlash = true;
        let i = path.length - 1;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        let preDotState = 0;
        // Get non-dir info
        for (; i >= rootEnd; --i) {
            code = path.charCodeAt(i);
            if (_util_ts_1.isPathSeparator(code)) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_2.CHAR_DOT) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                // We saw a non-dot and non-path separator before our dot, so we should
                // have a good chance at having a non-empty extension
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            // We saw a non-dot character immediately before the dot
            preDotState === 0 ||
            // The (right-most) trimmed path component is exactly '..'
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            if (end !== -1) {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
        else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
            ret.ext = path.slice(startDot, end);
        }
        // If the directory is the root, use the entire root as the `dir` including
        // the trailing slash if any (`C:\abc` -> `C:\`). Otherwise, strip out the
        // trailing slash (`C:\abc\def` -> `C:\abc`).
        if (startPart > 0 && startPart !== rootEnd) {
            ret.dir = path.slice(0, startPart - 1);
        }
        else
            ret.dir = ret.root;
        return ret;
    }
    exports_5("parse", parse);
    /** Converts a file URL to a path string.
     *
     *      fromFileUrl("file:///C:/Users/foo"); // "C:\\Users\\foo"
     *      fromFileUrl("file:///home/foo"); // "\\home\\foo"
     *
     * Note that non-file URLs are treated as file URLs and irrelevant components
     * are ignored.
     */
    function fromFileUrl(url) {
        return new URL(url).pathname
            .replace(/^\/*([A-Za-z]:)(\/|$)/, "$1/")
            .replace(/\//g, "\\");
    }
    exports_5("fromFileUrl", fromFileUrl);
    return {
        setters: [
            function (_constants_ts_2_1) {
                _constants_ts_2 = _constants_ts_2_1;
            },
            function (_util_ts_1_1) {
                _util_ts_1 = _util_ts_1_1;
            },
            function (assert_ts_1_1) {
                assert_ts_1 = assert_ts_1_1;
            }
        ],
        execute: function () {
            exports_5("sep", sep = "\\");
            exports_5("delimiter", delimiter = ";");
        }
    };
});
// Copyright the Browserify authors. MIT License.
// Ported from https://github.com/browserify/path-browserify/
/** This module is browser compatible. */
System.register("https://deno.land/std@0.57.0/path/posix", ["https://deno.land/std@0.57.0/path/_constants", "https://deno.land/std@0.57.0/path/_util"], function (exports_6, context_6) {
    "use strict";
    var _constants_ts_3, _util_ts_2, sep, delimiter;
    var __moduleName = context_6 && context_6.id;
    // path.resolve([from ...], to)
    function resolve(...pathSegments) {
        let resolvedPath = "";
        let resolvedAbsolute = false;
        for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            let path;
            if (i >= 0)
                path = pathSegments[i];
            else {
                if (globalThis.Deno == null) {
                    throw new TypeError("Resolved a relative path without a CWD.");
                }
                path = Deno.cwd();
            }
            _util_ts_2.assertPath(path);
            // Skip empty entries
            if (path.length === 0) {
                continue;
            }
            resolvedPath = `${path}/${resolvedPath}`;
            resolvedAbsolute = path.charCodeAt(0) === _constants_ts_3.CHAR_FORWARD_SLASH;
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        // Normalize the path
        resolvedPath = _util_ts_2.normalizeString(resolvedPath, !resolvedAbsolute, "/", _util_ts_2.isPosixPathSeparator);
        if (resolvedAbsolute) {
            if (resolvedPath.length > 0)
                return `/${resolvedPath}`;
            else
                return "/";
        }
        else if (resolvedPath.length > 0)
            return resolvedPath;
        else
            return ".";
    }
    exports_6("resolve", resolve);
    function normalize(path) {
        _util_ts_2.assertPath(path);
        if (path.length === 0)
            return ".";
        const isAbsolute = path.charCodeAt(0) === _constants_ts_3.CHAR_FORWARD_SLASH;
        const trailingSeparator = path.charCodeAt(path.length - 1) === _constants_ts_3.CHAR_FORWARD_SLASH;
        // Normalize the path
        path = _util_ts_2.normalizeString(path, !isAbsolute, "/", _util_ts_2.isPosixPathSeparator);
        if (path.length === 0 && !isAbsolute)
            path = ".";
        if (path.length > 0 && trailingSeparator)
            path += "/";
        if (isAbsolute)
            return `/${path}`;
        return path;
    }
    exports_6("normalize", normalize);
    function isAbsolute(path) {
        _util_ts_2.assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === _constants_ts_3.CHAR_FORWARD_SLASH;
    }
    exports_6("isAbsolute", isAbsolute);
    function join(...paths) {
        if (paths.length === 0)
            return ".";
        let joined;
        for (let i = 0, len = paths.length; i < len; ++i) {
            const path = paths[i];
            _util_ts_2.assertPath(path);
            if (path.length > 0) {
                if (!joined)
                    joined = path;
                else
                    joined += `/${path}`;
            }
        }
        if (!joined)
            return ".";
        return normalize(joined);
    }
    exports_6("join", join);
    function relative(from, to) {
        _util_ts_2.assertPath(from);
        _util_ts_2.assertPath(to);
        if (from === to)
            return "";
        from = resolve(from);
        to = resolve(to);
        if (from === to)
            return "";
        // Trim any leading backslashes
        let fromStart = 1;
        const fromEnd = from.length;
        for (; fromStart < fromEnd; ++fromStart) {
            if (from.charCodeAt(fromStart) !== _constants_ts_3.CHAR_FORWARD_SLASH)
                break;
        }
        const fromLen = fromEnd - fromStart;
        // Trim any leading backslashes
        let toStart = 1;
        const toEnd = to.length;
        for (; toStart < toEnd; ++toStart) {
            if (to.charCodeAt(toStart) !== _constants_ts_3.CHAR_FORWARD_SLASH)
                break;
        }
        const toLen = toEnd - toStart;
        // Compare paths to find the longest common path from root
        const length = fromLen < toLen ? fromLen : toLen;
        let lastCommonSep = -1;
        let i = 0;
        for (; i <= length; ++i) {
            if (i === length) {
                if (toLen > length) {
                    if (to.charCodeAt(toStart + i) === _constants_ts_3.CHAR_FORWARD_SLASH) {
                        // We get here if `from` is the exact base path for `to`.
                        // For example: from='/foo/bar'; to='/foo/bar/baz'
                        return to.slice(toStart + i + 1);
                    }
                    else if (i === 0) {
                        // We get here if `from` is the root
                        // For example: from='/'; to='/foo'
                        return to.slice(toStart + i);
                    }
                }
                else if (fromLen > length) {
                    if (from.charCodeAt(fromStart + i) === _constants_ts_3.CHAR_FORWARD_SLASH) {
                        // We get here if `to` is the exact base path for `from`.
                        // For example: from='/foo/bar/baz'; to='/foo/bar'
                        lastCommonSep = i;
                    }
                    else if (i === 0) {
                        // We get here if `to` is the root.
                        // For example: from='/foo'; to='/'
                        lastCommonSep = 0;
                    }
                }
                break;
            }
            const fromCode = from.charCodeAt(fromStart + i);
            const toCode = to.charCodeAt(toStart + i);
            if (fromCode !== toCode)
                break;
            else if (fromCode === _constants_ts_3.CHAR_FORWARD_SLASH)
                lastCommonSep = i;
        }
        let out = "";
        // Generate the relative path based on the path difference between `to`
        // and `from`
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
            if (i === fromEnd || from.charCodeAt(i) === _constants_ts_3.CHAR_FORWARD_SLASH) {
                if (out.length === 0)
                    out += "..";
                else
                    out += "/..";
            }
        }
        // Lastly, append the rest of the destination (`to`) path that comes after
        // the common path parts
        if (out.length > 0)
            return out + to.slice(toStart + lastCommonSep);
        else {
            toStart += lastCommonSep;
            if (to.charCodeAt(toStart) === _constants_ts_3.CHAR_FORWARD_SLASH)
                ++toStart;
            return to.slice(toStart);
        }
    }
    exports_6("relative", relative);
    function toNamespacedPath(path) {
        // Non-op on posix systems
        return path;
    }
    exports_6("toNamespacedPath", toNamespacedPath);
    function dirname(path) {
        _util_ts_2.assertPath(path);
        if (path.length === 0)
            return ".";
        const hasRoot = path.charCodeAt(0) === _constants_ts_3.CHAR_FORWARD_SLASH;
        let end = -1;
        let matchedSlash = true;
        for (let i = path.length - 1; i >= 1; --i) {
            if (path.charCodeAt(i) === _constants_ts_3.CHAR_FORWARD_SLASH) {
                if (!matchedSlash) {
                    end = i;
                    break;
                }
            }
            else {
                // We saw the first non-path separator
                matchedSlash = false;
            }
        }
        if (end === -1)
            return hasRoot ? "/" : ".";
        if (hasRoot && end === 1)
            return "//";
        return path.slice(0, end);
    }
    exports_6("dirname", dirname);
    function basename(path, ext = "") {
        if (ext !== undefined && typeof ext !== "string") {
            throw new TypeError('"ext" argument must be a string');
        }
        _util_ts_2.assertPath(path);
        let start = 0;
        let end = -1;
        let matchedSlash = true;
        let i;
        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
            if (ext.length === path.length && ext === path)
                return "";
            let extIdx = ext.length - 1;
            let firstNonSlashEnd = -1;
            for (i = path.length - 1; i >= 0; --i) {
                const code = path.charCodeAt(i);
                if (code === _constants_ts_3.CHAR_FORWARD_SLASH) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else {
                    if (firstNonSlashEnd === -1) {
                        // We saw the first non-path separator, remember this index in case
                        // we need it if the extension ends up not matching
                        matchedSlash = false;
                        firstNonSlashEnd = i + 1;
                    }
                    if (extIdx >= 0) {
                        // Try to match the explicit extension
                        if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) {
                                // We matched the extension, so mark this as the end of our path
                                // component
                                end = i;
                            }
                        }
                        else {
                            // Extension does not match, so our result is the entire path
                            // component
                            extIdx = -1;
                            end = firstNonSlashEnd;
                        }
                    }
                }
            }
            if (start === end)
                end = firstNonSlashEnd;
            else if (end === -1)
                end = path.length;
            return path.slice(start, end);
        }
        else {
            for (i = path.length - 1; i >= 0; --i) {
                if (path.charCodeAt(i) === _constants_ts_3.CHAR_FORWARD_SLASH) {
                    // If we reached a path separator that was not part of a set of path
                    // separators at the end of the string, stop now
                    if (!matchedSlash) {
                        start = i + 1;
                        break;
                    }
                }
                else if (end === -1) {
                    // We saw the first non-path separator, mark this as the end of our
                    // path component
                    matchedSlash = false;
                    end = i + 1;
                }
            }
            if (end === -1)
                return "";
            return path.slice(start, end);
        }
    }
    exports_6("basename", basename);
    function extname(path) {
        _util_ts_2.assertPath(path);
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        let preDotState = 0;
        for (let i = path.length - 1; i >= 0; --i) {
            const code = path.charCodeAt(i);
            if (code === _constants_ts_3.CHAR_FORWARD_SLASH) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_3.CHAR_DOT) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                // We saw a non-dot and non-path separator before our dot, so we should
                // have a good chance at having a non-empty extension
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            // We saw a non-dot character immediately before the dot
            preDotState === 0 ||
            // The (right-most) trimmed path component is exactly '..'
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            return "";
        }
        return path.slice(startDot, end);
    }
    exports_6("extname", extname);
    function format(pathObject) {
        /* eslint-disable max-len */
        if (pathObject === null || typeof pathObject !== "object") {
            throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
        }
        return _util_ts_2._format("/", pathObject);
    }
    exports_6("format", format);
    function parse(path) {
        _util_ts_2.assertPath(path);
        const ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path.length === 0)
            return ret;
        const isAbsolute = path.charCodeAt(0) === _constants_ts_3.CHAR_FORWARD_SLASH;
        let start;
        if (isAbsolute) {
            ret.root = "/";
            start = 1;
        }
        else {
            start = 0;
        }
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let i = path.length - 1;
        // Track the state of characters (if any) we see before our first dot and
        // after any path separator we find
        let preDotState = 0;
        // Get non-dir info
        for (; i >= start; --i) {
            const code = path.charCodeAt(i);
            if (code === _constants_ts_3.CHAR_FORWARD_SLASH) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    startPart = i + 1;
                    break;
                }
                continue;
            }
            if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // extension
                matchedSlash = false;
                end = i + 1;
            }
            if (code === _constants_ts_3.CHAR_DOT) {
                // If this is our first dot, mark it as the start of our extension
                if (startDot === -1)
                    startDot = i;
                else if (preDotState !== 1)
                    preDotState = 1;
            }
            else if (startDot !== -1) {
                // We saw a non-dot and non-path separator before our dot, so we should
                // have a good chance at having a non-empty extension
                preDotState = -1;
            }
        }
        if (startDot === -1 ||
            end === -1 ||
            // We saw a non-dot character immediately before the dot
            preDotState === 0 ||
            // The (right-most) trimmed path component is exactly '..'
            (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)) {
            if (end !== -1) {
                if (startPart === 0 && isAbsolute) {
                    ret.base = ret.name = path.slice(1, end);
                }
                else {
                    ret.base = ret.name = path.slice(startPart, end);
                }
            }
        }
        else {
            if (startPart === 0 && isAbsolute) {
                ret.name = path.slice(1, startDot);
                ret.base = path.slice(1, end);
            }
            else {
                ret.name = path.slice(startPart, startDot);
                ret.base = path.slice(startPart, end);
            }
            ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0)
            ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute)
            ret.dir = "/";
        return ret;
    }
    exports_6("parse", parse);
    /** Converts a file URL to a path string.
     *
     *      fromFileUrl("file:///home/foo"); // "/home/foo"
     *
     * Note that non-file URLs are treated as file URLs and irrelevant components
     * are ignored.
     */
    function fromFileUrl(url) {
        return new URL(url).pathname;
    }
    exports_6("fromFileUrl", fromFileUrl);
    return {
        setters: [
            function (_constants_ts_3_1) {
                _constants_ts_3 = _constants_ts_3_1;
            },
            function (_util_ts_2_1) {
                _util_ts_2 = _util_ts_2_1;
            }
        ],
        execute: function () {
            exports_6("sep", sep = "/");
            exports_6("delimiter", delimiter = ":");
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
/** This module is browser compatible. */
System.register("https://deno.land/std@0.57.0/path/separator", ["https://deno.land/std@0.57.0/path/_constants"], function (exports_7, context_7) {
    "use strict";
    var _constants_ts_4, SEP, SEP_PATTERN;
    var __moduleName = context_7 && context_7.id;
    return {
        setters: [
            function (_constants_ts_4_1) {
                _constants_ts_4 = _constants_ts_4_1;
            }
        ],
        execute: function () {
            exports_7("SEP", SEP = _constants_ts_4.isWindows ? "\\" : "/");
            exports_7("SEP_PATTERN", SEP_PATTERN = _constants_ts_4.isWindows ? /[\\/]+/ : /\/+/);
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
/** This module is browser compatible. */
System.register("https://deno.land/std@0.57.0/path/common", ["https://deno.land/std@0.57.0/path/separator"], function (exports_8, context_8) {
    "use strict";
    var separator_ts_1;
    var __moduleName = context_8 && context_8.id;
    /** Determines the common path from a set of paths, using an optional separator,
     * which defaults to the OS default separator.
     *
     *       import { common } from "https://deno.land/std/path/mod.ts";
     *       const p = common([
     *         "./deno/std/path/mod.ts",
     *         "./deno/std/fs/mod.ts",
     *       ]);
     *       console.log(p); // "./deno/std/"
     *
     */
    function common(paths, sep = separator_ts_1.SEP) {
        const [first = "", ...remaining] = paths;
        if (first === "" || remaining.length === 0) {
            return first.substring(0, first.lastIndexOf(sep) + 1);
        }
        const parts = first.split(sep);
        let endOfPrefix = parts.length;
        for (const path of remaining) {
            const compare = path.split(sep);
            for (let i = 0; i < endOfPrefix; i++) {
                if (compare[i] !== parts[i]) {
                    endOfPrefix = i;
                }
            }
            if (endOfPrefix === 0) {
                return "";
            }
        }
        const prefix = parts.slice(0, endOfPrefix).join(sep);
        return prefix.endsWith(sep) ? prefix : `${prefix}${sep}`;
    }
    exports_8("common", common);
    return {
        setters: [
            function (separator_ts_1_1) {
                separator_ts_1 = separator_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
// This file is ported from globrex@0.1.2
// MIT License
// Copyright (c) 2018 Terkel Gjervig Nielsen
/** This module is browser compatible. */
System.register("https://deno.land/std@0.57.0/path/_globrex", ["https://deno.land/std@0.57.0/path/_constants"], function (exports_9, context_9) {
    "use strict";
    var _constants_ts_5, SEP, SEP_ESC, SEP_RAW, GLOBSTAR, WILDCARD, GLOBSTAR_SEGMENT, WILDCARD_SEGMENT;
    var __moduleName = context_9 && context_9.id;
    /**
     * Convert any glob pattern to a JavaScript Regexp object
     * @param glob Glob pattern to convert
     * @param opts Configuration object
     * @returns Converted object with string, segments and RegExp object
     */
    function globrex(glob, { extended = false, globstar = false, strict = false, filepath = false, flags = "", } = {}) {
        const sepPattern = new RegExp(`^${SEP}${strict ? "" : "+"}$`);
        let regex = "";
        let segment = "";
        let pathRegexStr = "";
        const pathSegments = [];
        // If we are doing extended matching, this boolean is true when we are inside
        // a group (eg {*.html,*.js}), and false otherwise.
        let inGroup = false;
        let inRange = false;
        // extglob stack. Keep track of scope
        const ext = [];
        // Helper function to build string and segments
        function add(str, options = { split: false, last: false, only: "" }) {
            const { split, last, only } = options;
            if (only !== "path")
                regex += str;
            if (filepath && only !== "regex") {
                pathRegexStr += str.match(sepPattern) ? SEP : str;
                if (split) {
                    if (last)
                        segment += str;
                    if (segment !== "") {
                        // change it 'includes'
                        if (!flags.includes("g"))
                            segment = `^${segment}$`;
                        pathSegments.push(new RegExp(segment, flags));
                    }
                    segment = "";
                }
                else {
                    segment += str;
                }
            }
        }
        let c, n;
        for (let i = 0; i < glob.length; i++) {
            c = glob[i];
            n = glob[i + 1];
            if (["\\", "$", "^", ".", "="].includes(c)) {
                add(`\\${c}`);
                continue;
            }
            if (c.match(sepPattern)) {
                add(SEP, { split: true });
                if (n != null && n.match(sepPattern) && !strict)
                    regex += "?";
                continue;
            }
            if (c === "(") {
                if (ext.length) {
                    add(`${c}?:`);
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === ")") {
                if (ext.length) {
                    add(c);
                    const type = ext.pop();
                    if (type === "@") {
                        add("{1}");
                    }
                    else if (type === "!") {
                        add(WILDCARD);
                    }
                    else {
                        add(type);
                    }
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "|") {
                if (ext.length) {
                    add(c);
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "+") {
                if (n === "(" && extended) {
                    ext.push(c);
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "@" && extended) {
                if (n === "(") {
                    ext.push(c);
                    continue;
                }
            }
            if (c === "!") {
                if (extended) {
                    if (inRange) {
                        add("^");
                        continue;
                    }
                    if (n === "(") {
                        ext.push(c);
                        add("(?!");
                        i++;
                        continue;
                    }
                    add(`\\${c}`);
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "?") {
                if (extended) {
                    if (n === "(") {
                        ext.push(c);
                    }
                    else {
                        add(".");
                    }
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "[") {
                if (inRange && n === ":") {
                    i++; // skip [
                    let value = "";
                    while (glob[++i] !== ":")
                        value += glob[i];
                    if (value === "alnum")
                        add("(?:\\w|\\d)");
                    else if (value === "space")
                        add("\\s");
                    else if (value === "digit")
                        add("\\d");
                    i++; // skip last ]
                    continue;
                }
                if (extended) {
                    inRange = true;
                    add(c);
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "]") {
                if (extended) {
                    inRange = false;
                    add(c);
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "{") {
                if (extended) {
                    inGroup = true;
                    add("(?:");
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "}") {
                if (extended) {
                    inGroup = false;
                    add(")");
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === ",") {
                if (inGroup) {
                    add("|");
                    continue;
                }
                add(`\\${c}`);
                continue;
            }
            if (c === "*") {
                if (n === "(" && extended) {
                    ext.push(c);
                    continue;
                }
                // Move over all consecutive "*"'s.
                // Also store the previous and next characters
                const prevChar = glob[i - 1];
                let starCount = 1;
                while (glob[i + 1] === "*") {
                    starCount++;
                    i++;
                }
                const nextChar = glob[i + 1];
                if (!globstar) {
                    // globstar is disabled, so treat any number of "*" as one
                    add(".*");
                }
                else {
                    // globstar is enabled, so determine if this is a globstar segment
                    const isGlobstar = starCount > 1 && // multiple "*"'s
                        // from the start of the segment
                        [SEP_RAW, "/", undefined].includes(prevChar) &&
                        // to the end of the segment
                        [SEP_RAW, "/", undefined].includes(nextChar);
                    if (isGlobstar) {
                        // it's a globstar, so match zero or more path segments
                        add(GLOBSTAR, { only: "regex" });
                        add(GLOBSTAR_SEGMENT, { only: "path", last: true, split: true });
                        i++; // move over the "/"
                    }
                    else {
                        // it's not a globstar, so only match one path segment
                        add(WILDCARD, { only: "regex" });
                        add(WILDCARD_SEGMENT, { only: "path" });
                    }
                }
                continue;
            }
            add(c);
        }
        // When regexp 'g' flag is specified don't
        // constrain the regular expression with ^ & $
        if (!flags.includes("g")) {
            regex = `^${regex}$`;
            segment = `^${segment}$`;
            if (filepath)
                pathRegexStr = `^${pathRegexStr}$`;
        }
        const result = { regex: new RegExp(regex, flags) };
        // Push the last segment
        if (filepath) {
            pathSegments.push(new RegExp(segment, flags));
            result.path = {
                regex: new RegExp(pathRegexStr, flags),
                segments: pathSegments,
                globstar: new RegExp(!flags.includes("g") ? `^${GLOBSTAR_SEGMENT}$` : GLOBSTAR_SEGMENT, flags),
            };
        }
        return result;
    }
    exports_9("globrex", globrex);
    return {
        setters: [
            function (_constants_ts_5_1) {
                _constants_ts_5 = _constants_ts_5_1;
            }
        ],
        execute: function () {
            SEP = _constants_ts_5.isWindows ? `(?:\\\\|\\/)` : `\\/`;
            SEP_ESC = _constants_ts_5.isWindows ? `\\\\` : `/`;
            SEP_RAW = _constants_ts_5.isWindows ? `\\` : `/`;
            GLOBSTAR = `(?:(?:[^${SEP_ESC}/]*(?:${SEP_ESC}|\/|$))*)`;
            WILDCARD = `(?:[^${SEP_ESC}/]*)`;
            GLOBSTAR_SEGMENT = `((?:[^${SEP_ESC}/]*(?:${SEP_ESC}|\/|$))*)`;
            WILDCARD_SEGMENT = `(?:[^${SEP_ESC}/]*)`;
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
/** This module is browser compatible. */
System.register("https://deno.land/std@0.57.0/path/glob", ["https://deno.land/std@0.57.0/path/separator", "https://deno.land/std@0.57.0/path/_globrex", "https://deno.land/std@0.57.0/path/mod", "https://deno.land/std@0.57.0/_util/assert"], function (exports_10, context_10) {
    "use strict";
    var separator_ts_2, _globrex_ts_1, mod_ts_1, assert_ts_2;
    var __moduleName = context_10 && context_10.id;
    /**
     * Generate a regex based on glob pattern and options
     * This was meant to be using the the `fs.walk` function
     * but can be used anywhere else.
     * Examples:
     *
     *     Looking for all the `ts` files:
     *     walkSync(".", {
     *       match: [globToRegExp("*.ts")]
     *     })
     *
     *     Looking for all the `.json` files in any subfolder:
     *     walkSync(".", {
     *       match: [globToRegExp(join("a", "**", "*.json"),{
     *         flags: "g",
     *         extended: true,
     *         globstar: true
     *       })]
     *     })
     *
     * @param glob - Glob pattern to be used
     * @param options - Specific options for the glob pattern
     * @returns A RegExp for the glob pattern
     */
    function globToRegExp(glob, { extended = false, globstar = true } = {}) {
        const result = _globrex_ts_1.globrex(glob, {
            extended,
            globstar,
            strict: false,
            filepath: true,
        });
        assert_ts_2.assert(result.path != null);
        return result.path.regex;
    }
    exports_10("globToRegExp", globToRegExp);
    /** Test whether the given string is a glob */
    function isGlob(str) {
        const chars = { "{": "}", "(": ")", "[": "]" };
        /* eslint-disable-next-line max-len */
        const regex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
        if (str === "") {
            return false;
        }
        let match;
        while ((match = regex.exec(str))) {
            if (match[2])
                return true;
            let idx = match.index + match[0].length;
            // if an open bracket/brace/paren is escaped,
            // set the index to the next closing character
            const open = match[1];
            const close = open ? chars[open] : null;
            if (open && close) {
                const n = str.indexOf(close, idx);
                if (n !== -1) {
                    idx = n + 1;
                }
            }
            str = str.slice(idx);
        }
        return false;
    }
    exports_10("isGlob", isGlob);
    /** Like normalize(), but doesn't collapse "**\/.." when `globstar` is true. */
    function normalizeGlob(glob, { globstar = false } = {}) {
        if (!!glob.match(/\0/g)) {
            throw new Error(`Glob contains invalid characters: "${glob}"`);
        }
        if (!globstar) {
            return mod_ts_1.normalize(glob);
        }
        const s = separator_ts_2.SEP_PATTERN.source;
        const badParentPattern = new RegExp(`(?<=(${s}|^)\\*\\*${s})\\.\\.(?=${s}|$)`, "g");
        return mod_ts_1.normalize(glob.replace(badParentPattern, "\0")).replace(/\0/g, "..");
    }
    exports_10("normalizeGlob", normalizeGlob);
    /** Like join(), but doesn't collapse "**\/.." when `globstar` is true. */
    function joinGlobs(globs, { extended = false, globstar = false } = {}) {
        if (!globstar || globs.length == 0) {
            return mod_ts_1.join(...globs);
        }
        if (globs.length === 0)
            return ".";
        let joined;
        for (const glob of globs) {
            const path = glob;
            if (path.length > 0) {
                if (!joined)
                    joined = path;
                else
                    joined += `${separator_ts_2.SEP}${path}`;
            }
        }
        if (!joined)
            return ".";
        return normalizeGlob(joined, { extended, globstar });
    }
    exports_10("joinGlobs", joinGlobs);
    return {
        setters: [
            function (separator_ts_2_1) {
                separator_ts_2 = separator_ts_2_1;
            },
            function (_globrex_ts_1_1) {
                _globrex_ts_1 = _globrex_ts_1_1;
            },
            function (mod_ts_1_1) {
                mod_ts_1 = mod_ts_1_1;
            },
            function (assert_ts_2_1) {
                assert_ts_2 = assert_ts_2_1;
            }
        ],
        execute: function () {
        }
    };
});
// Copyright the Browserify authors. MIT License.
// Ported mostly from https://github.com/browserify/path-browserify/
/** This module is browser compatible. */
System.register("https://deno.land/std@0.57.0/path/mod", ["https://deno.land/std@0.57.0/path/_constants", "https://deno.land/std@0.57.0/path/win32", "https://deno.land/std@0.57.0/path/posix", "https://deno.land/std@0.57.0/path/common", "https://deno.land/std@0.57.0/path/separator", "https://deno.land/std@0.57.0/path/_interface", "https://deno.land/std@0.57.0/path/glob"], function (exports_11, context_11) {
    "use strict";
    var _constants_ts_6, _win32, _posix, path, win32, posix, basename, delimiter, dirname, extname, format, fromFileUrl, isAbsolute, join, normalize, parse, relative, resolve, sep, toNamespacedPath;
    var __moduleName = context_11 && context_11.id;
    var exportedNames_1 = {
        "win32": true,
        "posix": true,
        "basename": true,
        "delimiter": true,
        "dirname": true,
        "extname": true,
        "format": true,
        "fromFileUrl": true,
        "isAbsolute": true,
        "join": true,
        "normalize": true,
        "parse": true,
        "relative": true,
        "resolve": true,
        "sep": true,
        "toNamespacedPath": true,
        "SEP": true,
        "SEP_PATTERN": true
    };
    function exportStar_1(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default" && !exportedNames_1.hasOwnProperty(n)) exports[n] = m[n];
        }
        exports_11(exports);
    }
    return {
        setters: [
            function (_constants_ts_6_1) {
                _constants_ts_6 = _constants_ts_6_1;
            },
            function (_win32_1) {
                _win32 = _win32_1;
            },
            function (_posix_1) {
                _posix = _posix_1;
            },
            function (common_ts_1_1) {
                exportStar_1(common_ts_1_1);
            },
            function (separator_ts_3_1) {
                exports_11({
                    "SEP": separator_ts_3_1["SEP"],
                    "SEP_PATTERN": separator_ts_3_1["SEP_PATTERN"]
                });
            },
            function (_interface_ts_1_1) {
                exportStar_1(_interface_ts_1_1);
            },
            function (glob_ts_1_1) {
                exportStar_1(glob_ts_1_1);
            }
        ],
        execute: function () {
            path = _constants_ts_6.isWindows ? _win32 : _posix;
            exports_11("win32", win32 = _win32);
            exports_11("posix", posix = _posix);
            exports_11("basename", basename = path.basename), exports_11("delimiter", delimiter = path.delimiter), exports_11("dirname", dirname = path.dirname), exports_11("extname", extname = path.extname), exports_11("format", format = path.format), exports_11("fromFileUrl", fromFileUrl = path.fromFileUrl), exports_11("isAbsolute", isAbsolute = path.isAbsolute), exports_11("join", join = path.join), exports_11("normalize", normalize = path.normalize), exports_11("parse", parse = path.parse), exports_11("relative", relative = path.relative), exports_11("resolve", resolve = path.resolve), exports_11("sep", sep = path.sep), exports_11("toNamespacedPath", toNamespacedPath = path.toNamespacedPath);
        }
    };
});
System.register("https://deno.land/std@0.57.0/io/util", ["https://deno.land/std@0.57.0/path/mod"], function (exports_12, context_12) {
    "use strict";
    var mkdir, open, path;
    var __moduleName = context_12 && context_12.id;
    /**
     * Copy bytes from one Uint8Array to another.  Bytes from `src` which don't fit
     * into `dst` will not be copied.
     *
     * @param src Source byte array
     * @param dst Destination byte array
     * @param off Offset into `dst` at which to begin writing values from `src`.
     * @return number of bytes copied
     */
    function copyBytes(src, dst, off = 0) {
        off = Math.max(0, Math.min(off, dst.byteLength));
        const dstBytesAvailable = dst.byteLength - off;
        if (src.byteLength > dstBytesAvailable) {
            src = src.subarray(0, dstBytesAvailable);
        }
        dst.set(src, off);
        return src.byteLength;
    }
    exports_12("copyBytes", copyBytes);
    function charCode(s) {
        return s.charCodeAt(0);
    }
    exports_12("charCode", charCode);
    /** Create or open a temporal file at specified directory with prefix and
     *  postfix
     * */
    async function tempFile(dir, opts = { prefix: "", postfix: "" }) {
        const r = Math.floor(Math.random() * 1000000);
        const filepath = path.resolve(`${dir}/${opts.prefix || ""}${r}${opts.postfix || ""}`);
        await mkdir(path.dirname(filepath), { recursive: true });
        const file = await open(filepath, {
            create: true,
            read: true,
            write: true,
            append: true,
        });
        return { file, filepath };
    }
    exports_12("tempFile", tempFile);
    return {
        setters: [
            function (path_1) {
                path = path_1;
            }
        ],
        execute: function () {
            // Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
            mkdir = Deno.mkdir, open = Deno.open;
        }
    };
});
System.register("https://deno.land/std@0.57.0/bytes/mod", ["https://deno.land/std@0.57.0/io/util"], function (exports_13, context_13) {
    "use strict";
    var util_ts_1;
    var __moduleName = context_13 && context_13.id;
    /** Find first index of binary pattern from a. If not found, then return -1
     * @param source soruce array
     * @param pat pattern to find in source array
     */
    function findIndex(source, pat) {
        const s = pat[0];
        for (let i = 0; i < source.length; i++) {
            if (source[i] !== s)
                continue;
            const pin = i;
            let matched = 1;
            let j = i;
            while (matched < pat.length) {
                j++;
                if (source[j] !== pat[j - pin]) {
                    break;
                }
                matched++;
            }
            if (matched === pat.length) {
                return pin;
            }
        }
        return -1;
    }
    exports_13("findIndex", findIndex);
    /** Find last index of binary pattern from a. If not found, then return -1.
     * @param source soruce array
     * @param pat pattern to find in source array
     */
    function findLastIndex(source, pat) {
        const e = pat[pat.length - 1];
        for (let i = source.length - 1; i >= 0; i--) {
            if (source[i] !== e)
                continue;
            const pin = i;
            let matched = 1;
            let j = i;
            while (matched < pat.length) {
                j--;
                if (source[j] !== pat[pat.length - 1 - (pin - j)]) {
                    break;
                }
                matched++;
            }
            if (matched === pat.length) {
                return pin - pat.length + 1;
            }
        }
        return -1;
    }
    exports_13("findLastIndex", findLastIndex);
    /** Check whether binary arrays are equal to each other.
     * @param source first array to check equality
     * @param match second array to check equality
     */
    function equal(source, match) {
        if (source.length !== match.length)
            return false;
        for (let i = 0; i < match.length; i++) {
            if (source[i] !== match[i])
                return false;
        }
        return true;
    }
    exports_13("equal", equal);
    /** Check whether binary array starts with prefix.
     * @param source srouce array
     * @param prefix prefix array to check in source
     */
    function hasPrefix(source, prefix) {
        for (let i = 0, max = prefix.length; i < max; i++) {
            if (source[i] !== prefix[i])
                return false;
        }
        return true;
    }
    exports_13("hasPrefix", hasPrefix);
    /** Check whether binary array ends with suffix.
     * @param source srouce array
     * @param suffix suffix array to check in source
     */
    function hasSuffix(source, suffix) {
        for (let srci = source.length - 1, sfxi = suffix.length - 1; sfxi >= 0; srci--, sfxi--) {
            if (source[srci] !== suffix[sfxi])
                return false;
        }
        return true;
    }
    exports_13("hasSuffix", hasSuffix);
    /** Repeat bytes. returns a new byte slice consisting of `count` copies of `b`.
     * @param origin The origin bytes
     * @param count The count you want to repeat.
     */
    function repeat(origin, count) {
        if (count === 0) {
            return new Uint8Array();
        }
        if (count < 0) {
            throw new Error("bytes: negative repeat count");
        }
        else if ((origin.length * count) / count !== origin.length) {
            throw new Error("bytes: repeat count causes overflow");
        }
        const int = Math.floor(count);
        if (int !== count) {
            throw new Error("bytes: repeat count must be an integer");
        }
        const nb = new Uint8Array(origin.length * count);
        let bp = util_ts_1.copyBytes(origin, nb);
        for (; bp < nb.length; bp *= 2) {
            util_ts_1.copyBytes(nb.slice(0, bp), nb, bp);
        }
        return nb;
    }
    exports_13("repeat", repeat);
    /** Concatenate two binary arrays and return new one.
     * @param origin origin array to concatenate
     * @param b array to concatenate with origin
     */
    function concat(origin, b) {
        const output = new Uint8Array(origin.length + b.length);
        output.set(origin, 0);
        output.set(b, origin.length);
        return output;
    }
    exports_13("concat", concat);
    /** Check srouce array contains pattern array.
     * @param source srouce array
     * @param pat patter array
     */
    function contains(source, pat) {
        return findIndex(source, pat) != -1;
    }
    exports_13("contains", contains);
    return {
        setters: [
            function (util_ts_1_1) {
                util_ts_1 = util_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
/*
 * [js-sha1]{@link https://github.com/emn178/js-sha1}
 *
 * @version 0.6.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
System.register("https://deno.land/std@0.57.0/hash/sha1", [], function (exports_14, context_14) {
    "use strict";
    var HEX_CHARS, EXTRA, SHIFT, blocks, Sha1;
    var __moduleName = context_14 && context_14.id;
    return {
        setters: [],
        execute: function () {
            HEX_CHARS = "0123456789abcdef".split("");
            EXTRA = [-2147483648, 8388608, 32768, 128];
            SHIFT = [24, 16, 8, 0];
            blocks = [];
            Sha1 = class Sha1 {
                constructor(sharedMemory = false) {
                    this.#h0 = 0x67452301;
                    this.#h1 = 0xefcdab89;
                    this.#h2 = 0x98badcfe;
                    this.#h3 = 0x10325476;
                    this.#h4 = 0xc3d2e1f0;
                    this.#lastByteIndex = 0;
                    if (sharedMemory) {
                        blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                        this.#blocks = blocks;
                    }
                    else {
                        this.#blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                    }
                    this.#h0 = 0x67452301;
                    this.#h1 = 0xefcdab89;
                    this.#h2 = 0x98badcfe;
                    this.#h3 = 0x10325476;
                    this.#h4 = 0xc3d2e1f0;
                    this.#block = this.#start = this.#bytes = this.#hBytes = 0;
                    this.#finalized = this.#hashed = false;
                }
                #blocks;
                #block;
                #start;
                #bytes;
                #hBytes;
                #finalized;
                #hashed;
                #h0;
                #h1;
                #h2;
                #h3;
                #h4;
                #lastByteIndex;
                update(message) {
                    if (this.#finalized) {
                        return this;
                    }
                    let msg;
                    if (message instanceof ArrayBuffer) {
                        msg = new Uint8Array(message);
                    }
                    else {
                        msg = message;
                    }
                    let index = 0;
                    const length = msg.length;
                    const blocks = this.#blocks;
                    while (index < length) {
                        let i;
                        if (this.#hashed) {
                            this.#hashed = false;
                            blocks[0] = this.#block;
                            blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                        }
                        if (typeof msg !== "string") {
                            for (i = this.#start; index < length && i < 64; ++index) {
                                blocks[i >> 2] |= msg[index] << SHIFT[i++ & 3];
                            }
                        }
                        else {
                            for (i = this.#start; index < length && i < 64; ++index) {
                                let code = msg.charCodeAt(index);
                                if (code < 0x80) {
                                    blocks[i >> 2] |= code << SHIFT[i++ & 3];
                                }
                                else if (code < 0x800) {
                                    blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                                else if (code < 0xd800 || code >= 0xe000) {
                                    blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                                else {
                                    code =
                                        0x10000 +
                                            (((code & 0x3ff) << 10) | (msg.charCodeAt(++index) & 0x3ff));
                                    blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                            }
                        }
                        this.#lastByteIndex = i;
                        this.#bytes += i - this.#start;
                        if (i >= 64) {
                            this.#block = blocks[16];
                            this.#start = i - 64;
                            this.hash();
                            this.#hashed = true;
                        }
                        else {
                            this.#start = i;
                        }
                    }
                    if (this.#bytes > 4294967295) {
                        this.#hBytes += (this.#bytes / 4294967296) >>> 0;
                        this.#bytes = this.#bytes >>> 0;
                    }
                    return this;
                }
                finalize() {
                    if (this.#finalized) {
                        return;
                    }
                    this.#finalized = true;
                    const blocks = this.#blocks;
                    const i = this.#lastByteIndex;
                    blocks[16] = this.#block;
                    blocks[i >> 2] |= EXTRA[i & 3];
                    this.#block = blocks[16];
                    if (i >= 56) {
                        if (!this.#hashed) {
                            this.hash();
                        }
                        blocks[0] = this.#block;
                        blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                    }
                    blocks[14] = (this.#hBytes << 3) | (this.#bytes >>> 29);
                    blocks[15] = this.#bytes << 3;
                    this.hash();
                }
                hash() {
                    let a = this.#h0;
                    let b = this.#h1;
                    let c = this.#h2;
                    let d = this.#h3;
                    let e = this.#h4;
                    let f;
                    let j;
                    let t;
                    const blocks = this.#blocks;
                    for (j = 16; j < 80; ++j) {
                        t = blocks[j - 3] ^ blocks[j - 8] ^ blocks[j - 14] ^ blocks[j - 16];
                        blocks[j] = (t << 1) | (t >>> 31);
                    }
                    for (j = 0; j < 20; j += 5) {
                        f = (b & c) | (~b & d);
                        t = (a << 5) | (a >>> 27);
                        e = (t + f + e + 1518500249 + blocks[j]) >>> 0;
                        b = (b << 30) | (b >>> 2);
                        f = (a & b) | (~a & c);
                        t = (e << 5) | (e >>> 27);
                        d = (t + f + d + 1518500249 + blocks[j + 1]) >>> 0;
                        a = (a << 30) | (a >>> 2);
                        f = (e & a) | (~e & b);
                        t = (d << 5) | (d >>> 27);
                        c = (t + f + c + 1518500249 + blocks[j + 2]) >>> 0;
                        e = (e << 30) | (e >>> 2);
                        f = (d & e) | (~d & a);
                        t = (c << 5) | (c >>> 27);
                        b = (t + f + b + 1518500249 + blocks[j + 3]) >>> 0;
                        d = (d << 30) | (d >>> 2);
                        f = (c & d) | (~c & e);
                        t = (b << 5) | (b >>> 27);
                        a = (t + f + a + 1518500249 + blocks[j + 4]) >>> 0;
                        c = (c << 30) | (c >>> 2);
                    }
                    for (; j < 40; j += 5) {
                        f = b ^ c ^ d;
                        t = (a << 5) | (a >>> 27);
                        e = (t + f + e + 1859775393 + blocks[j]) >>> 0;
                        b = (b << 30) | (b >>> 2);
                        f = a ^ b ^ c;
                        t = (e << 5) | (e >>> 27);
                        d = (t + f + d + 1859775393 + blocks[j + 1]) >>> 0;
                        a = (a << 30) | (a >>> 2);
                        f = e ^ a ^ b;
                        t = (d << 5) | (d >>> 27);
                        c = (t + f + c + 1859775393 + blocks[j + 2]) >>> 0;
                        e = (e << 30) | (e >>> 2);
                        f = d ^ e ^ a;
                        t = (c << 5) | (c >>> 27);
                        b = (t + f + b + 1859775393 + blocks[j + 3]) >>> 0;
                        d = (d << 30) | (d >>> 2);
                        f = c ^ d ^ e;
                        t = (b << 5) | (b >>> 27);
                        a = (t + f + a + 1859775393 + blocks[j + 4]) >>> 0;
                        c = (c << 30) | (c >>> 2);
                    }
                    for (; j < 60; j += 5) {
                        f = (b & c) | (b & d) | (c & d);
                        t = (a << 5) | (a >>> 27);
                        e = (t + f + e - 1894007588 + blocks[j]) >>> 0;
                        b = (b << 30) | (b >>> 2);
                        f = (a & b) | (a & c) | (b & c);
                        t = (e << 5) | (e >>> 27);
                        d = (t + f + d - 1894007588 + blocks[j + 1]) >>> 0;
                        a = (a << 30) | (a >>> 2);
                        f = (e & a) | (e & b) | (a & b);
                        t = (d << 5) | (d >>> 27);
                        c = (t + f + c - 1894007588 + blocks[j + 2]) >>> 0;
                        e = (e << 30) | (e >>> 2);
                        f = (d & e) | (d & a) | (e & a);
                        t = (c << 5) | (c >>> 27);
                        b = (t + f + b - 1894007588 + blocks[j + 3]) >>> 0;
                        d = (d << 30) | (d >>> 2);
                        f = (c & d) | (c & e) | (d & e);
                        t = (b << 5) | (b >>> 27);
                        a = (t + f + a - 1894007588 + blocks[j + 4]) >>> 0;
                        c = (c << 30) | (c >>> 2);
                    }
                    for (; j < 80; j += 5) {
                        f = b ^ c ^ d;
                        t = (a << 5) | (a >>> 27);
                        e = (t + f + e - 899497514 + blocks[j]) >>> 0;
                        b = (b << 30) | (b >>> 2);
                        f = a ^ b ^ c;
                        t = (e << 5) | (e >>> 27);
                        d = (t + f + d - 899497514 + blocks[j + 1]) >>> 0;
                        a = (a << 30) | (a >>> 2);
                        f = e ^ a ^ b;
                        t = (d << 5) | (d >>> 27);
                        c = (t + f + c - 899497514 + blocks[j + 2]) >>> 0;
                        e = (e << 30) | (e >>> 2);
                        f = d ^ e ^ a;
                        t = (c << 5) | (c >>> 27);
                        b = (t + f + b - 899497514 + blocks[j + 3]) >>> 0;
                        d = (d << 30) | (d >>> 2);
                        f = c ^ d ^ e;
                        t = (b << 5) | (b >>> 27);
                        a = (t + f + a - 899497514 + blocks[j + 4]) >>> 0;
                        c = (c << 30) | (c >>> 2);
                    }
                    this.#h0 = (this.#h0 + a) >>> 0;
                    this.#h1 = (this.#h1 + b) >>> 0;
                    this.#h2 = (this.#h2 + c) >>> 0;
                    this.#h3 = (this.#h3 + d) >>> 0;
                    this.#h4 = (this.#h4 + e) >>> 0;
                }
                hex() {
                    this.finalize();
                    const h0 = this.#h0;
                    const h1 = this.#h1;
                    const h2 = this.#h2;
                    const h3 = this.#h3;
                    const h4 = this.#h4;
                    return (HEX_CHARS[(h0 >> 28) & 0x0f] +
                        HEX_CHARS[(h0 >> 24) & 0x0f] +
                        HEX_CHARS[(h0 >> 20) & 0x0f] +
                        HEX_CHARS[(h0 >> 16) & 0x0f] +
                        HEX_CHARS[(h0 >> 12) & 0x0f] +
                        HEX_CHARS[(h0 >> 8) & 0x0f] +
                        HEX_CHARS[(h0 >> 4) & 0x0f] +
                        HEX_CHARS[h0 & 0x0f] +
                        HEX_CHARS[(h1 >> 28) & 0x0f] +
                        HEX_CHARS[(h1 >> 24) & 0x0f] +
                        HEX_CHARS[(h1 >> 20) & 0x0f] +
                        HEX_CHARS[(h1 >> 16) & 0x0f] +
                        HEX_CHARS[(h1 >> 12) & 0x0f] +
                        HEX_CHARS[(h1 >> 8) & 0x0f] +
                        HEX_CHARS[(h1 >> 4) & 0x0f] +
                        HEX_CHARS[h1 & 0x0f] +
                        HEX_CHARS[(h2 >> 28) & 0x0f] +
                        HEX_CHARS[(h2 >> 24) & 0x0f] +
                        HEX_CHARS[(h2 >> 20) & 0x0f] +
                        HEX_CHARS[(h2 >> 16) & 0x0f] +
                        HEX_CHARS[(h2 >> 12) & 0x0f] +
                        HEX_CHARS[(h2 >> 8) & 0x0f] +
                        HEX_CHARS[(h2 >> 4) & 0x0f] +
                        HEX_CHARS[h2 & 0x0f] +
                        HEX_CHARS[(h3 >> 28) & 0x0f] +
                        HEX_CHARS[(h3 >> 24) & 0x0f] +
                        HEX_CHARS[(h3 >> 20) & 0x0f] +
                        HEX_CHARS[(h3 >> 16) & 0x0f] +
                        HEX_CHARS[(h3 >> 12) & 0x0f] +
                        HEX_CHARS[(h3 >> 8) & 0x0f] +
                        HEX_CHARS[(h3 >> 4) & 0x0f] +
                        HEX_CHARS[h3 & 0x0f] +
                        HEX_CHARS[(h4 >> 28) & 0x0f] +
                        HEX_CHARS[(h4 >> 24) & 0x0f] +
                        HEX_CHARS[(h4 >> 20) & 0x0f] +
                        HEX_CHARS[(h4 >> 16) & 0x0f] +
                        HEX_CHARS[(h4 >> 12) & 0x0f] +
                        HEX_CHARS[(h4 >> 8) & 0x0f] +
                        HEX_CHARS[(h4 >> 4) & 0x0f] +
                        HEX_CHARS[h4 & 0x0f]);
                }
                toString() {
                    return this.hex();
                }
                digest() {
                    this.finalize();
                    const h0 = this.#h0;
                    const h1 = this.#h1;
                    const h2 = this.#h2;
                    const h3 = this.#h3;
                    const h4 = this.#h4;
                    return [
                        (h0 >> 24) & 0xff,
                        (h0 >> 16) & 0xff,
                        (h0 >> 8) & 0xff,
                        h0 & 0xff,
                        (h1 >> 24) & 0xff,
                        (h1 >> 16) & 0xff,
                        (h1 >> 8) & 0xff,
                        h1 & 0xff,
                        (h2 >> 24) & 0xff,
                        (h2 >> 16) & 0xff,
                        (h2 >> 8) & 0xff,
                        h2 & 0xff,
                        (h3 >> 24) & 0xff,
                        (h3 >> 16) & 0xff,
                        (h3 >> 8) & 0xff,
                        h3 & 0xff,
                        (h4 >> 24) & 0xff,
                        (h4 >> 16) & 0xff,
                        (h4 >> 8) & 0xff,
                        h4 & 0xff,
                    ];
                }
                array() {
                    return this.digest();
                }
                arrayBuffer() {
                    this.finalize();
                    const buffer = new ArrayBuffer(20);
                    const dataView = new DataView(buffer);
                    dataView.setUint32(0, this.#h0);
                    dataView.setUint32(4, this.#h1);
                    dataView.setUint32(8, this.#h2);
                    dataView.setUint32(12, this.#h3);
                    dataView.setUint32(16, this.#h4);
                    return buffer;
                }
            };
            exports_14("Sha1", Sha1);
        }
    };
});
/*
 * Adapted to deno from:
 *
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
System.register("https://deno.land/std@0.57.0/hash/sha256", [], function (exports_15, context_15) {
    "use strict";
    var HEX_CHARS, EXTRA, SHIFT, K, blocks, Sha256, HmacSha256;
    var __moduleName = context_15 && context_15.id;
    return {
        setters: [],
        execute: function () {
            HEX_CHARS = "0123456789abcdef".split("");
            EXTRA = [-2147483648, 8388608, 32768, 128];
            SHIFT = [24, 16, 8, 0];
            // prettier-ignore
            // deno-fmt-ignore
            K = [
                0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1,
                0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
                0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,
                0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
                0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,
                0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
                0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,
                0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
                0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,
                0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
                0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
            ];
            blocks = [];
            Sha256 = class Sha256 {
                constructor(is224 = false, sharedMemory = false) {
                    this.#lastByteIndex = 0;
                    this.init(is224, sharedMemory);
                }
                #block;
                #blocks;
                #bytes;
                #finalized;
                #first;
                #h0;
                #h1;
                #h2;
                #h3;
                #h4;
                #h5;
                #h6;
                #h7;
                #hashed;
                #hBytes;
                #is224;
                #lastByteIndex;
                #start;
                init(is224, sharedMemory) {
                    if (sharedMemory) {
                        blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                        this.#blocks = blocks;
                    }
                    else {
                        this.#blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                    }
                    if (is224) {
                        this.#h0 = 0xc1059ed8;
                        this.#h1 = 0x367cd507;
                        this.#h2 = 0x3070dd17;
                        this.#h3 = 0xf70e5939;
                        this.#h4 = 0xffc00b31;
                        this.#h5 = 0x68581511;
                        this.#h6 = 0x64f98fa7;
                        this.#h7 = 0xbefa4fa4;
                    }
                    else {
                        // 256
                        this.#h0 = 0x6a09e667;
                        this.#h1 = 0xbb67ae85;
                        this.#h2 = 0x3c6ef372;
                        this.#h3 = 0xa54ff53a;
                        this.#h4 = 0x510e527f;
                        this.#h5 = 0x9b05688c;
                        this.#h6 = 0x1f83d9ab;
                        this.#h7 = 0x5be0cd19;
                    }
                    this.#block = this.#start = this.#bytes = this.#hBytes = 0;
                    this.#finalized = this.#hashed = false;
                    this.#first = true;
                    this.#is224 = is224;
                }
                /** Update hash
                 *
                 * @param message The message you want to hash.
                 */
                update(message) {
                    if (this.#finalized) {
                        return this;
                    }
                    let msg;
                    if (message instanceof ArrayBuffer) {
                        msg = new Uint8Array(message);
                    }
                    else {
                        msg = message;
                    }
                    let index = 0;
                    const length = msg.length;
                    const blocks = this.#blocks;
                    while (index < length) {
                        let i;
                        if (this.#hashed) {
                            this.#hashed = false;
                            blocks[0] = this.#block;
                            blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                        }
                        if (typeof msg !== "string") {
                            for (i = this.#start; index < length && i < 64; ++index) {
                                blocks[i >> 2] |= msg[index] << SHIFT[i++ & 3];
                            }
                        }
                        else {
                            for (i = this.#start; index < length && i < 64; ++index) {
                                let code = msg.charCodeAt(index);
                                if (code < 0x80) {
                                    blocks[i >> 2] |= code << SHIFT[i++ & 3];
                                }
                                else if (code < 0x800) {
                                    blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                                else if (code < 0xd800 || code >= 0xe000) {
                                    blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                                else {
                                    code =
                                        0x10000 +
                                            (((code & 0x3ff) << 10) | (msg.charCodeAt(++index) & 0x3ff));
                                    blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
                                    blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
                                }
                            }
                        }
                        this.#lastByteIndex = i;
                        this.#bytes += i - this.#start;
                        if (i >= 64) {
                            this.#block = blocks[16];
                            this.#start = i - 64;
                            this.hash();
                            this.#hashed = true;
                        }
                        else {
                            this.#start = i;
                        }
                    }
                    if (this.#bytes > 4294967295) {
                        this.#hBytes += (this.#bytes / 4294967296) << 0;
                        this.#bytes = this.#bytes % 4294967296;
                    }
                    return this;
                }
                finalize() {
                    if (this.#finalized) {
                        return;
                    }
                    this.#finalized = true;
                    const blocks = this.#blocks;
                    const i = this.#lastByteIndex;
                    blocks[16] = this.#block;
                    blocks[i >> 2] |= EXTRA[i & 3];
                    this.#block = blocks[16];
                    if (i >= 56) {
                        if (!this.#hashed) {
                            this.hash();
                        }
                        blocks[0] = this.#block;
                        blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
                    }
                    blocks[14] = (this.#hBytes << 3) | (this.#bytes >>> 29);
                    blocks[15] = this.#bytes << 3;
                    this.hash();
                }
                hash() {
                    let a = this.#h0;
                    let b = this.#h1;
                    let c = this.#h2;
                    let d = this.#h3;
                    let e = this.#h4;
                    let f = this.#h5;
                    let g = this.#h6;
                    let h = this.#h7;
                    const blocks = this.#blocks;
                    let s0;
                    let s1;
                    let maj;
                    let t1;
                    let t2;
                    let ch;
                    let ab;
                    let da;
                    let cd;
                    let bc;
                    for (let j = 16; j < 64; ++j) {
                        // rightrotate
                        t1 = blocks[j - 15];
                        s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);
                        t1 = blocks[j - 2];
                        s1 =
                            ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10);
                        blocks[j] = (blocks[j - 16] + s0 + blocks[j - 7] + s1) << 0;
                    }
                    bc = b & c;
                    for (let j = 0; j < 64; j += 4) {
                        if (this.#first) {
                            if (this.#is224) {
                                ab = 300032;
                                t1 = blocks[0] - 1413257819;
                                h = (t1 - 150054599) << 0;
                                d = (t1 + 24177077) << 0;
                            }
                            else {
                                ab = 704751109;
                                t1 = blocks[0] - 210244248;
                                h = (t1 - 1521486534) << 0;
                                d = (t1 + 143694565) << 0;
                            }
                            this.#first = false;
                        }
                        else {
                            s0 =
                                ((a >>> 2) | (a << 30)) ^
                                    ((a >>> 13) | (a << 19)) ^
                                    ((a >>> 22) | (a << 10));
                            s1 =
                                ((e >>> 6) | (e << 26)) ^
                                    ((e >>> 11) | (e << 21)) ^
                                    ((e >>> 25) | (e << 7));
                            ab = a & b;
                            maj = ab ^ (a & c) ^ bc;
                            ch = (e & f) ^ (~e & g);
                            t1 = h + s1 + ch + K[j] + blocks[j];
                            t2 = s0 + maj;
                            h = (d + t1) << 0;
                            d = (t1 + t2) << 0;
                        }
                        s0 =
                            ((d >>> 2) | (d << 30)) ^
                                ((d >>> 13) | (d << 19)) ^
                                ((d >>> 22) | (d << 10));
                        s1 =
                            ((h >>> 6) | (h << 26)) ^
                                ((h >>> 11) | (h << 21)) ^
                                ((h >>> 25) | (h << 7));
                        da = d & a;
                        maj = da ^ (d & b) ^ ab;
                        ch = (h & e) ^ (~h & f);
                        t1 = g + s1 + ch + K[j + 1] + blocks[j + 1];
                        t2 = s0 + maj;
                        g = (c + t1) << 0;
                        c = (t1 + t2) << 0;
                        s0 =
                            ((c >>> 2) | (c << 30)) ^
                                ((c >>> 13) | (c << 19)) ^
                                ((c >>> 22) | (c << 10));
                        s1 =
                            ((g >>> 6) | (g << 26)) ^
                                ((g >>> 11) | (g << 21)) ^
                                ((g >>> 25) | (g << 7));
                        cd = c & d;
                        maj = cd ^ (c & a) ^ da;
                        ch = (g & h) ^ (~g & e);
                        t1 = f + s1 + ch + K[j + 2] + blocks[j + 2];
                        t2 = s0 + maj;
                        f = (b + t1) << 0;
                        b = (t1 + t2) << 0;
                        s0 =
                            ((b >>> 2) | (b << 30)) ^
                                ((b >>> 13) | (b << 19)) ^
                                ((b >>> 22) | (b << 10));
                        s1 =
                            ((f >>> 6) | (f << 26)) ^
                                ((f >>> 11) | (f << 21)) ^
                                ((f >>> 25) | (f << 7));
                        bc = b & c;
                        maj = bc ^ (b & d) ^ cd;
                        ch = (f & g) ^ (~f & h);
                        t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];
                        t2 = s0 + maj;
                        e = (a + t1) << 0;
                        a = (t1 + t2) << 0;
                    }
                    this.#h0 = (this.#h0 + a) << 0;
                    this.#h1 = (this.#h1 + b) << 0;
                    this.#h2 = (this.#h2 + c) << 0;
                    this.#h3 = (this.#h3 + d) << 0;
                    this.#h4 = (this.#h4 + e) << 0;
                    this.#h5 = (this.#h5 + f) << 0;
                    this.#h6 = (this.#h6 + g) << 0;
                    this.#h7 = (this.#h7 + h) << 0;
                }
                /** Return hash in hex string. */
                hex() {
                    this.finalize();
                    const h0 = this.#h0;
                    const h1 = this.#h1;
                    const h2 = this.#h2;
                    const h3 = this.#h3;
                    const h4 = this.#h4;
                    const h5 = this.#h5;
                    const h6 = this.#h6;
                    const h7 = this.#h7;
                    let hex = HEX_CHARS[(h0 >> 28) & 0x0f] +
                        HEX_CHARS[(h0 >> 24) & 0x0f] +
                        HEX_CHARS[(h0 >> 20) & 0x0f] +
                        HEX_CHARS[(h0 >> 16) & 0x0f] +
                        HEX_CHARS[(h0 >> 12) & 0x0f] +
                        HEX_CHARS[(h0 >> 8) & 0x0f] +
                        HEX_CHARS[(h0 >> 4) & 0x0f] +
                        HEX_CHARS[h0 & 0x0f] +
                        HEX_CHARS[(h1 >> 28) & 0x0f] +
                        HEX_CHARS[(h1 >> 24) & 0x0f] +
                        HEX_CHARS[(h1 >> 20) & 0x0f] +
                        HEX_CHARS[(h1 >> 16) & 0x0f] +
                        HEX_CHARS[(h1 >> 12) & 0x0f] +
                        HEX_CHARS[(h1 >> 8) & 0x0f] +
                        HEX_CHARS[(h1 >> 4) & 0x0f] +
                        HEX_CHARS[h1 & 0x0f] +
                        HEX_CHARS[(h2 >> 28) & 0x0f] +
                        HEX_CHARS[(h2 >> 24) & 0x0f] +
                        HEX_CHARS[(h2 >> 20) & 0x0f] +
                        HEX_CHARS[(h2 >> 16) & 0x0f] +
                        HEX_CHARS[(h2 >> 12) & 0x0f] +
                        HEX_CHARS[(h2 >> 8) & 0x0f] +
                        HEX_CHARS[(h2 >> 4) & 0x0f] +
                        HEX_CHARS[h2 & 0x0f] +
                        HEX_CHARS[(h3 >> 28) & 0x0f] +
                        HEX_CHARS[(h3 >> 24) & 0x0f] +
                        HEX_CHARS[(h3 >> 20) & 0x0f] +
                        HEX_CHARS[(h3 >> 16) & 0x0f] +
                        HEX_CHARS[(h3 >> 12) & 0x0f] +
                        HEX_CHARS[(h3 >> 8) & 0x0f] +
                        HEX_CHARS[(h3 >> 4) & 0x0f] +
                        HEX_CHARS[h3 & 0x0f] +
                        HEX_CHARS[(h4 >> 28) & 0x0f] +
                        HEX_CHARS[(h4 >> 24) & 0x0f] +
                        HEX_CHARS[(h4 >> 20) & 0x0f] +
                        HEX_CHARS[(h4 >> 16) & 0x0f] +
                        HEX_CHARS[(h4 >> 12) & 0x0f] +
                        HEX_CHARS[(h4 >> 8) & 0x0f] +
                        HEX_CHARS[(h4 >> 4) & 0x0f] +
                        HEX_CHARS[h4 & 0x0f] +
                        HEX_CHARS[(h5 >> 28) & 0x0f] +
                        HEX_CHARS[(h5 >> 24) & 0x0f] +
                        HEX_CHARS[(h5 >> 20) & 0x0f] +
                        HEX_CHARS[(h5 >> 16) & 0x0f] +
                        HEX_CHARS[(h5 >> 12) & 0x0f] +
                        HEX_CHARS[(h5 >> 8) & 0x0f] +
                        HEX_CHARS[(h5 >> 4) & 0x0f] +
                        HEX_CHARS[h5 & 0x0f] +
                        HEX_CHARS[(h6 >> 28) & 0x0f] +
                        HEX_CHARS[(h6 >> 24) & 0x0f] +
                        HEX_CHARS[(h6 >> 20) & 0x0f] +
                        HEX_CHARS[(h6 >> 16) & 0x0f] +
                        HEX_CHARS[(h6 >> 12) & 0x0f] +
                        HEX_CHARS[(h6 >> 8) & 0x0f] +
                        HEX_CHARS[(h6 >> 4) & 0x0f] +
                        HEX_CHARS[h6 & 0x0f];
                    if (!this.#is224) {
                        hex +=
                            HEX_CHARS[(h7 >> 28) & 0x0f] +
                                HEX_CHARS[(h7 >> 24) & 0x0f] +
                                HEX_CHARS[(h7 >> 20) & 0x0f] +
                                HEX_CHARS[(h7 >> 16) & 0x0f] +
                                HEX_CHARS[(h7 >> 12) & 0x0f] +
                                HEX_CHARS[(h7 >> 8) & 0x0f] +
                                HEX_CHARS[(h7 >> 4) & 0x0f] +
                                HEX_CHARS[h7 & 0x0f];
                    }
                    return hex;
                }
                /** Return hash in hex string. */
                toString() {
                    return this.hex();
                }
                /** Return hash in integer array. */
                digest() {
                    this.finalize();
                    const h0 = this.#h0;
                    const h1 = this.#h1;
                    const h2 = this.#h2;
                    const h3 = this.#h3;
                    const h4 = this.#h4;
                    const h5 = this.#h5;
                    const h6 = this.#h6;
                    const h7 = this.#h7;
                    const arr = [
                        (h0 >> 24) & 0xff,
                        (h0 >> 16) & 0xff,
                        (h0 >> 8) & 0xff,
                        h0 & 0xff,
                        (h1 >> 24) & 0xff,
                        (h1 >> 16) & 0xff,
                        (h1 >> 8) & 0xff,
                        h1 & 0xff,
                        (h2 >> 24) & 0xff,
                        (h2 >> 16) & 0xff,
                        (h2 >> 8) & 0xff,
                        h2 & 0xff,
                        (h3 >> 24) & 0xff,
                        (h3 >> 16) & 0xff,
                        (h3 >> 8) & 0xff,
                        h3 & 0xff,
                        (h4 >> 24) & 0xff,
                        (h4 >> 16) & 0xff,
                        (h4 >> 8) & 0xff,
                        h4 & 0xff,
                        (h5 >> 24) & 0xff,
                        (h5 >> 16) & 0xff,
                        (h5 >> 8) & 0xff,
                        h5 & 0xff,
                        (h6 >> 24) & 0xff,
                        (h6 >> 16) & 0xff,
                        (h6 >> 8) & 0xff,
                        h6 & 0xff,
                    ];
                    if (!this.#is224) {
                        arr.push((h7 >> 24) & 0xff, (h7 >> 16) & 0xff, (h7 >> 8) & 0xff, h7 & 0xff);
                    }
                    return arr;
                }
                /** Return hash in integer array. */
                array() {
                    return this.digest();
                }
                /** Return hash in ArrayBuffer. */
                arrayBuffer() {
                    this.finalize();
                    const buffer = new ArrayBuffer(this.#is224 ? 28 : 32);
                    const dataView = new DataView(buffer);
                    dataView.setUint32(0, this.#h0);
                    dataView.setUint32(4, this.#h1);
                    dataView.setUint32(8, this.#h2);
                    dataView.setUint32(12, this.#h3);
                    dataView.setUint32(16, this.#h4);
                    dataView.setUint32(20, this.#h5);
                    dataView.setUint32(24, this.#h6);
                    if (!this.#is224) {
                        dataView.setUint32(28, this.#h7);
                    }
                    return buffer;
                }
            };
            exports_15("Sha256", Sha256);
            HmacSha256 = class HmacSha256 extends Sha256 {
                constructor(secretKey, is224 = false, sharedMemory = false) {
                    super(is224, sharedMemory);
                    let key;
                    if (typeof secretKey === "string") {
                        const bytes = [];
                        const length = secretKey.length;
                        let index = 0;
                        for (let i = 0; i < length; ++i) {
                            let code = secretKey.charCodeAt(i);
                            if (code < 0x80) {
                                bytes[index++] = code;
                            }
                            else if (code < 0x800) {
                                bytes[index++] = 0xc0 | (code >> 6);
                                bytes[index++] = 0x80 | (code & 0x3f);
                            }
                            else if (code < 0xd800 || code >= 0xe000) {
                                bytes[index++] = 0xe0 | (code >> 12);
                                bytes[index++] = 0x80 | ((code >> 6) & 0x3f);
                                bytes[index++] = 0x80 | (code & 0x3f);
                            }
                            else {
                                code =
                                    0x10000 +
                                        (((code & 0x3ff) << 10) | (secretKey.charCodeAt(++i) & 0x3ff));
                                bytes[index++] = 0xf0 | (code >> 18);
                                bytes[index++] = 0x80 | ((code >> 12) & 0x3f);
                                bytes[index++] = 0x80 | ((code >> 6) & 0x3f);
                                bytes[index++] = 0x80 | (code & 0x3f);
                            }
                        }
                        key = bytes;
                    }
                    else {
                        if (secretKey instanceof ArrayBuffer) {
                            key = new Uint8Array(secretKey);
                        }
                        else {
                            key = secretKey;
                        }
                    }
                    if (key.length > 64) {
                        key = new Sha256(is224, true).update(key).array();
                    }
                    const oKeyPad = [];
                    const iKeyPad = [];
                    for (let i = 0; i < 64; ++i) {
                        const b = key[i] || 0;
                        oKeyPad[i] = 0x5c ^ b;
                        iKeyPad[i] = 0x36 ^ b;
                    }
                    this.update(iKeyPad);
                    this.#oKeyPad = oKeyPad;
                    this.#inner = true;
                    this.#is224 = is224;
                    this.#sharedMemory = sharedMemory;
                }
                #inner;
                #is224;
                #oKeyPad;
                #sharedMemory;
                finalize() {
                    super.finalize();
                    if (this.#inner) {
                        this.#inner = false;
                        const innerHash = this.array();
                        super.init(this.#is224, this.#sharedMemory);
                        this.update(this.#oKeyPad);
                        this.update(innerHash);
                        super.finalize();
                    }
                }
            };
            exports_15("HmacSha256", HmacSha256);
        }
    };
});
System.register("https://deno.land/std@0.57.0/encoding/utf8", [], function (exports_16, context_16) {
    "use strict";
    var encoder, decoder;
    var __moduleName = context_16 && context_16.id;
    /** Shorthand for new TextEncoder().encode() */
    function encode(input) {
        return encoder.encode(input);
    }
    exports_16("encode", encode);
    /** Shorthand for new TextDecoder().decode() */
    function decode(input) {
        return decoder.decode(input);
    }
    exports_16("decode", decode);
    return {
        setters: [],
        execute: function () {
            /** A default TextEncoder instance */
            exports_16("encoder", encoder = new TextEncoder());
            /** A default TextDecoder instance */
            exports_16("decoder", decoder = new TextDecoder());
        }
    };
});
// Based on https://github.com/golang/go/blob/891682/src/bufio/bufio.go
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
System.register("https://deno.land/std@0.57.0/io/bufio", ["https://deno.land/std@0.57.0/io/util", "https://deno.land/std@0.57.0/_util/assert"], function (exports_17, context_17) {
    "use strict";
    var util_ts_2, assert_ts_3, DEFAULT_BUF_SIZE, MIN_BUF_SIZE, MAX_CONSECUTIVE_EMPTY_READS, CR, LF, BufferFullError, PartialReadError, BufReader, AbstractBufBase, BufWriter, BufWriterSync;
    var __moduleName = context_17 && context_17.id;
    /** Generate longest proper prefix which is also suffix array. */
    function createLPS(pat) {
        const lps = new Uint8Array(pat.length);
        lps[0] = 0;
        let prefixEnd = 0;
        let i = 1;
        while (i < lps.length) {
            if (pat[i] == pat[prefixEnd]) {
                prefixEnd++;
                lps[i] = prefixEnd;
                i++;
            }
            else if (prefixEnd === 0) {
                lps[i] = 0;
                i++;
            }
            else {
                prefixEnd = pat[prefixEnd - 1];
            }
        }
        return lps;
    }
    /** Read delimited bytes from a Reader. */
    async function* readDelim(reader, delim) {
        // Avoid unicode problems
        const delimLen = delim.length;
        const delimLPS = createLPS(delim);
        let inputBuffer = new Deno.Buffer();
        const inspectArr = new Uint8Array(Math.max(1024, delimLen + 1));
        // Modified KMP
        let inspectIndex = 0;
        let matchIndex = 0;
        while (true) {
            const result = await reader.read(inspectArr);
            if (result === null) {
                // Yield last chunk.
                yield inputBuffer.bytes();
                return;
            }
            if (result < 0) {
                // Discard all remaining and silently fail.
                return;
            }
            const sliceRead = inspectArr.subarray(0, result);
            await Deno.writeAll(inputBuffer, sliceRead);
            let sliceToProcess = inputBuffer.bytes();
            while (inspectIndex < sliceToProcess.length) {
                if (sliceToProcess[inspectIndex] === delim[matchIndex]) {
                    inspectIndex++;
                    matchIndex++;
                    if (matchIndex === delimLen) {
                        // Full match
                        const matchEnd = inspectIndex - delimLen;
                        const readyBytes = sliceToProcess.subarray(0, matchEnd);
                        // Copy
                        const pendingBytes = sliceToProcess.slice(inspectIndex);
                        yield readyBytes;
                        // Reset match, different from KMP.
                        sliceToProcess = pendingBytes;
                        inspectIndex = 0;
                        matchIndex = 0;
                    }
                }
                else {
                    if (matchIndex === 0) {
                        inspectIndex++;
                    }
                    else {
                        matchIndex = delimLPS[matchIndex - 1];
                    }
                }
            }
            // Keep inspectIndex and matchIndex.
            inputBuffer = new Deno.Buffer(sliceToProcess);
        }
    }
    exports_17("readDelim", readDelim);
    /** Read delimited strings from a Reader. */
    async function* readStringDelim(reader, delim) {
        const encoder = new TextEncoder();
        const decoder = new TextDecoder();
        for await (const chunk of readDelim(reader, encoder.encode(delim))) {
            yield decoder.decode(chunk);
        }
    }
    exports_17("readStringDelim", readStringDelim);
    /** Read strings line-by-line from a Reader. */
    // eslint-disable-next-line require-await
    async function* readLines(reader) {
        yield* readStringDelim(reader, "\n");
    }
    exports_17("readLines", readLines);
    return {
        setters: [
            function (util_ts_2_1) {
                util_ts_2 = util_ts_2_1;
            },
            function (assert_ts_3_1) {
                assert_ts_3 = assert_ts_3_1;
            }
        ],
        execute: function () {
            DEFAULT_BUF_SIZE = 4096;
            MIN_BUF_SIZE = 16;
            MAX_CONSECUTIVE_EMPTY_READS = 100;
            CR = util_ts_2.charCode("\r");
            LF = util_ts_2.charCode("\n");
            BufferFullError = class BufferFullError extends Error {
                constructor(partial) {
                    super("Buffer full");
                    this.partial = partial;
                    this.name = "BufferFullError";
                }
            };
            exports_17("BufferFullError", BufferFullError);
            PartialReadError = class PartialReadError extends Deno.errors.UnexpectedEof {
                constructor() {
                    super("Encountered UnexpectedEof, data only partially read");
                    this.name = "PartialReadError";
                }
            };
            exports_17("PartialReadError", PartialReadError);
            /** BufReader implements buffering for a Reader object. */
            BufReader = class BufReader {
                constructor(rd, size = DEFAULT_BUF_SIZE) {
                    this.r = 0; // buf read position.
                    this.w = 0; // buf write position.
                    this.eof = false;
                    if (size < MIN_BUF_SIZE) {
                        size = MIN_BUF_SIZE;
                    }
                    this._reset(new Uint8Array(size), rd);
                }
                // private lastByte: number;
                // private lastCharSize: number;
                /** return new BufReader unless r is BufReader */
                static create(r, size = DEFAULT_BUF_SIZE) {
                    return r instanceof BufReader ? r : new BufReader(r, size);
                }
                /** Returns the size of the underlying buffer in bytes. */
                size() {
                    return this.buf.byteLength;
                }
                buffered() {
                    return this.w - this.r;
                }
                // Reads a new chunk into the buffer.
                async _fill() {
                    // Slide existing data to beginning.
                    if (this.r > 0) {
                        this.buf.copyWithin(0, this.r, this.w);
                        this.w -= this.r;
                        this.r = 0;
                    }
                    if (this.w >= this.buf.byteLength) {
                        throw Error("bufio: tried to fill full buffer");
                    }
                    // Read new data: try a limited number of times.
                    for (let i = MAX_CONSECUTIVE_EMPTY_READS; i > 0; i--) {
                        const rr = await this.rd.read(this.buf.subarray(this.w));
                        if (rr === null) {
                            this.eof = true;
                            return;
                        }
                        assert_ts_3.assert(rr >= 0, "negative read");
                        this.w += rr;
                        if (rr > 0) {
                            return;
                        }
                    }
                    throw new Error(`No progress after ${MAX_CONSECUTIVE_EMPTY_READS} read() calls`);
                }
                /** Discards any buffered data, resets all state, and switches
                 * the buffered reader to read from r.
                 */
                reset(r) {
                    this._reset(this.buf, r);
                }
                _reset(buf, rd) {
                    this.buf = buf;
                    this.rd = rd;
                    this.eof = false;
                    // this.lastByte = -1;
                    // this.lastCharSize = -1;
                }
                /** reads data into p.
                 * It returns the number of bytes read into p.
                 * The bytes are taken from at most one Read on the underlying Reader,
                 * hence n may be less than len(p).
                 * To read exactly len(p) bytes, use io.ReadFull(b, p).
                 */
                async read(p) {
                    let rr = p.byteLength;
                    if (p.byteLength === 0)
                        return rr;
                    if (this.r === this.w) {
                        if (p.byteLength >= this.buf.byteLength) {
                            // Large read, empty buffer.
                            // Read directly into p to avoid copy.
                            const rr = await this.rd.read(p);
                            const nread = rr ?? 0;
                            assert_ts_3.assert(nread >= 0, "negative read");
                            // if (rr.nread > 0) {
                            //   this.lastByte = p[rr.nread - 1];
                            //   this.lastCharSize = -1;
                            // }
                            return rr;
                        }
                        // One read.
                        // Do not use this.fill, which will loop.
                        this.r = 0;
                        this.w = 0;
                        rr = await this.rd.read(this.buf);
                        if (rr === 0 || rr === null)
                            return rr;
                        assert_ts_3.assert(rr >= 0, "negative read");
                        this.w += rr;
                    }
                    // copy as much as we can
                    const copied = util_ts_2.copyBytes(this.buf.subarray(this.r, this.w), p, 0);
                    this.r += copied;
                    // this.lastByte = this.buf[this.r - 1];
                    // this.lastCharSize = -1;
                    return copied;
                }
                /** reads exactly `p.length` bytes into `p`.
                 *
                 * If successful, `p` is returned.
                 *
                 * If the end of the underlying stream has been reached, and there are no more
                 * bytes available in the buffer, `readFull()` returns `null` instead.
                 *
                 * An error is thrown if some bytes could be read, but not enough to fill `p`
                 * entirely before the underlying stream reported an error or EOF. Any error
                 * thrown will have a `partial` property that indicates the slice of the
                 * buffer that has been successfully filled with data.
                 *
                 * Ported from https://golang.org/pkg/io/#ReadFull
                 */
                async readFull(p) {
                    let bytesRead = 0;
                    while (bytesRead < p.length) {
                        try {
                            const rr = await this.read(p.subarray(bytesRead));
                            if (rr === null) {
                                if (bytesRead === 0) {
                                    return null;
                                }
                                else {
                                    throw new PartialReadError();
                                }
                            }
                            bytesRead += rr;
                        }
                        catch (err) {
                            err.partial = p.subarray(0, bytesRead);
                            throw err;
                        }
                    }
                    return p;
                }
                /** Returns the next byte [0, 255] or `null`. */
                async readByte() {
                    while (this.r === this.w) {
                        if (this.eof)
                            return null;
                        await this._fill(); // buffer is empty.
                    }
                    const c = this.buf[this.r];
                    this.r++;
                    // this.lastByte = c;
                    return c;
                }
                /** readString() reads until the first occurrence of delim in the input,
                 * returning a string containing the data up to and including the delimiter.
                 * If ReadString encounters an error before finding a delimiter,
                 * it returns the data read before the error and the error itself
                 * (often `null`).
                 * ReadString returns err != nil if and only if the returned data does not end
                 * in delim.
                 * For simple uses, a Scanner may be more convenient.
                 */
                async readString(delim) {
                    if (delim.length !== 1) {
                        throw new Error("Delimiter should be a single character");
                    }
                    const buffer = await this.readSlice(delim.charCodeAt(0));
                    if (buffer === null)
                        return null;
                    return new TextDecoder().decode(buffer);
                }
                /** `readLine()` is a low-level line-reading primitive. Most callers should
                 * use `readString('\n')` instead or use a Scanner.
                 *
                 * `readLine()` tries to return a single line, not including the end-of-line
                 * bytes. If the line was too long for the buffer then `more` is set and the
                 * beginning of the line is returned. The rest of the line will be returned
                 * from future calls. `more` will be false when returning the last fragment
                 * of the line. The returned buffer is only valid until the next call to
                 * `readLine()`.
                 *
                 * The text returned from ReadLine does not include the line end ("\r\n" or
                 * "\n").
                 *
                 * When the end of the underlying stream is reached, the final bytes in the
                 * stream are returned. No indication or error is given if the input ends
                 * without a final line end. When there are no more trailing bytes to read,
                 * `readLine()` returns `null`.
                 *
                 * Calling `unreadByte()` after `readLine()` will always unread the last byte
                 * read (possibly a character belonging to the line end) even if that byte is
                 * not part of the line returned by `readLine()`.
                 */
                async readLine() {
                    let line;
                    try {
                        line = await this.readSlice(LF);
                    }
                    catch (err) {
                        let { partial } = err;
                        assert_ts_3.assert(partial instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");
                        // Don't throw if `readSlice()` failed with `BufferFullError`, instead we
                        // just return whatever is available and set the `more` flag.
                        if (!(err instanceof BufferFullError)) {
                            throw err;
                        }
                        // Handle the case where "\r\n" straddles the buffer.
                        if (!this.eof &&
                            partial.byteLength > 0 &&
                            partial[partial.byteLength - 1] === CR) {
                            // Put the '\r' back on buf and drop it from line.
                            // Let the next call to ReadLine check for "\r\n".
                            assert_ts_3.assert(this.r > 0, "bufio: tried to rewind past start of buffer");
                            this.r--;
                            partial = partial.subarray(0, partial.byteLength - 1);
                        }
                        return { line: partial, more: !this.eof };
                    }
                    if (line === null) {
                        return null;
                    }
                    if (line.byteLength === 0) {
                        return { line, more: false };
                    }
                    if (line[line.byteLength - 1] == LF) {
                        let drop = 1;
                        if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {
                            drop = 2;
                        }
                        line = line.subarray(0, line.byteLength - drop);
                    }
                    return { line, more: false };
                }
                /** `readSlice()` reads until the first occurrence of `delim` in the input,
                 * returning a slice pointing at the bytes in the buffer. The bytes stop
                 * being valid at the next read.
                 *
                 * If `readSlice()` encounters an error before finding a delimiter, or the
                 * buffer fills without finding a delimiter, it throws an error with a
                 * `partial` property that contains the entire buffer.
                 *
                 * If `readSlice()` encounters the end of the underlying stream and there are
                 * any bytes left in the buffer, the rest of the buffer is returned. In other
                 * words, EOF is always treated as a delimiter. Once the buffer is empty,
                 * it returns `null`.
                 *
                 * Because the data returned from `readSlice()` will be overwritten by the
                 * next I/O operation, most clients should use `readString()` instead.
                 */
                async readSlice(delim) {
                    let s = 0; // search start index
                    let slice;
                    while (true) {
                        // Search buffer.
                        let i = this.buf.subarray(this.r + s, this.w).indexOf(delim);
                        if (i >= 0) {
                            i += s;
                            slice = this.buf.subarray(this.r, this.r + i + 1);
                            this.r += i + 1;
                            break;
                        }
                        // EOF?
                        if (this.eof) {
                            if (this.r === this.w) {
                                return null;
                            }
                            slice = this.buf.subarray(this.r, this.w);
                            this.r = this.w;
                            break;
                        }
                        // Buffer full?
                        if (this.buffered() >= this.buf.byteLength) {
                            this.r = this.w;
                            // #4521 The internal buffer should not be reused across reads because it causes corruption of data.
                            const oldbuf = this.buf;
                            const newbuf = this.buf.slice(0);
                            this.buf = newbuf;
                            throw new BufferFullError(oldbuf);
                        }
                        s = this.w - this.r; // do not rescan area we scanned before
                        // Buffer is not full.
                        try {
                            await this._fill();
                        }
                        catch (err) {
                            err.partial = slice;
                            throw err;
                        }
                    }
                    // Handle last byte, if any.
                    // const i = slice.byteLength - 1;
                    // if (i >= 0) {
                    //   this.lastByte = slice[i];
                    //   this.lastCharSize = -1
                    // }
                    return slice;
                }
                /** `peek()` returns the next `n` bytes without advancing the reader. The
                 * bytes stop being valid at the next read call.
                 *
                 * When the end of the underlying stream is reached, but there are unread
                 * bytes left in the buffer, those bytes are returned. If there are no bytes
                 * left in the buffer, it returns `null`.
                 *
                 * If an error is encountered before `n` bytes are available, `peek()` throws
                 * an error with the `partial` property set to a slice of the buffer that
                 * contains the bytes that were available before the error occurred.
                 */
                async peek(n) {
                    if (n < 0) {
                        throw Error("negative count");
                    }
                    let avail = this.w - this.r;
                    while (avail < n && avail < this.buf.byteLength && !this.eof) {
                        try {
                            await this._fill();
                        }
                        catch (err) {
                            err.partial = this.buf.subarray(this.r, this.w);
                            throw err;
                        }
                        avail = this.w - this.r;
                    }
                    if (avail === 0 && this.eof) {
                        return null;
                    }
                    else if (avail < n && this.eof) {
                        return this.buf.subarray(this.r, this.r + avail);
                    }
                    else if (avail < n) {
                        throw new BufferFullError(this.buf.subarray(this.r, this.w));
                    }
                    return this.buf.subarray(this.r, this.r + n);
                }
            };
            exports_17("BufReader", BufReader);
            AbstractBufBase = class AbstractBufBase {
                constructor() {
                    this.usedBufferBytes = 0;
                    this.err = null;
                }
                /** Size returns the size of the underlying buffer in bytes. */
                size() {
                    return this.buf.byteLength;
                }
                /** Returns how many bytes are unused in the buffer. */
                available() {
                    return this.buf.byteLength - this.usedBufferBytes;
                }
                /** buffered returns the number of bytes that have been written into the
                 * current buffer.
                 */
                buffered() {
                    return this.usedBufferBytes;
                }
                checkBytesWritten(numBytesWritten) {
                    if (numBytesWritten < this.usedBufferBytes) {
                        if (numBytesWritten > 0) {
                            this.buf.copyWithin(0, numBytesWritten, this.usedBufferBytes);
                            this.usedBufferBytes -= numBytesWritten;
                        }
                        this.err = new Error("Short write");
                        throw this.err;
                    }
                }
            };
            /** BufWriter implements buffering for an deno.Writer object.
             * If an error occurs writing to a Writer, no more data will be
             * accepted and all subsequent writes, and flush(), will return the error.
             * After all data has been written, the client should call the
             * flush() method to guarantee all data has been forwarded to
             * the underlying deno.Writer.
             */
            BufWriter = class BufWriter extends AbstractBufBase {
                constructor(writer, size = DEFAULT_BUF_SIZE) {
                    super();
                    this.writer = writer;
                    if (size <= 0) {
                        size = DEFAULT_BUF_SIZE;
                    }
                    this.buf = new Uint8Array(size);
                }
                /** return new BufWriter unless writer is BufWriter */
                static create(writer, size = DEFAULT_BUF_SIZE) {
                    return writer instanceof BufWriter ? writer : new BufWriter(writer, size);
                }
                /** Discards any unflushed buffered data, clears any error, and
                 * resets buffer to write its output to w.
                 */
                reset(w) {
                    this.err = null;
                    this.usedBufferBytes = 0;
                    this.writer = w;
                }
                /** Flush writes any buffered data to the underlying io.Writer. */
                async flush() {
                    if (this.err !== null)
                        throw this.err;
                    if (this.usedBufferBytes === 0)
                        return;
                    let numBytesWritten = 0;
                    try {
                        numBytesWritten = await this.writer.write(this.buf.subarray(0, this.usedBufferBytes));
                    }
                    catch (e) {
                        this.err = e;
                        throw e;
                    }
                    this.checkBytesWritten(numBytesWritten);
                    this.usedBufferBytes = 0;
                }
                /** Writes the contents of `data` into the buffer.  If the contents won't fully
                 * fit into the buffer, those bytes that can are copied into the buffer, the
                 * buffer is the flushed to the writer and the remaining bytes are copied into
                 * the now empty buffer.
                 *
                 * @return the number of bytes written to the buffer.
                 */
                async write(data) {
                    if (this.err !== null)
                        throw this.err;
                    if (data.length === 0)
                        return 0;
                    let totalBytesWritten = 0;
                    let numBytesWritten = 0;
                    while (data.byteLength > this.available()) {
                        if (this.buffered() === 0) {
                            // Large write, empty buffer.
                            // Write directly from data to avoid copy.
                            try {
                                numBytesWritten = await this.writer.write(data);
                            }
                            catch (e) {
                                this.err = e;
                                throw e;
                            }
                        }
                        else {
                            numBytesWritten = util_ts_2.copyBytes(data, this.buf, this.usedBufferBytes);
                            this.usedBufferBytes += numBytesWritten;
                            await this.flush();
                        }
                        totalBytesWritten += numBytesWritten;
                        data = data.subarray(numBytesWritten);
                    }
                    numBytesWritten = util_ts_2.copyBytes(data, this.buf, this.usedBufferBytes);
                    this.usedBufferBytes += numBytesWritten;
                    totalBytesWritten += numBytesWritten;
                    return totalBytesWritten;
                }
            };
            exports_17("BufWriter", BufWriter);
            /** BufWriterSync implements buffering for a deno.WriterSync object.
             * If an error occurs writing to a WriterSync, no more data will be
             * accepted and all subsequent writes, and flush(), will return the error.
             * After all data has been written, the client should call the
             * flush() method to guarantee all data has been forwarded to
             * the underlying deno.WriterSync.
             */
            BufWriterSync = class BufWriterSync extends AbstractBufBase {
                constructor(writer, size = DEFAULT_BUF_SIZE) {
                    super();
                    this.writer = writer;
                    if (size <= 0) {
                        size = DEFAULT_BUF_SIZE;
                    }
                    this.buf = new Uint8Array(size);
                }
                /** return new BufWriterSync unless writer is BufWriterSync */
                static create(writer, size = DEFAULT_BUF_SIZE) {
                    return writer instanceof BufWriterSync
                        ? writer
                        : new BufWriterSync(writer, size);
                }
                /** Discards any unflushed buffered data, clears any error, and
                 * resets buffer to write its output to w.
                 */
                reset(w) {
                    this.err = null;
                    this.usedBufferBytes = 0;
                    this.writer = w;
                }
                /** Flush writes any buffered data to the underlying io.WriterSync. */
                flush() {
                    if (this.err !== null)
                        throw this.err;
                    if (this.usedBufferBytes === 0)
                        return;
                    let numBytesWritten = 0;
                    try {
                        numBytesWritten = this.writer.writeSync(this.buf.subarray(0, this.usedBufferBytes));
                    }
                    catch (e) {
                        this.err = e;
                        throw e;
                    }
                    this.checkBytesWritten(numBytesWritten);
                    this.usedBufferBytes = 0;
                }
                /** Writes the contents of `data` into the buffer.  If the contents won't fully
                 * fit into the buffer, those bytes that can are copied into the buffer, the
                 * buffer is the flushed to the writer and the remaining bytes are copied into
                 * the now empty buffer.
                 *
                 * @return the number of bytes written to the buffer.
                 */
                writeSync(data) {
                    if (this.err !== null)
                        throw this.err;
                    if (data.length === 0)
                        return 0;
                    let totalBytesWritten = 0;
                    let numBytesWritten = 0;
                    while (data.byteLength > this.available()) {
                        if (this.buffered() === 0) {
                            // Large write, empty buffer.
                            // Write directly from data to avoid copy.
                            try {
                                numBytesWritten = this.writer.writeSync(data);
                            }
                            catch (e) {
                                this.err = e;
                                throw e;
                            }
                        }
                        else {
                            numBytesWritten = util_ts_2.copyBytes(data, this.buf, this.usedBufferBytes);
                            this.usedBufferBytes += numBytesWritten;
                            this.flush();
                        }
                        totalBytesWritten += numBytesWritten;
                        data = data.subarray(numBytesWritten);
                    }
                    numBytesWritten = util_ts_2.copyBytes(data, this.buf, this.usedBufferBytes);
                    this.usedBufferBytes += numBytesWritten;
                    totalBytesWritten += numBytesWritten;
                    return totalBytesWritten;
                }
            };
            exports_17("BufWriterSync", BufWriterSync);
        }
    };
});
System.register("https://deno.land/std@0.57.0/async/deferred", [], function (exports_18, context_18) {
    "use strict";
    var __moduleName = context_18 && context_18.id;
    /** Creates a Promise with the `reject` and `resolve` functions
     * placed as methods on the promise object itself. It allows you to do:
     *
     *     const p = deferred<number>();
     *     // ...
     *     p.resolve(42);
     */
    function deferred() {
        let methods;
        const promise = new Promise((resolve, reject) => {
            methods = { resolve, reject };
        });
        return Object.assign(promise, methods);
    }
    exports_18("deferred", deferred);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.57.0/async/delay", [], function (exports_19, context_19) {
    "use strict";
    var __moduleName = context_19 && context_19.id;
    // Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
    /* Resolves after the given number of milliseconds. */
    function delay(ms) {
        return new Promise((res) => setTimeout(() => {
            res();
        }, ms));
    }
    exports_19("delay", delay);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.57.0/async/mux_async_iterator", ["https://deno.land/std@0.57.0/async/deferred"], function (exports_20, context_20) {
    "use strict";
    var deferred_ts_1, MuxAsyncIterator;
    var __moduleName = context_20 && context_20.id;
    return {
        setters: [
            function (deferred_ts_1_1) {
                deferred_ts_1 = deferred_ts_1_1;
            }
        ],
        execute: function () {
            /** The MuxAsyncIterator class multiplexes multiple async iterators into a
             * single stream. It currently makes a few assumptions:
             * - The iterators do not throw.
             * - The final result (the value returned and not yielded from the iterator)
             *   does not matter; if there is any, it is discarded.
             */
            MuxAsyncIterator = class MuxAsyncIterator {
                constructor() {
                    this.iteratorCount = 0;
                    this.yields = [];
                    this.signal = deferred_ts_1.deferred();
                }
                add(iterator) {
                    ++this.iteratorCount;
                    this.callIteratorNext(iterator);
                }
                async callIteratorNext(iterator) {
                    const { value, done } = await iterator.next();
                    if (done) {
                        --this.iteratorCount;
                    }
                    else {
                        this.yields.push({ iterator, value });
                    }
                    this.signal.resolve();
                }
                async *iterate() {
                    while (this.iteratorCount > 0) {
                        // Sleep until any of the wrapped iterators yields.
                        await this.signal;
                        // Note that while we're looping over `yields`, new items may be added.
                        for (let i = 0; i < this.yields.length; i++) {
                            const { iterator, value } = this.yields[i];
                            yield value;
                            this.callIteratorNext(iterator);
                        }
                        // Clear the `yields` list and reset the `signal` promise.
                        this.yields.length = 0;
                        this.signal = deferred_ts_1.deferred();
                    }
                }
                [Symbol.asyncIterator]() {
                    return this.iterate();
                }
            };
            exports_20("MuxAsyncIterator", MuxAsyncIterator);
        }
    };
});
System.register("https://deno.land/std@0.57.0/async/mod", ["https://deno.land/std@0.57.0/async/deferred", "https://deno.land/std@0.57.0/async/delay", "https://deno.land/std@0.57.0/async/mux_async_iterator"], function (exports_21, context_21) {
    "use strict";
    var __moduleName = context_21 && context_21.id;
    function exportStar_2(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default") exports[n] = m[n];
        }
        exports_21(exports);
    }
    return {
        setters: [
            function (deferred_ts_2_1) {
                exportStar_2(deferred_ts_2_1);
            },
            function (delay_ts_1_1) {
                exportStar_2(delay_ts_1_1);
            },
            function (mux_async_iterator_ts_1_1) {
                exportStar_2(mux_async_iterator_ts_1_1);
            }
        ],
        execute: function () {
        }
    };
});
// Based on https://github.com/golang/go/tree/master/src/net/textproto
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
System.register("https://deno.land/std@0.57.0/textproto/mod", ["https://deno.land/std@0.57.0/io/util", "https://deno.land/std@0.57.0/bytes/mod", "https://deno.land/std@0.57.0/encoding/utf8"], function (exports_22, context_22) {
    "use strict";
    var util_ts_3, mod_ts_2, utf8_ts_1, invalidHeaderCharRegex, TextProtoReader;
    var __moduleName = context_22 && context_22.id;
    function str(buf) {
        if (buf == null) {
            return "";
        }
        else {
            return utf8_ts_1.decode(buf);
        }
    }
    return {
        setters: [
            function (util_ts_3_1) {
                util_ts_3 = util_ts_3_1;
            },
            function (mod_ts_2_1) {
                mod_ts_2 = mod_ts_2_1;
            },
            function (utf8_ts_1_1) {
                utf8_ts_1 = utf8_ts_1_1;
            }
        ],
        execute: function () {
            // FROM https://github.com/denoland/deno/blob/b34628a26ab0187a827aa4ebe256e23178e25d39/cli/js/web/headers.ts#L9
            invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/g;
            TextProtoReader = class TextProtoReader {
                constructor(r) {
                    this.r = r;
                }
                /** readLine() reads a single line from the TextProtoReader,
                 * eliding the final \n or \r\n from the returned string.
                 */
                async readLine() {
                    const s = await this.readLineSlice();
                    if (s === null)
                        return null;
                    return str(s);
                }
                /** ReadMIMEHeader reads a MIME-style header from r.
                 * The header is a sequence of possibly continued Key: Value lines
                 * ending in a blank line.
                 * The returned map m maps CanonicalMIMEHeaderKey(key) to a
                 * sequence of values in the same order encountered in the input.
                 *
                 * For example, consider this input:
                 *
                 *	My-Key: Value 1
                 *	Long-Key: Even
                 *	       Longer Value
                 *	My-Key: Value 2
                 *
                 * Given that input, ReadMIMEHeader returns the map:
                 *
                 *	map[string][]string{
                 *		"My-Key": {"Value 1", "Value 2"},
                 *		"Long-Key": {"Even Longer Value"},
                 *	}
                 */
                async readMIMEHeader() {
                    const m = new Headers();
                    let line;
                    // The first line cannot start with a leading space.
                    let buf = await this.r.peek(1);
                    if (buf === null) {
                        return null;
                    }
                    else if (buf[0] == util_ts_3.charCode(" ") || buf[0] == util_ts_3.charCode("\t")) {
                        line = (await this.readLineSlice());
                    }
                    buf = await this.r.peek(1);
                    if (buf === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    else if (buf[0] == util_ts_3.charCode(" ") || buf[0] == util_ts_3.charCode("\t")) {
                        throw new Deno.errors.InvalidData(`malformed MIME header initial line: ${str(line)}`);
                    }
                    while (true) {
                        const kv = await this.readLineSlice(); // readContinuedLineSlice
                        if (kv === null)
                            throw new Deno.errors.UnexpectedEof();
                        if (kv.byteLength === 0)
                            return m;
                        // Key ends at first colon
                        let i = kv.indexOf(util_ts_3.charCode(":"));
                        if (i < 0) {
                            throw new Deno.errors.InvalidData(`malformed MIME header line: ${str(kv)}`);
                        }
                        //let key = canonicalMIMEHeaderKey(kv.subarray(0, endKey));
                        const key = str(kv.subarray(0, i));
                        // As per RFC 7230 field-name is a token,
                        // tokens consist of one or more chars.
                        // We could throw `Deno.errors.InvalidData` here,
                        // but better to be liberal in what we
                        // accept, so if we get an empty key, skip it.
                        if (key == "") {
                            continue;
                        }
                        // Skip initial spaces in value.
                        i++; // skip colon
                        while (i < kv.byteLength &&
                            (kv[i] == util_ts_3.charCode(" ") || kv[i] == util_ts_3.charCode("\t"))) {
                            i++;
                        }
                        const value = str(kv.subarray(i)).replace(invalidHeaderCharRegex, encodeURI);
                        // In case of invalid header we swallow the error
                        // example: "Audio Mode" => invalid due to space in the key
                        try {
                            m.append(key, value);
                        }
                        catch {
                            // Pass
                        }
                    }
                }
                async readLineSlice() {
                    // this.closeDot();
                    let line;
                    while (true) {
                        const r = await this.r.readLine();
                        if (r === null)
                            return null;
                        const { line: l, more } = r;
                        // Avoid the copy if the first call produced a full line.
                        if (!line && !more) {
                            // TODO(ry):
                            // This skipSpace() is definitely misplaced, but I don't know where it
                            // comes from nor how to fix it.
                            if (this.skipSpace(l) === 0) {
                                return new Uint8Array(0);
                            }
                            return l;
                        }
                        line = line ? mod_ts_2.concat(line, l) : l;
                        if (!more) {
                            break;
                        }
                    }
                    return line;
                }
                skipSpace(l) {
                    let n = 0;
                    for (let i = 0; i < l.length; i++) {
                        if (l[i] === util_ts_3.charCode(" ") || l[i] === util_ts_3.charCode("\t")) {
                            continue;
                        }
                        n++;
                    }
                    return n;
                }
            };
            exports_22("TextProtoReader", TextProtoReader);
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
System.register("https://deno.land/std@0.57.0/http/http_status", [], function (exports_23, context_23) {
    "use strict";
    var Status, STATUS_TEXT;
    var __moduleName = context_23 && context_23.id;
    return {
        setters: [],
        execute: function () {
            /** HTTP status codes */
            (function (Status) {
                /** RFC 7231, 6.2.1 */
                Status[Status["Continue"] = 100] = "Continue";
                /** RFC 7231, 6.2.2 */
                Status[Status["SwitchingProtocols"] = 101] = "SwitchingProtocols";
                /** RFC 2518, 10.1 */
                Status[Status["Processing"] = 102] = "Processing";
                /** RFC 8297 **/
                Status[Status["EarlyHints"] = 103] = "EarlyHints";
                /** RFC 7231, 6.3.1 */
                Status[Status["OK"] = 200] = "OK";
                /** RFC 7231, 6.3.2 */
                Status[Status["Created"] = 201] = "Created";
                /** RFC 7231, 6.3.3 */
                Status[Status["Accepted"] = 202] = "Accepted";
                /** RFC 7231, 6.3.4 */
                Status[Status["NonAuthoritativeInfo"] = 203] = "NonAuthoritativeInfo";
                /** RFC 7231, 6.3.5 */
                Status[Status["NoContent"] = 204] = "NoContent";
                /** RFC 7231, 6.3.6 */
                Status[Status["ResetContent"] = 205] = "ResetContent";
                /** RFC 7233, 4.1 */
                Status[Status["PartialContent"] = 206] = "PartialContent";
                /** RFC 4918, 11.1 */
                Status[Status["MultiStatus"] = 207] = "MultiStatus";
                /** RFC 5842, 7.1 */
                Status[Status["AlreadyReported"] = 208] = "AlreadyReported";
                /** RFC 3229, 10.4.1 */
                Status[Status["IMUsed"] = 226] = "IMUsed";
                /** RFC 7231, 6.4.1 */
                Status[Status["MultipleChoices"] = 300] = "MultipleChoices";
                /** RFC 7231, 6.4.2 */
                Status[Status["MovedPermanently"] = 301] = "MovedPermanently";
                /** RFC 7231, 6.4.3 */
                Status[Status["Found"] = 302] = "Found";
                /** RFC 7231, 6.4.4 */
                Status[Status["SeeOther"] = 303] = "SeeOther";
                /** RFC 7232, 4.1 */
                Status[Status["NotModified"] = 304] = "NotModified";
                /** RFC 7231, 6.4.5 */
                Status[Status["UseProxy"] = 305] = "UseProxy";
                /** RFC 7231, 6.4.7 */
                Status[Status["TemporaryRedirect"] = 307] = "TemporaryRedirect";
                /** RFC 7538, 3 */
                Status[Status["PermanentRedirect"] = 308] = "PermanentRedirect";
                /** RFC 7231, 6.5.1 */
                Status[Status["BadRequest"] = 400] = "BadRequest";
                /** RFC 7235, 3.1 */
                Status[Status["Unauthorized"] = 401] = "Unauthorized";
                /** RFC 7231, 6.5.2 */
                Status[Status["PaymentRequired"] = 402] = "PaymentRequired";
                /** RFC 7231, 6.5.3 */
                Status[Status["Forbidden"] = 403] = "Forbidden";
                /** RFC 7231, 6.5.4 */
                Status[Status["NotFound"] = 404] = "NotFound";
                /** RFC 7231, 6.5.5 */
                Status[Status["MethodNotAllowed"] = 405] = "MethodNotAllowed";
                /** RFC 7231, 6.5.6 */
                Status[Status["NotAcceptable"] = 406] = "NotAcceptable";
                /** RFC 7235, 3.2 */
                Status[Status["ProxyAuthRequired"] = 407] = "ProxyAuthRequired";
                /** RFC 7231, 6.5.7 */
                Status[Status["RequestTimeout"] = 408] = "RequestTimeout";
                /** RFC 7231, 6.5.8 */
                Status[Status["Conflict"] = 409] = "Conflict";
                /** RFC 7231, 6.5.9 */
                Status[Status["Gone"] = 410] = "Gone";
                /** RFC 7231, 6.5.10 */
                Status[Status["LengthRequired"] = 411] = "LengthRequired";
                /** RFC 7232, 4.2 */
                Status[Status["PreconditionFailed"] = 412] = "PreconditionFailed";
                /** RFC 7231, 6.5.11 */
                Status[Status["RequestEntityTooLarge"] = 413] = "RequestEntityTooLarge";
                /** RFC 7231, 6.5.12 */
                Status[Status["RequestURITooLong"] = 414] = "RequestURITooLong";
                /** RFC 7231, 6.5.13 */
                Status[Status["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
                /** RFC 7233, 4.4 */
                Status[Status["RequestedRangeNotSatisfiable"] = 416] = "RequestedRangeNotSatisfiable";
                /** RFC 7231, 6.5.14 */
                Status[Status["ExpectationFailed"] = 417] = "ExpectationFailed";
                /** RFC 7168, 2.3.3 */
                Status[Status["Teapot"] = 418] = "Teapot";
                /** RFC 7540, 9.1.2 */
                Status[Status["MisdirectedRequest"] = 421] = "MisdirectedRequest";
                /** RFC 4918, 11.2 */
                Status[Status["UnprocessableEntity"] = 422] = "UnprocessableEntity";
                /** RFC 4918, 11.3 */
                Status[Status["Locked"] = 423] = "Locked";
                /** RFC 4918, 11.4 */
                Status[Status["FailedDependency"] = 424] = "FailedDependency";
                /** RFC 8470, 5.2 */
                Status[Status["TooEarly"] = 425] = "TooEarly";
                /** RFC 7231, 6.5.15 */
                Status[Status["UpgradeRequired"] = 426] = "UpgradeRequired";
                /** RFC 6585, 3 */
                Status[Status["PreconditionRequired"] = 428] = "PreconditionRequired";
                /** RFC 6585, 4 */
                Status[Status["TooManyRequests"] = 429] = "TooManyRequests";
                /** RFC 6585, 5 */
                Status[Status["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
                /** RFC 7725, 3 */
                Status[Status["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
                /** RFC 7231, 6.6.1 */
                Status[Status["InternalServerError"] = 500] = "InternalServerError";
                /** RFC 7231, 6.6.2 */
                Status[Status["NotImplemented"] = 501] = "NotImplemented";
                /** RFC 7231, 6.6.3 */
                Status[Status["BadGateway"] = 502] = "BadGateway";
                /** RFC 7231, 6.6.4 */
                Status[Status["ServiceUnavailable"] = 503] = "ServiceUnavailable";
                /** RFC 7231, 6.6.5 */
                Status[Status["GatewayTimeout"] = 504] = "GatewayTimeout";
                /** RFC 7231, 6.6.6 */
                Status[Status["HTTPVersionNotSupported"] = 505] = "HTTPVersionNotSupported";
                /** RFC 2295, 8.1 */
                Status[Status["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
                /** RFC 4918, 11.5 */
                Status[Status["InsufficientStorage"] = 507] = "InsufficientStorage";
                /** RFC 5842, 7.2 */
                Status[Status["LoopDetected"] = 508] = "LoopDetected";
                /** RFC 2774, 7 */
                Status[Status["NotExtended"] = 510] = "NotExtended";
                /** RFC 6585, 6 */
                Status[Status["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";
            })(Status || (Status = {}));
            exports_23("Status", Status);
            exports_23("STATUS_TEXT", STATUS_TEXT = new Map([
                [Status.Continue, "Continue"],
                [Status.SwitchingProtocols, "Switching Protocols"],
                [Status.Processing, "Processing"],
                [Status.EarlyHints, "Early Hints"],
                [Status.OK, "OK"],
                [Status.Created, "Created"],
                [Status.Accepted, "Accepted"],
                [Status.NonAuthoritativeInfo, "Non-Authoritative Information"],
                [Status.NoContent, "No Content"],
                [Status.ResetContent, "Reset Content"],
                [Status.PartialContent, "Partial Content"],
                [Status.MultiStatus, "Multi-Status"],
                [Status.AlreadyReported, "Already Reported"],
                [Status.IMUsed, "IM Used"],
                [Status.MultipleChoices, "Multiple Choices"],
                [Status.MovedPermanently, "Moved Permanently"],
                [Status.Found, "Found"],
                [Status.SeeOther, "See Other"],
                [Status.NotModified, "Not Modified"],
                [Status.UseProxy, "Use Proxy"],
                [Status.TemporaryRedirect, "Temporary Redirect"],
                [Status.PermanentRedirect, "Permanent Redirect"],
                [Status.BadRequest, "Bad Request"],
                [Status.Unauthorized, "Unauthorized"],
                [Status.PaymentRequired, "Payment Required"],
                [Status.Forbidden, "Forbidden"],
                [Status.NotFound, "Not Found"],
                [Status.MethodNotAllowed, "Method Not Allowed"],
                [Status.NotAcceptable, "Not Acceptable"],
                [Status.ProxyAuthRequired, "Proxy Authentication Required"],
                [Status.RequestTimeout, "Request Timeout"],
                [Status.Conflict, "Conflict"],
                [Status.Gone, "Gone"],
                [Status.LengthRequired, "Length Required"],
                [Status.PreconditionFailed, "Precondition Failed"],
                [Status.RequestEntityTooLarge, "Request Entity Too Large"],
                [Status.RequestURITooLong, "Request URI Too Long"],
                [Status.UnsupportedMediaType, "Unsupported Media Type"],
                [Status.RequestedRangeNotSatisfiable, "Requested Range Not Satisfiable"],
                [Status.ExpectationFailed, "Expectation Failed"],
                [Status.Teapot, "I'm a teapot"],
                [Status.MisdirectedRequest, "Misdirected Request"],
                [Status.UnprocessableEntity, "Unprocessable Entity"],
                [Status.Locked, "Locked"],
                [Status.FailedDependency, "Failed Dependency"],
                [Status.TooEarly, "Too Early"],
                [Status.UpgradeRequired, "Upgrade Required"],
                [Status.PreconditionRequired, "Precondition Required"],
                [Status.TooManyRequests, "Too Many Requests"],
                [Status.RequestHeaderFieldsTooLarge, "Request Header Fields Too Large"],
                [Status.UnavailableForLegalReasons, "Unavailable For Legal Reasons"],
                [Status.InternalServerError, "Internal Server Error"],
                [Status.NotImplemented, "Not Implemented"],
                [Status.BadGateway, "Bad Gateway"],
                [Status.ServiceUnavailable, "Service Unavailable"],
                [Status.GatewayTimeout, "Gateway Timeout"],
                [Status.HTTPVersionNotSupported, "HTTP Version Not Supported"],
                [Status.VariantAlsoNegotiates, "Variant Also Negotiates"],
                [Status.InsufficientStorage, "Insufficient Storage"],
                [Status.LoopDetected, "Loop Detected"],
                [Status.NotExtended, "Not Extended"],
                [Status.NetworkAuthenticationRequired, "Network Authentication Required"],
            ]));
        }
    };
});
System.register("https://deno.land/std@0.57.0/http/_io", ["https://deno.land/std@0.57.0/io/bufio", "https://deno.land/std@0.57.0/textproto/mod", "https://deno.land/std@0.57.0/_util/assert", "https://deno.land/std@0.57.0/encoding/utf8", "https://deno.land/std@0.57.0/http/server", "https://deno.land/std@0.57.0/http/http_status"], function (exports_24, context_24) {
    "use strict";
    var bufio_ts_1, mod_ts_3, assert_ts_4, utf8_ts_2, server_ts_1, http_status_ts_1;
    var __moduleName = context_24 && context_24.id;
    function emptyReader() {
        return {
            read(_) {
                return Promise.resolve(null);
            },
        };
    }
    exports_24("emptyReader", emptyReader);
    function bodyReader(contentLength, r) {
        let totalRead = 0;
        let finished = false;
        async function read(buf) {
            if (finished)
                return null;
            let result;
            const remaining = contentLength - totalRead;
            if (remaining >= buf.byteLength) {
                result = await r.read(buf);
            }
            else {
                const readBuf = buf.subarray(0, remaining);
                result = await r.read(readBuf);
            }
            if (result !== null) {
                totalRead += result;
            }
            finished = totalRead === contentLength;
            return result;
        }
        return { read };
    }
    exports_24("bodyReader", bodyReader);
    function chunkedBodyReader(h, r) {
        // Based on https://tools.ietf.org/html/rfc2616#section-19.4.6
        const tp = new mod_ts_3.TextProtoReader(r);
        let finished = false;
        const chunks = [];
        async function read(buf) {
            if (finished)
                return null;
            const [chunk] = chunks;
            if (chunk) {
                const chunkRemaining = chunk.data.byteLength - chunk.offset;
                const readLength = Math.min(chunkRemaining, buf.byteLength);
                for (let i = 0; i < readLength; i++) {
                    buf[i] = chunk.data[chunk.offset + i];
                }
                chunk.offset += readLength;
                if (chunk.offset === chunk.data.byteLength) {
                    chunks.shift();
                    // Consume \r\n;
                    if ((await tp.readLine()) === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                }
                return readLength;
            }
            const line = await tp.readLine();
            if (line === null)
                throw new Deno.errors.UnexpectedEof();
            // TODO: handle chunk extension
            const [chunkSizeString] = line.split(";");
            const chunkSize = parseInt(chunkSizeString, 16);
            if (Number.isNaN(chunkSize) || chunkSize < 0) {
                throw new Error("Invalid chunk size");
            }
            if (chunkSize > 0) {
                if (chunkSize > buf.byteLength) {
                    let eof = await r.readFull(buf);
                    if (eof === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    const restChunk = new Uint8Array(chunkSize - buf.byteLength);
                    eof = await r.readFull(restChunk);
                    if (eof === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    else {
                        chunks.push({
                            offset: 0,
                            data: restChunk,
                        });
                    }
                    return buf.byteLength;
                }
                else {
                    const bufToFill = buf.subarray(0, chunkSize);
                    const eof = await r.readFull(bufToFill);
                    if (eof === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    // Consume \r\n
                    if ((await tp.readLine()) === null) {
                        throw new Deno.errors.UnexpectedEof();
                    }
                    return chunkSize;
                }
            }
            else {
                assert_ts_4.assert(chunkSize === 0);
                // Consume \r\n
                if ((await r.readLine()) === null) {
                    throw new Deno.errors.UnexpectedEof();
                }
                await readTrailers(h, r);
                finished = true;
                return null;
            }
        }
        return { read };
    }
    exports_24("chunkedBodyReader", chunkedBodyReader);
    function isProhibidedForTrailer(key) {
        const s = new Set(["transfer-encoding", "content-length", "trailer"]);
        return s.has(key.toLowerCase());
    }
    /** Read trailer headers from reader and append values to headers. "trailer"
     * field will be deleted. */
    async function readTrailers(headers, r) {
        const trailers = parseTrailer(headers.get("trailer"));
        if (trailers == null)
            return;
        const trailerNames = [...trailers.keys()];
        const tp = new mod_ts_3.TextProtoReader(r);
        const result = await tp.readMIMEHeader();
        if (result == null) {
            throw new Deno.errors.InvalidData("Missing trailer header.");
        }
        const undeclared = [...result.keys()].filter((k) => !trailerNames.includes(k));
        if (undeclared.length > 0) {
            throw new Deno.errors.InvalidData(`Undeclared trailers: ${Deno.inspect(undeclared)}.`);
        }
        for (const [k, v] of result) {
            headers.append(k, v);
        }
        const missingTrailers = trailerNames.filter((k) => !result.has(k));
        if (missingTrailers.length > 0) {
            throw new Deno.errors.InvalidData(`Missing trailers: ${Deno.inspect(missingTrailers)}.`);
        }
        headers.delete("trailer");
    }
    exports_24("readTrailers", readTrailers);
    function parseTrailer(field) {
        if (field == null) {
            return undefined;
        }
        const trailerNames = field.split(",").map((v) => v.trim().toLowerCase());
        if (trailerNames.length === 0) {
            throw new Deno.errors.InvalidData("Empty trailer header.");
        }
        const prohibited = trailerNames.filter((k) => isProhibidedForTrailer(k));
        if (prohibited.length > 0) {
            throw new Deno.errors.InvalidData(`Prohibited trailer names: ${Deno.inspect(prohibited)}.`);
        }
        return new Headers(trailerNames.map((key) => [key, ""]));
    }
    async function writeChunkedBody(w, r) {
        const writer = bufio_ts_1.BufWriter.create(w);
        for await (const chunk of Deno.iter(r)) {
            if (chunk.byteLength <= 0)
                continue;
            const start = utf8_ts_2.encoder.encode(`${chunk.byteLength.toString(16)}\r\n`);
            const end = utf8_ts_2.encoder.encode("\r\n");
            await writer.write(start);
            await writer.write(chunk);
            await writer.write(end);
        }
        const endChunk = utf8_ts_2.encoder.encode("0\r\n\r\n");
        await writer.write(endChunk);
    }
    exports_24("writeChunkedBody", writeChunkedBody);
    /** Write trailer headers to writer. It should mostly should be called after
     * `writeResponse()`. */
    async function writeTrailers(w, headers, trailers) {
        const trailer = headers.get("trailer");
        if (trailer === null) {
            throw new TypeError("Missing trailer header.");
        }
        const transferEncoding = headers.get("transfer-encoding");
        if (transferEncoding === null || !transferEncoding.match(/^chunked/)) {
            throw new TypeError(`Trailers are only allowed for "transfer-encoding: chunked", got "transfer-encoding: ${transferEncoding}".`);
        }
        const writer = bufio_ts_1.BufWriter.create(w);
        const trailerNames = trailer.split(",").map((s) => s.trim().toLowerCase());
        const prohibitedTrailers = trailerNames.filter((k) => isProhibidedForTrailer(k));
        if (prohibitedTrailers.length > 0) {
            throw new TypeError(`Prohibited trailer names: ${Deno.inspect(prohibitedTrailers)}.`);
        }
        const undeclared = [...trailers.keys()].filter((k) => !trailerNames.includes(k));
        if (undeclared.length > 0) {
            throw new TypeError(`Undeclared trailers: ${Deno.inspect(undeclared)}.`);
        }
        for (const [key, value] of trailers) {
            await writer.write(utf8_ts_2.encoder.encode(`${key}: ${value}\r\n`));
        }
        await writer.write(utf8_ts_2.encoder.encode("\r\n"));
        await writer.flush();
    }
    exports_24("writeTrailers", writeTrailers);
    async function writeResponse(w, r) {
        const protoMajor = 1;
        const protoMinor = 1;
        const statusCode = r.status || 200;
        const statusText = http_status_ts_1.STATUS_TEXT.get(statusCode);
        const writer = bufio_ts_1.BufWriter.create(w);
        if (!statusText) {
            throw new Deno.errors.InvalidData("Bad status code");
        }
        if (!r.body) {
            r.body = new Uint8Array();
        }
        if (typeof r.body === "string") {
            r.body = utf8_ts_2.encoder.encode(r.body);
        }
        let out = `HTTP/${protoMajor}.${protoMinor} ${statusCode} ${statusText}\r\n`;
        const headers = r.headers ?? new Headers();
        if (r.body && !headers.get("content-length")) {
            if (r.body instanceof Uint8Array) {
                out += `content-length: ${r.body.byteLength}\r\n`;
            }
            else if (!headers.get("transfer-encoding")) {
                out += "transfer-encoding: chunked\r\n";
            }
        }
        for (const [key, value] of headers) {
            out += `${key}: ${value}\r\n`;
        }
        out += `\r\n`;
        const header = utf8_ts_2.encoder.encode(out);
        const n = await writer.write(header);
        assert_ts_4.assert(n === header.byteLength);
        if (r.body instanceof Uint8Array) {
            const n = await writer.write(r.body);
            assert_ts_4.assert(n === r.body.byteLength);
        }
        else if (headers.has("content-length")) {
            const contentLength = headers.get("content-length");
            assert_ts_4.assert(contentLength != null);
            const bodyLength = parseInt(contentLength);
            const n = await Deno.copy(r.body, writer);
            assert_ts_4.assert(n === bodyLength);
        }
        else {
            await writeChunkedBody(writer, r.body);
        }
        if (r.trailers) {
            const t = await r.trailers();
            await writeTrailers(writer, headers, t);
        }
        await writer.flush();
    }
    exports_24("writeResponse", writeResponse);
    /**
     * ParseHTTPVersion parses a HTTP version string.
     * "HTTP/1.0" returns (1, 0).
     * Ported from https://github.com/golang/go/blob/f5c43b9/src/net/http/request.go#L766-L792
     */
    function parseHTTPVersion(vers) {
        switch (vers) {
            case "HTTP/1.1":
                return [1, 1];
            case "HTTP/1.0":
                return [1, 0];
            default: {
                const Big = 1000000; // arbitrary upper bound
                if (!vers.startsWith("HTTP/")) {
                    break;
                }
                const dot = vers.indexOf(".");
                if (dot < 0) {
                    break;
                }
                const majorStr = vers.substring(vers.indexOf("/") + 1, dot);
                const major = Number(majorStr);
                if (!Number.isInteger(major) || major < 0 || major > Big) {
                    break;
                }
                const minorStr = vers.substring(dot + 1);
                const minor = Number(minorStr);
                if (!Number.isInteger(minor) || minor < 0 || minor > Big) {
                    break;
                }
                return [major, minor];
            }
        }
        throw new Error(`malformed HTTP version ${vers}`);
    }
    exports_24("parseHTTPVersion", parseHTTPVersion);
    async function readRequest(conn, bufr) {
        const tp = new mod_ts_3.TextProtoReader(bufr);
        const firstLine = await tp.readLine(); // e.g. GET /index.html HTTP/1.0
        if (firstLine === null)
            return null;
        const headers = await tp.readMIMEHeader();
        if (headers === null)
            throw new Deno.errors.UnexpectedEof();
        const req = new server_ts_1.ServerRequest();
        req.conn = conn;
        req.r = bufr;
        [req.method, req.url, req.proto] = firstLine.split(" ", 3);
        [req.protoMinor, req.protoMajor] = parseHTTPVersion(req.proto);
        req.headers = headers;
        fixLength(req);
        return req;
    }
    exports_24("readRequest", readRequest);
    function fixLength(req) {
        const contentLength = req.headers.get("Content-Length");
        if (contentLength) {
            const arrClen = contentLength.split(",");
            if (arrClen.length > 1) {
                const distinct = [...new Set(arrClen.map((e) => e.trim()))];
                if (distinct.length > 1) {
                    throw Error("cannot contain multiple Content-Length headers");
                }
                else {
                    req.headers.set("Content-Length", distinct[0]);
                }
            }
            const c = req.headers.get("Content-Length");
            if (req.method === "HEAD" && c && c !== "0") {
                throw Error("http: method cannot contain a Content-Length");
            }
            if (c && req.headers.has("transfer-encoding")) {
                // A sender MUST NOT send a Content-Length header field in any message
                // that contains a Transfer-Encoding header field.
                // rfc: https://tools.ietf.org/html/rfc7230#section-3.3.2
                throw new Error("http: Transfer-Encoding and Content-Length cannot be send together");
            }
        }
    }
    return {
        setters: [
            function (bufio_ts_1_1) {
                bufio_ts_1 = bufio_ts_1_1;
            },
            function (mod_ts_3_1) {
                mod_ts_3 = mod_ts_3_1;
            },
            function (assert_ts_4_1) {
                assert_ts_4 = assert_ts_4_1;
            },
            function (utf8_ts_2_1) {
                utf8_ts_2 = utf8_ts_2_1;
            },
            function (server_ts_1_1) {
                server_ts_1 = server_ts_1_1;
            },
            function (http_status_ts_1_1) {
                http_status_ts_1 = http_status_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.57.0/http/server", ["https://deno.land/std@0.57.0/encoding/utf8", "https://deno.land/std@0.57.0/io/bufio", "https://deno.land/std@0.57.0/_util/assert", "https://deno.land/std@0.57.0/async/mod", "https://deno.land/std@0.57.0/http/_io"], function (exports_25, context_25) {
    "use strict";
    var utf8_ts_3, bufio_ts_2, assert_ts_5, mod_ts_4, _io_ts_1, listen, listenTls, ServerRequest, Server;
    var __moduleName = context_25 && context_25.id;
    /**
     * Create a HTTP server
     *
     *     import { serve } from "https://deno.land/std/http/server.ts";
     *     const body = "Hello World\n";
     *     const server = serve({ port: 8000 });
     *     for await (const req of server) {
     *       req.respond({ body });
     *     }
     */
    function serve(addr) {
        if (typeof addr === "string") {
            const [hostname, port] = addr.split(":");
            addr = { hostname, port: Number(port) };
        }
        const listener = listen(addr);
        return new Server(listener);
    }
    exports_25("serve", serve);
    /**
     * Start an HTTP server with given options and request handler
     *
     *     const body = "Hello World\n";
     *     const options = { port: 8000 };
     *     listenAndServe(options, (req) => {
     *       req.respond({ body });
     *     });
     *
     * @param options Server configuration
     * @param handler Request handler
     */
    async function listenAndServe(addr, handler) {
        const server = serve(addr);
        for await (const request of server) {
            handler(request);
        }
    }
    exports_25("listenAndServe", listenAndServe);
    /**
     * Create an HTTPS server with given options
     *
     *     const body = "Hello HTTPS";
     *     const options = {
     *       hostname: "localhost",
     *       port: 443,
     *       certFile: "./path/to/localhost.crt",
     *       keyFile: "./path/to/localhost.key",
     *     };
     *     for await (const req of serveTLS(options)) {
     *       req.respond({ body });
     *     }
     *
     * @param options Server configuration
     * @return Async iterable server instance for incoming requests
     */
    function serveTLS(options) {
        const tlsOptions = {
            ...options,
            transport: "tcp",
        };
        const listener = listenTls(tlsOptions);
        return new Server(listener);
    }
    exports_25("serveTLS", serveTLS);
    /**
     * Start an HTTPS server with given options and request handler
     *
     *     const body = "Hello HTTPS";
     *     const options = {
     *       hostname: "localhost",
     *       port: 443,
     *       certFile: "./path/to/localhost.crt",
     *       keyFile: "./path/to/localhost.key",
     *     };
     *     listenAndServeTLS(options, (req) => {
     *       req.respond({ body });
     *     });
     *
     * @param options Server configuration
     * @param handler Request handler
     */
    async function listenAndServeTLS(options, handler) {
        const server = serveTLS(options);
        for await (const request of server) {
            handler(request);
        }
    }
    exports_25("listenAndServeTLS", listenAndServeTLS);
    return {
        setters: [
            function (utf8_ts_3_1) {
                utf8_ts_3 = utf8_ts_3_1;
            },
            function (bufio_ts_2_1) {
                bufio_ts_2 = bufio_ts_2_1;
            },
            function (assert_ts_5_1) {
                assert_ts_5 = assert_ts_5_1;
            },
            function (mod_ts_4_1) {
                mod_ts_4 = mod_ts_4_1;
            },
            function (_io_ts_1_1) {
                _io_ts_1 = _io_ts_1_1;
            }
        ],
        execute: function () {
            listen = Deno.listen, listenTls = Deno.listenTls;
            ServerRequest = class ServerRequest {
                constructor() {
                    this.done = mod_ts_4.deferred();
                    this._contentLength = undefined;
                    this._body = null;
                    this.finalized = false;
                }
                /**
                 * Value of Content-Length header.
                 * If null, then content length is invalid or not given (e.g. chunked encoding).
                 */
                get contentLength() {
                    // undefined means not cached.
                    // null means invalid or not provided.
                    if (this._contentLength === undefined) {
                        const cl = this.headers.get("content-length");
                        if (cl) {
                            this._contentLength = parseInt(cl);
                            // Convert NaN to null (as NaN harder to test)
                            if (Number.isNaN(this._contentLength)) {
                                this._contentLength = null;
                            }
                        }
                        else {
                            this._contentLength = null;
                        }
                    }
                    return this._contentLength;
                }
                /**
                 * Body of the request.  The easiest way to consume the body is:
                 *
                 *     const buf: Uint8Array = await Deno.readAll(req.body);
                 */
                get body() {
                    if (!this._body) {
                        if (this.contentLength != null) {
                            this._body = _io_ts_1.bodyReader(this.contentLength, this.r);
                        }
                        else {
                            const transferEncoding = this.headers.get("transfer-encoding");
                            if (transferEncoding != null) {
                                const parts = transferEncoding
                                    .split(",")
                                    .map((e) => e.trim().toLowerCase());
                                assert_ts_5.assert(parts.includes("chunked"), 'transfer-encoding must include "chunked" if content-length is not set');
                                this._body = _io_ts_1.chunkedBodyReader(this.headers, this.r);
                            }
                            else {
                                // Neither content-length nor transfer-encoding: chunked
                                this._body = _io_ts_1.emptyReader();
                            }
                        }
                    }
                    return this._body;
                }
                async respond(r) {
                    let err;
                    try {
                        // Write our response!
                        await _io_ts_1.writeResponse(this.w, r);
                    }
                    catch (e) {
                        try {
                            // Eagerly close on error.
                            this.conn.close();
                        }
                        catch {
                            // Pass
                        }
                        err = e;
                    }
                    // Signal that this request has been processed and the next pipelined
                    // request on the same connection can be accepted.
                    this.done.resolve(err);
                    if (err) {
                        // Error during responding, rethrow.
                        throw err;
                    }
                }
                async finalize() {
                    if (this.finalized)
                        return;
                    // Consume unread body
                    const body = this.body;
                    const buf = new Uint8Array(1024);
                    while ((await body.read(buf)) !== null) {
                        // Pass
                    }
                    this.finalized = true;
                }
            };
            exports_25("ServerRequest", ServerRequest);
            Server = class Server {
                constructor(listener) {
                    this.listener = listener;
                    this.closing = false;
                    this.connections = [];
                }
                close() {
                    this.closing = true;
                    this.listener.close();
                    for (const conn of this.connections) {
                        try {
                            conn.close();
                        }
                        catch (e) {
                            // Connection might have been already closed
                            if (!(e instanceof Deno.errors.BadResource)) {
                                throw e;
                            }
                        }
                    }
                }
                // Yields all HTTP requests on a single TCP connection.
                async *iterateHttpRequests(conn) {
                    const reader = new bufio_ts_2.BufReader(conn);
                    const writer = new bufio_ts_2.BufWriter(conn);
                    while (!this.closing) {
                        let request;
                        try {
                            request = await _io_ts_1.readRequest(conn, reader);
                        }
                        catch (error) {
                            if (error instanceof Deno.errors.InvalidData ||
                                error instanceof Deno.errors.UnexpectedEof) {
                                // An error was thrown while parsing request headers.
                                await _io_ts_1.writeResponse(writer, {
                                    status: 400,
                                    body: utf8_ts_3.encode(`${error.message}\r\n\r\n`),
                                });
                            }
                            break;
                        }
                        if (request === null) {
                            break;
                        }
                        request.w = writer;
                        yield request;
                        // Wait for the request to be processed before we accept a new request on
                        // this connection.
                        const responseError = await request.done;
                        if (responseError) {
                            // Something bad happened during response.
                            // (likely other side closed during pipelined req)
                            // req.done implies this connection already closed, so we can just return.
                            this.untrackConnection(request.conn);
                            return;
                        }
                        // Consume unread body and trailers if receiver didn't consume those data
                        await request.finalize();
                    }
                    this.untrackConnection(conn);
                    try {
                        conn.close();
                    }
                    catch (e) {
                        // might have been already closed
                    }
                }
                trackConnection(conn) {
                    this.connections.push(conn);
                }
                untrackConnection(conn) {
                    const index = this.connections.indexOf(conn);
                    if (index !== -1) {
                        this.connections.splice(index, 1);
                    }
                }
                // Accepts a new TCP connection and yields all HTTP requests that arrive on
                // it. When a connection is accepted, it also creates a new iterator of the
                // same kind and adds it to the request multiplexer so that another TCP
                // connection can be accepted.
                async *acceptConnAndIterateHttpRequests(mux) {
                    if (this.closing)
                        return;
                    // Wait for a new connection.
                    let conn;
                    try {
                        conn = await this.listener.accept();
                    }
                    catch (error) {
                        if (error instanceof Deno.errors.BadResource ||
                            error instanceof Deno.errors.InvalidData ||
                            error instanceof Deno.errors.UnexpectedEof) {
                            return mux.add(this.acceptConnAndIterateHttpRequests(mux));
                        }
                        throw error;
                    }
                    this.trackConnection(conn);
                    // Try to accept another connection and add it to the multiplexer.
                    mux.add(this.acceptConnAndIterateHttpRequests(mux));
                    // Yield the requests that arrive on the just-accepted connection.
                    yield* this.iterateHttpRequests(conn);
                }
                [Symbol.asyncIterator]() {
                    const mux = new mod_ts_4.MuxAsyncIterator();
                    mux.add(this.acceptConnAndIterateHttpRequests(mux));
                    return mux.iterate();
                }
            };
            exports_25("Server", Server);
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
/** A module to print ANSI terminal colors. Inspired by chalk, kleur, and colors
 * on npm.
 *
 * ```
 * import { bgBlue, red, bold } from "https://deno.land/std/fmt/colors.ts";
 * console.log(bgBlue(red(bold("Hello world!"))));
 * ```
 *
 * This module supports `NO_COLOR` environmental variable disabling any coloring
 * if `NO_COLOR` is set.
 *
 * This module is browser compatible. */
System.register("https://deno.land/std@0.57.0/fmt/colors", [], function (exports_26, context_26) {
    "use strict";
    var noColor, enabled, ANSI_PATTERN;
    var __moduleName = context_26 && context_26.id;
    function setColorEnabled(value) {
        if (noColor) {
            return;
        }
        enabled = value;
    }
    exports_26("setColorEnabled", setColorEnabled);
    function getColorEnabled() {
        return enabled;
    }
    exports_26("getColorEnabled", getColorEnabled);
    function code(open, close) {
        return {
            open: `\x1b[${open.join(";")}m`,
            close: `\x1b[${close}m`,
            regexp: new RegExp(`\\x1b\\[${close}m`, "g"),
        };
    }
    function run(str, code) {
        return enabled
            ? `${code.open}${str.replace(code.regexp, code.open)}${code.close}`
            : str;
    }
    function reset(str) {
        return run(str, code([0], 0));
    }
    exports_26("reset", reset);
    function bold(str) {
        return run(str, code([1], 22));
    }
    exports_26("bold", bold);
    function dim(str) {
        return run(str, code([2], 22));
    }
    exports_26("dim", dim);
    function italic(str) {
        return run(str, code([3], 23));
    }
    exports_26("italic", italic);
    function underline(str) {
        return run(str, code([4], 24));
    }
    exports_26("underline", underline);
    function inverse(str) {
        return run(str, code([7], 27));
    }
    exports_26("inverse", inverse);
    function hidden(str) {
        return run(str, code([8], 28));
    }
    exports_26("hidden", hidden);
    function strikethrough(str) {
        return run(str, code([9], 29));
    }
    exports_26("strikethrough", strikethrough);
    function black(str) {
        return run(str, code([30], 39));
    }
    exports_26("black", black);
    function red(str) {
        return run(str, code([31], 39));
    }
    exports_26("red", red);
    function green(str) {
        return run(str, code([32], 39));
    }
    exports_26("green", green);
    function yellow(str) {
        return run(str, code([33], 39));
    }
    exports_26("yellow", yellow);
    function blue(str) {
        return run(str, code([34], 39));
    }
    exports_26("blue", blue);
    function magenta(str) {
        return run(str, code([35], 39));
    }
    exports_26("magenta", magenta);
    function cyan(str) {
        return run(str, code([36], 39));
    }
    exports_26("cyan", cyan);
    function white(str) {
        return run(str, code([37], 39));
    }
    exports_26("white", white);
    function gray(str) {
        return run(str, code([90], 39));
    }
    exports_26("gray", gray);
    function bgBlack(str) {
        return run(str, code([40], 49));
    }
    exports_26("bgBlack", bgBlack);
    function bgRed(str) {
        return run(str, code([41], 49));
    }
    exports_26("bgRed", bgRed);
    function bgGreen(str) {
        return run(str, code([42], 49));
    }
    exports_26("bgGreen", bgGreen);
    function bgYellow(str) {
        return run(str, code([43], 49));
    }
    exports_26("bgYellow", bgYellow);
    function bgBlue(str) {
        return run(str, code([44], 49));
    }
    exports_26("bgBlue", bgBlue);
    function bgMagenta(str) {
        return run(str, code([45], 49));
    }
    exports_26("bgMagenta", bgMagenta);
    function bgCyan(str) {
        return run(str, code([46], 49));
    }
    exports_26("bgCyan", bgCyan);
    function bgWhite(str) {
        return run(str, code([47], 49));
    }
    exports_26("bgWhite", bgWhite);
    /* Special Color Sequences */
    function clampAndTruncate(n, max = 255, min = 0) {
        return Math.trunc(Math.max(Math.min(n, max), min));
    }
    /** Set text color using paletted 8bit colors.
     * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit */
    function rgb8(str, color) {
        return run(str, code([38, 5, clampAndTruncate(color)], 39));
    }
    exports_26("rgb8", rgb8);
    /** Set background color using paletted 8bit colors.
     * https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit */
    function bgRgb8(str, color) {
        return run(str, code([48, 5, clampAndTruncate(color)], 49));
    }
    exports_26("bgRgb8", bgRgb8);
    /** Set text color using 24bit rgb.
     * `color` can be a number in range `0x000000` to `0xffffff` or
     * an `Rgb`.
     *
     * To produce the color magenta:
     *
     *      rgba24("foo", 0xff00ff);
     *      rgba24("foo", {r: 255, g: 0, b: 255});
     */
    function rgb24(str, color) {
        if (typeof color === "number") {
            return run(str, code([38, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff], 39));
        }
        return run(str, code([
            38,
            2,
            clampAndTruncate(color.r),
            clampAndTruncate(color.g),
            clampAndTruncate(color.b),
        ], 39));
    }
    exports_26("rgb24", rgb24);
    /** Set background color using 24bit rgb.
     * `color` can be a number in range `0x000000` to `0xffffff` or
     * an `Rgb`.
     *
     * To produce the color magenta:
     *
     *      bgRgba24("foo", 0xff00ff);
     *      bgRgba24("foo", {r: 255, g: 0, b: 255});
     */
    function bgRgb24(str, color) {
        if (typeof color === "number") {
            return run(str, code([48, 2, (color >> 16) & 0xff, (color >> 8) & 0xff, color & 0xff], 49));
        }
        return run(str, code([
            48,
            2,
            clampAndTruncate(color.r),
            clampAndTruncate(color.g),
            clampAndTruncate(color.b),
        ], 49));
    }
    exports_26("bgRgb24", bgRgb24);
    function stripColor(string) {
        return string.replace(ANSI_PATTERN, "");
    }
    exports_26("stripColor", stripColor);
    return {
        setters: [],
        execute: function () {
            noColor = globalThis.Deno?.noColor ?? true;
            enabled = !noColor;
            // https://github.com/chalk/ansi-regex/blob/2b56fb0c7a07108e5b54241e8faec160d393aedb/index.js
            ANSI_PATTERN = new RegExp([
                "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
                "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))",
            ].join("|"), "g");
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
/** This module is browser compatible. */
System.register("https://deno.land/std@0.57.0/testing/diff", [], function (exports_27, context_27) {
    "use strict";
    var DiffType, REMOVED, COMMON, ADDED;
    var __moduleName = context_27 && context_27.id;
    function createCommon(A, B, reverse) {
        const common = [];
        if (A.length === 0 || B.length === 0)
            return [];
        for (let i = 0; i < Math.min(A.length, B.length); i += 1) {
            if (A[reverse ? A.length - i - 1 : i] === B[reverse ? B.length - i - 1 : i]) {
                common.push(A[reverse ? A.length - i - 1 : i]);
            }
            else {
                return common;
            }
        }
        return common;
    }
    function diff(A, B) {
        const prefixCommon = createCommon(A, B);
        const suffixCommon = createCommon(A.slice(prefixCommon.length), B.slice(prefixCommon.length), true).reverse();
        A = suffixCommon.length
            ? A.slice(prefixCommon.length, -suffixCommon.length)
            : A.slice(prefixCommon.length);
        B = suffixCommon.length
            ? B.slice(prefixCommon.length, -suffixCommon.length)
            : B.slice(prefixCommon.length);
        const swapped = B.length > A.length;
        [A, B] = swapped ? [B, A] : [A, B];
        const M = A.length;
        const N = B.length;
        if (!M && !N && !suffixCommon.length && !prefixCommon.length)
            return [];
        if (!N) {
            return [
                ...prefixCommon.map((c) => ({ type: DiffType.common, value: c })),
                ...A.map((a) => ({
                    type: swapped ? DiffType.added : DiffType.removed,
                    value: a,
                })),
                ...suffixCommon.map((c) => ({ type: DiffType.common, value: c })),
            ];
        }
        const offset = N;
        const delta = M - N;
        const size = M + N + 1;
        const fp = new Array(size).fill({ y: -1 });
        /**
         * INFO:
         * This buffer is used to save memory and improve performance.
         * The first half is used to save route and last half is used to save diff
         * type.
         * This is because, when I kept new uint8array area to save type,performance
         * worsened.
         */
        const routes = new Uint32Array((M * N + size + 1) * 2);
        const diffTypesPtrOffset = routes.length / 2;
        let ptr = 0;
        let p = -1;
        function backTrace(A, B, current, swapped) {
            const M = A.length;
            const N = B.length;
            const result = [];
            let a = M - 1;
            let b = N - 1;
            let j = routes[current.id];
            let type = routes[current.id + diffTypesPtrOffset];
            while (true) {
                if (!j && !type)
                    break;
                const prev = j;
                if (type === REMOVED) {
                    result.unshift({
                        type: swapped ? DiffType.removed : DiffType.added,
                        value: B[b],
                    });
                    b -= 1;
                }
                else if (type === ADDED) {
                    result.unshift({
                        type: swapped ? DiffType.added : DiffType.removed,
                        value: A[a],
                    });
                    a -= 1;
                }
                else {
                    result.unshift({ type: DiffType.common, value: A[a] });
                    a -= 1;
                    b -= 1;
                }
                j = routes[prev];
                type = routes[prev + diffTypesPtrOffset];
            }
            return result;
        }
        function createFP(slide, down, k, M) {
            if (slide && slide.y === -1 && down && down.y === -1) {
                return { y: 0, id: 0 };
            }
            if ((down && down.y === -1) ||
                k === M ||
                (slide && slide.y) > (down && down.y) + 1) {
                const prev = slide.id;
                ptr++;
                routes[ptr] = prev;
                routes[ptr + diffTypesPtrOffset] = ADDED;
                return { y: slide.y, id: ptr };
            }
            else {
                const prev = down.id;
                ptr++;
                routes[ptr] = prev;
                routes[ptr + diffTypesPtrOffset] = REMOVED;
                return { y: down.y + 1, id: ptr };
            }
        }
        function snake(k, slide, down, _offset, A, B) {
            const M = A.length;
            const N = B.length;
            if (k < -N || M < k)
                return { y: -1, id: -1 };
            const fp = createFP(slide, down, k, M);
            while (fp.y + k < M && fp.y < N && A[fp.y + k] === B[fp.y]) {
                const prev = fp.id;
                ptr++;
                fp.id = ptr;
                fp.y += 1;
                routes[ptr] = prev;
                routes[ptr + diffTypesPtrOffset] = COMMON;
            }
            return fp;
        }
        while (fp[delta + offset].y < N) {
            p = p + 1;
            for (let k = -p; k < delta; ++k) {
                fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
            }
            for (let k = delta + p; k > delta; --k) {
                fp[k + offset] = snake(k, fp[k - 1 + offset], fp[k + 1 + offset], offset, A, B);
            }
            fp[delta + offset] = snake(delta, fp[delta - 1 + offset], fp[delta + 1 + offset], offset, A, B);
        }
        return [
            ...prefixCommon.map((c) => ({ type: DiffType.common, value: c })),
            ...backTrace(A, B, fp[delta + offset], swapped),
            ...suffixCommon.map((c) => ({ type: DiffType.common, value: c })),
        ];
    }
    exports_27("default", diff);
    return {
        setters: [],
        execute: function () {
            (function (DiffType) {
                DiffType["removed"] = "removed";
                DiffType["common"] = "common";
                DiffType["added"] = "added";
            })(DiffType || (DiffType = {}));
            exports_27("DiffType", DiffType);
            REMOVED = 1;
            COMMON = 2;
            ADDED = 3;
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
/** This module is browser compatible. Do not rely on good formatting of values
 * for AssertionError messages in browsers. */
System.register("https://deno.land/std@0.57.0/testing/asserts", ["https://deno.land/std@0.57.0/fmt/colors", "https://deno.land/std@0.57.0/testing/diff"], function (exports_28, context_28) {
    "use strict";
    var colors_ts_1, diff_ts_1, CAN_NOT_DISPLAY, AssertionError;
    var __moduleName = context_28 && context_28.id;
    function format(v) {
        let string = globalThis.Deno ? Deno.inspect(v) : String(v);
        if (typeof v == "string") {
            string = `"${string.replace(/(?=["\\])/g, "\\")}"`;
        }
        return string;
    }
    function createColor(diffType) {
        switch (diffType) {
            case diff_ts_1.DiffType.added:
                return (s) => colors_ts_1.green(colors_ts_1.bold(s));
            case diff_ts_1.DiffType.removed:
                return (s) => colors_ts_1.red(colors_ts_1.bold(s));
            default:
                return colors_ts_1.white;
        }
    }
    function createSign(diffType) {
        switch (diffType) {
            case diff_ts_1.DiffType.added:
                return "+   ";
            case diff_ts_1.DiffType.removed:
                return "-   ";
            default:
                return "    ";
        }
    }
    function buildMessage(diffResult) {
        const messages = [];
        messages.push("");
        messages.push("");
        messages.push(`    ${colors_ts_1.gray(colors_ts_1.bold("[Diff]"))} ${colors_ts_1.red(colors_ts_1.bold("Actual"))} / ${colors_ts_1.green(colors_ts_1.bold("Expected"))}`);
        messages.push("");
        messages.push("");
        diffResult.forEach((result) => {
            const c = createColor(result.type);
            messages.push(c(`${createSign(result.type)}${result.value}`));
        });
        messages.push("");
        return messages;
    }
    function isKeyedCollection(x) {
        return [Symbol.iterator, "size"].every((k) => k in x);
    }
    function equal(c, d) {
        const seen = new Map();
        return (function compare(a, b) {
            // Have to render RegExp & Date for string comparison
            // unless it's mistreated as object
            if (a &&
                b &&
                ((a instanceof RegExp && b instanceof RegExp) ||
                    (a instanceof Date && b instanceof Date))) {
                return String(a) === String(b);
            }
            if (Object.is(a, b)) {
                return true;
            }
            if (a && typeof a === "object" && b && typeof b === "object") {
                if (seen.get(a) === b) {
                    return true;
                }
                if (Object.keys(a || {}).length !== Object.keys(b || {}).length) {
                    return false;
                }
                if (isKeyedCollection(a) && isKeyedCollection(b)) {
                    if (a.size !== b.size) {
                        return false;
                    }
                    let unmatchedEntries = a.size;
                    for (const [aKey, aValue] of a.entries()) {
                        for (const [bKey, bValue] of b.entries()) {
                            /* Given that Map keys can be references, we need
                             * to ensure that they are also deeply equal */
                            if ((aKey === aValue && bKey === bValue && compare(aKey, bKey)) ||
                                (compare(aKey, bKey) && compare(aValue, bValue))) {
                                unmatchedEntries--;
                            }
                        }
                    }
                    return unmatchedEntries === 0;
                }
                const merged = { ...a, ...b };
                for (const key in merged) {
                    if (!compare(a && a[key], b && b[key])) {
                        return false;
                    }
                }
                seen.set(a, b);
                return true;
            }
            return false;
        })(c, d);
    }
    exports_28("equal", equal);
    /** Make an assertion, if not `true`, then throw. */
    function assert(expr, msg = "") {
        if (!expr) {
            throw new AssertionError(msg);
        }
    }
    exports_28("assert", assert);
    /**
     * Make an assertion that `actual` and `expected` are equal, deeply. If not
     * deeply equal, then throw.
     */
    function assertEquals(actual, expected, msg) {
        if (equal(actual, expected)) {
            return;
        }
        let message = "";
        const actualString = format(actual);
        const expectedString = format(expected);
        try {
            const diffResult = diff_ts_1.default(actualString.split("\n"), expectedString.split("\n"));
            const diffMsg = buildMessage(diffResult).join("\n");
            message = `Values are not equal:\n${diffMsg}`;
        }
        catch (e) {
            message = `\n${colors_ts_1.red(CAN_NOT_DISPLAY)} + \n\n`;
        }
        if (msg) {
            message = msg;
        }
        throw new AssertionError(message);
    }
    exports_28("assertEquals", assertEquals);
    /**
     * Make an assertion that `actual` and `expected` are not equal, deeply.
     * If not then throw.
     */
    function assertNotEquals(actual, expected, msg) {
        if (!equal(actual, expected)) {
            return;
        }
        let actualString;
        let expectedString;
        try {
            actualString = String(actual);
        }
        catch (e) {
            actualString = "[Cannot display]";
        }
        try {
            expectedString = String(expected);
        }
        catch (e) {
            expectedString = "[Cannot display]";
        }
        if (!msg) {
            msg = `actual: ${actualString} expected: ${expectedString}`;
        }
        throw new AssertionError(msg);
    }
    exports_28("assertNotEquals", assertNotEquals);
    /**
     * Make an assertion that `actual` and `expected` are strictly equal.  If
     * not then throw.
     */
    function assertStrictEquals(actual, expected, msg) {
        if (actual === expected) {
            return;
        }
        let message;
        if (msg) {
            message = msg;
        }
        else {
            const actualString = format(actual);
            const expectedString = format(expected);
            if (actualString === expectedString) {
                const withOffset = actualString
                    .split("\n")
                    .map((l) => `     ${l}`)
                    .join("\n");
                message = `Values have the same structure but are not reference-equal:\n\n${colors_ts_1.red(withOffset)}\n`;
            }
            else {
                try {
                    const diffResult = diff_ts_1.default(actualString.split("\n"), expectedString.split("\n"));
                    const diffMsg = buildMessage(diffResult).join("\n");
                    message = `Values are not strictly equal:\n${diffMsg}`;
                }
                catch (e) {
                    message = `\n${colors_ts_1.red(CAN_NOT_DISPLAY)} + \n\n`;
                }
            }
        }
        throw new AssertionError(message);
    }
    exports_28("assertStrictEquals", assertStrictEquals);
    /**
     * Make an assertion that actual contains expected. If not
     * then thrown.
     */
    function assertStringContains(actual, expected, msg) {
        if (!actual.includes(expected)) {
            if (!msg) {
                msg = `actual: "${actual}" expected to contain: "${expected}"`;
            }
            throw new AssertionError(msg);
        }
    }
    exports_28("assertStringContains", assertStringContains);
    /**
     * Make an assertion that `actual` contains the `expected` values
     * If not then thrown.
     */
    function assertArrayContains(actual, expected, msg) {
        const missing = [];
        for (let i = 0; i < expected.length; i++) {
            let found = false;
            for (let j = 0; j < actual.length; j++) {
                if (equal(expected[i], actual[j])) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                missing.push(expected[i]);
            }
        }
        if (missing.length === 0) {
            return;
        }
        if (!msg) {
            msg = `actual: "${format(actual)}" expected to contain: "${format(expected)}"\nmissing: ${format(missing)}`;
        }
        throw new AssertionError(msg);
    }
    exports_28("assertArrayContains", assertArrayContains);
    /**
     * Make an assertion that `actual` match RegExp `expected`. If not
     * then thrown
     */
    function assertMatch(actual, expected, msg) {
        if (!expected.test(actual)) {
            if (!msg) {
                msg = `actual: "${actual}" expected to match: "${expected}"`;
            }
            throw new AssertionError(msg);
        }
    }
    exports_28("assertMatch", assertMatch);
    /**
     * Forcefully throws a failed assertion
     */
    function fail(msg) {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        assert(false, `Failed assertion${msg ? `: ${msg}` : "."}`);
    }
    exports_28("fail", fail);
    /** Executes a function, expecting it to throw.  If it does not, then it
     * throws.  An error class and a string that should be included in the
     * error message can also be asserted.
     */
    function assertThrows(fn, ErrorClass, msgIncludes = "", msg) {
        let doesThrow = false;
        let error = null;
        try {
            fn();
        }
        catch (e) {
            if (ErrorClass && !(Object.getPrototypeOf(e) === ErrorClass.prototype)) {
                msg = `Expected error to be instance of "${ErrorClass.name}", but was "${e.constructor.name}"${msg ? `: ${msg}` : "."}`;
                throw new AssertionError(msg);
            }
            if (msgIncludes &&
                !colors_ts_1.stripColor(e.message).includes(colors_ts_1.stripColor(msgIncludes))) {
                msg = `Expected error message to include "${msgIncludes}", but got "${e.message}"${msg ? `: ${msg}` : "."}`;
                throw new AssertionError(msg);
            }
            doesThrow = true;
            error = e;
        }
        if (!doesThrow) {
            msg = `Expected function to throw${msg ? `: ${msg}` : "."}`;
            throw new AssertionError(msg);
        }
        return error;
    }
    exports_28("assertThrows", assertThrows);
    async function assertThrowsAsync(fn, ErrorClass, msgIncludes = "", msg) {
        let doesThrow = false;
        let error = null;
        try {
            await fn();
        }
        catch (e) {
            if (ErrorClass && !(Object.getPrototypeOf(e) === ErrorClass.prototype)) {
                msg = `Expected error to be instance of "${ErrorClass.name}", but got "${e.name}"${msg ? `: ${msg}` : "."}`;
                throw new AssertionError(msg);
            }
            if (msgIncludes &&
                !colors_ts_1.stripColor(e.message).includes(colors_ts_1.stripColor(msgIncludes))) {
                msg = `Expected error message to include "${msgIncludes}", but got "${e.message}"${msg ? `: ${msg}` : "."}`;
                throw new AssertionError(msg);
            }
            doesThrow = true;
            error = e;
        }
        if (!doesThrow) {
            msg = `Expected function to throw${msg ? `: ${msg}` : "."}`;
            throw new AssertionError(msg);
        }
        return error;
    }
    exports_28("assertThrowsAsync", assertThrowsAsync);
    /** Use this to stub out methods that will throw when invoked. */
    function unimplemented(msg) {
        throw new AssertionError(msg || "unimplemented");
    }
    exports_28("unimplemented", unimplemented);
    /** Use this to assert unreachable code. */
    function unreachable() {
        throw new AssertionError("unreachable");
    }
    exports_28("unreachable", unreachable);
    return {
        setters: [
            function (colors_ts_1_1) {
                colors_ts_1 = colors_ts_1_1;
            },
            function (diff_ts_1_1) {
                diff_ts_1 = diff_ts_1_1;
            }
        ],
        execute: function () {
            CAN_NOT_DISPLAY = "[Cannot display]";
            AssertionError = class AssertionError extends Error {
                constructor(message) {
                    super(message);
                    this.name = "AssertionError";
                }
            };
            exports_28("AssertionError", AssertionError);
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
System.register("https://deno.land/std@0.57.0/_util/has_own_property", [], function (exports_29, context_29) {
    "use strict";
    var __moduleName = context_29 && context_29.id;
    /**
     * Determines whether an object has a property with the specified name.
     * Avoid calling prototype builtin `hasOwnProperty` for two reasons:
     *
     * 1. `hasOwnProperty` is defined on the object as something else:
     *
     *      const options = {
     *        ending: 'utf8',
     *        hasOwnProperty: 'foo'
     *      };
     *      options.hasOwnProperty('ending') // throws a TypeError
     *
     * 2. The object doesn't inherit from `Object.prototype`:
     *
     *       const options = Object.create(null);
     *       options.ending = 'utf8';
     *       options.hasOwnProperty('ending'); // throws a TypeError
     *
     * @param obj A Object.
     * @param v A property name.
     * @see https://eslint.org/docs/rules/no-prototype-builtins
     */
    function hasOwnProperty(obj, v) {
        if (obj == null) {
            return false;
        }
        return Object.prototype.hasOwnProperty.call(obj, v);
    }
    exports_29("hasOwnProperty", hasOwnProperty);
    return {
        setters: [],
        execute: function () {
        }
    };
});
System.register("https://deno.land/std@0.57.0/io/ioutil", ["https://deno.land/std@0.57.0/_util/assert"], function (exports_30, context_30) {
    "use strict";
    var assert_ts_6, DEFAULT_BUFFER_SIZE, MAX_SAFE_INTEGER;
    var __moduleName = context_30 && context_30.id;
    /** copy N size at the most.
     *  If read size is lesser than N, then returns nread
     * */
    async function copyN(r, dest, size) {
        let bytesRead = 0;
        let buf = new Uint8Array(DEFAULT_BUFFER_SIZE);
        while (bytesRead < size) {
            if (size - bytesRead < DEFAULT_BUFFER_SIZE) {
                buf = new Uint8Array(size - bytesRead);
            }
            const result = await r.read(buf);
            const nread = result ?? 0;
            bytesRead += nread;
            if (nread > 0) {
                let n = 0;
                while (n < nread) {
                    n += await dest.write(buf.slice(n, nread));
                }
                assert_ts_6.assert(n === nread, "could not write");
            }
            if (result === null) {
                break;
            }
        }
        return bytesRead;
    }
    exports_30("copyN", copyN);
    /** Read big endian 16bit short from BufReader */
    async function readShort(buf) {
        const high = await buf.readByte();
        if (high === null)
            return null;
        const low = await buf.readByte();
        if (low === null)
            throw new Deno.errors.UnexpectedEof();
        return (high << 8) | low;
    }
    exports_30("readShort", readShort);
    /** Read big endian 32bit integer from BufReader */
    async function readInt(buf) {
        const high = await readShort(buf);
        if (high === null)
            return null;
        const low = await readShort(buf);
        if (low === null)
            throw new Deno.errors.UnexpectedEof();
        return (high << 16) | low;
    }
    exports_30("readInt", readInt);
    /** Read big endian 64bit long from BufReader */
    async function readLong(buf) {
        const high = await readInt(buf);
        if (high === null)
            return null;
        const low = await readInt(buf);
        if (low === null)
            throw new Deno.errors.UnexpectedEof();
        const big = (BigInt(high) << 32n) | BigInt(low);
        // We probably should provide a similar API that returns BigInt values.
        if (big > MAX_SAFE_INTEGER) {
            throw new RangeError("Long value too big to be represented as a JavaScript number.");
        }
        return Number(big);
    }
    exports_30("readLong", readLong);
    /** Slice number into 64bit big endian byte array */
    function sliceLongToBytes(d, dest = new Array(8)) {
        let big = BigInt(d);
        for (let i = 0; i < 8; i++) {
            dest[7 - i] = Number(big & 0xffn);
            big >>= 8n;
        }
        return dest;
    }
    exports_30("sliceLongToBytes", sliceLongToBytes);
    return {
        setters: [
            function (assert_ts_6_1) {
                assert_ts_6 = assert_ts_6_1;
            }
        ],
        execute: function () {
            DEFAULT_BUFFER_SIZE = 32 * 1024;
            MAX_SAFE_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
System.register("https://deno.land/std@0.57.0/ws/mod", ["https://deno.land/std@0.57.0/encoding/utf8", "https://deno.land/std@0.57.0/_util/has_own_property", "https://deno.land/std@0.57.0/io/bufio", "https://deno.land/std@0.57.0/io/ioutil", "https://deno.land/std@0.57.0/hash/sha1", "https://deno.land/std@0.57.0/http/_io", "https://deno.land/std@0.57.0/textproto/mod", "https://deno.land/std@0.57.0/async/deferred", "https://deno.land/std@0.57.0/_util/assert", "https://deno.land/std@0.57.0/bytes/mod"], function (exports_31, context_31) {
    "use strict";
    var utf8_ts_4, has_own_property_ts_1, bufio_ts_3, ioutil_ts_1, sha1_ts_1, _io_ts_2, mod_ts_5, deferred_ts_3, assert_ts_7, mod_ts_6, OpCode, WebSocketImpl, kGUID, kSecChars;
    var __moduleName = context_31 && context_31.id;
    function isWebSocketCloseEvent(a) {
        return has_own_property_ts_1.hasOwnProperty(a, "code");
    }
    exports_31("isWebSocketCloseEvent", isWebSocketCloseEvent);
    function isWebSocketPingEvent(a) {
        return Array.isArray(a) && a[0] === "ping" && a[1] instanceof Uint8Array;
    }
    exports_31("isWebSocketPingEvent", isWebSocketPingEvent);
    function isWebSocketPongEvent(a) {
        return Array.isArray(a) && a[0] === "pong" && a[1] instanceof Uint8Array;
    }
    exports_31("isWebSocketPongEvent", isWebSocketPongEvent);
    /** Unmask masked websocket payload */
    function unmask(payload, mask) {
        if (mask) {
            for (let i = 0, len = payload.length; i < len; i++) {
                payload[i] ^= mask[i & 3];
            }
        }
    }
    exports_31("unmask", unmask);
    /** Write websocket frame to given writer */
    async function writeFrame(frame, writer) {
        const payloadLength = frame.payload.byteLength;
        let header;
        const hasMask = frame.mask ? 0x80 : 0;
        if (frame.mask && frame.mask.byteLength !== 4) {
            throw new Error("invalid mask. mask must be 4 bytes: length=" + frame.mask.byteLength);
        }
        if (payloadLength < 126) {
            header = new Uint8Array([0x80 | frame.opcode, hasMask | payloadLength]);
        }
        else if (payloadLength < 0xffff) {
            header = new Uint8Array([
                0x80 | frame.opcode,
                hasMask | 0b01111110,
                payloadLength >>> 8,
                payloadLength & 0x00ff,
            ]);
        }
        else {
            header = new Uint8Array([
                0x80 | frame.opcode,
                hasMask | 0b01111111,
                ...ioutil_ts_1.sliceLongToBytes(payloadLength),
            ]);
        }
        if (frame.mask) {
            header = mod_ts_6.concat(header, frame.mask);
        }
        unmask(frame.payload, frame.mask);
        header = mod_ts_6.concat(header, frame.payload);
        const w = bufio_ts_3.BufWriter.create(writer);
        await w.write(header);
        await w.flush();
    }
    exports_31("writeFrame", writeFrame);
    /** Read websocket frame from given BufReader
     * @throws `Deno.errors.UnexpectedEof` When peer closed connection without close frame
     * @throws `Error` Frame is invalid
     */
    async function readFrame(buf) {
        let b = await buf.readByte();
        assert_ts_7.assert(b !== null);
        let isLastFrame = false;
        switch (b >>> 4) {
            case 0b1000:
                isLastFrame = true;
                break;
            case 0b0000:
                isLastFrame = false;
                break;
            default:
                throw new Error("invalid signature");
        }
        const opcode = b & 0x0f;
        // has_mask & payload
        b = await buf.readByte();
        assert_ts_7.assert(b !== null);
        const hasMask = b >>> 7;
        let payloadLength = b & 0b01111111;
        if (payloadLength === 126) {
            const l = await ioutil_ts_1.readShort(buf);
            assert_ts_7.assert(l !== null);
            payloadLength = l;
        }
        else if (payloadLength === 127) {
            const l = await ioutil_ts_1.readLong(buf);
            assert_ts_7.assert(l !== null);
            payloadLength = Number(l);
        }
        // mask
        let mask;
        if (hasMask) {
            mask = new Uint8Array(4);
            assert_ts_7.assert((await buf.readFull(mask)) !== null);
        }
        // payload
        const payload = new Uint8Array(payloadLength);
        assert_ts_7.assert((await buf.readFull(payload)) !== null);
        return {
            isLastFrame,
            opcode,
            mask,
            payload,
        };
    }
    exports_31("readFrame", readFrame);
    // Create client-to-server mask, random 32bit number
    function createMask() {
        return crypto.getRandomValues(new Uint8Array(4));
    }
    /** Return whether given headers is acceptable for websocket  */
    function acceptable(req) {
        const upgrade = req.headers.get("upgrade");
        if (!upgrade || upgrade.toLowerCase() !== "websocket") {
            return false;
        }
        const secKey = req.headers.get("sec-websocket-key");
        return (req.headers.has("sec-websocket-key") &&
            typeof secKey === "string" &&
            secKey.length > 0);
    }
    exports_31("acceptable", acceptable);
    /** Create sec-websocket-accept header value with given nonce */
    function createSecAccept(nonce) {
        const sha1 = new sha1_ts_1.Sha1();
        sha1.update(nonce + kGUID);
        const bytes = sha1.digest();
        return btoa(String.fromCharCode(...bytes));
    }
    exports_31("createSecAccept", createSecAccept);
    /** Upgrade given TCP connection into websocket connection */
    async function acceptWebSocket(req) {
        const { conn, headers, bufReader, bufWriter } = req;
        if (acceptable(req)) {
            const sock = new WebSocketImpl({ conn, bufReader, bufWriter });
            const secKey = headers.get("sec-websocket-key");
            if (typeof secKey !== "string") {
                throw new Error("sec-websocket-key is not provided");
            }
            const secAccept = createSecAccept(secKey);
            await _io_ts_2.writeResponse(bufWriter, {
                status: 101,
                headers: new Headers({
                    Upgrade: "websocket",
                    Connection: "Upgrade",
                    "Sec-WebSocket-Accept": secAccept,
                }),
            });
            return sock;
        }
        throw new Error("request is not acceptable");
    }
    exports_31("acceptWebSocket", acceptWebSocket);
    /** Create WebSocket-Sec-Key. Base64 encoded 16 bytes string */
    function createSecKey() {
        let key = "";
        for (let i = 0; i < 16; i++) {
            const j = Math.floor(Math.random() * kSecChars.length);
            key += kSecChars[j];
        }
        return btoa(key);
    }
    exports_31("createSecKey", createSecKey);
    async function handshake(url, headers, bufReader, bufWriter) {
        const { hostname, pathname, search } = url;
        const key = createSecKey();
        if (!headers.has("host")) {
            headers.set("host", hostname);
        }
        headers.set("upgrade", "websocket");
        headers.set("connection", "upgrade");
        headers.set("sec-websocket-key", key);
        headers.set("sec-websocket-version", "13");
        let headerStr = `GET ${pathname}${search} HTTP/1.1\r\n`;
        for (const [key, value] of headers) {
            headerStr += `${key}: ${value}\r\n`;
        }
        headerStr += "\r\n";
        await bufWriter.write(utf8_ts_4.encode(headerStr));
        await bufWriter.flush();
        const tpReader = new mod_ts_5.TextProtoReader(bufReader);
        const statusLine = await tpReader.readLine();
        if (statusLine === null) {
            throw new Deno.errors.UnexpectedEof();
        }
        const m = statusLine.match(/^(?<version>\S+) (?<statusCode>\S+) /);
        if (!m) {
            throw new Error("ws: invalid status line: " + statusLine);
        }
        assert_ts_7.assert(m.groups);
        const { version, statusCode } = m.groups;
        if (version !== "HTTP/1.1" || statusCode !== "101") {
            throw new Error(`ws: server didn't accept handshake: ` +
                `version=${version}, statusCode=${statusCode}`);
        }
        const responseHeaders = await tpReader.readMIMEHeader();
        if (responseHeaders === null) {
            throw new Deno.errors.UnexpectedEof();
        }
        const expectedSecAccept = createSecAccept(key);
        const secAccept = responseHeaders.get("sec-websocket-accept");
        if (secAccept !== expectedSecAccept) {
            throw new Error(`ws: unexpected sec-websocket-accept header: ` +
                `expected=${expectedSecAccept}, actual=${secAccept}`);
        }
    }
    exports_31("handshake", handshake);
    /**
     * Connect to given websocket endpoint url.
     * Endpoint must be acceptable for URL.
     */
    async function connectWebSocket(endpoint, headers = new Headers()) {
        const url = new URL(endpoint);
        const { hostname } = url;
        let conn;
        if (url.protocol === "http:" || url.protocol === "ws:") {
            const port = parseInt(url.port || "80");
            conn = await Deno.connect({ hostname, port });
        }
        else if (url.protocol === "https:" || url.protocol === "wss:") {
            const port = parseInt(url.port || "443");
            conn = await Deno.connectTls({ hostname, port });
        }
        else {
            throw new Error("ws: unsupported protocol: " + url.protocol);
        }
        const bufWriter = new bufio_ts_3.BufWriter(conn);
        const bufReader = new bufio_ts_3.BufReader(conn);
        try {
            await handshake(url, headers, bufReader, bufWriter);
        }
        catch (err) {
            conn.close();
            throw err;
        }
        return new WebSocketImpl({
            conn,
            bufWriter,
            bufReader,
            mask: createMask(),
        });
    }
    exports_31("connectWebSocket", connectWebSocket);
    function createWebSocket(params) {
        return new WebSocketImpl(params);
    }
    exports_31("createWebSocket", createWebSocket);
    return {
        setters: [
            function (utf8_ts_4_1) {
                utf8_ts_4 = utf8_ts_4_1;
            },
            function (has_own_property_ts_1_1) {
                has_own_property_ts_1 = has_own_property_ts_1_1;
            },
            function (bufio_ts_3_1) {
                bufio_ts_3 = bufio_ts_3_1;
            },
            function (ioutil_ts_1_1) {
                ioutil_ts_1 = ioutil_ts_1_1;
            },
            function (sha1_ts_1_1) {
                sha1_ts_1 = sha1_ts_1_1;
            },
            function (_io_ts_2_1) {
                _io_ts_2 = _io_ts_2_1;
            },
            function (mod_ts_5_1) {
                mod_ts_5 = mod_ts_5_1;
            },
            function (deferred_ts_3_1) {
                deferred_ts_3 = deferred_ts_3_1;
            },
            function (assert_ts_7_1) {
                assert_ts_7 = assert_ts_7_1;
            },
            function (mod_ts_6_1) {
                mod_ts_6 = mod_ts_6_1;
            }
        ],
        execute: function () {
            (function (OpCode) {
                OpCode[OpCode["Continue"] = 0] = "Continue";
                OpCode[OpCode["TextFrame"] = 1] = "TextFrame";
                OpCode[OpCode["BinaryFrame"] = 2] = "BinaryFrame";
                OpCode[OpCode["Close"] = 8] = "Close";
                OpCode[OpCode["Ping"] = 9] = "Ping";
                OpCode[OpCode["Pong"] = 10] = "Pong";
            })(OpCode || (OpCode = {}));
            exports_31("OpCode", OpCode);
            WebSocketImpl = class WebSocketImpl {
                constructor({ conn, bufReader, bufWriter, mask, }) {
                    this.sendQueue = [];
                    this._isClosed = false;
                    this.conn = conn;
                    this.mask = mask;
                    this.bufReader = bufReader || new bufio_ts_3.BufReader(conn);
                    this.bufWriter = bufWriter || new bufio_ts_3.BufWriter(conn);
                }
                async *[Symbol.asyncIterator]() {
                    let frames = [];
                    let payloadsLength = 0;
                    while (!this._isClosed) {
                        let frame;
                        try {
                            frame = await readFrame(this.bufReader);
                        }
                        catch (e) {
                            this.ensureSocketClosed();
                            break;
                        }
                        unmask(frame.payload, frame.mask);
                        switch (frame.opcode) {
                            case OpCode.TextFrame:
                            case OpCode.BinaryFrame:
                            case OpCode.Continue:
                                frames.push(frame);
                                payloadsLength += frame.payload.length;
                                if (frame.isLastFrame) {
                                    const concat = new Uint8Array(payloadsLength);
                                    let offs = 0;
                                    for (const frame of frames) {
                                        concat.set(frame.payload, offs);
                                        offs += frame.payload.length;
                                    }
                                    if (frames[0].opcode === OpCode.TextFrame) {
                                        // text
                                        yield utf8_ts_4.decode(concat);
                                    }
                                    else {
                                        // binary
                                        yield concat;
                                    }
                                    frames = [];
                                    payloadsLength = 0;
                                }
                                break;
                            case OpCode.Close: {
                                // [0x12, 0x34] -> 0x1234
                                const code = (frame.payload[0] << 8) | frame.payload[1];
                                const reason = utf8_ts_4.decode(frame.payload.subarray(2, frame.payload.length));
                                await this.close(code, reason);
                                yield { code, reason };
                                return;
                            }
                            case OpCode.Ping:
                                await this.enqueue({
                                    opcode: OpCode.Pong,
                                    payload: frame.payload,
                                    isLastFrame: true,
                                });
                                yield ["ping", frame.payload];
                                break;
                            case OpCode.Pong:
                                yield ["pong", frame.payload];
                                break;
                            default:
                        }
                    }
                }
                dequeue() {
                    const [entry] = this.sendQueue;
                    if (!entry)
                        return;
                    if (this._isClosed)
                        return;
                    const { d, frame } = entry;
                    writeFrame(frame, this.bufWriter)
                        .then(() => d.resolve())
                        .catch((e) => d.reject(e))
                        .finally(() => {
                        this.sendQueue.shift();
                        this.dequeue();
                    });
                }
                enqueue(frame) {
                    if (this._isClosed) {
                        throw new Deno.errors.ConnectionReset("Socket has already been closed");
                    }
                    const d = deferred_ts_3.deferred();
                    this.sendQueue.push({ d, frame });
                    if (this.sendQueue.length === 1) {
                        this.dequeue();
                    }
                    return d;
                }
                send(data) {
                    const opcode = typeof data === "string" ? OpCode.TextFrame : OpCode.BinaryFrame;
                    const payload = typeof data === "string" ? utf8_ts_4.encode(data) : data;
                    const isLastFrame = true;
                    const frame = {
                        isLastFrame,
                        opcode,
                        payload,
                        mask: this.mask,
                    };
                    return this.enqueue(frame);
                }
                ping(data = "") {
                    const payload = typeof data === "string" ? utf8_ts_4.encode(data) : data;
                    const frame = {
                        isLastFrame: true,
                        opcode: OpCode.Ping,
                        mask: this.mask,
                        payload,
                    };
                    return this.enqueue(frame);
                }
                get isClosed() {
                    return this._isClosed;
                }
                async close(code = 1000, reason) {
                    try {
                        const header = [code >>> 8, code & 0x00ff];
                        let payload;
                        if (reason) {
                            const reasonBytes = utf8_ts_4.encode(reason);
                            payload = new Uint8Array(2 + reasonBytes.byteLength);
                            payload.set(header);
                            payload.set(reasonBytes, 2);
                        }
                        else {
                            payload = new Uint8Array(header);
                        }
                        await this.enqueue({
                            isLastFrame: true,
                            opcode: OpCode.Close,
                            mask: this.mask,
                            payload,
                        });
                    }
                    catch (e) {
                        throw e;
                    }
                    finally {
                        this.ensureSocketClosed();
                    }
                }
                closeForce() {
                    this.ensureSocketClosed();
                }
                ensureSocketClosed() {
                    if (this.isClosed)
                        return;
                    try {
                        this.conn.close();
                    }
                    catch (e) {
                        console.error(e);
                    }
                    finally {
                        this._isClosed = true;
                        const rest = this.sendQueue;
                        this.sendQueue = [];
                        rest.forEach((e) => e.d.reject(new Deno.errors.ConnectionReset("Socket has already been closed")));
                    }
                }
            };
            kGUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
            kSecChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-.~_";
        }
    };
});
System.register("https://deno.land/x/media_types@v2.3.6/db", [], function (exports_32, context_32) {
    "use strict";
    var db;
    var __moduleName = context_32 && context_32.id;
    return {
        setters: [],
        execute: function () {
            exports_32("db", db = {
                "application/1d-interleaved-parityfec": {
                    source: "iana",
                },
                "application/3gpdash-qoe-report+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/3gpp-ims+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/a2l": {
                    source: "iana",
                },
                "application/activemessage": {
                    source: "iana",
                },
                "application/activity+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-costmap+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-costmapfilter+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-directory+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-endpointcost+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-endpointcostparams+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-endpointprop+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-endpointpropparams+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-error+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-networkmap+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-networkmapfilter+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-updatestreamcontrol+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/alto-updatestreamparams+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/aml": {
                    source: "iana",
                },
                "application/andrew-inset": {
                    source: "iana",
                    extensions: ["ez"],
                },
                "application/applefile": {
                    source: "iana",
                },
                "application/applixware": {
                    source: "apache",
                    extensions: ["aw"],
                },
                "application/atf": {
                    source: "iana",
                },
                "application/atfx": {
                    source: "iana",
                },
                "application/atom+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["atom"],
                },
                "application/atomcat+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["atomcat"],
                },
                "application/atomdeleted+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["atomdeleted"],
                },
                "application/atomicmail": {
                    source: "iana",
                },
                "application/atomsvc+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["atomsvc"],
                },
                "application/atsc-dwd+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["dwd"],
                },
                "application/atsc-dynamic-event-message": {
                    source: "iana",
                },
                "application/atsc-held+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["held"],
                },
                "application/atsc-rdt+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/atsc-rsat+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rsat"],
                },
                "application/atxml": {
                    source: "iana",
                },
                "application/auth-policy+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/bacnet-xdd+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/batch-smtp": {
                    source: "iana",
                },
                "application/bdoc": {
                    compressible: false,
                    extensions: ["bdoc"],
                },
                "application/beep+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/calendar+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/calendar+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xcs"],
                },
                "application/call-completion": {
                    source: "iana",
                },
                "application/cals-1840": {
                    source: "iana",
                },
                "application/cap+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/cbor": {
                    source: "iana",
                },
                "application/cbor-seq": {
                    source: "iana",
                },
                "application/cccex": {
                    source: "iana",
                },
                "application/ccmp+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/ccxml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["ccxml"],
                },
                "application/cdfx+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["cdfx"],
                },
                "application/cdmi-capability": {
                    source: "iana",
                    extensions: ["cdmia"],
                },
                "application/cdmi-container": {
                    source: "iana",
                    extensions: ["cdmic"],
                },
                "application/cdmi-domain": {
                    source: "iana",
                    extensions: ["cdmid"],
                },
                "application/cdmi-object": {
                    source: "iana",
                    extensions: ["cdmio"],
                },
                "application/cdmi-queue": {
                    source: "iana",
                    extensions: ["cdmiq"],
                },
                "application/cdni": {
                    source: "iana",
                },
                "application/cea": {
                    source: "iana",
                },
                "application/cea-2018+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/cellml+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/cfw": {
                    source: "iana",
                },
                "application/clue+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/clue_info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/cms": {
                    source: "iana",
                },
                "application/cnrp+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/coap-group+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/coap-payload": {
                    source: "iana",
                },
                "application/commonground": {
                    source: "iana",
                },
                "application/conference-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/cose": {
                    source: "iana",
                },
                "application/cose-key": {
                    source: "iana",
                },
                "application/cose-key-set": {
                    source: "iana",
                },
                "application/cpl+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/csrattrs": {
                    source: "iana",
                },
                "application/csta+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/cstadata+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/csvm+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/cu-seeme": {
                    source: "apache",
                    extensions: ["cu"],
                },
                "application/cwt": {
                    source: "iana",
                },
                "application/cybercash": {
                    source: "iana",
                },
                "application/dart": {
                    compressible: true,
                },
                "application/dash+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["mpd"],
                },
                "application/dashdelta": {
                    source: "iana",
                },
                "application/davmount+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["davmount"],
                },
                "application/dca-rft": {
                    source: "iana",
                },
                "application/dcd": {
                    source: "iana",
                },
                "application/dec-dx": {
                    source: "iana",
                },
                "application/dialog-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/dicom": {
                    source: "iana",
                },
                "application/dicom+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/dicom+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/dii": {
                    source: "iana",
                },
                "application/dit": {
                    source: "iana",
                },
                "application/dns": {
                    source: "iana",
                },
                "application/dns+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/dns-message": {
                    source: "iana",
                },
                "application/docbook+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["dbk"],
                },
                "application/dots+cbor": {
                    source: "iana",
                },
                "application/dskpp+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/dssc+der": {
                    source: "iana",
                    extensions: ["dssc"],
                },
                "application/dssc+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xdssc"],
                },
                "application/dvcs": {
                    source: "iana",
                },
                "application/ecmascript": {
                    source: "iana",
                    compressible: true,
                    extensions: ["ecma", "es"],
                },
                "application/edi-consent": {
                    source: "iana",
                },
                "application/edi-x12": {
                    source: "iana",
                    compressible: false,
                },
                "application/edifact": {
                    source: "iana",
                    compressible: false,
                },
                "application/efi": {
                    source: "iana",
                },
                "application/emergencycalldata.comment+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/emergencycalldata.control+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/emergencycalldata.deviceinfo+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/emergencycalldata.ecall.msd": {
                    source: "iana",
                },
                "application/emergencycalldata.providerinfo+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/emergencycalldata.serviceinfo+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/emergencycalldata.subscriberinfo+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/emergencycalldata.veds+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/emma+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["emma"],
                },
                "application/emotionml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["emotionml"],
                },
                "application/encaprtp": {
                    source: "iana",
                },
                "application/epp+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/epub+zip": {
                    source: "iana",
                    compressible: false,
                    extensions: ["epub"],
                },
                "application/eshop": {
                    source: "iana",
                },
                "application/exi": {
                    source: "iana",
                    extensions: ["exi"],
                },
                "application/expect-ct-report+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/fastinfoset": {
                    source: "iana",
                },
                "application/fastsoap": {
                    source: "iana",
                },
                "application/fdt+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["fdt"],
                },
                "application/fhir+json": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/fhir+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/fido.trusted-apps+json": {
                    compressible: true,
                },
                "application/fits": {
                    source: "iana",
                },
                "application/flexfec": {
                    source: "iana",
                },
                "application/font-sfnt": {
                    source: "iana",
                },
                "application/font-tdpfr": {
                    source: "iana",
                    extensions: ["pfr"],
                },
                "application/font-woff": {
                    source: "iana",
                    compressible: false,
                },
                "application/framework-attributes+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/geo+json": {
                    source: "iana",
                    compressible: true,
                    extensions: ["geojson"],
                },
                "application/geo+json-seq": {
                    source: "iana",
                },
                "application/geopackage+sqlite3": {
                    source: "iana",
                },
                "application/geoxacml+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/gltf-buffer": {
                    source: "iana",
                },
                "application/gml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["gml"],
                },
                "application/gpx+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["gpx"],
                },
                "application/gxf": {
                    source: "apache",
                    extensions: ["gxf"],
                },
                "application/gzip": {
                    source: "iana",
                    compressible: false,
                    extensions: ["gz"],
                },
                "application/h224": {
                    source: "iana",
                },
                "application/held+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/hjson": {
                    extensions: ["hjson"],
                },
                "application/http": {
                    source: "iana",
                },
                "application/hyperstudio": {
                    source: "iana",
                    extensions: ["stk"],
                },
                "application/ibe-key-request+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/ibe-pkg-reply+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/ibe-pp-data": {
                    source: "iana",
                },
                "application/iges": {
                    source: "iana",
                },
                "application/im-iscomposing+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/index": {
                    source: "iana",
                },
                "application/index.cmd": {
                    source: "iana",
                },
                "application/index.obj": {
                    source: "iana",
                },
                "application/index.response": {
                    source: "iana",
                },
                "application/index.vnd": {
                    source: "iana",
                },
                "application/inkml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["ink", "inkml"],
                },
                "application/iotp": {
                    source: "iana",
                },
                "application/ipfix": {
                    source: "iana",
                    extensions: ["ipfix"],
                },
                "application/ipp": {
                    source: "iana",
                },
                "application/isup": {
                    source: "iana",
                },
                "application/its+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["its"],
                },
                "application/java-archive": {
                    source: "apache",
                    compressible: false,
                    extensions: ["jar", "war", "ear"],
                },
                "application/java-serialized-object": {
                    source: "apache",
                    compressible: false,
                    extensions: ["ser"],
                },
                "application/java-vm": {
                    source: "apache",
                    compressible: false,
                    extensions: ["class"],
                },
                "application/javascript": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                    extensions: ["js", "mjs"],
                },
                "application/jf2feed+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/jose": {
                    source: "iana",
                },
                "application/jose+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/jrd+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/json": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                    extensions: ["json", "map"],
                },
                "application/json-patch+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/json-seq": {
                    source: "iana",
                },
                "application/json5": {
                    extensions: ["json5"],
                },
                "application/jsonml+json": {
                    source: "apache",
                    compressible: true,
                    extensions: ["jsonml"],
                },
                "application/jwk+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/jwk-set+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/jwt": {
                    source: "iana",
                },
                "application/kpml-request+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/kpml-response+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/ld+json": {
                    source: "iana",
                    compressible: true,
                    extensions: ["jsonld"],
                },
                "application/lgr+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["lgr"],
                },
                "application/link-format": {
                    source: "iana",
                },
                "application/load-control+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/lost+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["lostxml"],
                },
                "application/lostsync+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/lpf+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/lxf": {
                    source: "iana",
                },
                "application/mac-binhex40": {
                    source: "iana",
                    extensions: ["hqx"],
                },
                "application/mac-compactpro": {
                    source: "apache",
                    extensions: ["cpt"],
                },
                "application/macwriteii": {
                    source: "iana",
                },
                "application/mads+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["mads"],
                },
                "application/manifest+json": {
                    charset: "UTF-8",
                    compressible: true,
                    extensions: ["webmanifest"],
                },
                "application/marc": {
                    source: "iana",
                    extensions: ["mrc"],
                },
                "application/marcxml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["mrcx"],
                },
                "application/mathematica": {
                    source: "iana",
                    extensions: ["ma", "nb", "mb"],
                },
                "application/mathml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["mathml"],
                },
                "application/mathml-content+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mathml-presentation+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-associated-procedure-description+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-deregister+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-envelope+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-msk+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-msk-response+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-protection-description+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-reception-report+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-register+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-register-response+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-schedule+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbms-user-service-description+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mbox": {
                    source: "iana",
                    extensions: ["mbox"],
                },
                "application/media-policy-dataset+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/media_control+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/mediaservercontrol+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["mscml"],
                },
                "application/merge-patch+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/metalink+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["metalink"],
                },
                "application/metalink4+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["meta4"],
                },
                "application/mets+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["mets"],
                },
                "application/mf4": {
                    source: "iana",
                },
                "application/mikey": {
                    source: "iana",
                },
                "application/mipc": {
                    source: "iana",
                },
                "application/mmt-aei+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["maei"],
                },
                "application/mmt-usd+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["musd"],
                },
                "application/mods+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["mods"],
                },
                "application/moss-keys": {
                    source: "iana",
                },
                "application/moss-signature": {
                    source: "iana",
                },
                "application/mosskey-data": {
                    source: "iana",
                },
                "application/mosskey-request": {
                    source: "iana",
                },
                "application/mp21": {
                    source: "iana",
                    extensions: ["m21", "mp21"],
                },
                "application/mp4": {
                    source: "iana",
                    extensions: ["mp4s", "m4p"],
                },
                "application/mpeg4-generic": {
                    source: "iana",
                },
                "application/mpeg4-iod": {
                    source: "iana",
                },
                "application/mpeg4-iod-xmt": {
                    source: "iana",
                },
                "application/mrb-consumer+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xdf"],
                },
                "application/mrb-publish+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xdf"],
                },
                "application/msc-ivr+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/msc-mixer+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/msword": {
                    source: "iana",
                    compressible: false,
                    extensions: ["doc", "dot"],
                },
                "application/mud+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/multipart-core": {
                    source: "iana",
                },
                "application/mxf": {
                    source: "iana",
                    extensions: ["mxf"],
                },
                "application/n-quads": {
                    source: "iana",
                    extensions: ["nq"],
                },
                "application/n-triples": {
                    source: "iana",
                    extensions: ["nt"],
                },
                "application/nasdata": {
                    source: "iana",
                },
                "application/news-checkgroups": {
                    source: "iana",
                    charset: "US-ASCII",
                },
                "application/news-groupinfo": {
                    source: "iana",
                    charset: "US-ASCII",
                },
                "application/news-transmission": {
                    source: "iana",
                },
                "application/nlsml+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/node": {
                    source: "iana",
                    extensions: ["cjs"],
                },
                "application/nss": {
                    source: "iana",
                },
                "application/ocsp-request": {
                    source: "iana",
                },
                "application/ocsp-response": {
                    source: "iana",
                },
                "application/octet-stream": {
                    source: "iana",
                    compressible: false,
                    extensions: [
                        "bin",
                        "dms",
                        "lrf",
                        "mar",
                        "so",
                        "dist",
                        "distz",
                        "pkg",
                        "bpk",
                        "dump",
                        "elc",
                        "deploy",
                        "exe",
                        "dll",
                        "deb",
                        "dmg",
                        "iso",
                        "img",
                        "msi",
                        "msp",
                        "msm",
                        "buffer",
                    ],
                },
                "application/oda": {
                    source: "iana",
                    extensions: ["oda"],
                },
                "application/odm+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/odx": {
                    source: "iana",
                },
                "application/oebps-package+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["opf"],
                },
                "application/ogg": {
                    source: "iana",
                    compressible: false,
                    extensions: ["ogx"],
                },
                "application/omdoc+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["omdoc"],
                },
                "application/onenote": {
                    source: "apache",
                    extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"],
                },
                "application/oscore": {
                    source: "iana",
                },
                "application/oxps": {
                    source: "iana",
                    extensions: ["oxps"],
                },
                "application/p2p-overlay+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["relo"],
                },
                "application/parityfec": {
                    source: "iana",
                },
                "application/passport": {
                    source: "iana",
                },
                "application/patch-ops-error+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xer"],
                },
                "application/pdf": {
                    source: "iana",
                    compressible: false,
                    extensions: ["pdf"],
                },
                "application/pdx": {
                    source: "iana",
                },
                "application/pem-certificate-chain": {
                    source: "iana",
                },
                "application/pgp-encrypted": {
                    source: "iana",
                    compressible: false,
                    extensions: ["pgp"],
                },
                "application/pgp-keys": {
                    source: "iana",
                },
                "application/pgp-signature": {
                    source: "iana",
                    extensions: ["asc", "sig"],
                },
                "application/pics-rules": {
                    source: "apache",
                    extensions: ["prf"],
                },
                "application/pidf+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/pidf-diff+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/pkcs10": {
                    source: "iana",
                    extensions: ["p10"],
                },
                "application/pkcs12": {
                    source: "iana",
                },
                "application/pkcs7-mime": {
                    source: "iana",
                    extensions: ["p7m", "p7c"],
                },
                "application/pkcs7-signature": {
                    source: "iana",
                    extensions: ["p7s"],
                },
                "application/pkcs8": {
                    source: "iana",
                    extensions: ["p8"],
                },
                "application/pkcs8-encrypted": {
                    source: "iana",
                },
                "application/pkix-attr-cert": {
                    source: "iana",
                    extensions: ["ac"],
                },
                "application/pkix-cert": {
                    source: "iana",
                    extensions: ["cer"],
                },
                "application/pkix-crl": {
                    source: "iana",
                    extensions: ["crl"],
                },
                "application/pkix-pkipath": {
                    source: "iana",
                    extensions: ["pkipath"],
                },
                "application/pkixcmp": {
                    source: "iana",
                    extensions: ["pki"],
                },
                "application/pls+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["pls"],
                },
                "application/poc-settings+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/postscript": {
                    source: "iana",
                    compressible: true,
                    extensions: ["ai", "eps", "ps"],
                },
                "application/ppsp-tracker+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/problem+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/problem+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/provenance+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["provx"],
                },
                "application/prs.alvestrand.titrax-sheet": {
                    source: "iana",
                },
                "application/prs.cww": {
                    source: "iana",
                    extensions: ["cww"],
                },
                "application/prs.hpub+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/prs.nprend": {
                    source: "iana",
                },
                "application/prs.plucker": {
                    source: "iana",
                },
                "application/prs.rdf-xml-crypt": {
                    source: "iana",
                },
                "application/prs.xsf+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/pskc+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["pskcxml"],
                },
                "application/pvd+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/qsig": {
                    source: "iana",
                },
                "application/raml+yaml": {
                    compressible: true,
                    extensions: ["raml"],
                },
                "application/raptorfec": {
                    source: "iana",
                },
                "application/rdap+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/rdf+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rdf", "owl"],
                },
                "application/reginfo+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rif"],
                },
                "application/relax-ng-compact-syntax": {
                    source: "iana",
                    extensions: ["rnc"],
                },
                "application/remote-printing": {
                    source: "iana",
                },
                "application/reputon+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/resource-lists+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rl"],
                },
                "application/resource-lists-diff+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rld"],
                },
                "application/rfc+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/riscos": {
                    source: "iana",
                },
                "application/rlmi+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/rls-services+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rs"],
                },
                "application/route-apd+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rapd"],
                },
                "application/route-s-tsid+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["sls"],
                },
                "application/route-usd+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rusd"],
                },
                "application/rpki-ghostbusters": {
                    source: "iana",
                    extensions: ["gbr"],
                },
                "application/rpki-manifest": {
                    source: "iana",
                    extensions: ["mft"],
                },
                "application/rpki-publication": {
                    source: "iana",
                },
                "application/rpki-roa": {
                    source: "iana",
                    extensions: ["roa"],
                },
                "application/rpki-updown": {
                    source: "iana",
                },
                "application/rsd+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["rsd"],
                },
                "application/rss+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["rss"],
                },
                "application/rtf": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rtf"],
                },
                "application/rtploopback": {
                    source: "iana",
                },
                "application/rtx": {
                    source: "iana",
                },
                "application/samlassertion+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/samlmetadata+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/sbe": {
                    source: "iana",
                },
                "application/sbml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["sbml"],
                },
                "application/scaip+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/scim+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/scvp-cv-request": {
                    source: "iana",
                    extensions: ["scq"],
                },
                "application/scvp-cv-response": {
                    source: "iana",
                    extensions: ["scs"],
                },
                "application/scvp-vp-request": {
                    source: "iana",
                    extensions: ["spq"],
                },
                "application/scvp-vp-response": {
                    source: "iana",
                    extensions: ["spp"],
                },
                "application/sdp": {
                    source: "iana",
                    extensions: ["sdp"],
                },
                "application/secevent+jwt": {
                    source: "iana",
                },
                "application/senml+cbor": {
                    source: "iana",
                },
                "application/senml+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/senml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["senmlx"],
                },
                "application/senml-etch+cbor": {
                    source: "iana",
                },
                "application/senml-etch+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/senml-exi": {
                    source: "iana",
                },
                "application/sensml+cbor": {
                    source: "iana",
                },
                "application/sensml+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/sensml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["sensmlx"],
                },
                "application/sensml-exi": {
                    source: "iana",
                },
                "application/sep+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/sep-exi": {
                    source: "iana",
                },
                "application/session-info": {
                    source: "iana",
                },
                "application/set-payment": {
                    source: "iana",
                },
                "application/set-payment-initiation": {
                    source: "iana",
                    extensions: ["setpay"],
                },
                "application/set-registration": {
                    source: "iana",
                },
                "application/set-registration-initiation": {
                    source: "iana",
                    extensions: ["setreg"],
                },
                "application/sgml": {
                    source: "iana",
                },
                "application/sgml-open-catalog": {
                    source: "iana",
                },
                "application/shf+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["shf"],
                },
                "application/sieve": {
                    source: "iana",
                    extensions: ["siv", "sieve"],
                },
                "application/simple-filter+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/simple-message-summary": {
                    source: "iana",
                },
                "application/simplesymbolcontainer": {
                    source: "iana",
                },
                "application/sipc": {
                    source: "iana",
                },
                "application/slate": {
                    source: "iana",
                },
                "application/smil": {
                    source: "iana",
                },
                "application/smil+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["smi", "smil"],
                },
                "application/smpte336m": {
                    source: "iana",
                },
                "application/soap+fastinfoset": {
                    source: "iana",
                },
                "application/soap+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/sparql-query": {
                    source: "iana",
                    extensions: ["rq"],
                },
                "application/sparql-results+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["srx"],
                },
                "application/spirits-event+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/sql": {
                    source: "iana",
                },
                "application/srgs": {
                    source: "iana",
                    extensions: ["gram"],
                },
                "application/srgs+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["grxml"],
                },
                "application/sru+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["sru"],
                },
                "application/ssdl+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["ssdl"],
                },
                "application/ssml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["ssml"],
                },
                "application/stix+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/swid+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["swidtag"],
                },
                "application/tamp-apex-update": {
                    source: "iana",
                },
                "application/tamp-apex-update-confirm": {
                    source: "iana",
                },
                "application/tamp-community-update": {
                    source: "iana",
                },
                "application/tamp-community-update-confirm": {
                    source: "iana",
                },
                "application/tamp-error": {
                    source: "iana",
                },
                "application/tamp-sequence-adjust": {
                    source: "iana",
                },
                "application/tamp-sequence-adjust-confirm": {
                    source: "iana",
                },
                "application/tamp-status-query": {
                    source: "iana",
                },
                "application/tamp-status-response": {
                    source: "iana",
                },
                "application/tamp-update": {
                    source: "iana",
                },
                "application/tamp-update-confirm": {
                    source: "iana",
                },
                "application/tar": {
                    compressible: true,
                },
                "application/taxii+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/td+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/tei+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["tei", "teicorpus"],
                },
                "application/tetra_isi": {
                    source: "iana",
                },
                "application/thraud+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["tfi"],
                },
                "application/timestamp-query": {
                    source: "iana",
                },
                "application/timestamp-reply": {
                    source: "iana",
                },
                "application/timestamped-data": {
                    source: "iana",
                    extensions: ["tsd"],
                },
                "application/tlsrpt+gzip": {
                    source: "iana",
                },
                "application/tlsrpt+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/tnauthlist": {
                    source: "iana",
                },
                "application/toml": {
                    compressible: true,
                    extensions: ["toml"],
                },
                "application/trickle-ice-sdpfrag": {
                    source: "iana",
                },
                "application/trig": {
                    source: "iana",
                },
                "application/ttml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["ttml"],
                },
                "application/tve-trigger": {
                    source: "iana",
                },
                "application/tzif": {
                    source: "iana",
                },
                "application/tzif-leap": {
                    source: "iana",
                },
                "application/ulpfec": {
                    source: "iana",
                },
                "application/urc-grpsheet+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/urc-ressheet+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rsheet"],
                },
                "application/urc-targetdesc+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/urc-uisocketdesc+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vcard+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vcard+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vemmi": {
                    source: "iana",
                },
                "application/vividence.scriptfile": {
                    source: "apache",
                },
                "application/vnd.1000minds.decision-model+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["1km"],
                },
                "application/vnd.3gpp-prose+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp-prose-pc3ch+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp-v2x-local-service-information": {
                    source: "iana",
                },
                "application/vnd.3gpp.access-transfer-events+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.bsf+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.gmop+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mc-signalling-ear": {
                    source: "iana",
                },
                "application/vnd.3gpp.mcdata-affiliation-command+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcdata-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcdata-payload": {
                    source: "iana",
                },
                "application/vnd.3gpp.mcdata-service-config+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcdata-signalling": {
                    source: "iana",
                },
                "application/vnd.3gpp.mcdata-ue-config+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcdata-user-profile+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-affiliation-command+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-floor-request+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-location-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-service-config+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-signed+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-ue-config+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-ue-init-config+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcptt-user-profile+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcvideo-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcvideo-location-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcvideo-service-config+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcvideo-transmission-request+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcvideo-ue-config+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mcvideo-user-profile+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.mid-call+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.pic-bw-large": {
                    source: "iana",
                    extensions: ["plb"],
                },
                "application/vnd.3gpp.pic-bw-small": {
                    source: "iana",
                    extensions: ["psb"],
                },
                "application/vnd.3gpp.pic-bw-var": {
                    source: "iana",
                    extensions: ["pvb"],
                },
                "application/vnd.3gpp.sms": {
                    source: "iana",
                },
                "application/vnd.3gpp.sms+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.srvcc-ext+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.srvcc-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.state-and-event-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp.ussd+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp2.bcmcsinfo+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.3gpp2.sms": {
                    source: "iana",
                },
                "application/vnd.3gpp2.tcap": {
                    source: "iana",
                    extensions: ["tcap"],
                },
                "application/vnd.3lightssoftware.imagescal": {
                    source: "iana",
                },
                "application/vnd.3m.post-it-notes": {
                    source: "iana",
                    extensions: ["pwn"],
                },
                "application/vnd.accpac.simply.aso": {
                    source: "iana",
                    extensions: ["aso"],
                },
                "application/vnd.accpac.simply.imp": {
                    source: "iana",
                    extensions: ["imp"],
                },
                "application/vnd.acucobol": {
                    source: "iana",
                    extensions: ["acu"],
                },
                "application/vnd.acucorp": {
                    source: "iana",
                    extensions: ["atc", "acutc"],
                },
                "application/vnd.adobe.air-application-installer-package+zip": {
                    source: "apache",
                    compressible: false,
                    extensions: ["air"],
                },
                "application/vnd.adobe.flash.movie": {
                    source: "iana",
                },
                "application/vnd.adobe.formscentral.fcdt": {
                    source: "iana",
                    extensions: ["fcdt"],
                },
                "application/vnd.adobe.fxp": {
                    source: "iana",
                    extensions: ["fxp", "fxpl"],
                },
                "application/vnd.adobe.partial-upload": {
                    source: "iana",
                },
                "application/vnd.adobe.xdp+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xdp"],
                },
                "application/vnd.adobe.xfdf": {
                    source: "iana",
                    extensions: ["xfdf"],
                },
                "application/vnd.aether.imp": {
                    source: "iana",
                },
                "application/vnd.afpc.afplinedata": {
                    source: "iana",
                },
                "application/vnd.afpc.afplinedata-pagedef": {
                    source: "iana",
                },
                "application/vnd.afpc.foca-charset": {
                    source: "iana",
                },
                "application/vnd.afpc.foca-codedfont": {
                    source: "iana",
                },
                "application/vnd.afpc.foca-codepage": {
                    source: "iana",
                },
                "application/vnd.afpc.modca": {
                    source: "iana",
                },
                "application/vnd.afpc.modca-formdef": {
                    source: "iana",
                },
                "application/vnd.afpc.modca-mediummap": {
                    source: "iana",
                },
                "application/vnd.afpc.modca-objectcontainer": {
                    source: "iana",
                },
                "application/vnd.afpc.modca-overlay": {
                    source: "iana",
                },
                "application/vnd.afpc.modca-pagesegment": {
                    source: "iana",
                },
                "application/vnd.ah-barcode": {
                    source: "iana",
                },
                "application/vnd.ahead.space": {
                    source: "iana",
                    extensions: ["ahead"],
                },
                "application/vnd.airzip.filesecure.azf": {
                    source: "iana",
                    extensions: ["azf"],
                },
                "application/vnd.airzip.filesecure.azs": {
                    source: "iana",
                    extensions: ["azs"],
                },
                "application/vnd.amadeus+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.amazon.ebook": {
                    source: "apache",
                    extensions: ["azw"],
                },
                "application/vnd.amazon.mobi8-ebook": {
                    source: "iana",
                },
                "application/vnd.americandynamics.acc": {
                    source: "iana",
                    extensions: ["acc"],
                },
                "application/vnd.amiga.ami": {
                    source: "iana",
                    extensions: ["ami"],
                },
                "application/vnd.amundsen.maze+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.android.ota": {
                    source: "iana",
                },
                "application/vnd.android.package-archive": {
                    source: "apache",
                    compressible: false,
                    extensions: ["apk"],
                },
                "application/vnd.anki": {
                    source: "iana",
                },
                "application/vnd.anser-web-certificate-issue-initiation": {
                    source: "iana",
                    extensions: ["cii"],
                },
                "application/vnd.anser-web-funds-transfer-initiation": {
                    source: "apache",
                    extensions: ["fti"],
                },
                "application/vnd.antix.game-component": {
                    source: "iana",
                    extensions: ["atx"],
                },
                "application/vnd.apache.thrift.binary": {
                    source: "iana",
                },
                "application/vnd.apache.thrift.compact": {
                    source: "iana",
                },
                "application/vnd.apache.thrift.json": {
                    source: "iana",
                },
                "application/vnd.api+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.aplextor.warrp+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.apothekende.reservation+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.apple.installer+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["mpkg"],
                },
                "application/vnd.apple.keynote": {
                    source: "iana",
                    extensions: ["keynote"],
                },
                "application/vnd.apple.mpegurl": {
                    source: "iana",
                    extensions: ["m3u8"],
                },
                "application/vnd.apple.numbers": {
                    source: "iana",
                    extensions: ["numbers"],
                },
                "application/vnd.apple.pages": {
                    source: "iana",
                    extensions: ["pages"],
                },
                "application/vnd.apple.pkpass": {
                    compressible: false,
                    extensions: ["pkpass"],
                },
                "application/vnd.arastra.swi": {
                    source: "iana",
                },
                "application/vnd.aristanetworks.swi": {
                    source: "iana",
                    extensions: ["swi"],
                },
                "application/vnd.artisan+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.artsquare": {
                    source: "iana",
                },
                "application/vnd.astraea-software.iota": {
                    source: "iana",
                    extensions: ["iota"],
                },
                "application/vnd.audiograph": {
                    source: "iana",
                    extensions: ["aep"],
                },
                "application/vnd.autopackage": {
                    source: "iana",
                },
                "application/vnd.avalon+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.avistar+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.balsamiq.bmml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["bmml"],
                },
                "application/vnd.balsamiq.bmpr": {
                    source: "iana",
                },
                "application/vnd.banana-accounting": {
                    source: "iana",
                },
                "application/vnd.bbf.usp.error": {
                    source: "iana",
                },
                "application/vnd.bbf.usp.msg": {
                    source: "iana",
                },
                "application/vnd.bbf.usp.msg+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.bekitzur-stech+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.bint.med-content": {
                    source: "iana",
                },
                "application/vnd.biopax.rdf+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.blink-idb-value-wrapper": {
                    source: "iana",
                },
                "application/vnd.blueice.multipass": {
                    source: "iana",
                    extensions: ["mpm"],
                },
                "application/vnd.bluetooth.ep.oob": {
                    source: "iana",
                },
                "application/vnd.bluetooth.le.oob": {
                    source: "iana",
                },
                "application/vnd.bmi": {
                    source: "iana",
                    extensions: ["bmi"],
                },
                "application/vnd.bpf": {
                    source: "iana",
                },
                "application/vnd.bpf3": {
                    source: "iana",
                },
                "application/vnd.businessobjects": {
                    source: "iana",
                    extensions: ["rep"],
                },
                "application/vnd.byu.uapi+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.cab-jscript": {
                    source: "iana",
                },
                "application/vnd.canon-cpdl": {
                    source: "iana",
                },
                "application/vnd.canon-lips": {
                    source: "iana",
                },
                "application/vnd.capasystems-pg+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.cendio.thinlinc.clientconf": {
                    source: "iana",
                },
                "application/vnd.century-systems.tcp_stream": {
                    source: "iana",
                },
                "application/vnd.chemdraw+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["cdxml"],
                },
                "application/vnd.chess-pgn": {
                    source: "iana",
                },
                "application/vnd.chipnuts.karaoke-mmd": {
                    source: "iana",
                    extensions: ["mmd"],
                },
                "application/vnd.ciedi": {
                    source: "iana",
                },
                "application/vnd.cinderella": {
                    source: "iana",
                    extensions: ["cdy"],
                },
                "application/vnd.cirpack.isdn-ext": {
                    source: "iana",
                },
                "application/vnd.citationstyles.style+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["csl"],
                },
                "application/vnd.claymore": {
                    source: "iana",
                    extensions: ["cla"],
                },
                "application/vnd.cloanto.rp9": {
                    source: "iana",
                    extensions: ["rp9"],
                },
                "application/vnd.clonk.c4group": {
                    source: "iana",
                    extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"],
                },
                "application/vnd.cluetrust.cartomobile-config": {
                    source: "iana",
                    extensions: ["c11amc"],
                },
                "application/vnd.cluetrust.cartomobile-config-pkg": {
                    source: "iana",
                    extensions: ["c11amz"],
                },
                "application/vnd.coffeescript": {
                    source: "iana",
                },
                "application/vnd.collabio.xodocuments.document": {
                    source: "iana",
                },
                "application/vnd.collabio.xodocuments.document-template": {
                    source: "iana",
                },
                "application/vnd.collabio.xodocuments.presentation": {
                    source: "iana",
                },
                "application/vnd.collabio.xodocuments.presentation-template": {
                    source: "iana",
                },
                "application/vnd.collabio.xodocuments.spreadsheet": {
                    source: "iana",
                },
                "application/vnd.collabio.xodocuments.spreadsheet-template": {
                    source: "iana",
                },
                "application/vnd.collection+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.collection.doc+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.collection.next+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.comicbook+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.comicbook-rar": {
                    source: "iana",
                },
                "application/vnd.commerce-battelle": {
                    source: "iana",
                },
                "application/vnd.commonspace": {
                    source: "iana",
                    extensions: ["csp"],
                },
                "application/vnd.contact.cmsg": {
                    source: "iana",
                    extensions: ["cdbcmsg"],
                },
                "application/vnd.coreos.ignition+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.cosmocaller": {
                    source: "iana",
                    extensions: ["cmc"],
                },
                "application/vnd.crick.clicker": {
                    source: "iana",
                    extensions: ["clkx"],
                },
                "application/vnd.crick.clicker.keyboard": {
                    source: "iana",
                    extensions: ["clkk"],
                },
                "application/vnd.crick.clicker.palette": {
                    source: "iana",
                    extensions: ["clkp"],
                },
                "application/vnd.crick.clicker.template": {
                    source: "iana",
                    extensions: ["clkt"],
                },
                "application/vnd.crick.clicker.wordbank": {
                    source: "iana",
                    extensions: ["clkw"],
                },
                "application/vnd.criticaltools.wbs+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["wbs"],
                },
                "application/vnd.cryptii.pipe+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.crypto-shade-file": {
                    source: "iana",
                },
                "application/vnd.ctc-posml": {
                    source: "iana",
                    extensions: ["pml"],
                },
                "application/vnd.ctct.ws+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.cups-pdf": {
                    source: "iana",
                },
                "application/vnd.cups-postscript": {
                    source: "iana",
                },
                "application/vnd.cups-ppd": {
                    source: "iana",
                    extensions: ["ppd"],
                },
                "application/vnd.cups-raster": {
                    source: "iana",
                },
                "application/vnd.cups-raw": {
                    source: "iana",
                },
                "application/vnd.curl": {
                    source: "iana",
                },
                "application/vnd.curl.car": {
                    source: "apache",
                    extensions: ["car"],
                },
                "application/vnd.curl.pcurl": {
                    source: "apache",
                    extensions: ["pcurl"],
                },
                "application/vnd.cyan.dean.root+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.cybank": {
                    source: "iana",
                },
                "application/vnd.d2l.coursepackage1p0+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.dart": {
                    source: "iana",
                    compressible: true,
                    extensions: ["dart"],
                },
                "application/vnd.data-vision.rdz": {
                    source: "iana",
                    extensions: ["rdz"],
                },
                "application/vnd.datapackage+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dataresource+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dbf": {
                    source: "iana",
                },
                "application/vnd.debian.binary-package": {
                    source: "iana",
                },
                "application/vnd.dece.data": {
                    source: "iana",
                    extensions: ["uvf", "uvvf", "uvd", "uvvd"],
                },
                "application/vnd.dece.ttml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["uvt", "uvvt"],
                },
                "application/vnd.dece.unspecified": {
                    source: "iana",
                    extensions: ["uvx", "uvvx"],
                },
                "application/vnd.dece.zip": {
                    source: "iana",
                    extensions: ["uvz", "uvvz"],
                },
                "application/vnd.denovo.fcselayout-link": {
                    source: "iana",
                    extensions: ["fe_launch"],
                },
                "application/vnd.desmume.movie": {
                    source: "iana",
                },
                "application/vnd.dir-bi.plate-dl-nosuffix": {
                    source: "iana",
                },
                "application/vnd.dm.delegation+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dna": {
                    source: "iana",
                    extensions: ["dna"],
                },
                "application/vnd.document+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dolby.mlp": {
                    source: "apache",
                    extensions: ["mlp"],
                },
                "application/vnd.dolby.mobile.1": {
                    source: "iana",
                },
                "application/vnd.dolby.mobile.2": {
                    source: "iana",
                },
                "application/vnd.doremir.scorecloud-binary-document": {
                    source: "iana",
                },
                "application/vnd.dpgraph": {
                    source: "iana",
                    extensions: ["dpg"],
                },
                "application/vnd.dreamfactory": {
                    source: "iana",
                    extensions: ["dfac"],
                },
                "application/vnd.drive+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ds-keypoint": {
                    source: "apache",
                    extensions: ["kpxx"],
                },
                "application/vnd.dtg.local": {
                    source: "iana",
                },
                "application/vnd.dtg.local.flash": {
                    source: "iana",
                },
                "application/vnd.dtg.local.html": {
                    source: "iana",
                },
                "application/vnd.dvb.ait": {
                    source: "iana",
                    extensions: ["ait"],
                },
                "application/vnd.dvb.dvbisl+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dvb.dvbj": {
                    source: "iana",
                },
                "application/vnd.dvb.esgcontainer": {
                    source: "iana",
                },
                "application/vnd.dvb.ipdcdftnotifaccess": {
                    source: "iana",
                },
                "application/vnd.dvb.ipdcesgaccess": {
                    source: "iana",
                },
                "application/vnd.dvb.ipdcesgaccess2": {
                    source: "iana",
                },
                "application/vnd.dvb.ipdcesgpdd": {
                    source: "iana",
                },
                "application/vnd.dvb.ipdcroaming": {
                    source: "iana",
                },
                "application/vnd.dvb.iptv.alfec-base": {
                    source: "iana",
                },
                "application/vnd.dvb.iptv.alfec-enhancement": {
                    source: "iana",
                },
                "application/vnd.dvb.notif-aggregate-root+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dvb.notif-container+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dvb.notif-generic+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dvb.notif-ia-msglist+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dvb.notif-ia-registration-request+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dvb.notif-ia-registration-response+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dvb.notif-init+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.dvb.pfr": {
                    source: "iana",
                },
                "application/vnd.dvb.service": {
                    source: "iana",
                    extensions: ["svc"],
                },
                "application/vnd.dxr": {
                    source: "iana",
                },
                "application/vnd.dynageo": {
                    source: "iana",
                    extensions: ["geo"],
                },
                "application/vnd.dzr": {
                    source: "iana",
                },
                "application/vnd.easykaraoke.cdgdownload": {
                    source: "iana",
                },
                "application/vnd.ecdis-update": {
                    source: "iana",
                },
                "application/vnd.ecip.rlp": {
                    source: "iana",
                },
                "application/vnd.ecowin.chart": {
                    source: "iana",
                    extensions: ["mag"],
                },
                "application/vnd.ecowin.filerequest": {
                    source: "iana",
                },
                "application/vnd.ecowin.fileupdate": {
                    source: "iana",
                },
                "application/vnd.ecowin.series": {
                    source: "iana",
                },
                "application/vnd.ecowin.seriesrequest": {
                    source: "iana",
                },
                "application/vnd.ecowin.seriesupdate": {
                    source: "iana",
                },
                "application/vnd.efi.img": {
                    source: "iana",
                },
                "application/vnd.efi.iso": {
                    source: "iana",
                },
                "application/vnd.emclient.accessrequest+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.enliven": {
                    source: "iana",
                    extensions: ["nml"],
                },
                "application/vnd.enphase.envoy": {
                    source: "iana",
                },
                "application/vnd.eprints.data+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.epson.esf": {
                    source: "iana",
                    extensions: ["esf"],
                },
                "application/vnd.epson.msf": {
                    source: "iana",
                    extensions: ["msf"],
                },
                "application/vnd.epson.quickanime": {
                    source: "iana",
                    extensions: ["qam"],
                },
                "application/vnd.epson.salt": {
                    source: "iana",
                    extensions: ["slt"],
                },
                "application/vnd.epson.ssf": {
                    source: "iana",
                    extensions: ["ssf"],
                },
                "application/vnd.ericsson.quickcall": {
                    source: "iana",
                },
                "application/vnd.espass-espass+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.eszigno3+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["es3", "et3"],
                },
                "application/vnd.etsi.aoc+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.asic-e+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.etsi.asic-s+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.etsi.cug+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.iptvcommand+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.iptvdiscovery+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.iptvprofile+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.iptvsad-bc+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.iptvsad-cod+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.iptvsad-npvr+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.iptvservice+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.iptvsync+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.iptvueprofile+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.mcid+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.mheg5": {
                    source: "iana",
                },
                "application/vnd.etsi.overload-control-policy-dataset+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.pstn+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.sci+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.simservs+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.timestamp-token": {
                    source: "iana",
                },
                "application/vnd.etsi.tsl+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.etsi.tsl.der": {
                    source: "iana",
                },
                "application/vnd.eudora.data": {
                    source: "iana",
                },
                "application/vnd.evolv.ecig.profile": {
                    source: "iana",
                },
                "application/vnd.evolv.ecig.settings": {
                    source: "iana",
                },
                "application/vnd.evolv.ecig.theme": {
                    source: "iana",
                },
                "application/vnd.exstream-empower+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.exstream-package": {
                    source: "iana",
                },
                "application/vnd.ezpix-album": {
                    source: "iana",
                    extensions: ["ez2"],
                },
                "application/vnd.ezpix-package": {
                    source: "iana",
                    extensions: ["ez3"],
                },
                "application/vnd.f-secure.mobile": {
                    source: "iana",
                },
                "application/vnd.fastcopy-disk-image": {
                    source: "iana",
                },
                "application/vnd.fdf": {
                    source: "iana",
                    extensions: ["fdf"],
                },
                "application/vnd.fdsn.mseed": {
                    source: "iana",
                    extensions: ["mseed"],
                },
                "application/vnd.fdsn.seed": {
                    source: "iana",
                    extensions: ["seed", "dataless"],
                },
                "application/vnd.ffsns": {
                    source: "iana",
                },
                "application/vnd.ficlab.flb+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.filmit.zfc": {
                    source: "iana",
                },
                "application/vnd.fints": {
                    source: "iana",
                },
                "application/vnd.firemonkeys.cloudcell": {
                    source: "iana",
                },
                "application/vnd.flographit": {
                    source: "iana",
                    extensions: ["gph"],
                },
                "application/vnd.fluxtime.clip": {
                    source: "iana",
                    extensions: ["ftc"],
                },
                "application/vnd.font-fontforge-sfd": {
                    source: "iana",
                },
                "application/vnd.framemaker": {
                    source: "iana",
                    extensions: ["fm", "frame", "maker", "book"],
                },
                "application/vnd.frogans.fnc": {
                    source: "iana",
                    extensions: ["fnc"],
                },
                "application/vnd.frogans.ltf": {
                    source: "iana",
                    extensions: ["ltf"],
                },
                "application/vnd.fsc.weblaunch": {
                    source: "iana",
                    extensions: ["fsc"],
                },
                "application/vnd.fujitsu.oasys": {
                    source: "iana",
                    extensions: ["oas"],
                },
                "application/vnd.fujitsu.oasys2": {
                    source: "iana",
                    extensions: ["oa2"],
                },
                "application/vnd.fujitsu.oasys3": {
                    source: "iana",
                    extensions: ["oa3"],
                },
                "application/vnd.fujitsu.oasysgp": {
                    source: "iana",
                    extensions: ["fg5"],
                },
                "application/vnd.fujitsu.oasysprs": {
                    source: "iana",
                    extensions: ["bh2"],
                },
                "application/vnd.fujixerox.art-ex": {
                    source: "iana",
                },
                "application/vnd.fujixerox.art4": {
                    source: "iana",
                },
                "application/vnd.fujixerox.ddd": {
                    source: "iana",
                    extensions: ["ddd"],
                },
                "application/vnd.fujixerox.docuworks": {
                    source: "iana",
                    extensions: ["xdw"],
                },
                "application/vnd.fujixerox.docuworks.binder": {
                    source: "iana",
                    extensions: ["xbd"],
                },
                "application/vnd.fujixerox.docuworks.container": {
                    source: "iana",
                },
                "application/vnd.fujixerox.hbpl": {
                    source: "iana",
                },
                "application/vnd.fut-misnet": {
                    source: "iana",
                },
                "application/vnd.futoin+cbor": {
                    source: "iana",
                },
                "application/vnd.futoin+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.fuzzysheet": {
                    source: "iana",
                    extensions: ["fzs"],
                },
                "application/vnd.genomatix.tuxedo": {
                    source: "iana",
                    extensions: ["txd"],
                },
                "application/vnd.gentics.grd+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.geo+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.geocube+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.geogebra.file": {
                    source: "iana",
                    extensions: ["ggb"],
                },
                "application/vnd.geogebra.tool": {
                    source: "iana",
                    extensions: ["ggt"],
                },
                "application/vnd.geometry-explorer": {
                    source: "iana",
                    extensions: ["gex", "gre"],
                },
                "application/vnd.geonext": {
                    source: "iana",
                    extensions: ["gxt"],
                },
                "application/vnd.geoplan": {
                    source: "iana",
                    extensions: ["g2w"],
                },
                "application/vnd.geospace": {
                    source: "iana",
                    extensions: ["g3w"],
                },
                "application/vnd.gerber": {
                    source: "iana",
                },
                "application/vnd.globalplatform.card-content-mgt": {
                    source: "iana",
                },
                "application/vnd.globalplatform.card-content-mgt-response": {
                    source: "iana",
                },
                "application/vnd.gmx": {
                    source: "iana",
                    extensions: ["gmx"],
                },
                "application/vnd.google-apps.document": {
                    compressible: false,
                    extensions: ["gdoc"],
                },
                "application/vnd.google-apps.presentation": {
                    compressible: false,
                    extensions: ["gslides"],
                },
                "application/vnd.google-apps.spreadsheet": {
                    compressible: false,
                    extensions: ["gsheet"],
                },
                "application/vnd.google-earth.kml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["kml"],
                },
                "application/vnd.google-earth.kmz": {
                    source: "iana",
                    compressible: false,
                    extensions: ["kmz"],
                },
                "application/vnd.gov.sk.e-form+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.gov.sk.e-form+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.gov.sk.xmldatacontainer+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.grafeq": {
                    source: "iana",
                    extensions: ["gqf", "gqs"],
                },
                "application/vnd.gridmp": {
                    source: "iana",
                },
                "application/vnd.groove-account": {
                    source: "iana",
                    extensions: ["gac"],
                },
                "application/vnd.groove-help": {
                    source: "iana",
                    extensions: ["ghf"],
                },
                "application/vnd.groove-identity-message": {
                    source: "iana",
                    extensions: ["gim"],
                },
                "application/vnd.groove-injector": {
                    source: "iana",
                    extensions: ["grv"],
                },
                "application/vnd.groove-tool-message": {
                    source: "iana",
                    extensions: ["gtm"],
                },
                "application/vnd.groove-tool-template": {
                    source: "iana",
                    extensions: ["tpl"],
                },
                "application/vnd.groove-vcard": {
                    source: "iana",
                    extensions: ["vcg"],
                },
                "application/vnd.hal+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.hal+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["hal"],
                },
                "application/vnd.handheld-entertainment+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["zmm"],
                },
                "application/vnd.hbci": {
                    source: "iana",
                    extensions: ["hbci"],
                },
                "application/vnd.hc+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.hcl-bireports": {
                    source: "iana",
                },
                "application/vnd.hdt": {
                    source: "iana",
                },
                "application/vnd.heroku+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.hhe.lesson-player": {
                    source: "iana",
                    extensions: ["les"],
                },
                "application/vnd.hp-hpgl": {
                    source: "iana",
                    extensions: ["hpgl"],
                },
                "application/vnd.hp-hpid": {
                    source: "iana",
                    extensions: ["hpid"],
                },
                "application/vnd.hp-hps": {
                    source: "iana",
                    extensions: ["hps"],
                },
                "application/vnd.hp-jlyt": {
                    source: "iana",
                    extensions: ["jlt"],
                },
                "application/vnd.hp-pcl": {
                    source: "iana",
                    extensions: ["pcl"],
                },
                "application/vnd.hp-pclxl": {
                    source: "iana",
                    extensions: ["pclxl"],
                },
                "application/vnd.httphone": {
                    source: "iana",
                },
                "application/vnd.hydrostatix.sof-data": {
                    source: "iana",
                    extensions: ["sfd-hdstx"],
                },
                "application/vnd.hyper+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.hyper-item+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.hyperdrive+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.hzn-3d-crossword": {
                    source: "iana",
                },
                "application/vnd.ibm.afplinedata": {
                    source: "iana",
                },
                "application/vnd.ibm.electronic-media": {
                    source: "iana",
                },
                "application/vnd.ibm.minipay": {
                    source: "iana",
                    extensions: ["mpy"],
                },
                "application/vnd.ibm.modcap": {
                    source: "iana",
                    extensions: ["afp", "listafp", "list3820"],
                },
                "application/vnd.ibm.rights-management": {
                    source: "iana",
                    extensions: ["irm"],
                },
                "application/vnd.ibm.secure-container": {
                    source: "iana",
                    extensions: ["sc"],
                },
                "application/vnd.iccprofile": {
                    source: "iana",
                    extensions: ["icc", "icm"],
                },
                "application/vnd.ieee.1905": {
                    source: "iana",
                },
                "application/vnd.igloader": {
                    source: "iana",
                    extensions: ["igl"],
                },
                "application/vnd.imagemeter.folder+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.imagemeter.image+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.immervision-ivp": {
                    source: "iana",
                    extensions: ["ivp"],
                },
                "application/vnd.immervision-ivu": {
                    source: "iana",
                    extensions: ["ivu"],
                },
                "application/vnd.ims.imsccv1p1": {
                    source: "iana",
                },
                "application/vnd.ims.imsccv1p2": {
                    source: "iana",
                },
                "application/vnd.ims.imsccv1p3": {
                    source: "iana",
                },
                "application/vnd.ims.lis.v2.result+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ims.lti.v2.toolproxy+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ims.lti.v2.toolproxy.id+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ims.lti.v2.toolsettings+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ims.lti.v2.toolsettings.simple+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.informedcontrol.rms+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.informix-visionary": {
                    source: "iana",
                },
                "application/vnd.infotech.project": {
                    source: "iana",
                },
                "application/vnd.infotech.project+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.innopath.wamp.notification": {
                    source: "iana",
                },
                "application/vnd.insors.igm": {
                    source: "iana",
                    extensions: ["igm"],
                },
                "application/vnd.intercon.formnet": {
                    source: "iana",
                    extensions: ["xpw", "xpx"],
                },
                "application/vnd.intergeo": {
                    source: "iana",
                    extensions: ["i2g"],
                },
                "application/vnd.intertrust.digibox": {
                    source: "iana",
                },
                "application/vnd.intertrust.nncp": {
                    source: "iana",
                },
                "application/vnd.intu.qbo": {
                    source: "iana",
                    extensions: ["qbo"],
                },
                "application/vnd.intu.qfx": {
                    source: "iana",
                    extensions: ["qfx"],
                },
                "application/vnd.iptc.g2.catalogitem+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.iptc.g2.conceptitem+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.iptc.g2.knowledgeitem+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.iptc.g2.newsitem+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.iptc.g2.newsmessage+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.iptc.g2.packageitem+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.iptc.g2.planningitem+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ipunplugged.rcprofile": {
                    source: "iana",
                    extensions: ["rcprofile"],
                },
                "application/vnd.irepository.package+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["irp"],
                },
                "application/vnd.is-xpr": {
                    source: "iana",
                    extensions: ["xpr"],
                },
                "application/vnd.isac.fcs": {
                    source: "iana",
                    extensions: ["fcs"],
                },
                "application/vnd.iso11783-10+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.jam": {
                    source: "iana",
                    extensions: ["jam"],
                },
                "application/vnd.japannet-directory-service": {
                    source: "iana",
                },
                "application/vnd.japannet-jpnstore-wakeup": {
                    source: "iana",
                },
                "application/vnd.japannet-payment-wakeup": {
                    source: "iana",
                },
                "application/vnd.japannet-registration": {
                    source: "iana",
                },
                "application/vnd.japannet-registration-wakeup": {
                    source: "iana",
                },
                "application/vnd.japannet-setstore-wakeup": {
                    source: "iana",
                },
                "application/vnd.japannet-verification": {
                    source: "iana",
                },
                "application/vnd.japannet-verification-wakeup": {
                    source: "iana",
                },
                "application/vnd.jcp.javame.midlet-rms": {
                    source: "iana",
                    extensions: ["rms"],
                },
                "application/vnd.jisp": {
                    source: "iana",
                    extensions: ["jisp"],
                },
                "application/vnd.joost.joda-archive": {
                    source: "iana",
                    extensions: ["joda"],
                },
                "application/vnd.jsk.isdn-ngn": {
                    source: "iana",
                },
                "application/vnd.kahootz": {
                    source: "iana",
                    extensions: ["ktz", "ktr"],
                },
                "application/vnd.kde.karbon": {
                    source: "iana",
                    extensions: ["karbon"],
                },
                "application/vnd.kde.kchart": {
                    source: "iana",
                    extensions: ["chrt"],
                },
                "application/vnd.kde.kformula": {
                    source: "iana",
                    extensions: ["kfo"],
                },
                "application/vnd.kde.kivio": {
                    source: "iana",
                    extensions: ["flw"],
                },
                "application/vnd.kde.kontour": {
                    source: "iana",
                    extensions: ["kon"],
                },
                "application/vnd.kde.kpresenter": {
                    source: "iana",
                    extensions: ["kpr", "kpt"],
                },
                "application/vnd.kde.kspread": {
                    source: "iana",
                    extensions: ["ksp"],
                },
                "application/vnd.kde.kword": {
                    source: "iana",
                    extensions: ["kwd", "kwt"],
                },
                "application/vnd.kenameaapp": {
                    source: "iana",
                    extensions: ["htke"],
                },
                "application/vnd.kidspiration": {
                    source: "iana",
                    extensions: ["kia"],
                },
                "application/vnd.kinar": {
                    source: "iana",
                    extensions: ["kne", "knp"],
                },
                "application/vnd.koan": {
                    source: "iana",
                    extensions: ["skp", "skd", "skt", "skm"],
                },
                "application/vnd.kodak-descriptor": {
                    source: "iana",
                    extensions: ["sse"],
                },
                "application/vnd.las": {
                    source: "iana",
                },
                "application/vnd.las.las+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.las.las+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["lasxml"],
                },
                "application/vnd.laszip": {
                    source: "iana",
                },
                "application/vnd.leap+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.liberty-request+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.llamagraphics.life-balance.desktop": {
                    source: "iana",
                    extensions: ["lbd"],
                },
                "application/vnd.llamagraphics.life-balance.exchange+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["lbe"],
                },
                "application/vnd.logipipe.circuit+zip": {
                    source: "iana",
                    compressible: false,
                },
                "application/vnd.loom": {
                    source: "iana",
                },
                "application/vnd.lotus-1-2-3": {
                    source: "iana",
                    extensions: ["123"],
                },
                "application/vnd.lotus-approach": {
                    source: "iana",
                    extensions: ["apr"],
                },
                "application/vnd.lotus-freelance": {
                    source: "iana",
                    extensions: ["pre"],
                },
                "application/vnd.lotus-notes": {
                    source: "iana",
                    extensions: ["nsf"],
                },
                "application/vnd.lotus-organizer": {
                    source: "iana",
                    extensions: ["org"],
                },
                "application/vnd.lotus-screencam": {
                    source: "iana",
                    extensions: ["scm"],
                },
                "application/vnd.lotus-wordpro": {
                    source: "iana",
                    extensions: ["lwp"],
                },
                "application/vnd.macports.portpkg": {
                    source: "iana",
                    extensions: ["portpkg"],
                },
                "application/vnd.mapbox-vector-tile": {
                    source: "iana",
                },
                "application/vnd.marlin.drm.actiontoken+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.marlin.drm.conftoken+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.marlin.drm.license+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.marlin.drm.mdcf": {
                    source: "iana",
                },
                "application/vnd.mason+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.maxmind.maxmind-db": {
                    source: "iana",
                },
                "application/vnd.mcd": {
                    source: "iana",
                    extensions: ["mcd"],
                },
                "application/vnd.medcalcdata": {
                    source: "iana",
                    extensions: ["mc1"],
                },
                "application/vnd.mediastation.cdkey": {
                    source: "iana",
                    extensions: ["cdkey"],
                },
                "application/vnd.meridian-slingshot": {
                    source: "iana",
                },
                "application/vnd.mfer": {
                    source: "iana",
                    extensions: ["mwf"],
                },
                "application/vnd.mfmp": {
                    source: "iana",
                    extensions: ["mfm"],
                },
                "application/vnd.micro+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.micrografx.flo": {
                    source: "iana",
                    extensions: ["flo"],
                },
                "application/vnd.micrografx.igx": {
                    source: "iana",
                    extensions: ["igx"],
                },
                "application/vnd.microsoft.portable-executable": {
                    source: "iana",
                },
                "application/vnd.microsoft.windows.thumbnail-cache": {
                    source: "iana",
                },
                "application/vnd.miele+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.mif": {
                    source: "iana",
                    extensions: ["mif"],
                },
                "application/vnd.minisoft-hp3000-save": {
                    source: "iana",
                },
                "application/vnd.mitsubishi.misty-guard.trustweb": {
                    source: "iana",
                },
                "application/vnd.mobius.daf": {
                    source: "iana",
                    extensions: ["daf"],
                },
                "application/vnd.mobius.dis": {
                    source: "iana",
                    extensions: ["dis"],
                },
                "application/vnd.mobius.mbk": {
                    source: "iana",
                    extensions: ["mbk"],
                },
                "application/vnd.mobius.mqy": {
                    source: "iana",
                    extensions: ["mqy"],
                },
                "application/vnd.mobius.msl": {
                    source: "iana",
                    extensions: ["msl"],
                },
                "application/vnd.mobius.plc": {
                    source: "iana",
                    extensions: ["plc"],
                },
                "application/vnd.mobius.txf": {
                    source: "iana",
                    extensions: ["txf"],
                },
                "application/vnd.mophun.application": {
                    source: "iana",
                    extensions: ["mpn"],
                },
                "application/vnd.mophun.certificate": {
                    source: "iana",
                    extensions: ["mpc"],
                },
                "application/vnd.motorola.flexsuite": {
                    source: "iana",
                },
                "application/vnd.motorola.flexsuite.adsi": {
                    source: "iana",
                },
                "application/vnd.motorola.flexsuite.fis": {
                    source: "iana",
                },
                "application/vnd.motorola.flexsuite.gotap": {
                    source: "iana",
                },
                "application/vnd.motorola.flexsuite.kmr": {
                    source: "iana",
                },
                "application/vnd.motorola.flexsuite.ttc": {
                    source: "iana",
                },
                "application/vnd.motorola.flexsuite.wem": {
                    source: "iana",
                },
                "application/vnd.motorola.iprm": {
                    source: "iana",
                },
                "application/vnd.mozilla.xul+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xul"],
                },
                "application/vnd.ms-3mfdocument": {
                    source: "iana",
                },
                "application/vnd.ms-artgalry": {
                    source: "iana",
                    extensions: ["cil"],
                },
                "application/vnd.ms-asf": {
                    source: "iana",
                },
                "application/vnd.ms-cab-compressed": {
                    source: "iana",
                    extensions: ["cab"],
                },
                "application/vnd.ms-color.iccprofile": {
                    source: "apache",
                },
                "application/vnd.ms-excel": {
                    source: "iana",
                    compressible: false,
                    extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"],
                },
                "application/vnd.ms-excel.addin.macroenabled.12": {
                    source: "iana",
                    extensions: ["xlam"],
                },
                "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
                    source: "iana",
                    extensions: ["xlsb"],
                },
                "application/vnd.ms-excel.sheet.macroenabled.12": {
                    source: "iana",
                    extensions: ["xlsm"],
                },
                "application/vnd.ms-excel.template.macroenabled.12": {
                    source: "iana",
                    extensions: ["xltm"],
                },
                "application/vnd.ms-fontobject": {
                    source: "iana",
                    compressible: true,
                    extensions: ["eot"],
                },
                "application/vnd.ms-htmlhelp": {
                    source: "iana",
                    extensions: ["chm"],
                },
                "application/vnd.ms-ims": {
                    source: "iana",
                    extensions: ["ims"],
                },
                "application/vnd.ms-lrm": {
                    source: "iana",
                    extensions: ["lrm"],
                },
                "application/vnd.ms-office.activex+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ms-officetheme": {
                    source: "iana",
                    extensions: ["thmx"],
                },
                "application/vnd.ms-opentype": {
                    source: "apache",
                    compressible: true,
                },
                "application/vnd.ms-outlook": {
                    compressible: false,
                    extensions: ["msg"],
                },
                "application/vnd.ms-package.obfuscated-opentype": {
                    source: "apache",
                },
                "application/vnd.ms-pki.seccat": {
                    source: "apache",
                    extensions: ["cat"],
                },
                "application/vnd.ms-pki.stl": {
                    source: "apache",
                    extensions: ["stl"],
                },
                "application/vnd.ms-playready.initiator+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ms-powerpoint": {
                    source: "iana",
                    compressible: false,
                    extensions: ["ppt", "pps", "pot"],
                },
                "application/vnd.ms-powerpoint.addin.macroenabled.12": {
                    source: "iana",
                    extensions: ["ppam"],
                },
                "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
                    source: "iana",
                    extensions: ["pptm"],
                },
                "application/vnd.ms-powerpoint.slide.macroenabled.12": {
                    source: "iana",
                    extensions: ["sldm"],
                },
                "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
                    source: "iana",
                    extensions: ["ppsm"],
                },
                "application/vnd.ms-powerpoint.template.macroenabled.12": {
                    source: "iana",
                    extensions: ["potm"],
                },
                "application/vnd.ms-printdevicecapabilities+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ms-printing.printticket+xml": {
                    source: "apache",
                    compressible: true,
                },
                "application/vnd.ms-printschematicket+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.ms-project": {
                    source: "iana",
                    extensions: ["mpp", "mpt"],
                },
                "application/vnd.ms-tnef": {
                    source: "iana",
                },
                "application/vnd.ms-windows.devicepairing": {
                    source: "iana",
                },
                "application/vnd.ms-windows.nwprinting.oob": {
                    source: "iana",
                },
                "application/vnd.ms-windows.printerpairing": {
                    source: "iana",
                },
                "application/vnd.ms-windows.wsd.oob": {
                    source: "iana",
                },
                "application/vnd.ms-wmdrm.lic-chlg-req": {
                    source: "iana",
                },
                "application/vnd.ms-wmdrm.lic-resp": {
                    source: "iana",
                },
                "application/vnd.ms-wmdrm.meter-chlg-req": {
                    source: "iana",
                },
                "application/vnd.ms-wmdrm.meter-resp": {
                    source: "iana",
                },
                "application/vnd.ms-word.document.macroenabled.12": {
                    source: "iana",
                    extensions: ["docm"],
                },
                "application/vnd.ms-word.template.macroenabled.12": {
                    source: "iana",
                    extensions: ["dotm"],
                },
                "application/vnd.ms-works": {
                    source: "iana",
                    extensions: ["wps", "wks", "wcm", "wdb"],
                },
                "application/vnd.ms-wpl": {
                    source: "iana",
                    extensions: ["wpl"],
                },
                "application/vnd.ms-xpsdocument": {
                    source: "iana",
                    compressible: false,
                    extensions: ["xps"],
                },
                "application/vnd.msa-disk-image": {
                    source: "iana",
                },
                "application/vnd.mseq": {
                    source: "iana",
                    extensions: ["mseq"],
                },
                "application/vnd.msign": {
                    source: "iana",
                },
                "application/vnd.multiad.creator": {
                    source: "iana",
                },
                "application/vnd.multiad.creator.cif": {
                    source: "iana",
                },
                "application/vnd.music-niff": {
                    source: "iana",
                },
                "application/vnd.musician": {
                    source: "iana",
                    extensions: ["mus"],
                },
                "application/vnd.muvee.style": {
                    source: "iana",
                    extensions: ["msty"],
                },
                "application/vnd.mynfc": {
                    source: "iana",
                    extensions: ["taglet"],
                },
                "application/vnd.ncd.control": {
                    source: "iana",
                },
                "application/vnd.ncd.reference": {
                    source: "iana",
                },
                "application/vnd.nearst.inv+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.nervana": {
                    source: "iana",
                },
                "application/vnd.netfpx": {
                    source: "iana",
                },
                "application/vnd.neurolanguage.nlu": {
                    source: "iana",
                    extensions: ["nlu"],
                },
                "application/vnd.nimn": {
                    source: "iana",
                },
                "application/vnd.nintendo.nitro.rom": {
                    source: "iana",
                },
                "application/vnd.nintendo.snes.rom": {
                    source: "iana",
                },
                "application/vnd.nitf": {
                    source: "iana",
                    extensions: ["ntf", "nitf"],
                },
                "application/vnd.noblenet-directory": {
                    source: "iana",
                    extensions: ["nnd"],
                },
                "application/vnd.noblenet-sealer": {
                    source: "iana",
                    extensions: ["nns"],
                },
                "application/vnd.noblenet-web": {
                    source: "iana",
                    extensions: ["nnw"],
                },
                "application/vnd.nokia.catalogs": {
                    source: "iana",
                },
                "application/vnd.nokia.conml+wbxml": {
                    source: "iana",
                },
                "application/vnd.nokia.conml+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.nokia.iptv.config+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.nokia.isds-radio-presets": {
                    source: "iana",
                },
                "application/vnd.nokia.landmark+wbxml": {
                    source: "iana",
                },
                "application/vnd.nokia.landmark+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.nokia.landmarkcollection+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.nokia.n-gage.ac+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["ac"],
                },
                "application/vnd.nokia.n-gage.data": {
                    source: "iana",
                    extensions: ["ngdat"],
                },
                "application/vnd.nokia.n-gage.symbian.install": {
                    source: "iana",
                    extensions: ["n-gage"],
                },
                "application/vnd.nokia.ncd": {
                    source: "iana",
                },
                "application/vnd.nokia.pcd+wbxml": {
                    source: "iana",
                },
                "application/vnd.nokia.pcd+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.nokia.radio-preset": {
                    source: "iana",
                    extensions: ["rpst"],
                },
                "application/vnd.nokia.radio-presets": {
                    source: "iana",
                    extensions: ["rpss"],
                },
                "application/vnd.novadigm.edm": {
                    source: "iana",
                    extensions: ["edm"],
                },
                "application/vnd.novadigm.edx": {
                    source: "iana",
                    extensions: ["edx"],
                },
                "application/vnd.novadigm.ext": {
                    source: "iana",
                    extensions: ["ext"],
                },
                "application/vnd.ntt-local.content-share": {
                    source: "iana",
                },
                "application/vnd.ntt-local.file-transfer": {
                    source: "iana",
                },
                "application/vnd.ntt-local.ogw_remote-access": {
                    source: "iana",
                },
                "application/vnd.ntt-local.sip-ta_remote": {
                    source: "iana",
                },
                "application/vnd.ntt-local.sip-ta_tcp_stream": {
                    source: "iana",
                },
                "application/vnd.oasis.opendocument.chart": {
                    source: "iana",
                    extensions: ["odc"],
                },
                "application/vnd.oasis.opendocument.chart-template": {
                    source: "iana",
                    extensions: ["otc"],
                },
                "application/vnd.oasis.opendocument.database": {
                    source: "iana",
                    extensions: ["odb"],
                },
                "application/vnd.oasis.opendocument.formula": {
                    source: "iana",
                    extensions: ["odf"],
                },
                "application/vnd.oasis.opendocument.formula-template": {
                    source: "iana",
                    extensions: ["odft"],
                },
                "application/vnd.oasis.opendocument.graphics": {
                    source: "iana",
                    compressible: false,
                    extensions: ["odg"],
                },
                "application/vnd.oasis.opendocument.graphics-template": {
                    source: "iana",
                    extensions: ["otg"],
                },
                "application/vnd.oasis.opendocument.image": {
                    source: "iana",
                    extensions: ["odi"],
                },
                "application/vnd.oasis.opendocument.image-template": {
                    source: "iana",
                    extensions: ["oti"],
                },
                "application/vnd.oasis.opendocument.presentation": {
                    source: "iana",
                    compressible: false,
                    extensions: ["odp"],
                },
                "application/vnd.oasis.opendocument.presentation-template": {
                    source: "iana",
                    extensions: ["otp"],
                },
                "application/vnd.oasis.opendocument.spreadsheet": {
                    source: "iana",
                    compressible: false,
                    extensions: ["ods"],
                },
                "application/vnd.oasis.opendocument.spreadsheet-template": {
                    source: "iana",
                    extensions: ["ots"],
                },
                "application/vnd.oasis.opendocument.text": {
                    source: "iana",
                    compressible: false,
                    extensions: ["odt"],
                },
                "application/vnd.oasis.opendocument.text-master": {
                    source: "iana",
                    extensions: ["odm"],
                },
                "application/vnd.oasis.opendocument.text-template": {
                    source: "iana",
                    extensions: ["ott"],
                },
                "application/vnd.oasis.opendocument.text-web": {
                    source: "iana",
                    extensions: ["oth"],
                },
                "application/vnd.obn": {
                    source: "iana",
                },
                "application/vnd.ocf+cbor": {
                    source: "iana",
                },
                "application/vnd.oci.image.manifest.v1+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oftn.l10n+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oipf.contentaccessdownload+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oipf.contentaccessstreaming+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oipf.cspg-hexbinary": {
                    source: "iana",
                },
                "application/vnd.oipf.dae.svg+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oipf.dae.xhtml+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oipf.mippvcontrolmessage+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oipf.pae.gem": {
                    source: "iana",
                },
                "application/vnd.oipf.spdiscovery+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oipf.spdlist+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oipf.ueprofile+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oipf.userprofile+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.olpc-sugar": {
                    source: "iana",
                    extensions: ["xo"],
                },
                "application/vnd.oma-scws-config": {
                    source: "iana",
                },
                "application/vnd.oma-scws-http-request": {
                    source: "iana",
                },
                "application/vnd.oma-scws-http-response": {
                    source: "iana",
                },
                "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.bcast.drm-trigger+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.bcast.imd+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.bcast.ltkm": {
                    source: "iana",
                },
                "application/vnd.oma.bcast.notification+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.bcast.provisioningtrigger": {
                    source: "iana",
                },
                "application/vnd.oma.bcast.sgboot": {
                    source: "iana",
                },
                "application/vnd.oma.bcast.sgdd+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.bcast.sgdu": {
                    source: "iana",
                },
                "application/vnd.oma.bcast.simple-symbol-container": {
                    source: "iana",
                },
                "application/vnd.oma.bcast.smartcard-trigger+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.bcast.sprov+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.bcast.stkm": {
                    source: "iana",
                },
                "application/vnd.oma.cab-address-book+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.cab-feature-handler+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.cab-pcc+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.cab-subs-invite+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.cab-user-prefs+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.dcd": {
                    source: "iana",
                },
                "application/vnd.oma.dcdc": {
                    source: "iana",
                },
                "application/vnd.oma.dd2+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["dd2"],
                },
                "application/vnd.oma.drm.risd+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.group-usage-list+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.lwm2m+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.lwm2m+tlv": {
                    source: "iana",
                },
                "application/vnd.oma.pal+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.poc.detailed-progress-report+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.poc.final-report+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.poc.groups+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.poc.invocation-descriptor+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.poc.optimized-progress-report+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.push": {
                    source: "iana",
                },
                "application/vnd.oma.scidm.messages+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oma.xcap-directory+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.omads-email+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/vnd.omads-file+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/vnd.omads-folder+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/vnd.omaloc-supl-init": {
                    source: "iana",
                },
                "application/vnd.onepager": {
                    source: "iana",
                },
                "application/vnd.onepagertamp": {
                    source: "iana",
                },
                "application/vnd.onepagertamx": {
                    source: "iana",
                },
                "application/vnd.onepagertat": {
                    source: "iana",
                },
                "application/vnd.onepagertatp": {
                    source: "iana",
                },
                "application/vnd.onepagertatx": {
                    source: "iana",
                },
                "application/vnd.openblox.game+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["obgx"],
                },
                "application/vnd.openblox.game-binary": {
                    source: "iana",
                },
                "application/vnd.openeye.oeb": {
                    source: "iana",
                },
                "application/vnd.openofficeorg.extension": {
                    source: "apache",
                    extensions: ["oxt"],
                },
                "application/vnd.openstreetmap.data+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["osm"],
                },
                "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.drawing+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
                    source: "iana",
                    compressible: false,
                    extensions: ["pptx"],
                },
                "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.slide": {
                    source: "iana",
                    extensions: ["sldx"],
                },
                "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
                    source: "iana",
                    extensions: ["ppsx"],
                },
                "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.template": {
                    source: "iana",
                    extensions: ["potx"],
                },
                "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
                    source: "iana",
                    compressible: false,
                    extensions: ["xlsx"],
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
                    source: "iana",
                    extensions: ["xltx"],
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.theme+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.vmldrawing": {
                    source: "iana",
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
                    source: "iana",
                    compressible: false,
                    extensions: ["docx"],
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
                    source: "iana",
                    extensions: ["dotx"],
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-package.core-properties+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.openxmlformats-package.relationships+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oracle.resource+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.orange.indata": {
                    source: "iana",
                },
                "application/vnd.osa.netdeploy": {
                    source: "iana",
                },
                "application/vnd.osgeo.mapguide.package": {
                    source: "iana",
                    extensions: ["mgp"],
                },
                "application/vnd.osgi.bundle": {
                    source: "iana",
                },
                "application/vnd.osgi.dp": {
                    source: "iana",
                    extensions: ["dp"],
                },
                "application/vnd.osgi.subsystem": {
                    source: "iana",
                    extensions: ["esa"],
                },
                "application/vnd.otps.ct-kip+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.oxli.countgraph": {
                    source: "iana",
                },
                "application/vnd.pagerduty+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.palm": {
                    source: "iana",
                    extensions: ["pdb", "pqa", "oprc"],
                },
                "application/vnd.panoply": {
                    source: "iana",
                },
                "application/vnd.paos.xml": {
                    source: "iana",
                },
                "application/vnd.patentdive": {
                    source: "iana",
                },
                "application/vnd.patientecommsdoc": {
                    source: "iana",
                },
                "application/vnd.pawaafile": {
                    source: "iana",
                    extensions: ["paw"],
                },
                "application/vnd.pcos": {
                    source: "iana",
                },
                "application/vnd.pg.format": {
                    source: "iana",
                    extensions: ["str"],
                },
                "application/vnd.pg.osasli": {
                    source: "iana",
                    extensions: ["ei6"],
                },
                "application/vnd.piaccess.application-licence": {
                    source: "iana",
                },
                "application/vnd.picsel": {
                    source: "iana",
                    extensions: ["efif"],
                },
                "application/vnd.pmi.widget": {
                    source: "iana",
                    extensions: ["wg"],
                },
                "application/vnd.poc.group-advertisement+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.pocketlearn": {
                    source: "iana",
                    extensions: ["plf"],
                },
                "application/vnd.powerbuilder6": {
                    source: "iana",
                    extensions: ["pbd"],
                },
                "application/vnd.powerbuilder6-s": {
                    source: "iana",
                },
                "application/vnd.powerbuilder7": {
                    source: "iana",
                },
                "application/vnd.powerbuilder7-s": {
                    source: "iana",
                },
                "application/vnd.powerbuilder75": {
                    source: "iana",
                },
                "application/vnd.powerbuilder75-s": {
                    source: "iana",
                },
                "application/vnd.preminet": {
                    source: "iana",
                },
                "application/vnd.previewsystems.box": {
                    source: "iana",
                    extensions: ["box"],
                },
                "application/vnd.proteus.magazine": {
                    source: "iana",
                    extensions: ["mgz"],
                },
                "application/vnd.psfs": {
                    source: "iana",
                },
                "application/vnd.publishare-delta-tree": {
                    source: "iana",
                    extensions: ["qps"],
                },
                "application/vnd.pvi.ptid1": {
                    source: "iana",
                    extensions: ["ptid"],
                },
                "application/vnd.pwg-multiplexed": {
                    source: "iana",
                },
                "application/vnd.pwg-xhtml-print+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.qualcomm.brew-app-res": {
                    source: "iana",
                },
                "application/vnd.quarantainenet": {
                    source: "iana",
                },
                "application/vnd.quark.quarkxpress": {
                    source: "iana",
                    extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"],
                },
                "application/vnd.quobject-quoxdocument": {
                    source: "iana",
                },
                "application/vnd.radisys.moml+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-audit+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-audit-conf+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-audit-conn+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-audit-dialog+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-audit-stream+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-conf+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-dialog+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-dialog-base+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-dialog-fax-detect+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-dialog-group+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-dialog-speech+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.radisys.msml-dialog-transform+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.rainstor.data": {
                    source: "iana",
                },
                "application/vnd.rapid": {
                    source: "iana",
                },
                "application/vnd.rar": {
                    source: "iana",
                },
                "application/vnd.realvnc.bed": {
                    source: "iana",
                    extensions: ["bed"],
                },
                "application/vnd.recordare.musicxml": {
                    source: "iana",
                    extensions: ["mxl"],
                },
                "application/vnd.recordare.musicxml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["musicxml"],
                },
                "application/vnd.renlearn.rlprint": {
                    source: "iana",
                },
                "application/vnd.restful+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.rig.cryptonote": {
                    source: "iana",
                    extensions: ["cryptonote"],
                },
                "application/vnd.rim.cod": {
                    source: "apache",
                    extensions: ["cod"],
                },
                "application/vnd.rn-realmedia": {
                    source: "apache",
                    extensions: ["rm"],
                },
                "application/vnd.rn-realmedia-vbr": {
                    source: "apache",
                    extensions: ["rmvb"],
                },
                "application/vnd.route66.link66+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["link66"],
                },
                "application/vnd.rs-274x": {
                    source: "iana",
                },
                "application/vnd.ruckus.download": {
                    source: "iana",
                },
                "application/vnd.s3sms": {
                    source: "iana",
                },
                "application/vnd.sailingtracker.track": {
                    source: "iana",
                    extensions: ["st"],
                },
                "application/vnd.sar": {
                    source: "iana",
                },
                "application/vnd.sbm.cid": {
                    source: "iana",
                },
                "application/vnd.sbm.mid2": {
                    source: "iana",
                },
                "application/vnd.scribus": {
                    source: "iana",
                },
                "application/vnd.sealed.3df": {
                    source: "iana",
                },
                "application/vnd.sealed.csf": {
                    source: "iana",
                },
                "application/vnd.sealed.doc": {
                    source: "iana",
                },
                "application/vnd.sealed.eml": {
                    source: "iana",
                },
                "application/vnd.sealed.mht": {
                    source: "iana",
                },
                "application/vnd.sealed.net": {
                    source: "iana",
                },
                "application/vnd.sealed.ppt": {
                    source: "iana",
                },
                "application/vnd.sealed.tiff": {
                    source: "iana",
                },
                "application/vnd.sealed.xls": {
                    source: "iana",
                },
                "application/vnd.sealedmedia.softseal.html": {
                    source: "iana",
                },
                "application/vnd.sealedmedia.softseal.pdf": {
                    source: "iana",
                },
                "application/vnd.seemail": {
                    source: "iana",
                    extensions: ["see"],
                },
                "application/vnd.sema": {
                    source: "iana",
                    extensions: ["sema"],
                },
                "application/vnd.semd": {
                    source: "iana",
                    extensions: ["semd"],
                },
                "application/vnd.semf": {
                    source: "iana",
                    extensions: ["semf"],
                },
                "application/vnd.shade-save-file": {
                    source: "iana",
                },
                "application/vnd.shana.informed.formdata": {
                    source: "iana",
                    extensions: ["ifm"],
                },
                "application/vnd.shana.informed.formtemplate": {
                    source: "iana",
                    extensions: ["itp"],
                },
                "application/vnd.shana.informed.interchange": {
                    source: "iana",
                    extensions: ["iif"],
                },
                "application/vnd.shana.informed.package": {
                    source: "iana",
                    extensions: ["ipk"],
                },
                "application/vnd.shootproof+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.shopkick+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.shp": {
                    source: "iana",
                },
                "application/vnd.shx": {
                    source: "iana",
                },
                "application/vnd.sigrok.session": {
                    source: "iana",
                },
                "application/vnd.simtech-mindmapper": {
                    source: "iana",
                    extensions: ["twd", "twds"],
                },
                "application/vnd.siren+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.smaf": {
                    source: "iana",
                    extensions: ["mmf"],
                },
                "application/vnd.smart.notebook": {
                    source: "iana",
                },
                "application/vnd.smart.teacher": {
                    source: "iana",
                    extensions: ["teacher"],
                },
                "application/vnd.snesdev-page-table": {
                    source: "iana",
                },
                "application/vnd.software602.filler.form+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["fo"],
                },
                "application/vnd.software602.filler.form-xml-zip": {
                    source: "iana",
                },
                "application/vnd.solent.sdkm+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["sdkm", "sdkd"],
                },
                "application/vnd.spotfire.dxp": {
                    source: "iana",
                    extensions: ["dxp"],
                },
                "application/vnd.spotfire.sfs": {
                    source: "iana",
                    extensions: ["sfs"],
                },
                "application/vnd.sqlite3": {
                    source: "iana",
                },
                "application/vnd.sss-cod": {
                    source: "iana",
                },
                "application/vnd.sss-dtf": {
                    source: "iana",
                },
                "application/vnd.sss-ntf": {
                    source: "iana",
                },
                "application/vnd.stardivision.calc": {
                    source: "apache",
                    extensions: ["sdc"],
                },
                "application/vnd.stardivision.draw": {
                    source: "apache",
                    extensions: ["sda"],
                },
                "application/vnd.stardivision.impress": {
                    source: "apache",
                    extensions: ["sdd"],
                },
                "application/vnd.stardivision.math": {
                    source: "apache",
                    extensions: ["smf"],
                },
                "application/vnd.stardivision.writer": {
                    source: "apache",
                    extensions: ["sdw", "vor"],
                },
                "application/vnd.stardivision.writer-global": {
                    source: "apache",
                    extensions: ["sgl"],
                },
                "application/vnd.stepmania.package": {
                    source: "iana",
                    extensions: ["smzip"],
                },
                "application/vnd.stepmania.stepchart": {
                    source: "iana",
                    extensions: ["sm"],
                },
                "application/vnd.street-stream": {
                    source: "iana",
                },
                "application/vnd.sun.wadl+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["wadl"],
                },
                "application/vnd.sun.xml.calc": {
                    source: "apache",
                    extensions: ["sxc"],
                },
                "application/vnd.sun.xml.calc.template": {
                    source: "apache",
                    extensions: ["stc"],
                },
                "application/vnd.sun.xml.draw": {
                    source: "apache",
                    extensions: ["sxd"],
                },
                "application/vnd.sun.xml.draw.template": {
                    source: "apache",
                    extensions: ["std"],
                },
                "application/vnd.sun.xml.impress": {
                    source: "apache",
                    extensions: ["sxi"],
                },
                "application/vnd.sun.xml.impress.template": {
                    source: "apache",
                    extensions: ["sti"],
                },
                "application/vnd.sun.xml.math": {
                    source: "apache",
                    extensions: ["sxm"],
                },
                "application/vnd.sun.xml.writer": {
                    source: "apache",
                    extensions: ["sxw"],
                },
                "application/vnd.sun.xml.writer.global": {
                    source: "apache",
                    extensions: ["sxg"],
                },
                "application/vnd.sun.xml.writer.template": {
                    source: "apache",
                    extensions: ["stw"],
                },
                "application/vnd.sus-calendar": {
                    source: "iana",
                    extensions: ["sus", "susp"],
                },
                "application/vnd.svd": {
                    source: "iana",
                    extensions: ["svd"],
                },
                "application/vnd.swiftview-ics": {
                    source: "iana",
                },
                "application/vnd.symbian.install": {
                    source: "apache",
                    extensions: ["sis", "sisx"],
                },
                "application/vnd.syncml+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                    extensions: ["xsm"],
                },
                "application/vnd.syncml.dm+wbxml": {
                    source: "iana",
                    charset: "UTF-8",
                    extensions: ["bdm"],
                },
                "application/vnd.syncml.dm+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                    extensions: ["xdm"],
                },
                "application/vnd.syncml.dm.notification": {
                    source: "iana",
                },
                "application/vnd.syncml.dmddf+wbxml": {
                    source: "iana",
                },
                "application/vnd.syncml.dmddf+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                    extensions: ["ddf"],
                },
                "application/vnd.syncml.dmtnds+wbxml": {
                    source: "iana",
                },
                "application/vnd.syncml.dmtnds+xml": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                },
                "application/vnd.syncml.ds.notification": {
                    source: "iana",
                },
                "application/vnd.tableschema+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.tao.intent-module-archive": {
                    source: "iana",
                    extensions: ["tao"],
                },
                "application/vnd.tcpdump.pcap": {
                    source: "iana",
                    extensions: ["pcap", "cap", "dmp"],
                },
                "application/vnd.think-cell.ppttc+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.tmd.mediaflex.api+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.tml": {
                    source: "iana",
                },
                "application/vnd.tmobile-livetv": {
                    source: "iana",
                    extensions: ["tmo"],
                },
                "application/vnd.tri.onesource": {
                    source: "iana",
                },
                "application/vnd.trid.tpt": {
                    source: "iana",
                    extensions: ["tpt"],
                },
                "application/vnd.triscape.mxs": {
                    source: "iana",
                    extensions: ["mxs"],
                },
                "application/vnd.trueapp": {
                    source: "iana",
                    extensions: ["tra"],
                },
                "application/vnd.truedoc": {
                    source: "iana",
                },
                "application/vnd.ubisoft.webplayer": {
                    source: "iana",
                },
                "application/vnd.ufdl": {
                    source: "iana",
                    extensions: ["ufd", "ufdl"],
                },
                "application/vnd.uiq.theme": {
                    source: "iana",
                    extensions: ["utz"],
                },
                "application/vnd.umajin": {
                    source: "iana",
                    extensions: ["umj"],
                },
                "application/vnd.unity": {
                    source: "iana",
                    extensions: ["unityweb"],
                },
                "application/vnd.uoml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["uoml"],
                },
                "application/vnd.uplanet.alert": {
                    source: "iana",
                },
                "application/vnd.uplanet.alert-wbxml": {
                    source: "iana",
                },
                "application/vnd.uplanet.bearer-choice": {
                    source: "iana",
                },
                "application/vnd.uplanet.bearer-choice-wbxml": {
                    source: "iana",
                },
                "application/vnd.uplanet.cacheop": {
                    source: "iana",
                },
                "application/vnd.uplanet.cacheop-wbxml": {
                    source: "iana",
                },
                "application/vnd.uplanet.channel": {
                    source: "iana",
                },
                "application/vnd.uplanet.channel-wbxml": {
                    source: "iana",
                },
                "application/vnd.uplanet.list": {
                    source: "iana",
                },
                "application/vnd.uplanet.list-wbxml": {
                    source: "iana",
                },
                "application/vnd.uplanet.listcmd": {
                    source: "iana",
                },
                "application/vnd.uplanet.listcmd-wbxml": {
                    source: "iana",
                },
                "application/vnd.uplanet.signal": {
                    source: "iana",
                },
                "application/vnd.uri-map": {
                    source: "iana",
                },
                "application/vnd.valve.source.material": {
                    source: "iana",
                },
                "application/vnd.vcx": {
                    source: "iana",
                    extensions: ["vcx"],
                },
                "application/vnd.vd-study": {
                    source: "iana",
                },
                "application/vnd.vectorworks": {
                    source: "iana",
                },
                "application/vnd.vel+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.verimatrix.vcas": {
                    source: "iana",
                },
                "application/vnd.veryant.thin": {
                    source: "iana",
                },
                "application/vnd.ves.encrypted": {
                    source: "iana",
                },
                "application/vnd.vidsoft.vidconference": {
                    source: "iana",
                },
                "application/vnd.visio": {
                    source: "iana",
                    extensions: ["vsd", "vst", "vss", "vsw"],
                },
                "application/vnd.visionary": {
                    source: "iana",
                    extensions: ["vis"],
                },
                "application/vnd.vividence.scriptfile": {
                    source: "iana",
                },
                "application/vnd.vsf": {
                    source: "iana",
                    extensions: ["vsf"],
                },
                "application/vnd.wap.sic": {
                    source: "iana",
                },
                "application/vnd.wap.slc": {
                    source: "iana",
                },
                "application/vnd.wap.wbxml": {
                    source: "iana",
                    charset: "UTF-8",
                    extensions: ["wbxml"],
                },
                "application/vnd.wap.wmlc": {
                    source: "iana",
                    extensions: ["wmlc"],
                },
                "application/vnd.wap.wmlscriptc": {
                    source: "iana",
                    extensions: ["wmlsc"],
                },
                "application/vnd.webturbo": {
                    source: "iana",
                    extensions: ["wtb"],
                },
                "application/vnd.wfa.p2p": {
                    source: "iana",
                },
                "application/vnd.wfa.wsc": {
                    source: "iana",
                },
                "application/vnd.windows.devicepairing": {
                    source: "iana",
                },
                "application/vnd.wmc": {
                    source: "iana",
                },
                "application/vnd.wmf.bootstrap": {
                    source: "iana",
                },
                "application/vnd.wolfram.mathematica": {
                    source: "iana",
                },
                "application/vnd.wolfram.mathematica.package": {
                    source: "iana",
                },
                "application/vnd.wolfram.player": {
                    source: "iana",
                    extensions: ["nbp"],
                },
                "application/vnd.wordperfect": {
                    source: "iana",
                    extensions: ["wpd"],
                },
                "application/vnd.wqd": {
                    source: "iana",
                    extensions: ["wqd"],
                },
                "application/vnd.wrq-hp3000-labelled": {
                    source: "iana",
                },
                "application/vnd.wt.stf": {
                    source: "iana",
                    extensions: ["stf"],
                },
                "application/vnd.wv.csp+wbxml": {
                    source: "iana",
                },
                "application/vnd.wv.csp+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.wv.ssp+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.xacml+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.xara": {
                    source: "iana",
                    extensions: ["xar"],
                },
                "application/vnd.xfdl": {
                    source: "iana",
                    extensions: ["xfdl"],
                },
                "application/vnd.xfdl.webform": {
                    source: "iana",
                },
                "application/vnd.xmi+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/vnd.xmpie.cpkg": {
                    source: "iana",
                },
                "application/vnd.xmpie.dpkg": {
                    source: "iana",
                },
                "application/vnd.xmpie.plan": {
                    source: "iana",
                },
                "application/vnd.xmpie.ppkg": {
                    source: "iana",
                },
                "application/vnd.xmpie.xlim": {
                    source: "iana",
                },
                "application/vnd.yamaha.hv-dic": {
                    source: "iana",
                    extensions: ["hvd"],
                },
                "application/vnd.yamaha.hv-script": {
                    source: "iana",
                    extensions: ["hvs"],
                },
                "application/vnd.yamaha.hv-voice": {
                    source: "iana",
                    extensions: ["hvp"],
                },
                "application/vnd.yamaha.openscoreformat": {
                    source: "iana",
                    extensions: ["osf"],
                },
                "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["osfpvg"],
                },
                "application/vnd.yamaha.remote-setup": {
                    source: "iana",
                },
                "application/vnd.yamaha.smaf-audio": {
                    source: "iana",
                    extensions: ["saf"],
                },
                "application/vnd.yamaha.smaf-phrase": {
                    source: "iana",
                    extensions: ["spf"],
                },
                "application/vnd.yamaha.through-ngn": {
                    source: "iana",
                },
                "application/vnd.yamaha.tunnel-udpencap": {
                    source: "iana",
                },
                "application/vnd.yaoweme": {
                    source: "iana",
                },
                "application/vnd.yellowriver-custom-menu": {
                    source: "iana",
                    extensions: ["cmp"],
                },
                "application/vnd.youtube.yt": {
                    source: "iana",
                },
                "application/vnd.zul": {
                    source: "iana",
                    extensions: ["zir", "zirz"],
                },
                "application/vnd.zzazz.deck+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["zaz"],
                },
                "application/voicexml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["vxml"],
                },
                "application/voucher-cms+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/vq-rtcpxr": {
                    source: "iana",
                },
                "application/wasm": {
                    compressible: true,
                    extensions: ["wasm"],
                },
                "application/watcherinfo+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/webpush-options+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/whoispp-query": {
                    source: "iana",
                },
                "application/whoispp-response": {
                    source: "iana",
                },
                "application/widget": {
                    source: "iana",
                    extensions: ["wgt"],
                },
                "application/winhlp": {
                    source: "apache",
                    extensions: ["hlp"],
                },
                "application/wita": {
                    source: "iana",
                },
                "application/wordperfect5.1": {
                    source: "iana",
                },
                "application/wsdl+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["wsdl"],
                },
                "application/wspolicy+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["wspolicy"],
                },
                "application/x-7z-compressed": {
                    source: "apache",
                    compressible: false,
                    extensions: ["7z"],
                },
                "application/x-abiword": {
                    source: "apache",
                    extensions: ["abw"],
                },
                "application/x-ace-compressed": {
                    source: "apache",
                    extensions: ["ace"],
                },
                "application/x-amf": {
                    source: "apache",
                },
                "application/x-apple-diskimage": {
                    source: "apache",
                    extensions: ["dmg"],
                },
                "application/x-arj": {
                    compressible: false,
                    extensions: ["arj"],
                },
                "application/x-authorware-bin": {
                    source: "apache",
                    extensions: ["aab", "x32", "u32", "vox"],
                },
                "application/x-authorware-map": {
                    source: "apache",
                    extensions: ["aam"],
                },
                "application/x-authorware-seg": {
                    source: "apache",
                    extensions: ["aas"],
                },
                "application/x-bcpio": {
                    source: "apache",
                    extensions: ["bcpio"],
                },
                "application/x-bdoc": {
                    compressible: false,
                    extensions: ["bdoc"],
                },
                "application/x-bittorrent": {
                    source: "apache",
                    extensions: ["torrent"],
                },
                "application/x-blorb": {
                    source: "apache",
                    extensions: ["blb", "blorb"],
                },
                "application/x-bzip": {
                    source: "apache",
                    compressible: false,
                    extensions: ["bz"],
                },
                "application/x-bzip2": {
                    source: "apache",
                    compressible: false,
                    extensions: ["bz2", "boz"],
                },
                "application/x-cbr": {
                    source: "apache",
                    extensions: ["cbr", "cba", "cbt", "cbz", "cb7"],
                },
                "application/x-cdlink": {
                    source: "apache",
                    extensions: ["vcd"],
                },
                "application/x-cfs-compressed": {
                    source: "apache",
                    extensions: ["cfs"],
                },
                "application/x-chat": {
                    source: "apache",
                    extensions: ["chat"],
                },
                "application/x-chess-pgn": {
                    source: "apache",
                    extensions: ["pgn"],
                },
                "application/x-chrome-extension": {
                    extensions: ["crx"],
                },
                "application/x-cocoa": {
                    source: "nginx",
                    extensions: ["cco"],
                },
                "application/x-compress": {
                    source: "apache",
                },
                "application/x-conference": {
                    source: "apache",
                    extensions: ["nsc"],
                },
                "application/x-cpio": {
                    source: "apache",
                    extensions: ["cpio"],
                },
                "application/x-csh": {
                    source: "apache",
                    extensions: ["csh"],
                },
                "application/x-deb": {
                    compressible: false,
                },
                "application/x-debian-package": {
                    source: "apache",
                    extensions: ["deb", "udeb"],
                },
                "application/x-dgc-compressed": {
                    source: "apache",
                    extensions: ["dgc"],
                },
                "application/x-director": {
                    source: "apache",
                    extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"],
                },
                "application/x-doom": {
                    source: "apache",
                    extensions: ["wad"],
                },
                "application/x-dtbncx+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["ncx"],
                },
                "application/x-dtbook+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["dtb"],
                },
                "application/x-dtbresource+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["res"],
                },
                "application/x-dvi": {
                    source: "apache",
                    compressible: false,
                    extensions: ["dvi"],
                },
                "application/x-envoy": {
                    source: "apache",
                    extensions: ["evy"],
                },
                "application/x-eva": {
                    source: "apache",
                    extensions: ["eva"],
                },
                "application/x-font-bdf": {
                    source: "apache",
                    extensions: ["bdf"],
                },
                "application/x-font-dos": {
                    source: "apache",
                },
                "application/x-font-framemaker": {
                    source: "apache",
                },
                "application/x-font-ghostscript": {
                    source: "apache",
                    extensions: ["gsf"],
                },
                "application/x-font-libgrx": {
                    source: "apache",
                },
                "application/x-font-linux-psf": {
                    source: "apache",
                    extensions: ["psf"],
                },
                "application/x-font-pcf": {
                    source: "apache",
                    extensions: ["pcf"],
                },
                "application/x-font-snf": {
                    source: "apache",
                    extensions: ["snf"],
                },
                "application/x-font-speedo": {
                    source: "apache",
                },
                "application/x-font-sunos-news": {
                    source: "apache",
                },
                "application/x-font-type1": {
                    source: "apache",
                    extensions: ["pfa", "pfb", "pfm", "afm"],
                },
                "application/x-font-vfont": {
                    source: "apache",
                },
                "application/x-freearc": {
                    source: "apache",
                    extensions: ["arc"],
                },
                "application/x-futuresplash": {
                    source: "apache",
                    extensions: ["spl"],
                },
                "application/x-gca-compressed": {
                    source: "apache",
                    extensions: ["gca"],
                },
                "application/x-glulx": {
                    source: "apache",
                    extensions: ["ulx"],
                },
                "application/x-gnumeric": {
                    source: "apache",
                    extensions: ["gnumeric"],
                },
                "application/x-gramps-xml": {
                    source: "apache",
                    extensions: ["gramps"],
                },
                "application/x-gtar": {
                    source: "apache",
                    extensions: ["gtar"],
                },
                "application/x-gzip": {
                    source: "apache",
                },
                "application/x-hdf": {
                    source: "apache",
                    extensions: ["hdf"],
                },
                "application/x-httpd-php": {
                    compressible: true,
                    extensions: ["php"],
                },
                "application/x-install-instructions": {
                    source: "apache",
                    extensions: ["install"],
                },
                "application/x-iso9660-image": {
                    source: "apache",
                    extensions: ["iso"],
                },
                "application/x-java-archive-diff": {
                    source: "nginx",
                    extensions: ["jardiff"],
                },
                "application/x-java-jnlp-file": {
                    source: "apache",
                    compressible: false,
                    extensions: ["jnlp"],
                },
                "application/x-javascript": {
                    compressible: true,
                },
                "application/x-keepass2": {
                    extensions: ["kdbx"],
                },
                "application/x-latex": {
                    source: "apache",
                    compressible: false,
                    extensions: ["latex"],
                },
                "application/x-lua-bytecode": {
                    extensions: ["luac"],
                },
                "application/x-lzh-compressed": {
                    source: "apache",
                    extensions: ["lzh", "lha"],
                },
                "application/x-makeself": {
                    source: "nginx",
                    extensions: ["run"],
                },
                "application/x-mie": {
                    source: "apache",
                    extensions: ["mie"],
                },
                "application/x-mobipocket-ebook": {
                    source: "apache",
                    extensions: ["prc", "mobi"],
                },
                "application/x-mpegurl": {
                    compressible: false,
                },
                "application/x-ms-application": {
                    source: "apache",
                    extensions: ["application"],
                },
                "application/x-ms-shortcut": {
                    source: "apache",
                    extensions: ["lnk"],
                },
                "application/x-ms-wmd": {
                    source: "apache",
                    extensions: ["wmd"],
                },
                "application/x-ms-wmz": {
                    source: "apache",
                    extensions: ["wmz"],
                },
                "application/x-ms-xbap": {
                    source: "apache",
                    extensions: ["xbap"],
                },
                "application/x-msaccess": {
                    source: "apache",
                    extensions: ["mdb"],
                },
                "application/x-msbinder": {
                    source: "apache",
                    extensions: ["obd"],
                },
                "application/x-mscardfile": {
                    source: "apache",
                    extensions: ["crd"],
                },
                "application/x-msclip": {
                    source: "apache",
                    extensions: ["clp"],
                },
                "application/x-msdos-program": {
                    extensions: ["exe"],
                },
                "application/x-msdownload": {
                    source: "apache",
                    extensions: ["exe", "dll", "com", "bat", "msi"],
                },
                "application/x-msmediaview": {
                    source: "apache",
                    extensions: ["mvb", "m13", "m14"],
                },
                "application/x-msmetafile": {
                    source: "apache",
                    extensions: ["wmf", "wmz", "emf", "emz"],
                },
                "application/x-msmoney": {
                    source: "apache",
                    extensions: ["mny"],
                },
                "application/x-mspublisher": {
                    source: "apache",
                    extensions: ["pub"],
                },
                "application/x-msschedule": {
                    source: "apache",
                    extensions: ["scd"],
                },
                "application/x-msterminal": {
                    source: "apache",
                    extensions: ["trm"],
                },
                "application/x-mswrite": {
                    source: "apache",
                    extensions: ["wri"],
                },
                "application/x-netcdf": {
                    source: "apache",
                    extensions: ["nc", "cdf"],
                },
                "application/x-ns-proxy-autoconfig": {
                    compressible: true,
                    extensions: ["pac"],
                },
                "application/x-nzb": {
                    source: "apache",
                    extensions: ["nzb"],
                },
                "application/x-perl": {
                    source: "nginx",
                    extensions: ["pl", "pm"],
                },
                "application/x-pilot": {
                    source: "nginx",
                    extensions: ["prc", "pdb"],
                },
                "application/x-pkcs12": {
                    source: "apache",
                    compressible: false,
                    extensions: ["p12", "pfx"],
                },
                "application/x-pkcs7-certificates": {
                    source: "apache",
                    extensions: ["p7b", "spc"],
                },
                "application/x-pkcs7-certreqresp": {
                    source: "apache",
                    extensions: ["p7r"],
                },
                "application/x-pki-message": {
                    source: "iana",
                },
                "application/x-rar-compressed": {
                    source: "apache",
                    compressible: false,
                    extensions: ["rar"],
                },
                "application/x-redhat-package-manager": {
                    source: "nginx",
                    extensions: ["rpm"],
                },
                "application/x-research-info-systems": {
                    source: "apache",
                    extensions: ["ris"],
                },
                "application/x-sea": {
                    source: "nginx",
                    extensions: ["sea"],
                },
                "application/x-sh": {
                    source: "apache",
                    compressible: true,
                    extensions: ["sh"],
                },
                "application/x-shar": {
                    source: "apache",
                    extensions: ["shar"],
                },
                "application/x-shockwave-flash": {
                    source: "apache",
                    compressible: false,
                    extensions: ["swf"],
                },
                "application/x-silverlight-app": {
                    source: "apache",
                    extensions: ["xap"],
                },
                "application/x-sql": {
                    source: "apache",
                    extensions: ["sql"],
                },
                "application/x-stuffit": {
                    source: "apache",
                    compressible: false,
                    extensions: ["sit"],
                },
                "application/x-stuffitx": {
                    source: "apache",
                    extensions: ["sitx"],
                },
                "application/x-subrip": {
                    source: "apache",
                    extensions: ["srt"],
                },
                "application/x-sv4cpio": {
                    source: "apache",
                    extensions: ["sv4cpio"],
                },
                "application/x-sv4crc": {
                    source: "apache",
                    extensions: ["sv4crc"],
                },
                "application/x-t3vm-image": {
                    source: "apache",
                    extensions: ["t3"],
                },
                "application/x-tads": {
                    source: "apache",
                    extensions: ["gam"],
                },
                "application/x-tar": {
                    source: "apache",
                    compressible: true,
                    extensions: ["tar"],
                },
                "application/x-tcl": {
                    source: "apache",
                    extensions: ["tcl", "tk"],
                },
                "application/x-tex": {
                    source: "apache",
                    extensions: ["tex"],
                },
                "application/x-tex-tfm": {
                    source: "apache",
                    extensions: ["tfm"],
                },
                "application/x-texinfo": {
                    source: "apache",
                    extensions: ["texinfo", "texi"],
                },
                "application/x-tgif": {
                    source: "apache",
                    extensions: ["obj"],
                },
                "application/x-ustar": {
                    source: "apache",
                    extensions: ["ustar"],
                },
                "application/x-virtualbox-hdd": {
                    compressible: true,
                    extensions: ["hdd"],
                },
                "application/x-virtualbox-ova": {
                    compressible: true,
                    extensions: ["ova"],
                },
                "application/x-virtualbox-ovf": {
                    compressible: true,
                    extensions: ["ovf"],
                },
                "application/x-virtualbox-vbox": {
                    compressible: true,
                    extensions: ["vbox"],
                },
                "application/x-virtualbox-vbox-extpack": {
                    compressible: false,
                    extensions: ["vbox-extpack"],
                },
                "application/x-virtualbox-vdi": {
                    compressible: true,
                    extensions: ["vdi"],
                },
                "application/x-virtualbox-vhd": {
                    compressible: true,
                    extensions: ["vhd"],
                },
                "application/x-virtualbox-vmdk": {
                    compressible: true,
                    extensions: ["vmdk"],
                },
                "application/x-wais-source": {
                    source: "apache",
                    extensions: ["src"],
                },
                "application/x-web-app-manifest+json": {
                    compressible: true,
                    extensions: ["webapp"],
                },
                "application/x-www-form-urlencoded": {
                    source: "iana",
                    compressible: true,
                },
                "application/x-x509-ca-cert": {
                    source: "iana",
                    extensions: ["der", "crt", "pem"],
                },
                "application/x-x509-ca-ra-cert": {
                    source: "iana",
                },
                "application/x-x509-next-ca-cert": {
                    source: "iana",
                },
                "application/x-xfig": {
                    source: "apache",
                    extensions: ["fig"],
                },
                "application/x-xliff+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["xlf"],
                },
                "application/x-xpinstall": {
                    source: "apache",
                    compressible: false,
                    extensions: ["xpi"],
                },
                "application/x-xz": {
                    source: "apache",
                    extensions: ["xz"],
                },
                "application/x-zmachine": {
                    source: "apache",
                    extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"],
                },
                "application/x400-bp": {
                    source: "iana",
                },
                "application/xacml+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/xaml+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["xaml"],
                },
                "application/xcap-att+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xav"],
                },
                "application/xcap-caps+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xca"],
                },
                "application/xcap-diff+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xdf"],
                },
                "application/xcap-el+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xel"],
                },
                "application/xcap-error+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xer"],
                },
                "application/xcap-ns+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xns"],
                },
                "application/xcon-conference-info+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/xcon-conference-info-diff+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/xenc+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xenc"],
                },
                "application/xhtml+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xhtml", "xht"],
                },
                "application/xhtml-voice+xml": {
                    source: "apache",
                    compressible: true,
                },
                "application/xliff+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xlf"],
                },
                "application/xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xml", "xsl", "xsd", "rng"],
                },
                "application/xml-dtd": {
                    source: "iana",
                    compressible: true,
                    extensions: ["dtd"],
                },
                "application/xml-external-parsed-entity": {
                    source: "iana",
                },
                "application/xml-patch+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/xmpp+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/xop+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xop"],
                },
                "application/xproc+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["xpl"],
                },
                "application/xslt+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xslt"],
                },
                "application/xspf+xml": {
                    source: "apache",
                    compressible: true,
                    extensions: ["xspf"],
                },
                "application/xv+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["mxml", "xhvml", "xvml", "xvm"],
                },
                "application/yang": {
                    source: "iana",
                    extensions: ["yang"],
                },
                "application/yang-data+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/yang-data+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/yang-patch+json": {
                    source: "iana",
                    compressible: true,
                },
                "application/yang-patch+xml": {
                    source: "iana",
                    compressible: true,
                },
                "application/yin+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["yin"],
                },
                "application/zip": {
                    source: "iana",
                    compressible: false,
                    extensions: ["zip"],
                },
                "application/zlib": {
                    source: "iana",
                },
                "application/zstd": {
                    source: "iana",
                },
                "audio/1d-interleaved-parityfec": {
                    source: "iana",
                },
                "audio/32kadpcm": {
                    source: "iana",
                },
                "audio/3gpp": {
                    source: "iana",
                    compressible: false,
                    extensions: ["3gpp"],
                },
                "audio/3gpp2": {
                    source: "iana",
                },
                "audio/aac": {
                    source: "iana",
                },
                "audio/ac3": {
                    source: "iana",
                },
                "audio/adpcm": {
                    source: "apache",
                    extensions: ["adp"],
                },
                "audio/amr": {
                    source: "iana",
                },
                "audio/amr-wb": {
                    source: "iana",
                },
                "audio/amr-wb+": {
                    source: "iana",
                },
                "audio/aptx": {
                    source: "iana",
                },
                "audio/asc": {
                    source: "iana",
                },
                "audio/atrac-advanced-lossless": {
                    source: "iana",
                },
                "audio/atrac-x": {
                    source: "iana",
                },
                "audio/atrac3": {
                    source: "iana",
                },
                "audio/basic": {
                    source: "iana",
                    compressible: false,
                    extensions: ["au", "snd"],
                },
                "audio/bv16": {
                    source: "iana",
                },
                "audio/bv32": {
                    source: "iana",
                },
                "audio/clearmode": {
                    source: "iana",
                },
                "audio/cn": {
                    source: "iana",
                },
                "audio/dat12": {
                    source: "iana",
                },
                "audio/dls": {
                    source: "iana",
                },
                "audio/dsr-es201108": {
                    source: "iana",
                },
                "audio/dsr-es202050": {
                    source: "iana",
                },
                "audio/dsr-es202211": {
                    source: "iana",
                },
                "audio/dsr-es202212": {
                    source: "iana",
                },
                "audio/dv": {
                    source: "iana",
                },
                "audio/dvi4": {
                    source: "iana",
                },
                "audio/eac3": {
                    source: "iana",
                },
                "audio/encaprtp": {
                    source: "iana",
                },
                "audio/evrc": {
                    source: "iana",
                },
                "audio/evrc-qcp": {
                    source: "iana",
                },
                "audio/evrc0": {
                    source: "iana",
                },
                "audio/evrc1": {
                    source: "iana",
                },
                "audio/evrcb": {
                    source: "iana",
                },
                "audio/evrcb0": {
                    source: "iana",
                },
                "audio/evrcb1": {
                    source: "iana",
                },
                "audio/evrcnw": {
                    source: "iana",
                },
                "audio/evrcnw0": {
                    source: "iana",
                },
                "audio/evrcnw1": {
                    source: "iana",
                },
                "audio/evrcwb": {
                    source: "iana",
                },
                "audio/evrcwb0": {
                    source: "iana",
                },
                "audio/evrcwb1": {
                    source: "iana",
                },
                "audio/evs": {
                    source: "iana",
                },
                "audio/flexfec": {
                    source: "iana",
                },
                "audio/fwdred": {
                    source: "iana",
                },
                "audio/g711-0": {
                    source: "iana",
                },
                "audio/g719": {
                    source: "iana",
                },
                "audio/g722": {
                    source: "iana",
                },
                "audio/g7221": {
                    source: "iana",
                },
                "audio/g723": {
                    source: "iana",
                },
                "audio/g726-16": {
                    source: "iana",
                },
                "audio/g726-24": {
                    source: "iana",
                },
                "audio/g726-32": {
                    source: "iana",
                },
                "audio/g726-40": {
                    source: "iana",
                },
                "audio/g728": {
                    source: "iana",
                },
                "audio/g729": {
                    source: "iana",
                },
                "audio/g7291": {
                    source: "iana",
                },
                "audio/g729d": {
                    source: "iana",
                },
                "audio/g729e": {
                    source: "iana",
                },
                "audio/gsm": {
                    source: "iana",
                },
                "audio/gsm-efr": {
                    source: "iana",
                },
                "audio/gsm-hr-08": {
                    source: "iana",
                },
                "audio/ilbc": {
                    source: "iana",
                },
                "audio/ip-mr_v2.5": {
                    source: "iana",
                },
                "audio/isac": {
                    source: "apache",
                },
                "audio/l16": {
                    source: "iana",
                },
                "audio/l20": {
                    source: "iana",
                },
                "audio/l24": {
                    source: "iana",
                    compressible: false,
                },
                "audio/l8": {
                    source: "iana",
                },
                "audio/lpc": {
                    source: "iana",
                },
                "audio/melp": {
                    source: "iana",
                },
                "audio/melp1200": {
                    source: "iana",
                },
                "audio/melp2400": {
                    source: "iana",
                },
                "audio/melp600": {
                    source: "iana",
                },
                "audio/mhas": {
                    source: "iana",
                },
                "audio/midi": {
                    source: "apache",
                    extensions: ["mid", "midi", "kar", "rmi"],
                },
                "audio/mobile-xmf": {
                    source: "iana",
                    extensions: ["mxmf"],
                },
                "audio/mp3": {
                    compressible: false,
                    extensions: ["mp3"],
                },
                "audio/mp4": {
                    source: "iana",
                    compressible: false,
                    extensions: ["m4a", "mp4a"],
                },
                "audio/mp4a-latm": {
                    source: "iana",
                },
                "audio/mpa": {
                    source: "iana",
                },
                "audio/mpa-robust": {
                    source: "iana",
                },
                "audio/mpeg": {
                    source: "iana",
                    compressible: false,
                    extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
                },
                "audio/mpeg4-generic": {
                    source: "iana",
                },
                "audio/musepack": {
                    source: "apache",
                },
                "audio/ogg": {
                    source: "iana",
                    compressible: false,
                    extensions: ["oga", "ogg", "spx"],
                },
                "audio/opus": {
                    source: "iana",
                },
                "audio/parityfec": {
                    source: "iana",
                },
                "audio/pcma": {
                    source: "iana",
                },
                "audio/pcma-wb": {
                    source: "iana",
                },
                "audio/pcmu": {
                    source: "iana",
                },
                "audio/pcmu-wb": {
                    source: "iana",
                },
                "audio/prs.sid": {
                    source: "iana",
                },
                "audio/qcelp": {
                    source: "iana",
                },
                "audio/raptorfec": {
                    source: "iana",
                },
                "audio/red": {
                    source: "iana",
                },
                "audio/rtp-enc-aescm128": {
                    source: "iana",
                },
                "audio/rtp-midi": {
                    source: "iana",
                },
                "audio/rtploopback": {
                    source: "iana",
                },
                "audio/rtx": {
                    source: "iana",
                },
                "audio/s3m": {
                    source: "apache",
                    extensions: ["s3m"],
                },
                "audio/silk": {
                    source: "apache",
                    extensions: ["sil"],
                },
                "audio/smv": {
                    source: "iana",
                },
                "audio/smv-qcp": {
                    source: "iana",
                },
                "audio/smv0": {
                    source: "iana",
                },
                "audio/sp-midi": {
                    source: "iana",
                },
                "audio/speex": {
                    source: "iana",
                },
                "audio/t140c": {
                    source: "iana",
                },
                "audio/t38": {
                    source: "iana",
                },
                "audio/telephone-event": {
                    source: "iana",
                },
                "audio/tetra_acelp": {
                    source: "iana",
                },
                "audio/tetra_acelp_bb": {
                    source: "iana",
                },
                "audio/tone": {
                    source: "iana",
                },
                "audio/uemclip": {
                    source: "iana",
                },
                "audio/ulpfec": {
                    source: "iana",
                },
                "audio/usac": {
                    source: "iana",
                },
                "audio/vdvi": {
                    source: "iana",
                },
                "audio/vmr-wb": {
                    source: "iana",
                },
                "audio/vnd.3gpp.iufp": {
                    source: "iana",
                },
                "audio/vnd.4sb": {
                    source: "iana",
                },
                "audio/vnd.audiokoz": {
                    source: "iana",
                },
                "audio/vnd.celp": {
                    source: "iana",
                },
                "audio/vnd.cisco.nse": {
                    source: "iana",
                },
                "audio/vnd.cmles.radio-events": {
                    source: "iana",
                },
                "audio/vnd.cns.anp1": {
                    source: "iana",
                },
                "audio/vnd.cns.inf1": {
                    source: "iana",
                },
                "audio/vnd.dece.audio": {
                    source: "iana",
                    extensions: ["uva", "uvva"],
                },
                "audio/vnd.digital-winds": {
                    source: "iana",
                    extensions: ["eol"],
                },
                "audio/vnd.dlna.adts": {
                    source: "iana",
                },
                "audio/vnd.dolby.heaac.1": {
                    source: "iana",
                },
                "audio/vnd.dolby.heaac.2": {
                    source: "iana",
                },
                "audio/vnd.dolby.mlp": {
                    source: "iana",
                },
                "audio/vnd.dolby.mps": {
                    source: "iana",
                },
                "audio/vnd.dolby.pl2": {
                    source: "iana",
                },
                "audio/vnd.dolby.pl2x": {
                    source: "iana",
                },
                "audio/vnd.dolby.pl2z": {
                    source: "iana",
                },
                "audio/vnd.dolby.pulse.1": {
                    source: "iana",
                },
                "audio/vnd.dra": {
                    source: "iana",
                    extensions: ["dra"],
                },
                "audio/vnd.dts": {
                    source: "iana",
                    extensions: ["dts"],
                },
                "audio/vnd.dts.hd": {
                    source: "iana",
                    extensions: ["dtshd"],
                },
                "audio/vnd.dts.uhd": {
                    source: "iana",
                },
                "audio/vnd.dvb.file": {
                    source: "iana",
                },
                "audio/vnd.everad.plj": {
                    source: "iana",
                },
                "audio/vnd.hns.audio": {
                    source: "iana",
                },
                "audio/vnd.lucent.voice": {
                    source: "iana",
                    extensions: ["lvp"],
                },
                "audio/vnd.ms-playready.media.pya": {
                    source: "iana",
                    extensions: ["pya"],
                },
                "audio/vnd.nokia.mobile-xmf": {
                    source: "iana",
                },
                "audio/vnd.nortel.vbk": {
                    source: "iana",
                },
                "audio/vnd.nuera.ecelp4800": {
                    source: "iana",
                    extensions: ["ecelp4800"],
                },
                "audio/vnd.nuera.ecelp7470": {
                    source: "iana",
                    extensions: ["ecelp7470"],
                },
                "audio/vnd.nuera.ecelp9600": {
                    source: "iana",
                    extensions: ["ecelp9600"],
                },
                "audio/vnd.octel.sbc": {
                    source: "iana",
                },
                "audio/vnd.presonus.multitrack": {
                    source: "iana",
                },
                "audio/vnd.qcelp": {
                    source: "iana",
                },
                "audio/vnd.rhetorex.32kadpcm": {
                    source: "iana",
                },
                "audio/vnd.rip": {
                    source: "iana",
                    extensions: ["rip"],
                },
                "audio/vnd.rn-realaudio": {
                    compressible: false,
                },
                "audio/vnd.sealedmedia.softseal.mpeg": {
                    source: "iana",
                },
                "audio/vnd.vmx.cvsd": {
                    source: "iana",
                },
                "audio/vnd.wave": {
                    compressible: false,
                },
                "audio/vorbis": {
                    source: "iana",
                    compressible: false,
                },
                "audio/vorbis-config": {
                    source: "iana",
                },
                "audio/wav": {
                    compressible: false,
                    extensions: ["wav"],
                },
                "audio/wave": {
                    compressible: false,
                    extensions: ["wav"],
                },
                "audio/webm": {
                    source: "apache",
                    compressible: false,
                    extensions: ["weba"],
                },
                "audio/x-aac": {
                    source: "apache",
                    compressible: false,
                    extensions: ["aac"],
                },
                "audio/x-aiff": {
                    source: "apache",
                    extensions: ["aif", "aiff", "aifc"],
                },
                "audio/x-caf": {
                    source: "apache",
                    compressible: false,
                    extensions: ["caf"],
                },
                "audio/x-flac": {
                    source: "apache",
                    extensions: ["flac"],
                },
                "audio/x-m4a": {
                    source: "nginx",
                    extensions: ["m4a"],
                },
                "audio/x-matroska": {
                    source: "apache",
                    extensions: ["mka"],
                },
                "audio/x-mpegurl": {
                    source: "apache",
                    extensions: ["m3u"],
                },
                "audio/x-ms-wax": {
                    source: "apache",
                    extensions: ["wax"],
                },
                "audio/x-ms-wma": {
                    source: "apache",
                    extensions: ["wma"],
                },
                "audio/x-pn-realaudio": {
                    source: "apache",
                    extensions: ["ram", "ra"],
                },
                "audio/x-pn-realaudio-plugin": {
                    source: "apache",
                    extensions: ["rmp"],
                },
                "audio/x-realaudio": {
                    source: "nginx",
                    extensions: ["ra"],
                },
                "audio/x-tta": {
                    source: "apache",
                },
                "audio/x-wav": {
                    source: "apache",
                    extensions: ["wav"],
                },
                "audio/xm": {
                    source: "apache",
                    extensions: ["xm"],
                },
                "chemical/x-cdx": {
                    source: "apache",
                    extensions: ["cdx"],
                },
                "chemical/x-cif": {
                    source: "apache",
                    extensions: ["cif"],
                },
                "chemical/x-cmdf": {
                    source: "apache",
                    extensions: ["cmdf"],
                },
                "chemical/x-cml": {
                    source: "apache",
                    extensions: ["cml"],
                },
                "chemical/x-csml": {
                    source: "apache",
                    extensions: ["csml"],
                },
                "chemical/x-pdb": {
                    source: "apache",
                },
                "chemical/x-xyz": {
                    source: "apache",
                    extensions: ["xyz"],
                },
                "font/collection": {
                    source: "iana",
                    extensions: ["ttc"],
                },
                "font/otf": {
                    source: "iana",
                    compressible: true,
                    extensions: ["otf"],
                },
                "font/sfnt": {
                    source: "iana",
                },
                "font/ttf": {
                    source: "iana",
                    compressible: true,
                    extensions: ["ttf"],
                },
                "font/woff": {
                    source: "iana",
                    extensions: ["woff"],
                },
                "font/woff2": {
                    source: "iana",
                    extensions: ["woff2"],
                },
                "image/aces": {
                    source: "iana",
                    extensions: ["exr"],
                },
                "image/apng": {
                    compressible: false,
                    extensions: ["apng"],
                },
                "image/avci": {
                    source: "iana",
                },
                "image/avcs": {
                    source: "iana",
                },
                "image/bmp": {
                    source: "iana",
                    compressible: true,
                    extensions: ["bmp"],
                },
                "image/cgm": {
                    source: "iana",
                    extensions: ["cgm"],
                },
                "image/dicom-rle": {
                    source: "iana",
                    extensions: ["drle"],
                },
                "image/emf": {
                    source: "iana",
                    extensions: ["emf"],
                },
                "image/fits": {
                    source: "iana",
                    extensions: ["fits"],
                },
                "image/g3fax": {
                    source: "iana",
                    extensions: ["g3"],
                },
                "image/gif": {
                    source: "iana",
                    compressible: false,
                    extensions: ["gif"],
                },
                "image/heic": {
                    source: "iana",
                    extensions: ["heic"],
                },
                "image/heic-sequence": {
                    source: "iana",
                    extensions: ["heics"],
                },
                "image/heif": {
                    source: "iana",
                    extensions: ["heif"],
                },
                "image/heif-sequence": {
                    source: "iana",
                    extensions: ["heifs"],
                },
                "image/hej2k": {
                    source: "iana",
                    extensions: ["hej2"],
                },
                "image/hsj2": {
                    source: "iana",
                    extensions: ["hsj2"],
                },
                "image/ief": {
                    source: "iana",
                    extensions: ["ief"],
                },
                "image/jls": {
                    source: "iana",
                    extensions: ["jls"],
                },
                "image/jp2": {
                    source: "iana",
                    compressible: false,
                    extensions: ["jp2", "jpg2"],
                },
                "image/jpeg": {
                    source: "iana",
                    compressible: false,
                    extensions: ["jpeg", "jpg", "jpe"],
                },
                "image/jph": {
                    source: "iana",
                    extensions: ["jph"],
                },
                "image/jphc": {
                    source: "iana",
                    extensions: ["jhc"],
                },
                "image/jpm": {
                    source: "iana",
                    compressible: false,
                    extensions: ["jpm"],
                },
                "image/jpx": {
                    source: "iana",
                    compressible: false,
                    extensions: ["jpx", "jpf"],
                },
                "image/jxr": {
                    source: "iana",
                    extensions: ["jxr"],
                },
                "image/jxra": {
                    source: "iana",
                    extensions: ["jxra"],
                },
                "image/jxrs": {
                    source: "iana",
                    extensions: ["jxrs"],
                },
                "image/jxs": {
                    source: "iana",
                    extensions: ["jxs"],
                },
                "image/jxsc": {
                    source: "iana",
                    extensions: ["jxsc"],
                },
                "image/jxsi": {
                    source: "iana",
                    extensions: ["jxsi"],
                },
                "image/jxss": {
                    source: "iana",
                    extensions: ["jxss"],
                },
                "image/ktx": {
                    source: "iana",
                    extensions: ["ktx"],
                },
                "image/naplps": {
                    source: "iana",
                },
                "image/pjpeg": {
                    compressible: false,
                },
                "image/png": {
                    source: "iana",
                    compressible: false,
                    extensions: ["png"],
                },
                "image/prs.btif": {
                    source: "iana",
                    extensions: ["btif"],
                },
                "image/prs.pti": {
                    source: "iana",
                    extensions: ["pti"],
                },
                "image/pwg-raster": {
                    source: "iana",
                },
                "image/sgi": {
                    source: "apache",
                    extensions: ["sgi"],
                },
                "image/svg+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["svg", "svgz"],
                },
                "image/t38": {
                    source: "iana",
                    extensions: ["t38"],
                },
                "image/tiff": {
                    source: "iana",
                    compressible: false,
                    extensions: ["tif", "tiff"],
                },
                "image/tiff-fx": {
                    source: "iana",
                    extensions: ["tfx"],
                },
                "image/vnd.adobe.photoshop": {
                    source: "iana",
                    compressible: true,
                    extensions: ["psd"],
                },
                "image/vnd.airzip.accelerator.azv": {
                    source: "iana",
                    extensions: ["azv"],
                },
                "image/vnd.cns.inf2": {
                    source: "iana",
                },
                "image/vnd.dece.graphic": {
                    source: "iana",
                    extensions: ["uvi", "uvvi", "uvg", "uvvg"],
                },
                "image/vnd.djvu": {
                    source: "iana",
                    extensions: ["djvu", "djv"],
                },
                "image/vnd.dvb.subtitle": {
                    source: "iana",
                    extensions: ["sub"],
                },
                "image/vnd.dwg": {
                    source: "iana",
                    extensions: ["dwg"],
                },
                "image/vnd.dxf": {
                    source: "iana",
                    extensions: ["dxf"],
                },
                "image/vnd.fastbidsheet": {
                    source: "iana",
                    extensions: ["fbs"],
                },
                "image/vnd.fpx": {
                    source: "iana",
                    extensions: ["fpx"],
                },
                "image/vnd.fst": {
                    source: "iana",
                    extensions: ["fst"],
                },
                "image/vnd.fujixerox.edmics-mmr": {
                    source: "iana",
                    extensions: ["mmr"],
                },
                "image/vnd.fujixerox.edmics-rlc": {
                    source: "iana",
                    extensions: ["rlc"],
                },
                "image/vnd.globalgraphics.pgb": {
                    source: "iana",
                },
                "image/vnd.microsoft.icon": {
                    source: "iana",
                    extensions: ["ico"],
                },
                "image/vnd.mix": {
                    source: "iana",
                },
                "image/vnd.mozilla.apng": {
                    source: "iana",
                },
                "image/vnd.ms-dds": {
                    extensions: ["dds"],
                },
                "image/vnd.ms-modi": {
                    source: "iana",
                    extensions: ["mdi"],
                },
                "image/vnd.ms-photo": {
                    source: "apache",
                    extensions: ["wdp"],
                },
                "image/vnd.net-fpx": {
                    source: "iana",
                    extensions: ["npx"],
                },
                "image/vnd.radiance": {
                    source: "iana",
                },
                "image/vnd.sealed.png": {
                    source: "iana",
                },
                "image/vnd.sealedmedia.softseal.gif": {
                    source: "iana",
                },
                "image/vnd.sealedmedia.softseal.jpg": {
                    source: "iana",
                },
                "image/vnd.svf": {
                    source: "iana",
                },
                "image/vnd.tencent.tap": {
                    source: "iana",
                    extensions: ["tap"],
                },
                "image/vnd.valve.source.texture": {
                    source: "iana",
                    extensions: ["vtf"],
                },
                "image/vnd.wap.wbmp": {
                    source: "iana",
                    extensions: ["wbmp"],
                },
                "image/vnd.xiff": {
                    source: "iana",
                    extensions: ["xif"],
                },
                "image/vnd.zbrush.pcx": {
                    source: "iana",
                    extensions: ["pcx"],
                },
                "image/webp": {
                    source: "apache",
                    extensions: ["webp"],
                },
                "image/wmf": {
                    source: "iana",
                    extensions: ["wmf"],
                },
                "image/x-3ds": {
                    source: "apache",
                    extensions: ["3ds"],
                },
                "image/x-cmu-raster": {
                    source: "apache",
                    extensions: ["ras"],
                },
                "image/x-cmx": {
                    source: "apache",
                    extensions: ["cmx"],
                },
                "image/x-freehand": {
                    source: "apache",
                    extensions: ["fh", "fhc", "fh4", "fh5", "fh7"],
                },
                "image/x-icon": {
                    source: "apache",
                    compressible: true,
                    extensions: ["ico"],
                },
                "image/x-jng": {
                    source: "nginx",
                    extensions: ["jng"],
                },
                "image/x-mrsid-image": {
                    source: "apache",
                    extensions: ["sid"],
                },
                "image/x-ms-bmp": {
                    source: "nginx",
                    compressible: true,
                    extensions: ["bmp"],
                },
                "image/x-pcx": {
                    source: "apache",
                    extensions: ["pcx"],
                },
                "image/x-pict": {
                    source: "apache",
                    extensions: ["pic", "pct"],
                },
                "image/x-portable-anymap": {
                    source: "apache",
                    extensions: ["pnm"],
                },
                "image/x-portable-bitmap": {
                    source: "apache",
                    extensions: ["pbm"],
                },
                "image/x-portable-graymap": {
                    source: "apache",
                    extensions: ["pgm"],
                },
                "image/x-portable-pixmap": {
                    source: "apache",
                    extensions: ["ppm"],
                },
                "image/x-rgb": {
                    source: "apache",
                    extensions: ["rgb"],
                },
                "image/x-tga": {
                    source: "apache",
                    extensions: ["tga"],
                },
                "image/x-xbitmap": {
                    source: "apache",
                    extensions: ["xbm"],
                },
                "image/x-xcf": {
                    compressible: false,
                },
                "image/x-xpixmap": {
                    source: "apache",
                    extensions: ["xpm"],
                },
                "image/x-xwindowdump": {
                    source: "apache",
                    extensions: ["xwd"],
                },
                "message/cpim": {
                    source: "iana",
                },
                "message/delivery-status": {
                    source: "iana",
                },
                "message/disposition-notification": {
                    source: "iana",
                    extensions: ["disposition-notification"],
                },
                "message/external-body": {
                    source: "iana",
                },
                "message/feedback-report": {
                    source: "iana",
                },
                "message/global": {
                    source: "iana",
                    extensions: ["u8msg"],
                },
                "message/global-delivery-status": {
                    source: "iana",
                    extensions: ["u8dsn"],
                },
                "message/global-disposition-notification": {
                    source: "iana",
                    extensions: ["u8mdn"],
                },
                "message/global-headers": {
                    source: "iana",
                    extensions: ["u8hdr"],
                },
                "message/http": {
                    source: "iana",
                    compressible: false,
                },
                "message/imdn+xml": {
                    source: "iana",
                    compressible: true,
                },
                "message/news": {
                    source: "iana",
                },
                "message/partial": {
                    source: "iana",
                    compressible: false,
                },
                "message/rfc822": {
                    source: "iana",
                    compressible: true,
                    extensions: ["eml", "mime"],
                },
                "message/s-http": {
                    source: "iana",
                },
                "message/sip": {
                    source: "iana",
                },
                "message/sipfrag": {
                    source: "iana",
                },
                "message/tracking-status": {
                    source: "iana",
                },
                "message/vnd.si.simp": {
                    source: "iana",
                },
                "message/vnd.wfa.wsc": {
                    source: "iana",
                    extensions: ["wsc"],
                },
                "model/3mf": {
                    source: "iana",
                    extensions: ["3mf"],
                },
                "model/gltf+json": {
                    source: "iana",
                    compressible: true,
                    extensions: ["gltf"],
                },
                "model/gltf-binary": {
                    source: "iana",
                    compressible: true,
                    extensions: ["glb"],
                },
                "model/iges": {
                    source: "iana",
                    compressible: false,
                    extensions: ["igs", "iges"],
                },
                "model/mesh": {
                    source: "iana",
                    compressible: false,
                    extensions: ["msh", "mesh", "silo"],
                },
                "model/mtl": {
                    source: "iana",
                    extensions: ["mtl"],
                },
                "model/obj": {
                    source: "iana",
                    extensions: ["obj"],
                },
                "model/stl": {
                    source: "iana",
                    extensions: ["stl"],
                },
                "model/vnd.collada+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["dae"],
                },
                "model/vnd.dwf": {
                    source: "iana",
                    extensions: ["dwf"],
                },
                "model/vnd.flatland.3dml": {
                    source: "iana",
                },
                "model/vnd.gdl": {
                    source: "iana",
                    extensions: ["gdl"],
                },
                "model/vnd.gs-gdl": {
                    source: "apache",
                },
                "model/vnd.gs.gdl": {
                    source: "iana",
                },
                "model/vnd.gtw": {
                    source: "iana",
                    extensions: ["gtw"],
                },
                "model/vnd.moml+xml": {
                    source: "iana",
                    compressible: true,
                },
                "model/vnd.mts": {
                    source: "iana",
                    extensions: ["mts"],
                },
                "model/vnd.opengex": {
                    source: "iana",
                    extensions: ["ogex"],
                },
                "model/vnd.parasolid.transmit.binary": {
                    source: "iana",
                    extensions: ["x_b"],
                },
                "model/vnd.parasolid.transmit.text": {
                    source: "iana",
                    extensions: ["x_t"],
                },
                "model/vnd.rosette.annotated-data-model": {
                    source: "iana",
                },
                "model/vnd.usdz+zip": {
                    source: "iana",
                    compressible: false,
                    extensions: ["usdz"],
                },
                "model/vnd.valve.source.compiled-map": {
                    source: "iana",
                    extensions: ["bsp"],
                },
                "model/vnd.vtu": {
                    source: "iana",
                    extensions: ["vtu"],
                },
                "model/vrml": {
                    source: "iana",
                    compressible: false,
                    extensions: ["wrl", "vrml"],
                },
                "model/x3d+binary": {
                    source: "apache",
                    compressible: false,
                    extensions: ["x3db", "x3dbz"],
                },
                "model/x3d+fastinfoset": {
                    source: "iana",
                    extensions: ["x3db"],
                },
                "model/x3d+vrml": {
                    source: "apache",
                    compressible: false,
                    extensions: ["x3dv", "x3dvz"],
                },
                "model/x3d+xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["x3d", "x3dz"],
                },
                "model/x3d-vrml": {
                    source: "iana",
                    extensions: ["x3dv"],
                },
                "multipart/alternative": {
                    source: "iana",
                    compressible: false,
                },
                "multipart/appledouble": {
                    source: "iana",
                },
                "multipart/byteranges": {
                    source: "iana",
                },
                "multipart/digest": {
                    source: "iana",
                },
                "multipart/encrypted": {
                    source: "iana",
                    compressible: false,
                },
                "multipart/form-data": {
                    source: "iana",
                    compressible: false,
                },
                "multipart/header-set": {
                    source: "iana",
                },
                "multipart/mixed": {
                    source: "iana",
                },
                "multipart/multilingual": {
                    source: "iana",
                },
                "multipart/parallel": {
                    source: "iana",
                },
                "multipart/related": {
                    source: "iana",
                    compressible: false,
                },
                "multipart/report": {
                    source: "iana",
                },
                "multipart/signed": {
                    source: "iana",
                    compressible: false,
                },
                "multipart/vnd.bint.med-plus": {
                    source: "iana",
                },
                "multipart/voice-message": {
                    source: "iana",
                },
                "multipart/x-mixed-replace": {
                    source: "iana",
                },
                "text/1d-interleaved-parityfec": {
                    source: "iana",
                },
                "text/cache-manifest": {
                    source: "iana",
                    compressible: true,
                    extensions: ["appcache", "manifest"],
                },
                "text/calendar": {
                    source: "iana",
                    extensions: ["ics", "ifb"],
                },
                "text/calender": {
                    compressible: true,
                },
                "text/cmd": {
                    compressible: true,
                },
                "text/coffeescript": {
                    extensions: ["coffee", "litcoffee"],
                },
                "text/css": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                    extensions: ["css"],
                },
                "text/csv": {
                    source: "iana",
                    compressible: true,
                    extensions: ["csv"],
                },
                "text/csv-schema": {
                    source: "iana",
                },
                "text/directory": {
                    source: "iana",
                },
                "text/dns": {
                    source: "iana",
                },
                "text/ecmascript": {
                    source: "iana",
                },
                "text/encaprtp": {
                    source: "iana",
                },
                "text/enriched": {
                    source: "iana",
                },
                "text/flexfec": {
                    source: "iana",
                },
                "text/fwdred": {
                    source: "iana",
                },
                "text/grammar-ref-list": {
                    source: "iana",
                },
                "text/html": {
                    source: "iana",
                    compressible: true,
                    extensions: ["html", "htm", "shtml"],
                },
                "text/jade": {
                    extensions: ["jade"],
                },
                "text/javascript": {
                    source: "iana",
                    compressible: true,
                },
                "text/jcr-cnd": {
                    source: "iana",
                },
                "text/jsx": {
                    compressible: true,
                    extensions: ["jsx"],
                },
                "text/less": {
                    compressible: true,
                    extensions: ["less"],
                },
                "text/markdown": {
                    source: "iana",
                    compressible: true,
                    extensions: ["markdown", "md"],
                },
                "text/mathml": {
                    source: "nginx",
                    extensions: ["mml"],
                },
                "text/mdx": {
                    compressible: true,
                    extensions: ["mdx"],
                },
                "text/mizar": {
                    source: "iana",
                },
                "text/n3": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                    extensions: ["n3"],
                },
                "text/parameters": {
                    source: "iana",
                    charset: "UTF-8",
                },
                "text/parityfec": {
                    source: "iana",
                },
                "text/plain": {
                    source: "iana",
                    compressible: true,
                    extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"],
                },
                "text/provenance-notation": {
                    source: "iana",
                    charset: "UTF-8",
                },
                "text/prs.fallenstein.rst": {
                    source: "iana",
                },
                "text/prs.lines.tag": {
                    source: "iana",
                    extensions: ["dsc"],
                },
                "text/prs.prop.logic": {
                    source: "iana",
                },
                "text/raptorfec": {
                    source: "iana",
                },
                "text/red": {
                    source: "iana",
                },
                "text/rfc822-headers": {
                    source: "iana",
                },
                "text/richtext": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rtx"],
                },
                "text/rtf": {
                    source: "iana",
                    compressible: true,
                    extensions: ["rtf"],
                },
                "text/rtp-enc-aescm128": {
                    source: "iana",
                },
                "text/rtploopback": {
                    source: "iana",
                },
                "text/rtx": {
                    source: "iana",
                },
                "text/sgml": {
                    source: "iana",
                    extensions: ["sgml", "sgm"],
                },
                "text/shex": {
                    extensions: ["shex"],
                },
                "text/slim": {
                    extensions: ["slim", "slm"],
                },
                "text/strings": {
                    source: "iana",
                },
                "text/stylus": {
                    extensions: ["stylus", "styl"],
                },
                "text/t140": {
                    source: "iana",
                },
                "text/tab-separated-values": {
                    source: "iana",
                    compressible: true,
                    extensions: ["tsv"],
                },
                "text/troff": {
                    source: "iana",
                    extensions: ["t", "tr", "roff", "man", "me", "ms"],
                },
                "text/turtle": {
                    source: "iana",
                    charset: "UTF-8",
                    extensions: ["ttl"],
                },
                "text/ulpfec": {
                    source: "iana",
                },
                "text/uri-list": {
                    source: "iana",
                    compressible: true,
                    extensions: ["uri", "uris", "urls"],
                },
                "text/vcard": {
                    source: "iana",
                    compressible: true,
                    extensions: ["vcard"],
                },
                "text/vnd.a": {
                    source: "iana",
                },
                "text/vnd.abc": {
                    source: "iana",
                },
                "text/vnd.ascii-art": {
                    source: "iana",
                },
                "text/vnd.curl": {
                    source: "iana",
                    extensions: ["curl"],
                },
                "text/vnd.curl.dcurl": {
                    source: "apache",
                    extensions: ["dcurl"],
                },
                "text/vnd.curl.mcurl": {
                    source: "apache",
                    extensions: ["mcurl"],
                },
                "text/vnd.curl.scurl": {
                    source: "apache",
                    extensions: ["scurl"],
                },
                "text/vnd.debian.copyright": {
                    source: "iana",
                    charset: "UTF-8",
                },
                "text/vnd.dmclientscript": {
                    source: "iana",
                },
                "text/vnd.dvb.subtitle": {
                    source: "iana",
                    extensions: ["sub"],
                },
                "text/vnd.esmertec.theme-descriptor": {
                    source: "iana",
                    charset: "UTF-8",
                },
                "text/vnd.ficlab.flt": {
                    source: "iana",
                },
                "text/vnd.fly": {
                    source: "iana",
                    extensions: ["fly"],
                },
                "text/vnd.fmi.flexstor": {
                    source: "iana",
                    extensions: ["flx"],
                },
                "text/vnd.gml": {
                    source: "iana",
                },
                "text/vnd.graphviz": {
                    source: "iana",
                    extensions: ["gv"],
                },
                "text/vnd.hgl": {
                    source: "iana",
                },
                "text/vnd.in3d.3dml": {
                    source: "iana",
                    extensions: ["3dml"],
                },
                "text/vnd.in3d.spot": {
                    source: "iana",
                    extensions: ["spot"],
                },
                "text/vnd.iptc.newsml": {
                    source: "iana",
                },
                "text/vnd.iptc.nitf": {
                    source: "iana",
                },
                "text/vnd.latex-z": {
                    source: "iana",
                },
                "text/vnd.motorola.reflex": {
                    source: "iana",
                },
                "text/vnd.ms-mediapackage": {
                    source: "iana",
                },
                "text/vnd.net2phone.commcenter.command": {
                    source: "iana",
                },
                "text/vnd.radisys.msml-basic-layout": {
                    source: "iana",
                },
                "text/vnd.senx.warpscript": {
                    source: "iana",
                },
                "text/vnd.si.uricatalogue": {
                    source: "iana",
                },
                "text/vnd.sosi": {
                    source: "iana",
                },
                "text/vnd.sun.j2me.app-descriptor": {
                    source: "iana",
                    charset: "UTF-8",
                    extensions: ["jad"],
                },
                "text/vnd.trolltech.linguist": {
                    source: "iana",
                    charset: "UTF-8",
                },
                "text/vnd.wap.si": {
                    source: "iana",
                },
                "text/vnd.wap.sl": {
                    source: "iana",
                },
                "text/vnd.wap.wml": {
                    source: "iana",
                    extensions: ["wml"],
                },
                "text/vnd.wap.wmlscript": {
                    source: "iana",
                    extensions: ["wmls"],
                },
                "text/vtt": {
                    source: "iana",
                    charset: "UTF-8",
                    compressible: true,
                    extensions: ["vtt"],
                },
                "text/x-asm": {
                    source: "apache",
                    extensions: ["s", "asm"],
                },
                "text/x-c": {
                    source: "apache",
                    extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"],
                },
                "text/x-component": {
                    source: "nginx",
                    extensions: ["htc"],
                },
                "text/x-fortran": {
                    source: "apache",
                    extensions: ["f", "for", "f77", "f90"],
                },
                "text/x-gwt-rpc": {
                    compressible: true,
                },
                "text/x-handlebars-template": {
                    extensions: ["hbs"],
                },
                "text/x-java-source": {
                    source: "apache",
                    extensions: ["java"],
                },
                "text/x-jquery-tmpl": {
                    compressible: true,
                },
                "text/x-lua": {
                    extensions: ["lua"],
                },
                "text/x-markdown": {
                    compressible: true,
                    extensions: ["mkd"],
                },
                "text/x-nfo": {
                    source: "apache",
                    extensions: ["nfo"],
                },
                "text/x-opml": {
                    source: "apache",
                    extensions: ["opml"],
                },
                "text/x-org": {
                    compressible: true,
                    extensions: ["org"],
                },
                "text/x-pascal": {
                    source: "apache",
                    extensions: ["p", "pas"],
                },
                "text/x-processing": {
                    compressible: true,
                    extensions: ["pde"],
                },
                "text/x-sass": {
                    extensions: ["sass"],
                },
                "text/x-scss": {
                    extensions: ["scss"],
                },
                "text/x-setext": {
                    source: "apache",
                    extensions: ["etx"],
                },
                "text/x-sfv": {
                    source: "apache",
                    extensions: ["sfv"],
                },
                "text/x-suse-ymp": {
                    compressible: true,
                    extensions: ["ymp"],
                },
                "text/x-uuencode": {
                    source: "apache",
                    extensions: ["uu"],
                },
                "text/x-vcalendar": {
                    source: "apache",
                    extensions: ["vcs"],
                },
                "text/x-vcard": {
                    source: "apache",
                    extensions: ["vcf"],
                },
                "text/xml": {
                    source: "iana",
                    compressible: true,
                    extensions: ["xml"],
                },
                "text/xml-external-parsed-entity": {
                    source: "iana",
                },
                "text/yaml": {
                    extensions: ["yaml", "yml"],
                },
                "video/1d-interleaved-parityfec": {
                    source: "iana",
                },
                "video/3gpp": {
                    source: "iana",
                    extensions: ["3gp", "3gpp"],
                },
                "video/3gpp-tt": {
                    source: "iana",
                },
                "video/3gpp2": {
                    source: "iana",
                    extensions: ["3g2"],
                },
                "video/bmpeg": {
                    source: "iana",
                },
                "video/bt656": {
                    source: "iana",
                },
                "video/celb": {
                    source: "iana",
                },
                "video/dv": {
                    source: "iana",
                },
                "video/encaprtp": {
                    source: "iana",
                },
                "video/flexfec": {
                    source: "iana",
                },
                "video/h261": {
                    source: "iana",
                    extensions: ["h261"],
                },
                "video/h263": {
                    source: "iana",
                    extensions: ["h263"],
                },
                "video/h263-1998": {
                    source: "iana",
                },
                "video/h263-2000": {
                    source: "iana",
                },
                "video/h264": {
                    source: "iana",
                    extensions: ["h264"],
                },
                "video/h264-rcdo": {
                    source: "iana",
                },
                "video/h264-svc": {
                    source: "iana",
                },
                "video/h265": {
                    source: "iana",
                },
                "video/iso.segment": {
                    source: "iana",
                },
                "video/jpeg": {
                    source: "iana",
                    extensions: ["jpgv"],
                },
                "video/jpeg2000": {
                    source: "iana",
                },
                "video/jpm": {
                    source: "apache",
                    extensions: ["jpm", "jpgm"],
                },
                "video/mj2": {
                    source: "iana",
                    extensions: ["mj2", "mjp2"],
                },
                "video/mp1s": {
                    source: "iana",
                },
                "video/mp2p": {
                    source: "iana",
                },
                "video/mp2t": {
                    source: "iana",
                    extensions: ["ts"],
                },
                "video/mp4": {
                    source: "iana",
                    compressible: false,
                    extensions: ["mp4", "mp4v", "mpg4"],
                },
                "video/mp4v-es": {
                    source: "iana",
                },
                "video/mpeg": {
                    source: "iana",
                    compressible: false,
                    extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"],
                },
                "video/mpeg4-generic": {
                    source: "iana",
                },
                "video/mpv": {
                    source: "iana",
                },
                "video/nv": {
                    source: "iana",
                },
                "video/ogg": {
                    source: "iana",
                    compressible: false,
                    extensions: ["ogv"],
                },
                "video/parityfec": {
                    source: "iana",
                },
                "video/pointer": {
                    source: "iana",
                },
                "video/quicktime": {
                    source: "iana",
                    compressible: false,
                    extensions: ["qt", "mov"],
                },
                "video/raptorfec": {
                    source: "iana",
                },
                "video/raw": {
                    source: "iana",
                },
                "video/rtp-enc-aescm128": {
                    source: "iana",
                },
                "video/rtploopback": {
                    source: "iana",
                },
                "video/rtx": {
                    source: "iana",
                },
                "video/smpte291": {
                    source: "iana",
                },
                "video/smpte292m": {
                    source: "iana",
                },
                "video/ulpfec": {
                    source: "iana",
                },
                "video/vc1": {
                    source: "iana",
                },
                "video/vc2": {
                    source: "iana",
                },
                "video/vnd.cctv": {
                    source: "iana",
                },
                "video/vnd.dece.hd": {
                    source: "iana",
                    extensions: ["uvh", "uvvh"],
                },
                "video/vnd.dece.mobile": {
                    source: "iana",
                    extensions: ["uvm", "uvvm"],
                },
                "video/vnd.dece.mp4": {
                    source: "iana",
                },
                "video/vnd.dece.pd": {
                    source: "iana",
                    extensions: ["uvp", "uvvp"],
                },
                "video/vnd.dece.sd": {
                    source: "iana",
                    extensions: ["uvs", "uvvs"],
                },
                "video/vnd.dece.video": {
                    source: "iana",
                    extensions: ["uvv", "uvvv"],
                },
                "video/vnd.directv.mpeg": {
                    source: "iana",
                },
                "video/vnd.directv.mpeg-tts": {
                    source: "iana",
                },
                "video/vnd.dlna.mpeg-tts": {
                    source: "iana",
                },
                "video/vnd.dvb.file": {
                    source: "iana",
                    extensions: ["dvb"],
                },
                "video/vnd.fvt": {
                    source: "iana",
                    extensions: ["fvt"],
                },
                "video/vnd.hns.video": {
                    source: "iana",
                },
                "video/vnd.iptvforum.1dparityfec-1010": {
                    source: "iana",
                },
                "video/vnd.iptvforum.1dparityfec-2005": {
                    source: "iana",
                },
                "video/vnd.iptvforum.2dparityfec-1010": {
                    source: "iana",
                },
                "video/vnd.iptvforum.2dparityfec-2005": {
                    source: "iana",
                },
                "video/vnd.iptvforum.ttsavc": {
                    source: "iana",
                },
                "video/vnd.iptvforum.ttsmpeg2": {
                    source: "iana",
                },
                "video/vnd.motorola.video": {
                    source: "iana",
                },
                "video/vnd.motorola.videop": {
                    source: "iana",
                },
                "video/vnd.mpegurl": {
                    source: "iana",
                    extensions: ["mxu", "m4u"],
                },
                "video/vnd.ms-playready.media.pyv": {
                    source: "iana",
                    extensions: ["pyv"],
                },
                "video/vnd.nokia.interleaved-multimedia": {
                    source: "iana",
                },
                "video/vnd.nokia.mp4vr": {
                    source: "iana",
                },
                "video/vnd.nokia.videovoip": {
                    source: "iana",
                },
                "video/vnd.objectvideo": {
                    source: "iana",
                },
                "video/vnd.radgamettools.bink": {
                    source: "iana",
                },
                "video/vnd.radgamettools.smacker": {
                    source: "iana",
                },
                "video/vnd.sealed.mpeg1": {
                    source: "iana",
                },
                "video/vnd.sealed.mpeg4": {
                    source: "iana",
                },
                "video/vnd.sealed.swf": {
                    source: "iana",
                },
                "video/vnd.sealedmedia.softseal.mov": {
                    source: "iana",
                },
                "video/vnd.uvvu.mp4": {
                    source: "iana",
                    extensions: ["uvu", "uvvu"],
                },
                "video/vnd.vivo": {
                    source: "iana",
                    extensions: ["viv"],
                },
                "video/vnd.youtube.yt": {
                    source: "iana",
                },
                "video/vp8": {
                    source: "iana",
                },
                "video/webm": {
                    source: "apache",
                    compressible: false,
                    extensions: ["webm"],
                },
                "video/x-f4v": {
                    source: "apache",
                    extensions: ["f4v"],
                },
                "video/x-fli": {
                    source: "apache",
                    extensions: ["fli"],
                },
                "video/x-flv": {
                    source: "apache",
                    compressible: false,
                    extensions: ["flv"],
                },
                "video/x-m4v": {
                    source: "apache",
                    extensions: ["m4v"],
                },
                "video/x-matroska": {
                    source: "apache",
                    compressible: false,
                    extensions: ["mkv", "mk3d", "mks"],
                },
                "video/x-mng": {
                    source: "apache",
                    extensions: ["mng"],
                },
                "video/x-ms-asf": {
                    source: "apache",
                    extensions: ["asf", "asx"],
                },
                "video/x-ms-vob": {
                    source: "apache",
                    extensions: ["vob"],
                },
                "video/x-ms-wm": {
                    source: "apache",
                    extensions: ["wm"],
                },
                "video/x-ms-wmv": {
                    source: "apache",
                    compressible: false,
                    extensions: ["wmv"],
                },
                "video/x-ms-wmx": {
                    source: "apache",
                    extensions: ["wmx"],
                },
                "video/x-ms-wvx": {
                    source: "apache",
                    extensions: ["wvx"],
                },
                "video/x-msvideo": {
                    source: "apache",
                    extensions: ["avi"],
                },
                "video/x-sgi-movie": {
                    source: "apache",
                    extensions: ["movie"],
                },
                "video/x-smv": {
                    source: "apache",
                    extensions: ["smv"],
                },
                "x-conference/x-cooltalk": {
                    source: "apache",
                    extensions: ["ice"],
                },
                "x-shader/x-fragment": {
                    compressible: true,
                },
                "x-shader/x-vertex": {
                    compressible: true,
                },
            });
        }
    };
});
// Copyright 2018-2020 the Deno authors. All rights reserved. MIT license.
System.register("https://deno.land/x/media_types@v2.3.6/deps", ["https://deno.land/std@0.57.0/path/mod"], function (exports_33, context_33) {
    "use strict";
    var __moduleName = context_33 && context_33.id;
    return {
        setters: [
            function (mod_ts_7_1) {
                exports_33({
                    "extname": mod_ts_7_1["extname"]
                });
            }
        ],
        execute: function () {
        }
    };
});
/*!
 * Ported from: https://github.com/jshttp/mime-types and licensed as:
 *
 * (The MIT License)
 *
 * Copyright (c) 2014 Jonathan Ong <me@jongleberry.com>
 * Copyright (c) 2015 Douglas Christopher Wilson <doug@somethingdoug.com>
 * Copyright (c) 2020 the Deno authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://deno.land/x/media_types@v2.3.6/mod", ["https://deno.land/x/media_types@v2.3.6/db", "https://deno.land/x/media_types@v2.3.6/deps"], function (exports_34, context_34) {
    "use strict";
    var db_ts_1, deps_ts_1, EXTRACT_TYPE_REGEXP, TEXT_TYPE_REGEXP, extensions, types;
    var __moduleName = context_34 && context_34.id;
    /** Internal function to populate the maps based on the Mime DB */
    function populateMaps(extensions, types) {
        const preference = ["nginx", "apache", undefined, "iana"];
        for (const type of Object.keys(db_ts_1.db)) {
            const mime = db_ts_1.db[type];
            const exts = mime.extensions;
            if (!exts || !exts.length) {
                continue;
            }
            extensions.set(type, exts);
            for (const ext of exts) {
                const current = types.get(ext);
                if (current) {
                    const from = preference.indexOf(db_ts_1.db[current].source);
                    const to = preference.indexOf(mime.source);
                    if (current !== "application/octet-stream" &&
                        (from > to ||
                            (from === to && current.substr(0, 12) === "application/"))) {
                        continue;
                    }
                }
                types.set(ext, type);
            }
        }
    }
    /** Given a media type return any default charset string.  Returns `undefined`
     * if not resolvable.
     */
    function charset(type) {
        const m = EXTRACT_TYPE_REGEXP.exec(type);
        if (!m) {
            return;
        }
        const [match] = m;
        const mime = db_ts_1.db[match.toLowerCase()];
        if (mime && mime.charset) {
            return mime.charset;
        }
        if (TEXT_TYPE_REGEXP.test(match)) {
            return "UTF-8";
        }
    }
    exports_34("charset", charset);
    /** Given an extension, lookup the appropriate media type for that extension.
     * Likely you should be using `contentType()` though instead.
     */
    function lookup(path) {
        const extension = deps_ts_1.extname("x." + path)
            .toLowerCase()
            .substr(1);
        return types.get(extension);
    }
    exports_34("lookup", lookup);
    /** Given an extension or media type, return the full `Content-Type` header
     * string.  Returns `undefined` if not resolvable.
     */
    function contentType(str) {
        let mime = str.includes("/") ? str : lookup(str);
        if (!mime) {
            return;
        }
        if (!mime.includes("charset")) {
            const cs = charset(mime);
            if (cs) {
                mime += `; charset=${cs.toLowerCase()}`;
            }
        }
        return mime;
    }
    exports_34("contentType", contentType);
    /** Given a media type, return the most appropriate extension or return
     * `undefined` if there is none.
     */
    function extension(type) {
        const match = EXTRACT_TYPE_REGEXP.exec(type);
        if (!match) {
            return;
        }
        const exts = extensions.get(match[1].toLowerCase());
        if (!exts || !exts.length) {
            return;
        }
        return exts[0];
    }
    exports_34("extension", extension);
    return {
        setters: [
            function (db_ts_1_1) {
                db_ts_1 = db_ts_1_1;
            },
            function (deps_ts_1_1) {
                deps_ts_1 = deps_ts_1_1;
            }
        ],
        execute: function () {
            EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
            TEXT_TYPE_REGEXP = /^text\//i;
            /** A map of extensions for a given media type */
            exports_34("extensions", extensions = new Map());
            /** A map of the media type for a given extension */
            exports_34("types", types = new Map());
            // Populate the maps upon module load
            populateMaps(extensions, types);
        }
    };
});
System.register("https://linweiwei123.github.io/aok/path_to_regexp", [], function (exports_35, context_35) {
    "use strict";
    var __moduleName = context_35 && context_35.id;
    /**
     * Tokenize input string.
     */
    function lexer(str) {
        const tokens = [];
        let i = 0;
        while (i < str.length) {
            const char = str[i];
            if (char === "*" || char === "+" || char === "?") {
                tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
                continue;
            }
            if (char === "\\") {
                tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
                continue;
            }
            if (char === "{") {
                tokens.push({ type: "OPEN", index: i, value: str[i++] });
                continue;
            }
            if (char === "}") {
                tokens.push({ type: "CLOSE", index: i, value: str[i++] });
                continue;
            }
            if (char === ":") {
                let name = "";
                let j = i + 1;
                while (j < str.length) {
                    const code = str.charCodeAt(j);
                    if (
                    // `0-9`
                    (code >= 48 && code <= 57) ||
                        // `A-Z`
                        (code >= 65 && code <= 90) ||
                        // `a-z`
                        (code >= 97 && code <= 122) ||
                        // `_`
                        code === 95) {
                        name += str[j++];
                        continue;
                    }
                    break;
                }
                if (!name)
                    throw new TypeError(`Missing parameter name at ${i}`);
                tokens.push({ type: "NAME", index: i, value: name });
                i = j;
                continue;
            }
            if (char === "(") {
                let count = 1;
                let pattern = "";
                let j = i + 1;
                if (str[j] === "?") {
                    throw new TypeError(`Pattern cannot start with "?" at ${j}`);
                }
                while (j < str.length) {
                    if (str[j] === "\\") {
                        pattern += str[j++] + str[j++];
                        continue;
                    }
                    if (str[j] === ")") {
                        count--;
                        if (count === 0) {
                            j++;
                            break;
                        }
                    }
                    else if (str[j] === "(") {
                        count++;
                        if (str[j + 1] !== "?") {
                            throw new TypeError(`Capturing groups are not allowed at ${j}`);
                        }
                    }
                    pattern += str[j++];
                }
                if (count)
                    throw new TypeError(`Unbalanced pattern at ${i}`);
                if (!pattern)
                    throw new TypeError(`Missing pattern at ${i}`);
                tokens.push({ type: "PATTERN", index: i, value: pattern });
                i = j;
                continue;
            }
            tokens.push({ type: "CHAR", index: i, value: str[i++] });
        }
        tokens.push({ type: "END", index: i, value: "" });
        return tokens;
    }
    /**
     * Parse a string for the raw tokens.
     */
    function parse(str, options = {}) {
        const tokens = lexer(str);
        const { prefixes = "./" } = options;
        const defaultPattern = `[^${escapeString(options.delimiter || "/#?")}]+?`;
        const result = [];
        let key = 0;
        let i = 0;
        let path = "";
        const tryConsume = (type) => {
            if (i < tokens.length && tokens[i].type === type)
                return tokens[i++].value;
        };
        const mustConsume = (type) => {
            const value = tryConsume(type);
            if (value !== undefined)
                return value;
            const { type: nextType, index } = tokens[i];
            throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);
        };
        const consumeText = () => {
            let result = "";
            let value;
            // tslint:disable-next-line
            while ((value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR"))) {
                result += value;
            }
            return result;
        };
        while (i < tokens.length) {
            const char = tryConsume("CHAR");
            const name = tryConsume("NAME");
            const pattern = tryConsume("PATTERN");
            if (name || pattern) {
                let prefix = char || "";
                if (prefixes.indexOf(prefix) === -1) {
                    path += prefix;
                    prefix = "";
                }
                if (path) {
                    result.push(path);
                    path = "";
                }
                result.push({
                    name: name || key++,
                    prefix,
                    suffix: "",
                    pattern: pattern || defaultPattern,
                    modifier: tryConsume("MODIFIER") || ""
                });
                continue;
            }
            const value = char || tryConsume("ESCAPED_CHAR");
            if (value) {
                path += value;
                continue;
            }
            if (path) {
                result.push(path);
                path = "";
            }
            const open = tryConsume("OPEN");
            if (open) {
                const prefix = consumeText();
                const name = tryConsume("NAME") || "";
                const pattern = tryConsume("PATTERN") || "";
                const suffix = consumeText();
                mustConsume("CLOSE");
                result.push({
                    name: name || (pattern ? key++ : ""),
                    pattern: name && !pattern ? defaultPattern : pattern,
                    prefix,
                    suffix,
                    modifier: tryConsume("MODIFIER") || ""
                });
                continue;
            }
            mustConsume("END");
        }
        return result;
    }
    exports_35("parse", parse);
    /**
     * Compile a string to a template function for the path.
     */
    function compile(str, options) {
        return tokensToFunction(parse(str, options), options);
    }
    exports_35("compile", compile);
    /**
     * Expose a method for transforming tokens into the path function.
     */
    function tokensToFunction(tokens, options = {}) {
        const reFlags = flags(options);
        const { encode = (x) => x, validate = true } = options;
        // Compile all the tokens into regexps.
        const matches = tokens.map(token => {
            if (typeof token === "object") {
                return new RegExp(`^(?:${token.pattern})$`, reFlags);
            }
        });
        return (data) => {
            let path = "";
            for (let i = 0; i < tokens.length; i++) {
                const token = tokens[i];
                if (typeof token === "string") {
                    path += token;
                    continue;
                }
                const value = data ? data[token.name] : undefined;
                const optional = token.modifier === "?" || token.modifier === "*";
                const repeat = token.modifier === "*" || token.modifier === "+";
                if (Array.isArray(value)) {
                    if (!repeat) {
                        throw new TypeError(`Expected "${token.name}" to not repeat, but got an array`);
                    }
                    if (value.length === 0) {
                        if (optional)
                            continue;
                        throw new TypeError(`Expected "${token.name}" to not be empty`);
                    }
                    for (let j = 0; j < value.length; j++) {
                        const segment = encode(value[j], token);
                        if (validate && !matches[i].test(segment)) {
                            throw new TypeError(`Expected all "${token.name}" to match "${token.pattern}", but got "${segment}"`);
                        }
                        path += token.prefix + segment + token.suffix;
                    }
                    continue;
                }
                if (typeof value === "string" || typeof value === "number") {
                    const segment = encode(String(value), token);
                    if (validate && !matches[i].test(segment)) {
                        throw new TypeError(`Expected "${token.name}" to match "${token.pattern}", but got "${segment}"`);
                    }
                    path += token.prefix + segment + token.suffix;
                    continue;
                }
                if (optional)
                    continue;
                const typeOfMessage = repeat ? "an array" : "a string";
                throw new TypeError(`Expected "${token.name}" to be ${typeOfMessage}`);
            }
            return path;
        };
    }
    exports_35("tokensToFunction", tokensToFunction);
    /**
     * Create path match function from `path-to-regexp` spec.
     */
    function match(str, options) {
        const keys = [];
        const re = pathToRegexp(str, keys, options);
        return regexpToFunction(re, keys, options);
    }
    exports_35("match", match);
    /**
     * Create a path match function from `path-to-regexp` output.
     */
    function regexpToFunction(re, keys, options = {}) {
        const { decode = (x) => x } = options;
        return function (pathname) {
            const m = re.exec(pathname);
            if (!m)
                return false;
            const { 0: path, index } = m;
            const params = Object.create(null);
            for (let i = 1; i < m.length; i++) {
                // tslint:disable-next-line
                if (m[i] === undefined)
                    continue;
                const key = keys[i - 1];
                if (key.modifier === "*" || key.modifier === "+") {
                    params[key.name] = m[i].split(key.prefix + key.suffix).map(value => {
                        return decode(value, key);
                    });
                }
                else {
                    params[key.name] = decode(m[i], key);
                }
            }
            return { path, index, params };
        };
    }
    exports_35("regexpToFunction", regexpToFunction);
    /**
     * Escape a regular expression string.
     */
    function escapeString(str) {
        return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
    }
    /**
     * Get the flags for a regexp from the options.
     */
    function flags(options) {
        return options && options.sensitive ? "" : "i";
    }
    /**
     * Pull out keys from a regexp.
     */
    function regexpToRegexp(path, keys) {
        if (!keys)
            return path;
        // Use a negative lookahead to match only capturing groups.
        const groups = path.source.match(/\((?!\?)/g);
        if (groups) {
            for (let i = 0; i < groups.length; i++) {
                keys.push({
                    name: i,
                    prefix: "",
                    suffix: "",
                    modifier: "",
                    pattern: ""
                });
            }
        }
        return path;
    }
    /**
     * Transform an array into a regexp.
     */
    function arrayToRegexp(paths, keys, options) {
        const parts = paths.map(path => pathToRegexp(path, keys, options).source);
        return new RegExp(`(?:${parts.join("|")})`, flags(options));
    }
    /**
     * Create a path regexp from string input.
     */
    function stringToRegexp(path, keys, options) {
        return tokensToRegexp(parse(path, options), keys, options);
    }
    /**
     * Expose a function for taking tokens and returning a RegExp.
     */
    function tokensToRegexp(tokens, keys, options = {}) {
        const { strict = false, start = true, end = true, encode = (x) => x } = options;
        const endsWith = `[${escapeString(options.endsWith || "")}]|$`;
        const delimiter = `[${escapeString(options.delimiter || "/#?")}]`;
        let route = start ? "^" : "";
        // Iterate over the tokens and create our regexp string.
        for (const token of tokens) {
            if (typeof token === "string") {
                route += escapeString(encode(token));
            }
            else {
                const prefix = escapeString(encode(token.prefix));
                const suffix = escapeString(encode(token.suffix));
                if (token.pattern) {
                    if (keys)
                        keys.push(token);
                    if (prefix || suffix) {
                        if (token.modifier === "+" || token.modifier === "*") {
                            const mod = token.modifier === "*" ? "?" : "";
                            route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;
                        }
                        else {
                            route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;
                        }
                    }
                    else {
                        route += `(${token.pattern})${token.modifier}`;
                    }
                }
                else {
                    route += `(?:${prefix}${suffix})${token.modifier}`;
                }
            }
        }
        if (end) {
            if (!strict)
                route += `${delimiter}?`;
            route += !options.endsWith ? "$" : `(?=${endsWith})`;
        }
        else {
            const endToken = tokens[tokens.length - 1];
            const isEndDelimited = typeof endToken === "string"
                ? delimiter.indexOf(endToken[endToken.length - 1]) > -1
                : // tslint:disable-next-line
                    endToken === undefined;
            if (!strict) {
                route += `(?:${delimiter}(?=${endsWith}))?`;
            }
            if (!isEndDelimited) {
                route += `(?=${delimiter}|${endsWith})`;
            }
        }
        return new RegExp(route, flags(options));
    }
    exports_35("tokensToRegexp", tokensToRegexp);
    /**
     * Normalize the given path string, returning a regular expression.
     *
     * An empty array can be passed in for the keys, which will hold the
     * placeholder key descriptions. For example, using `/user/:id`, `keys` will
     * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
     */
    function pathToRegexp(path, keys, options) {
        if (path instanceof RegExp)
            return regexpToRegexp(path, keys);
        if (Array.isArray(path))
            return arrayToRegexp(path, keys, options);
        return stringToRegexp(path, keys, options);
    }
    exports_35("pathToRegexp", pathToRegexp);
    return {
        setters: [],
        execute: function () {
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://linweiwei123.github.io/aok/deps", ["https://deno.land/std@0.57.0/bytes/mod", "https://deno.land/std@0.57.0/hash/sha1", "https://deno.land/std@0.57.0/hash/sha256", "https://deno.land/std@0.57.0/http/server", "https://deno.land/std@0.57.0/http/http_status", "https://deno.land/std@0.57.0/io/bufio", "https://deno.land/std@0.57.0/io/util", "https://deno.land/std@0.57.0/path/mod", "https://deno.land/std@0.57.0/testing/asserts", "https://deno.land/std@0.57.0/ws/mod", "https://deno.land/x/media_types@v2.3.6/mod", "https://linweiwei123.github.io/aok/path_to_regexp"], function (exports_36, context_36) {
    "use strict";
    var __moduleName = context_36 && context_36.id;
    return {
        setters: [
            function (mod_ts_8_1) {
                exports_36({
                    "equal": mod_ts_8_1["equal"]
                });
            },
            function (sha1_ts_2_1) {
                exports_36({
                    "Sha1": sha1_ts_2_1["Sha1"]
                });
            },
            function (sha256_ts_1_1) {
                exports_36({
                    "HmacSha256": sha256_ts_1_1["HmacSha256"]
                });
            },
            function (server_ts_2_1) {
                exports_36({
                    "serve": server_ts_2_1["serve"],
                    "Server": server_ts_2_1["Server"],
                    "ServerRequest": server_ts_2_1["ServerRequest"],
                    "serveTLS": server_ts_2_1["serveTLS"]
                });
            },
            function (http_status_ts_2_1) {
                exports_36({
                    "Status": http_status_ts_2_1["Status"],
                    "STATUS_TEXT": http_status_ts_2_1["STATUS_TEXT"]
                });
            },
            function (bufio_ts_4_1) {
                exports_36({
                    "BufWriter": bufio_ts_4_1["BufWriter"]
                });
            },
            function (util_ts_4_1) {
                exports_36({
                    "copyBytes": util_ts_4_1["copyBytes"]
                });
            },
            function (mod_ts_9_1) {
                exports_36({
                    "basename": mod_ts_9_1["basename"],
                    "extname": mod_ts_9_1["extname"],
                    "join": mod_ts_9_1["join"],
                    "isAbsolute": mod_ts_9_1["isAbsolute"],
                    "normalize": mod_ts_9_1["normalize"],
                    "parse": mod_ts_9_1["parse"],
                    "resolve": mod_ts_9_1["resolve"],
                    "sep": mod_ts_9_1["sep"]
                });
            },
            function (asserts_ts_1_1) {
                exports_36({
                    "assert": asserts_ts_1_1["assert"]
                });
            },
            function (mod_ts_10_1) {
                exports_36({
                    "acceptable": mod_ts_10_1["acceptable"],
                    "acceptWebSocket": mod_ts_10_1["acceptWebSocket"]
                });
            },
            function (mod_ts_11_1) {
                exports_36({
                    "contentType": mod_ts_11_1["contentType"],
                    "extension": mod_ts_11_1["extension"],
                    "lookup": mod_ts_11_1["lookup"]
                });
            },
            function (path_to_regexp_ts_1_1) {
                exports_36({
                    "compile": path_to_regexp_ts_1_1["compile"],
                    "pathParse": path_to_regexp_ts_1_1["parse"],
                    "pathToRegexp": path_to_regexp_ts_1_1["pathToRegexp"]
                });
            }
        ],
        execute: function () {
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://linweiwei123.github.io/aok/tssCompare", ["https://linweiwei123.github.io/aok/deps"], function (exports_37, context_37) {
    "use strict";
    var deps_ts_2;
    var __moduleName = context_37 && context_37.id;
    function compareArrayBuffer(a, b) {
        deps_ts_2.assert(a.byteLength === b.byteLength, "ArrayBuffer lengths must match.");
        const va = new DataView(a);
        const vb = new DataView(b);
        const length = va.byteLength;
        let out = 0;
        let i = -1;
        while (++i < length) {
            out |= va.getUint8(i) ^ vb.getUint8(i);
        }
        return out === 0;
    }
    /** Compare two strings, Uint8Arrays, ArrayBuffers, or arrays of numbers in a
     * way that avoids timing based attacks on the comparisons on the values.
     *
     * The function will return `true` if the values match, or `false`, if they
     * do not match. */
    function compare(a, b) {
        const key = new Uint8Array(32);
        window.crypto.getRandomValues(key);
        const ah = (new deps_ts_2.HmacSha256(key)).update(a).arrayBuffer();
        const bh = (new deps_ts_2.HmacSha256(key)).update(b).arrayBuffer();
        return compareArrayBuffer(ah, bh);
    }
    exports_37("compare", compare);
    return {
        setters: [
            function (deps_ts_2_1) {
                deps_ts_2 = deps_ts_2_1;
            }
        ],
        execute: function () {
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://linweiwei123.github.io/aok/keyStack", ["https://linweiwei123.github.io/aok/deps", "https://linweiwei123.github.io/aok/tssCompare"], function (exports_38, context_38) {
    "use strict";
    var deps_ts_3, tssCompare_ts_1, replacements, KeyStack;
    var __moduleName = context_38 && context_38.id;
    return {
        setters: [
            function (deps_ts_3_1) {
                deps_ts_3 = deps_ts_3_1;
            },
            function (tssCompare_ts_1_1) {
                tssCompare_ts_1 = tssCompare_ts_1_1;
            }
        ],
        execute: function () {
            replacements = {
                "/": "_",
                "+": "-",
                "=": "",
            };
            KeyStack = class KeyStack {
                /** A class which accepts an array of keys that are used to sign and verify
                 * data and allows easy key rotation without invalidation of previously signed
                 * data.
                 *
                 * @param keys An array of keys, of which the index 0 will be used to sign
                 *             data, but verification can happen against any key.
                 */
                constructor(keys) {
                    this.#sign = (data, key) => {
                        return btoa(String.fromCharCode.apply(undefined, new Uint8Array(new deps_ts_3.HmacSha256(key).update(data).arrayBuffer())))
                            .replace(/\/|\+|=/g, (c) => replacements[c]);
                    };
                    if (!(0 in keys)) {
                        throw new TypeError("keys must contain at least one value");
                    }
                    this.#keys = keys;
                }
                #keys;
                #sign;
                /** Take `data` and return a SHA256 HMAC digest that uses the current 0 index
                 * of the `keys` passed to the constructor.  This digest is in the form of a
                 * URL safe base64 encoded string. */
                sign(data) {
                    return this.#sign(data, this.#keys[0]);
                }
                /** Given `data` and a `digest`, verify that one of the `keys` provided the
                 * constructor was used to generate the `digest`.  Returns `true` if one of
                 * the keys was used, otherwise `false`. */
                verify(data, digest) {
                    return this.indexOf(data, digest) > -1;
                }
                /** Given `data` and a `digest`, return the current index of the key in the
                 * `keys` passed the constructor that was used to generate the digest.  If no
                 * key can be found, the method returns `-1`. */
                indexOf(data, digest) {
                    for (let i = 0; i < this.#keys.length; i++) {
                        if (tssCompare_ts_1.compare(digest, this.#sign(data, this.#keys[i]))) {
                            return i;
                        }
                    }
                    return -1;
                }
            };
            exports_38("KeyStack", KeyStack);
        }
    };
});
/*!
 * Adapted directly from http-errors at https://github.com/jshttp/http-errors
 * which is licensed as follows:
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Jonathan Ong me@jongleberry.com
 * Copyright (c) 2016 Douglas Christopher Wilson doug@somethingdoug.com
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
System.register("https://linweiwei123.github.io/aok/httpError", ["https://linweiwei123.github.io/aok/deps"], function (exports_39, context_39) {
    "use strict";
    var deps_ts_4, errorStatusMap, HttpError, httpErrors;
    var __moduleName = context_39 && context_39.id;
    function createHttpErrorConstructor(status) {
        const name = `${deps_ts_4.Status[status]}Error`;
        const Ctor = class extends HttpError {
            constructor(message) {
                super();
                this.message = message || deps_ts_4.STATUS_TEXT.get(status);
                this.status = status;
                this.expose = status >= 400 && status < 500 ? true : false;
                Object.defineProperty(this, "name", {
                    configurable: true,
                    enumerable: false,
                    value: name,
                    writable: true,
                });
            }
        };
        return Ctor;
    }
    /** Create a specific class of `HttpError` based on the status, which defaults
     * to _500 Internal Server Error_.
     */
    function createHttpError(status = 500, message) {
        return new httpErrors[deps_ts_4.Status[status]](message);
    }
    exports_39("createHttpError", createHttpError);
    function isHttpError(value) {
        return value instanceof HttpError;
    }
    exports_39("isHttpError", isHttpError);
    return {
        setters: [
            function (deps_ts_4_1) {
                deps_ts_4 = deps_ts_4_1;
            }
        ],
        execute: function () {
            errorStatusMap = {
                "BadRequest": 400,
                "Unauthorized": 401,
                "PaymentRequired": 402,
                "Forbidden": 403,
                "NotFound": 404,
                "MethodNotAllowed": 405,
                "NotAcceptable": 406,
                "ProxyAuthRequired": 407,
                "RequestTimeout": 408,
                "Conflict": 409,
                "Gone": 410,
                "LengthRequired": 411,
                "PreconditionFailed": 412,
                "RequestEntityTooLarge": 413,
                "RequestURITooLong": 414,
                "UnsupportedMediaType": 415,
                "RequestedRangeNotSatisfiable": 416,
                "ExpectationFailed": 417,
                "Teapot": 418,
                "MisdirectedRequest": 421,
                "UnprocessableEntity": 422,
                "Locked": 423,
                "FailedDependency": 424,
                "UpgradeRequired": 426,
                "PreconditionRequired": 428,
                "TooManyRequests": 429,
                "RequestHeaderFieldsTooLarge": 431,
                "UnavailableForLegalReasons": 451,
                "InternalServerError": 500,
                "NotImplemented": 501,
                "BadGateway": 502,
                "ServiceUnavailable": 503,
                "GatewayTimeout": 504,
                "HTTPVersionNotSupported": 505,
                "VariantAlsoNegotiates": 506,
                "InsufficientStorage": 507,
                "LoopDetected": 508,
                "NotExtended": 510,
                "NetworkAuthenticationRequired": 511,
            };
            /** A base class for individual classes of HTTP errors. */
            HttpError = class HttpError extends Error {
                constructor() {
                    super(...arguments);
                    /** Determines if details about the error should be automatically exposed
                     * in a response.  This is automatically set to `true` for 4XX errors, as
                     * they represent errors in the request, while 5XX errors are set to `false`
                     * as they are internal server errors and exposing details could leak
                     * important server security information. */
                    this.expose = false;
                    /** The HTTP error status associated with this class of error. */
                    this.status = deps_ts_4.Status.InternalServerError;
                }
            };
            exports_39("HttpError", HttpError);
            /** An object which contains an individual HTTP Error for each HTTP status
             * error code (4XX and 5XX).  When errors are raised related to a particular
             * HTTP status code, they will be of the appropriate instance located on this
             * object.  Also, context's `.throw()` will throw errors based on the passed
             * status code. */
            exports_39("httpErrors", httpErrors = {});
            for (const [key, value] of Object.entries(errorStatusMap)) {
                httpErrors[key] = createHttpErrorConstructor(value);
            }
        }
    };
});
/*!
 * Adapted directly from media-typer at https://github.com/jshttp/media-typer/
 * which is licensed as follows:
 *
 * media-typer
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
System.register("https://linweiwei123.github.io/aok/mediaTyper", [], function (exports_40, context_40) {
    "use strict";
    var SUBTYPE_NAME_REGEXP, TYPE_NAME_REGEXP, TYPE_REGEXP, MediaType;
    var __moduleName = context_40 && context_40.id;
    /** Given a media type object, return a media type string.
     *
     *       format({
     *         type: "text",
     *         subtype: "html"
     *       }); // returns "text/html"
     */
    function format(obj) {
        const { subtype, suffix, type } = obj;
        if (!TYPE_NAME_REGEXP.test(type)) {
            throw new TypeError("Invalid type.");
        }
        if (!SUBTYPE_NAME_REGEXP.test(subtype)) {
            throw new TypeError("Invalid subtype.");
        }
        let str = `${type}/${subtype}`;
        if (suffix) {
            if (!TYPE_NAME_REGEXP.test(suffix)) {
                throw new TypeError("Invalid suffix.");
            }
            str += `+${suffix}`;
        }
        return str;
    }
    exports_40("format", format);
    /** Given a media type string, return a media type object.
     *
     *       parse("application/json-patch+json");
     *       // returns {
     *       //   type: "application",
     *       //   subtype: "json-patch",
     *       //   suffix: "json"
     *       // }
     */
    function parse(str) {
        const match = TYPE_REGEXP.exec(str.toLowerCase());
        if (!match) {
            throw new TypeError("Invalid media type.");
        }
        let [, type, subtype] = match;
        let suffix;
        const idx = subtype.lastIndexOf("+");
        if (idx !== -1) {
            suffix = subtype.substr(idx + 1);
            subtype = subtype.substr(0, idx);
        }
        return new MediaType(type, subtype, suffix);
    }
    exports_40("parse", parse);
    return {
        setters: [],
        execute: function () {
            SUBTYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
            TYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
            TYPE_REGEXP = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
            MediaType = class MediaType {
                constructor(
                /** The type of the media type. */
                type, 
                /** The subtype of the media type. */
                subtype, 
                /** The optional suffix of the media type. */
                suffix) {
                    this.type = type;
                    this.subtype = subtype;
                    this.suffix = suffix;
                }
            };
        }
    };
});
/*!
 * Adapted directly from type-is at https://github.com/jshttp/type-is/
 * which is licensed as follows:
 *
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
System.register("https://linweiwei123.github.io/aok/isMediaType", ["https://linweiwei123.github.io/aok/deps", "https://linweiwei123.github.io/aok/mediaTyper"], function (exports_41, context_41) {
    "use strict";
    var deps_ts_5, mediaTyper_ts_1;
    var __moduleName = context_41 && context_41.id;
    function mimeMatch(expected, actual) {
        if (expected === undefined) {
            return false;
        }
        const actualParts = actual.split("/");
        const expectedParts = expected.split("/");
        if (actualParts.length !== 2 || expectedParts.length !== 2) {
            return false;
        }
        const [actualType, actualSubtype] = actualParts;
        const [expectedType, expectedSubtype] = expectedParts;
        if (expectedType !== "*" && expectedType !== actualType) {
            return false;
        }
        if (expectedSubtype.substr(0, 2) === "*+") {
            return (expectedSubtype.length <= actualSubtype.length + 1 &&
                expectedSubtype.substr(1) ===
                    actualSubtype.substr(1 - expectedSubtype.length));
        }
        if (expectedSubtype !== "*" && expectedSubtype !== actualSubtype) {
            return false;
        }
        return true;
    }
    function normalize(type) {
        switch (type) {
            case "urlencoded":
                return "application/x-www-form-urlencoded";
            case "multipart":
                return "multipart/*";
        }
        if (type[0] === "+") {
            return `*/*${type}`;
        }
        return type.includes("/") ? type : deps_ts_5.lookup(type);
    }
    function normalizeType(value) {
        try {
            const val = value.split(";");
            const type = mediaTyper_ts_1.parse(val[0]);
            return mediaTyper_ts_1.format(type);
        }
        catch {
            return;
        }
    }
    /** Given a value of the content type of a request and an array of types,
     * provide the matching type or `false` if no types are matched.
     */
    function isMediaType(value, types) {
        const val = normalizeType(value);
        if (!val) {
            return false;
        }
        if (!types.length) {
            return val;
        }
        for (const type of types) {
            if (mimeMatch(normalize(type), val)) {
                return type[0] === "+" || type.includes("*") ? val : type;
            }
        }
        return false;
    }
    exports_41("isMediaType", isMediaType);
    return {
        setters: [
            function (deps_ts_5_1) {
                deps_ts_5 = deps_ts_5_1;
            },
            function (mediaTyper_ts_1_1) {
                mediaTyper_ts_1 = mediaTyper_ts_1_1;
            }
        ],
        execute: function () {
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://linweiwei123.github.io/aok/util", ["https://linweiwei123.github.io/aok/deps", "https://linweiwei123.github.io/aok/httpError"], function (exports_42, context_42) {
    "use strict";
    var deps_ts_6, httpError_ts_1, ENCODE_CHARS_REGEXP, HTAB, SPACE, CR, LF, UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE, UP_PATH_REGEXP;
    var __moduleName = context_42 && context_42.id;
    /** Safely decode a URI component, where if it fails, instead of throwing,
     * just returns the original string
     */
    function decodeComponent(text) {
        try {
            return decodeURIComponent(text);
        }
        catch {
            return text;
        }
    }
    exports_42("decodeComponent", decodeComponent);
    /** Encodes the url preventing double enconding */
    function encodeUrl(url) {
        return String(url)
            .replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE)
            .replace(ENCODE_CHARS_REGEXP, encodeURI);
    }
    exports_42("encodeUrl", encodeUrl);
    function getRandomFilename(prefix = "", extension = "") {
        return `${prefix}${new deps_ts_6.Sha1().update(crypto.getRandomValues(new Uint8Array(256))).hex()}${extension ? `.${extension}` : ""}`;
    }
    exports_42("getRandomFilename", getRandomFilename);
    /** Determines if a HTTP `Status` is an `ErrorStatus` (4XX or 5XX). */
    function isErrorStatus(value) {
        return [
            deps_ts_6.Status.BadRequest,
            deps_ts_6.Status.Unauthorized,
            deps_ts_6.Status.PaymentRequired,
            deps_ts_6.Status.Forbidden,
            deps_ts_6.Status.NotFound,
            deps_ts_6.Status.MethodNotAllowed,
            deps_ts_6.Status.NotAcceptable,
            deps_ts_6.Status.ProxyAuthRequired,
            deps_ts_6.Status.RequestTimeout,
            deps_ts_6.Status.Conflict,
            deps_ts_6.Status.Gone,
            deps_ts_6.Status.LengthRequired,
            deps_ts_6.Status.PreconditionFailed,
            deps_ts_6.Status.RequestEntityTooLarge,
            deps_ts_6.Status.RequestURITooLong,
            deps_ts_6.Status.UnsupportedMediaType,
            deps_ts_6.Status.RequestedRangeNotSatisfiable,
            deps_ts_6.Status.ExpectationFailed,
            deps_ts_6.Status.Teapot,
            deps_ts_6.Status.MisdirectedRequest,
            deps_ts_6.Status.UnprocessableEntity,
            deps_ts_6.Status.Locked,
            deps_ts_6.Status.FailedDependency,
            deps_ts_6.Status.UpgradeRequired,
            deps_ts_6.Status.PreconditionRequired,
            deps_ts_6.Status.TooManyRequests,
            deps_ts_6.Status.RequestHeaderFieldsTooLarge,
            deps_ts_6.Status.UnavailableForLegalReasons,
            deps_ts_6.Status.InternalServerError,
            deps_ts_6.Status.NotImplemented,
            deps_ts_6.Status.BadGateway,
            deps_ts_6.Status.ServiceUnavailable,
            deps_ts_6.Status.GatewayTimeout,
            deps_ts_6.Status.HTTPVersionNotSupported,
            deps_ts_6.Status.VariantAlsoNegotiates,
            deps_ts_6.Status.InsufficientStorage,
            deps_ts_6.Status.LoopDetected,
            deps_ts_6.Status.NotExtended,
            deps_ts_6.Status.NetworkAuthenticationRequired,
        ].includes(value);
    }
    exports_42("isErrorStatus", isErrorStatus);
    /** Determines if a HTTP `Status` is a `RedirectStatus` (3XX). */
    function isRedirectStatus(value) {
        return [
            deps_ts_6.Status.MultipleChoices,
            deps_ts_6.Status.MovedPermanently,
            deps_ts_6.Status.Found,
            deps_ts_6.Status.SeeOther,
            deps_ts_6.Status.UseProxy,
            deps_ts_6.Status.TemporaryRedirect,
            deps_ts_6.Status.PermanentRedirect,
        ].includes(value);
    }
    exports_42("isRedirectStatus", isRedirectStatus);
    /** Determines if a string "looks" like HTML */
    function isHtml(value) {
        return /^\s*<(?:!DOCTYPE|html|body)/i.test(value);
    }
    exports_42("isHtml", isHtml);
    /** Returns `u8` with leading white space removed. */
    function skipLWSPChar(u8) {
        const result = new Uint8Array(u8.length);
        let j = 0;
        for (let i = 0; i < u8.length; i++) {
            if (u8[i] === SPACE || u8[i] === HTAB)
                continue;
            result[j++] = u8[i];
        }
        return result.slice(0, j);
    }
    exports_42("skipLWSPChar", skipLWSPChar);
    function stripEol(value) {
        if (value[value.byteLength - 1] == LF) {
            let drop = 1;
            if (value.byteLength > 1 && value[value.byteLength - 2] === CR) {
                drop = 2;
            }
            return value.subarray(0, value.byteLength - drop);
        }
        return value;
    }
    exports_42("stripEol", stripEol);
    function resolvePath(rootPath, relativePath) {
        let path = relativePath;
        let root = rootPath;
        // root is optional, similar to root.resolve
        if (arguments.length === 1) {
            path = rootPath;
            root = Deno.cwd();
        }
        if (path == null) {
            throw new TypeError("Argument relativePath is required.");
        }
        // containing NULL bytes is malicious
        if (path.includes("\0")) {
            throw httpError_ts_1.createHttpError(400, "Malicious Path");
        }
        // path should never be absolute
        if (deps_ts_6.isAbsolute(path)) {
            throw httpError_ts_1.createHttpError(400, "Malicious Path");
        }
        // path outside root
        if (UP_PATH_REGEXP.test(deps_ts_6.normalize("." + deps_ts_6.sep + path))) {
            throw httpError_ts_1.createHttpError(403);
        }
        // join the relative path
        return deps_ts_6.normalize(deps_ts_6.join(deps_ts_6.resolve(root), path));
    }
    exports_42("resolvePath", resolvePath);
    return {
        setters: [
            function (deps_ts_6_1) {
                deps_ts_6 = deps_ts_6_1;
            },
            function (httpError_ts_1_1) {
                httpError_ts_1 = httpError_ts_1_1;
            }
        ],
        execute: function () {
            ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
            HTAB = "\t".charCodeAt(0);
            SPACE = " ".charCodeAt(0);
            CR = "\r".charCodeAt(0);
            LF = "\n".charCodeAt(0);
            UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
            UNMATCHED_SURROGATE_PAIR_REPLACE = "$1\uFFFD$2";
            /*!
             * Adapted directly from https://github.com/pillarjs/resolve-path
             * which is licensed as follows:
             *
             * The MIT License (MIT)
             *
             * Copyright (c) 2014 Jonathan Ong <me@jongleberry.com>
             * Copyright (c) 2015-2018 Douglas Christopher Wilson <doug@somethingdoug.com>
             *
             * Permission is hereby granted, free of charge, to any person obtaining
             * a copy of this software and associated documentation files (the
             * 'Software'), to deal in the Software without restriction, including
             * without limitation the rights to use, copy, modify, merge, publish,
             * distribute, sublicense, and/or sell copies of the Software, and to
             * permit persons to whom the Software is furnished to do so, subject to
             * the following conditions:
             *
             * The above copyright notice and this permission notice shall be
             * included in all copies or substantial portions of the Software.
             *
             * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
             * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
             * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
             * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
             * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
             * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
             * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
             */
            UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://linweiwei123.github.io/aok/buf_reader", ["https://linweiwei123.github.io/aok/deps", "https://linweiwei123.github.io/aok/util"], function (exports_43, context_43) {
    "use strict";
    var deps_ts_7, util_ts_5, DEFAULT_BUF_SIZE, MIN_BUF_SIZE, MAX_CONSECUTIVE_EMPTY_READS, CR, LF, BufferFullError, BufReader;
    var __moduleName = context_43 && context_43.id;
    return {
        setters: [
            function (deps_ts_7_1) {
                deps_ts_7 = deps_ts_7_1;
            },
            function (util_ts_5_1) {
                util_ts_5 = util_ts_5_1;
            }
        ],
        execute: function () {
            DEFAULT_BUF_SIZE = 4096;
            MIN_BUF_SIZE = 16;
            MAX_CONSECUTIVE_EMPTY_READS = 100;
            CR = "\r".charCodeAt(0);
            LF = "\n".charCodeAt(0);
            BufferFullError = class BufferFullError extends Error {
                constructor(partial) {
                    super("Buffer full");
                    this.partial = partial;
                    this.name = "BufferFullError";
                }
            };
            exports_43("BufferFullError", BufferFullError);
            /** BufReader implements buffering for a Reader object. */
            BufReader = class BufReader {
                constructor(rd, size = DEFAULT_BUF_SIZE) {
                    this.#posRead = 0;
                    this.#posWrite = 0;
                    this.#eof = false;
                    // Reads a new chunk into the buffer.
                    this.#fill = async () => {
                        // Slide existing data to beginning.
                        if (this.#posRead > 0) {
                            this.#buffer.copyWithin(0, this.#posRead, this.#posWrite);
                            this.#posWrite -= this.#posRead;
                            this.#posRead = 0;
                        }
                        if (this.#posWrite >= this.#buffer.byteLength) {
                            throw Error("bufio: tried to fill full buffer");
                        }
                        // Read new data: try a limited number of times.
                        for (let i = MAX_CONSECUTIVE_EMPTY_READS; i > 0; i--) {
                            const rr = await this.#reader.read(this.#buffer.subarray(this.#posWrite));
                            if (rr === null) {
                                this.#eof = true;
                                return;
                            }
                            deps_ts_7.assert(rr >= 0, "negative read");
                            this.#posWrite += rr;
                            if (rr > 0) {
                                return;
                            }
                        }
                        throw new Error(`No progress after ${MAX_CONSECUTIVE_EMPTY_READS} read() calls`);
                    };
                    this.#reset = (buffer, reader) => {
                        this.#buffer = buffer;
                        this.#reader = reader;
                        this.#eof = false;
                    };
                    if (size < MIN_BUF_SIZE) {
                        size = MIN_BUF_SIZE;
                    }
                    this.#reset(new Uint8Array(size), rd);
                }
                #buffer;
                #reader;
                #posRead;
                #posWrite;
                #eof;
                // Reads a new chunk into the buffer.
                #fill;
                #reset;
                buffered() {
                    return this.#posWrite - this.#posRead;
                }
                async readLine(strip = true) {
                    let line;
                    try {
                        line = await this.readSlice(LF);
                    }
                    catch (err) {
                        let { partial } = err;
                        deps_ts_7.assert(partial instanceof Uint8Array, "Caught error from `readSlice()` without `partial` property");
                        // Don't throw if `readSlice()` failed with `BufferFullError`, instead we
                        // just return whatever is available and set the `more` flag.
                        if (!(err instanceof BufferFullError)) {
                            throw err;
                        }
                        // Handle the case where "\r\n" straddles the buffer.
                        if (!this.#eof &&
                            partial.byteLength > 0 &&
                            partial[partial.byteLength - 1] === CR) {
                            // Put the '\r' back on buf and drop it from line.
                            // Let the next call to ReadLine check for "\r\n".
                            deps_ts_7.assert(this.#posRead > 0, "Tried to rewind past start of buffer");
                            this.#posRead--;
                            partial = partial.subarray(0, partial.byteLength - 1);
                        }
                        return { bytes: partial, eol: this.#eof };
                    }
                    if (line === null) {
                        return null;
                    }
                    if (line.byteLength === 0) {
                        return { bytes: line, eol: true };
                    }
                    if (strip) {
                        line = util_ts_5.stripEol(line);
                    }
                    return { bytes: line, eol: true };
                }
                async readSlice(delim) {
                    let s = 0; // search start index
                    let slice;
                    while (true) {
                        // Search buffer.
                        let i = this.#buffer.subarray(this.#posRead + s, this.#posWrite).indexOf(delim);
                        if (i >= 0) {
                            i += s;
                            slice = this.#buffer.subarray(this.#posRead, this.#posRead + i + 1);
                            this.#posRead += i + 1;
                            break;
                        }
                        // EOF?
                        if (this.#eof) {
                            if (this.#posRead === this.#posWrite) {
                                return null;
                            }
                            slice = this.#buffer.subarray(this.#posRead, this.#posWrite);
                            this.#posRead = this.#posWrite;
                            break;
                        }
                        // Buffer full?
                        if (this.buffered() >= this.#buffer.byteLength) {
                            this.#posRead = this.#posWrite;
                            // #4521 The internal buffer should not be reused across reads because it causes corruption of data.
                            const oldbuf = this.#buffer;
                            const newbuf = this.#buffer.slice(0);
                            this.#buffer = newbuf;
                            throw new BufferFullError(oldbuf);
                        }
                        s = this.#posWrite - this.#posRead; // do not rescan area we scanned before
                        // Buffer is not full.
                        try {
                            await this.#fill();
                        }
                        catch (err) {
                            err.partial = slice;
                            throw err;
                        }
                    }
                    return slice;
                }
            };
            exports_43("BufReader", BufReader);
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://linweiwei123.github.io/aok/headers", ["https://linweiwei123.github.io/aok/httpError"], function (exports_44, context_44) {
    "use strict";
    var httpError_ts_2, COLON, HTAB, SPACE, decoder;
    var __moduleName = context_44 && context_44.id;
    /** With a provided attribute pattern, return a RegExp which will match and
     * capture in the first group the value of the attribute from a header value. */
    function toParamRegExp(attributePattern, flags) {
        // deno-fmt-ignore
        return new RegExp(`(?:^|;)\\s*${attributePattern}\\s*=\\s*` +
            `(` +
            `[^";\\s][^;\\s]*` +
            `|` +
            `"(?:[^"\\\\]|\\\\"?)+"?` +
            `)`, flags);
    }
    exports_44("toParamRegExp", toParamRegExp);
    /** Asynchronously read the headers out of body request and resolve with them as
     * a `Headers` object. */
    async function readHeaders(body) {
        const headers = new Headers();
        let readResult = await body.readLine();
        while (readResult) {
            const { bytes } = readResult;
            if (!bytes.length) {
                return headers;
            }
            let i = bytes.indexOf(COLON);
            if (i === -1) {
                throw new httpError_ts_2.httpErrors.BadRequest(`Malformed header: ${decoder.decode(bytes)}`);
            }
            const key = decoder.decode(bytes.subarray(0, i));
            if (key === "") {
                throw new httpError_ts_2.httpErrors.BadRequest("Invalid header key.");
            }
            i++;
            while (i < bytes.byteLength && (bytes[i] === SPACE || bytes[i] === HTAB)) {
                i++;
            }
            const value = decoder.decode(bytes.subarray(i));
            try {
                headers.append(key, value);
            }
            catch { }
            readResult = await body.readLine();
        }
        throw new httpError_ts_2.httpErrors.BadRequest("Unexpected end of body reached.");
    }
    exports_44("readHeaders", readHeaders);
    /** Unquotes attribute values that might be pass as part of a header. */
    function unquote(value) {
        if (value.startsWith(`"`)) {
            const parts = value.slice(1).split(`\\"`);
            for (let i = 0; i < parts.length; ++i) {
                const quoteIndex = parts[i].indexOf(`"`);
                if (quoteIndex !== -1) {
                    parts[i] = parts[i].slice(0, quoteIndex);
                    parts.length = i + 1; // Truncates and stops the loop
                }
                parts[i] = parts[i].replace(/\\(.)/g, "$1");
            }
            value = parts.join(`"`);
        }
        return value;
    }
    exports_44("unquote", unquote);
    return {
        setters: [
            function (httpError_ts_2_1) {
                httpError_ts_2 = httpError_ts_2_1;
            }
        ],
        execute: function () {
            COLON = ":".charCodeAt(0);
            HTAB = "\t".charCodeAt(0);
            SPACE = " ".charCodeAt(0);
            decoder = new TextDecoder();
        }
    };
});
/**
 * Adapted directly from content-disposition.js at
 * https://github.com/Rob--W/open-in-browser/blob/master/extension/content-disposition.js
 * which is licensed as:
 *
 * (c) 2017 Rob Wu <rob@robwu.nl> (https://robwu.nl)
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
System.register("https://linweiwei123.github.io/aok/content_disposition", ["https://linweiwei123.github.io/aok/headers"], function (exports_45, context_45) {
    "use strict";
    var headers_ts_1, needsEncodingFixup, FILENAME_STAR_REGEX, FILENAME_START_ITER_REGEX, FILENAME_REGEX;
    var __moduleName = context_45 && context_45.id;
    function fixupEncoding(value) {
        if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
            value = textDecode("utf-8", value);
            if (needsEncodingFixup) {
                value = textDecode("iso-8859-1", value);
            }
        }
        return value;
    }
    function rfc2047decode(value) {
        if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
            return value;
        }
        return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, (_, charset, encoding, text) => {
            if (encoding === "q" || encoding === "Q") {
                text = text.replace(/_/g, " ");
                text = text.replace(/=([0-9a-fA-F]{2})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));
                return textDecode(charset, text);
            }
            try {
                text = atob(text);
            }
            catch { }
            return textDecode(charset, text);
        });
    }
    function rfc2231getParam(header) {
        const matches = [];
        let match;
        while ((match = FILENAME_START_ITER_REGEX.exec(header))) {
            const [, ns, quote, part] = match;
            const n = parseInt(ns, 10);
            if (n in matches) {
                if (n === 0) {
                    break;
                }
                continue;
            }
            matches[n] = [quote, part];
        }
        const parts = [];
        for (let n = 0; n < matches.length; ++n) {
            if (!(n in matches)) {
                break;
            }
            let [quote, part] = matches[n];
            part = headers_ts_1.unquote(part);
            if (quote) {
                part = unescape(part);
                if (n === 0) {
                    part = rfc5987decode(part);
                }
            }
            parts.push(part);
        }
        return parts.join("");
    }
    function rfc5987decode(value) {
        const encodingEnd = value.indexOf(`'`);
        if (encodingEnd === -1) {
            return value;
        }
        const encoding = value.slice(0, encodingEnd);
        const langValue = value.slice(encodingEnd + 1);
        return textDecode(encoding, langValue.replace(/^[^']*'/, ""));
    }
    function textDecode(encoding, value) {
        if (encoding) {
            try {
                const decoder = new TextDecoder(encoding, { fatal: true });
                const bytes = Array.from(value, (c) => c.charCodeAt(0));
                if (bytes.every((code) => code <= 0xFF)) {
                    value = decoder.decode(new Uint8Array(bytes));
                    needsEncodingFixup = false;
                }
            }
            catch { }
        }
        return value;
    }
    function getFilename(header) {
        needsEncodingFixup = true;
        // filename*=ext-value ("ext-value" from RFC 5987, referenced by RFC 6266).
        let matches = FILENAME_STAR_REGEX.exec(header);
        if (matches) {
            const [, filename] = matches;
            return fixupEncoding(rfc2047decode(rfc5987decode(unescape(headers_ts_1.unquote(filename)))));
        }
        // Continuations (RFC 2231 section 3, referenced by RFC 5987 section 3.1).
        // filename*n*=part
        // filename*n=part
        const filename = rfc2231getParam(header);
        if (filename) {
            return fixupEncoding(rfc2047decode(filename));
        }
        // filename=value (RFC 5987, section 4.1).
        matches = FILENAME_REGEX.exec(header);
        if (matches) {
            const [, filename] = matches;
            return fixupEncoding(rfc2047decode(headers_ts_1.unquote(filename)));
        }
        return "";
    }
    exports_45("getFilename", getFilename);
    return {
        setters: [
            function (headers_ts_1_1) {
                headers_ts_1 = headers_ts_1_1;
            }
        ],
        execute: function () {
            needsEncodingFixup = false;
            FILENAME_STAR_REGEX = headers_ts_1.toParamRegExp("filename\\*", "i");
            FILENAME_START_ITER_REGEX = headers_ts_1.toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
            FILENAME_REGEX = headers_ts_1.toParamRegExp("filename", "i");
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://linweiwei123.github.io/aok/multipart", ["https://linweiwei123.github.io/aok/buf_reader", "https://linweiwei123.github.io/aok/content_disposition", "https://linweiwei123.github.io/aok/deps", "https://linweiwei123.github.io/aok/headers", "https://linweiwei123.github.io/aok/httpError", "https://linweiwei123.github.io/aok/util"], function (exports_46, context_46) {
    "use strict";
    var buf_reader_ts_1, content_disposition_ts_1, deps_ts_8, headers_ts_2, httpError_ts_3, util_ts_6, decoder, encoder, BOUNDARY_PARAM_REGEX, DEFAULT_BUFFER_SIZE, DEFAULT_MAX_FILE_SIZE, DEFAULT_MAX_SIZE, NAME_PARAM_REGEX, FormDataReader;
    var __moduleName = context_46 && context_46.id;
    function append(a, b) {
        const ab = new Uint8Array(a.length + b.length);
        ab.set(a, 0);
        ab.set(b, a.length);
        return ab;
    }
    function isEqual(a, b) {
        return deps_ts_8.equal(util_ts_6.skipLWSPChar(a), b);
    }
    async function readToStart(body, part) {
        let lineResult;
        let started = false;
        while ((lineResult = await body.readLine())) {
            if (isEqual(lineResult.bytes, part)) {
                started = true;
                break;
            }
        }
        if (!started) {
            throw new httpError_ts_3.httpErrors.BadRequest("Unable to find start of multi-part body.");
        }
    }
    /** Yield up individual parts by reading the body and parsing out the ford
     * data values. */
    async function* parts({ body, final, part, maxFileSize, maxSize, outPath, prefix }) {
        async function getFile(contentType) {
            const ext = deps_ts_8.extension(contentType);
            if (!ext) {
                throw new httpError_ts_3.httpErrors.BadRequest(`Invalid media type for part: ${ext}`);
            }
            if (!outPath) {
                outPath = await Deno.makeTempDir();
            }
            const filename = `${outPath}/${util_ts_6.getRandomFilename(prefix, ext)}`;
            const file = await Deno.open(filename, { write: true, createNew: true });
            return [filename, file];
        }
        while (true) {
            const headers = await headers_ts_2.readHeaders(body);
            const contentType = headers.get("content-type");
            const contentDisposition = headers.get("content-disposition");
            if (!contentDisposition) {
                throw new httpError_ts_3.httpErrors.BadRequest("Form data part missing content-disposition header");
            }
            if (!contentDisposition.match(/^form-data;/i)) {
                throw new httpError_ts_3.httpErrors.BadRequest(`Unexpected content-disposition header: "${contentDisposition}"`);
            }
            const matches = NAME_PARAM_REGEX.exec(contentDisposition);
            if (!matches) {
                throw new httpError_ts_3.httpErrors.BadRequest(`Unable to determine name of form body part`);
            }
            let [, name] = matches;
            name = headers_ts_2.unquote(name);
            if (contentType) {
                const originalName = content_disposition_ts_1.getFilename(contentDisposition);
                let byteLength = 0;
                let file;
                let filename;
                let buf;
                if (maxSize) {
                    buf = new Uint8Array();
                }
                else {
                    const result = await getFile(contentType);
                    filename = result[0];
                    file = result[1];
                }
                while (true) {
                    const readResult = await body.readLine(false);
                    if (!readResult) {
                        throw new httpError_ts_3.httpErrors.BadRequest("Unexpected EOF reached");
                    }
                    let { bytes } = readResult;
                    const strippedBytes = util_ts_6.stripEol(bytes);
                    if (isEqual(strippedBytes, part) || isEqual(strippedBytes, final)) {
                        if (file) {
                            file.close();
                        }
                        yield [
                            name,
                            {
                                content: buf,
                                contentType,
                                name,
                                filename,
                                originalName,
                            },
                        ];
                        if (isEqual(strippedBytes, final)) {
                            return;
                        }
                        break;
                    }
                    byteLength += bytes.byteLength;
                    if (byteLength > maxFileSize) {
                        if (file) {
                            file.close();
                        }
                        throw new httpError_ts_3.httpErrors.RequestEntityTooLarge(`File size exceeds limit of ${maxFileSize} bytes.`);
                    }
                    if (buf) {
                        if (byteLength > maxSize) {
                            const result = await getFile(contentType);
                            filename = result[0];
                            file = result[1];
                            await Deno.writeAll(file, buf);
                            buf = undefined;
                        }
                        else {
                            buf = append(buf, bytes);
                        }
                    }
                    if (file) {
                        await Deno.writeAll(file, bytes);
                    }
                }
            }
            else {
                const lines = [];
                while (true) {
                    const readResult = await body.readLine();
                    if (!readResult) {
                        throw new httpError_ts_3.httpErrors.BadRequest("Unexpected EOF reached");
                    }
                    const { bytes } = readResult;
                    if (isEqual(bytes, part) || isEqual(bytes, final)) {
                        yield [name, lines.join("\n")];
                        if (isEqual(bytes, final)) {
                            return;
                        }
                        break;
                    }
                    lines.push(decoder.decode(bytes));
                }
            }
        }
    }
    return {
        setters: [
            function (buf_reader_ts_1_1) {
                buf_reader_ts_1 = buf_reader_ts_1_1;
            },
            function (content_disposition_ts_1_1) {
                content_disposition_ts_1 = content_disposition_ts_1_1;
            },
            function (deps_ts_8_1) {
                deps_ts_8 = deps_ts_8_1;
            },
            function (headers_ts_2_1) {
                headers_ts_2 = headers_ts_2_1;
            },
            function (httpError_ts_3_1) {
                httpError_ts_3 = httpError_ts_3_1;
            },
            function (util_ts_6_1) {
                util_ts_6 = util_ts_6_1;
            }
        ],
        execute: function () {
            decoder = new TextDecoder();
            encoder = new TextEncoder();
            BOUNDARY_PARAM_REGEX = headers_ts_2.toParamRegExp("boundary", "i");
            DEFAULT_BUFFER_SIZE = 1048576; // 1mb
            DEFAULT_MAX_FILE_SIZE = 10485760; // 10mb
            DEFAULT_MAX_SIZE = 0; // all files written to disc
            NAME_PARAM_REGEX = headers_ts_2.toParamRegExp("name", "i");
            /** A class which provides an interface to access the fields of a
             * `multipart/form-data` body. */
            FormDataReader = class FormDataReader {
                constructor(contentType, body) {
                    this.#reading = false;
                    const matches = contentType.match(BOUNDARY_PARAM_REGEX);
                    if (!matches) {
                        throw new httpError_ts_3.httpErrors.BadRequest(`Content type "${contentType}" does not contain a valid boundary.`);
                    }
                    let [, boundary] = matches;
                    boundary = headers_ts_2.unquote(boundary);
                    this.#boundaryPart = encoder.encode(`--${boundary}`);
                    this.#boundaryFinal = encoder.encode(`--${boundary}--`);
                    this.#body = body;
                }
                #body;
                #boundaryFinal;
                #boundaryPart;
                #reading;
                /** Reads the multipart body of the response and resolves with an object which
                 * contains fields and files that were part of the response.
                 *
                 * *Note*: this method handles multiple files with the same `name` attribute
                 * in the request, but by design it does not handle multiple fields that share
                 * the same `name`.  If you expect the request body to contain multiple form
                 * data fields with the same name, it is better to use the `.stream()` method
                 * which will iterate over each form data field individually. */
                async read(options = {}) {
                    if (this.#reading) {
                        throw new Error("Body is already being read.");
                    }
                    this.#reading = true;
                    const { outPath, maxFileSize = DEFAULT_MAX_FILE_SIZE, maxSize = DEFAULT_MAX_SIZE, bufferSize = DEFAULT_BUFFER_SIZE, } = options;
                    const body = new buf_reader_ts_1.BufReader(this.#body, bufferSize);
                    await readToStart(body, this.#boundaryPart);
                    const result = { fields: {} };
                    try {
                        for await (const part of parts({
                            body,
                            part: this.#boundaryPart,
                            final: this.#boundaryFinal,
                            maxFileSize,
                            maxSize,
                            outPath,
                        })) {
                            const [key, value] = part;
                            if (typeof value === "string") {
                                result.fields[key] = value;
                            }
                            else {
                                if (!result.files) {
                                    result.files = [];
                                }
                                result.files.push(value);
                            }
                        }
                    }
                    catch (err) {
                        if (err instanceof Deno.errors.PermissionDenied) {
                            console.error(err.stack ? err.stack : `${err.name}: ${err.message}`);
                        }
                        else {
                            throw err;
                        }
                    }
                    return result;
                }
                /** Returns an iterator which will asynchronously yield each part of the form
                 * data.  The yielded value is a tuple, where the first element is the name
                 * of the part and the second element is a `string` or a `FormDataFile`
                 * object. */
                async *stream(options = {}) {
                    if (this.#reading) {
                        throw new Error("Body is already being read.");
                    }
                    this.#reading = true;
                    const { outPath, maxFileSize = DEFAULT_MAX_FILE_SIZE, maxSize = DEFAULT_MAX_SIZE, bufferSize = 32000, } = options;
                    const body = new buf_reader_ts_1.BufReader(this.#body, bufferSize);
                    await readToStart(body, this.#boundaryPart);
                    try {
                        for await (const part of parts({
                            body,
                            part: this.#boundaryPart,
                            final: this.#boundaryFinal,
                            maxFileSize,
                            maxSize,
                            outPath,
                        })) {
                            yield part;
                        }
                    }
                    catch (err) {
                        if (err instanceof Deno.errors.PermissionDenied) {
                            console.error(err.stack ? err.stack : `${err.name}: ${err.message}`);
                        }
                        else {
                            throw err;
                        }
                    }
                }
            };
            exports_46("FormDataReader", FormDataReader);
        }
    };
});
/*!
 * Adapted directly from negotiator at https://github.com/jshttp/negotiator/
 * which is licensed as follows:
 *
 * (The MIT License)
 *
 * Copyright (c) 2012-2014 Federico Romero
 * Copyright (c) 2012-2014 Isaac Z. Schlueter
 * Copyright (c) 2014-2015 Douglas Christopher Wilson
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://linweiwei123.github.io/aok/negotiation/common", [], function (exports_47, context_47) {
    "use strict";
    var __moduleName = context_47 && context_47.id;
    function compareSpecs(a, b) {
        return (b.q - a.q ||
            (b.s ?? 0) - (a.s ?? 0) ||
            (a.o ?? 0) - (b.o ?? 0) ||
            a.i - b.i ||
            0);
    }
    exports_47("compareSpecs", compareSpecs);
    function isQuality(spec) {
        return spec.q > 0;
    }
    exports_47("isQuality", isQuality);
    return {
        setters: [],
        execute: function () {
        }
    };
});
/*!
 * Adapted directly from negotiator at https://github.com/jshttp/negotiator/
 * which is licensed as follows:
 *
 * (The MIT License)
 *
 * Copyright (c) 2012-2014 Federico Romero
 * Copyright (c) 2012-2014 Isaac Z. Schlueter
 * Copyright (c) 2014-2015 Douglas Christopher Wilson
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://linweiwei123.github.io/aok/negotiation/charset", ["https://linweiwei123.github.io/aok/negotiation/common"], function (exports_48, context_48) {
    "use strict";
    var common_ts_2, SIMPLE_CHARSET_REGEXP;
    var __moduleName = context_48 && context_48.id;
    function parseCharset(str, i) {
        const match = SIMPLE_CHARSET_REGEXP.exec(str);
        if (!match) {
            return;
        }
        const [, charset] = match;
        let q = 1;
        if (match[2]) {
            const params = match[2].split(";");
            for (const param of params) {
                const [key, value] = param.trim().split("=");
                if (key === "q") {
                    q = parseFloat(value);
                    break;
                }
            }
        }
        return { charset, q, i };
    }
    function parseAcceptCharset(accept) {
        const accepts = accept.split(",");
        const result = [];
        for (let i = 0; i < accepts.length; i++) {
            const charset = parseCharset(accepts[i].trim(), i);
            if (charset) {
                result.push(charset);
            }
        }
        return result;
    }
    function specify(charset, spec, i) {
        let s = 0;
        if (spec.charset.toLowerCase() === charset.toLocaleLowerCase()) {
            s |= 1;
        }
        else if (spec.charset !== "*") {
            return;
        }
        return { i, o: spec.i, q: spec.q, s };
    }
    function getCharsetPriority(charset, accepted, index) {
        let priority = { i: -1, o: -1, q: 0, s: 0 };
        for (const accepts of accepted) {
            const spec = specify(charset, accepts, index);
            if (spec &&
                ((priority.s ?? 0) - (spec.s ?? 0) || priority.q - spec.q ||
                    (priority.o ?? 0) - (spec.o ?? 0)) < 0) {
                priority = spec;
            }
        }
        return priority;
    }
    function preferredCharsets(accept = "*", provided) {
        const accepts = parseAcceptCharset(accept);
        if (!provided) {
            return accepts
                .filter(common_ts_2.isQuality)
                .sort(common_ts_2.compareSpecs)
                .map((spec) => spec.charset);
        }
        const priorities = provided
            .map((type, index) => getCharsetPriority(type, accepts, index));
        return priorities
            .filter(common_ts_2.isQuality)
            .sort(common_ts_2.compareSpecs)
            .map((priority) => provided[priorities.indexOf(priority)]);
    }
    exports_48("preferredCharsets", preferredCharsets);
    return {
        setters: [
            function (common_ts_2_1) {
                common_ts_2 = common_ts_2_1;
            }
        ],
        execute: function () {
            SIMPLE_CHARSET_REGEXP = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
        }
    };
});
/*!
 * Adapted directly from negotiator at https://github.com/jshttp/negotiator/
 * which is licensed as follows:
 *
 * (The MIT License)
 *
 * Copyright (c) 2012-2014 Federico Romero
 * Copyright (c) 2012-2014 Isaac Z. Schlueter
 * Copyright (c) 2014-2015 Douglas Christopher Wilson
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://linweiwei123.github.io/aok/negotiation/encoding", ["https://linweiwei123.github.io/aok/negotiation/common"], function (exports_49, context_49) {
    "use strict";
    var common_ts_3, simpleEncodingRegExp;
    var __moduleName = context_49 && context_49.id;
    function parseEncoding(str, i) {
        const match = simpleEncodingRegExp.exec(str);
        if (!match) {
            return undefined;
        }
        const encoding = match[1];
        let q = 1;
        if (match[2]) {
            const params = match[2].split(";");
            for (const param of params) {
                const p = param.trim().split("=");
                if (p[0] === "q") {
                    q = parseFloat(p[1]);
                    break;
                }
            }
        }
        return { encoding, q, i };
    }
    function specify(encoding, spec, i = -1) {
        if (!spec.encoding) {
            return;
        }
        let s = 0;
        if (spec.encoding.toLocaleLowerCase() === encoding.toLocaleLowerCase()) {
            s = 1;
        }
        else if (spec.encoding !== "*") {
            return;
        }
        return {
            i,
            o: spec.i,
            q: spec.q,
            s,
        };
    }
    function parseAcceptEncoding(accept) {
        const accepts = accept.split(",");
        const parsedAccepts = [];
        let hasIdentity = false;
        let minQuality = 1;
        for (let i = 0; i < accepts.length; i++) {
            const encoding = parseEncoding(accepts[i].trim(), i);
            if (encoding) {
                parsedAccepts.push(encoding);
                hasIdentity = hasIdentity || !!specify("identity", encoding);
                minQuality = Math.min(minQuality, encoding.q || 1);
            }
        }
        if (!hasIdentity) {
            parsedAccepts.push({
                encoding: "identity",
                q: minQuality,
                i: accepts.length - 1,
            });
        }
        return parsedAccepts;
    }
    function getEncodingPriority(encoding, accepted, index) {
        let priority = { o: -1, q: 0, s: 0, i: 0 };
        for (const s of accepted) {
            const spec = specify(encoding, s, index);
            if (spec &&
                (priority.s - spec.s || priority.q - spec.q ||
                    priority.o - spec.o) <
                    0) {
                priority = spec;
            }
        }
        return priority;
    }
    /** Given an `Accept-Encoding` string, parse out the encoding returning a
     * negotiated encoding based on the `provided` encodings otherwise just a
     * prioritized array of encodings. */
    function preferredEncodings(accept, provided) {
        const accepts = parseAcceptEncoding(accept);
        if (!provided) {
            return accepts
                .filter(common_ts_3.isQuality)
                .sort(common_ts_3.compareSpecs)
                .map((spec) => spec.encoding);
        }
        const priorities = provided.map((type, index) => getEncodingPriority(type, accepts, index));
        return priorities
            .filter(common_ts_3.isQuality)
            .sort(common_ts_3.compareSpecs)
            .map((priority) => provided[priorities.indexOf(priority)]);
    }
    exports_49("preferredEncodings", preferredEncodings);
    return {
        setters: [
            function (common_ts_3_1) {
                common_ts_3 = common_ts_3_1;
            }
        ],
        execute: function () {
            simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
        }
    };
});
/*!
 * Adapted directly from negotiator at https://github.com/jshttp/negotiator/
 * which is licensed as follows:
 *
 * (The MIT License)
 *
 * Copyright (c) 2012-2014 Federico Romero
 * Copyright (c) 2012-2014 Isaac Z. Schlueter
 * Copyright (c) 2014-2015 Douglas Christopher Wilson
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://linweiwei123.github.io/aok/negotiation/language", ["https://linweiwei123.github.io/aok/negotiation/common"], function (exports_50, context_50) {
    "use strict";
    var common_ts_4, SIMPLE_LANGUAGE_REGEXP;
    var __moduleName = context_50 && context_50.id;
    function parseLanguage(str, i) {
        const match = SIMPLE_LANGUAGE_REGEXP.exec(str);
        if (!match) {
            return undefined;
        }
        const [, prefix, suffix] = match;
        const full = suffix ? `${prefix}-${suffix}` : prefix;
        let q = 1;
        if (match[3]) {
            const params = match[3].split(";");
            for (const param of params) {
                const [key, value] = param.trim().split("=");
                if (key === "q") {
                    q = parseFloat(value);
                    break;
                }
            }
        }
        return { prefix, suffix, full, q, i };
    }
    function parseAcceptLanguage(accept) {
        const accepts = accept.split(",");
        const result = [];
        for (let i = 0; i < accepts.length; i++) {
            const language = parseLanguage(accepts[i].trim(), i);
            if (language) {
                result.push(language);
            }
        }
        return result;
    }
    function specify(language, spec, i) {
        const p = parseLanguage(language, i);
        if (!p) {
            return undefined;
        }
        let s = 0;
        if (spec.full.toLowerCase() === p.full.toLowerCase()) {
            s |= 4;
        }
        else if (spec.prefix.toLowerCase() === p.prefix.toLowerCase()) {
            s |= 2;
        }
        else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
            s |= 1;
        }
        else if (spec.full !== "*") {
            return;
        }
        return { i, o: spec.i, q: spec.q, s };
    }
    function getLanguagePriority(language, accepted, index) {
        let priority = { i: -1, o: -1, q: 0, s: 0 };
        for (const accepts of accepted) {
            const spec = specify(language, accepts, index);
            if (spec &&
                ((priority.s ?? 0) - (spec.s ?? 0) || priority.q - spec.q ||
                    (priority.o ?? 0) - (spec.o ?? 0)) < 0) {
                priority = spec;
            }
        }
        return priority;
    }
    function preferredLanguages(accept = "*", provided) {
        const accepts = parseAcceptLanguage(accept);
        if (!provided) {
            return accepts
                .filter(common_ts_4.isQuality)
                .sort(common_ts_4.compareSpecs)
                .map((spec) => spec.full);
        }
        const priorities = provided
            .map((type, index) => getLanguagePriority(type, accepts, index));
        return priorities
            .filter(common_ts_4.isQuality)
            .sort(common_ts_4.compareSpecs)
            .map((priority) => provided[priorities.indexOf(priority)]);
    }
    exports_50("preferredLanguages", preferredLanguages);
    return {
        setters: [
            function (common_ts_4_1) {
                common_ts_4 = common_ts_4_1;
            }
        ],
        execute: function () {
            SIMPLE_LANGUAGE_REGEXP = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
        }
    };
});
/*!
 * Adapted directly from negotiator at https://github.com/jshttp/negotiator/
 * which is licensed as follows:
 *
 * (The MIT License)
 *
 * Copyright (c) 2012-2014 Federico Romero
 * Copyright (c) 2012-2014 Isaac Z. Schlueter
 * Copyright (c) 2014-2015 Douglas Christopher Wilson
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
System.register("https://linweiwei123.github.io/aok/negotiation/mediaType", ["https://linweiwei123.github.io/aok/negotiation/common"], function (exports_51, context_51) {
    "use strict";
    var common_ts_5, simpleMediaTypeRegExp;
    var __moduleName = context_51 && context_51.id;
    function quoteCount(str) {
        let count = 0;
        let index = 0;
        while ((index = str.indexOf(`"`, index)) !== -1) {
            count++;
            index++;
        }
        return count;
    }
    function splitMediaTypes(accept) {
        const accepts = accept.split(",");
        let j = 0;
        for (let i = 1; i < accepts.length; i++) {
            if (quoteCount(accepts[j]) % 2 === 0) {
                accepts[++j] = accepts[i];
            }
            else {
                accepts[j] += `,${accepts[i]}`;
            }
        }
        accepts.length = j + 1;
        return accepts;
    }
    function splitParameters(str) {
        const parameters = str.split(";");
        let j = 0;
        for (let i = 1; i < parameters.length; i++) {
            if (quoteCount(parameters[j]) % 2 === 0) {
                parameters[++j] = parameters[i];
            }
            else {
                parameters[j] += `;${parameters[i]}`;
            }
        }
        parameters.length = j + 1;
        return parameters.map((p) => p.trim());
    }
    function splitKeyValuePair(str) {
        const [key, value] = str.split("=");
        return [key.toLowerCase(), value];
    }
    function parseMediaType(str, i) {
        const match = simpleMediaTypeRegExp.exec(str);
        if (!match) {
            return;
        }
        const params = Object.create(null);
        let q = 1;
        const [, type, subtype, parameters] = match;
        if (parameters) {
            const kvps = splitParameters(parameters).map(splitKeyValuePair);
            for (const [key, val] of kvps) {
                const value = val && val[0] === `"` && val[val.length - 1] === `"`
                    ? val.substr(1, val.length - 2)
                    : val;
                if (key === "q" && value) {
                    q = parseFloat(value);
                    break;
                }
                params[key] = value;
            }
        }
        return { type, subtype, params, q, i };
    }
    function parseAccept(accept) {
        const accepts = splitMediaTypes(accept);
        const mediaTypes = [];
        for (let i = 0; i < accepts.length; i++) {
            const mediaType = parseMediaType(accepts[i].trim(), i);
            if (mediaType) {
                mediaTypes.push(mediaType);
            }
        }
        return mediaTypes;
    }
    function getFullType(spec) {
        return `${spec.type}/${spec.subtype}`;
    }
    function specify(type, spec, index) {
        const p = parseMediaType(type, index);
        if (!p) {
            return;
        }
        let s = 0;
        if (spec.type.toLowerCase() === p.type.toLowerCase()) {
            s |= 4;
        }
        else if (spec.type !== "*") {
            return;
        }
        if (spec.subtype.toLowerCase() === p.subtype.toLowerCase()) {
            s |= 2;
        }
        else if (spec.subtype !== "*") {
            return;
        }
        const keys = Object.keys(spec.params);
        if (keys.length) {
            if (keys.every((key) => (spec.params[key] || "").toLowerCase() ===
                (p.params[key] || "").toLowerCase())) {
                s |= 1;
            }
            else {
                return;
            }
        }
        return {
            i: index,
            o: spec.o,
            q: spec.q,
            s,
        };
    }
    function getMediaTypePriority(type, accepted, index) {
        let priority = { o: -1, q: 0, s: 0, i: index };
        for (const accepts of accepted) {
            const spec = specify(type, accepts, index);
            if (spec &&
                ((priority.s || 0) - (spec.s || 0) ||
                    (priority.q || 0) - (spec.q || 0) ||
                    (priority.o || 0) - (spec.o || 0)) < 0) {
                priority = spec;
            }
        }
        return priority;
    }
    function preferredMediaTypes(accept, provided) {
        const accepts = parseAccept(accept === undefined ? "*/*" : accept || "");
        if (!provided) {
            return accepts
                .filter(common_ts_5.isQuality)
                .sort(common_ts_5.compareSpecs)
                .map(getFullType);
        }
        const priorities = provided.map((type, index) => {
            return getMediaTypePriority(type, accepts, index);
        });
        return priorities
            .filter(common_ts_5.isQuality)
            .sort(common_ts_5.compareSpecs)
            .map((priority) => provided[priorities.indexOf(priority)]);
    }
    exports_51("preferredMediaTypes", preferredMediaTypes);
    return {
        setters: [
            function (common_ts_5_1) {
                common_ts_5 = common_ts_5_1;
            }
        ],
        execute: function () {
            simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://linweiwei123.github.io/aok/request", ["https://linweiwei123.github.io/aok/httpError", "https://linweiwei123.github.io/aok/isMediaType", "https://linweiwei123.github.io/aok/multipart", "https://linweiwei123.github.io/aok/negotiation/charset", "https://linweiwei123.github.io/aok/negotiation/encoding", "https://linweiwei123.github.io/aok/negotiation/language", "https://linweiwei123.github.io/aok/negotiation/mediaType"], function (exports_52, context_52) {
    "use strict";
    var httpError_ts_4, isMediaType_ts_1, multipart_ts_1, charset_ts_1, encoding_ts_1, language_ts_1, mediaType_ts_1, decoder, defaultBodyContentTypes, Request;
    var __moduleName = context_52 && context_52.id;
    return {
        setters: [
            function (httpError_ts_4_1) {
                httpError_ts_4 = httpError_ts_4_1;
            },
            function (isMediaType_ts_1_1) {
                isMediaType_ts_1 = isMediaType_ts_1_1;
            },
            function (multipart_ts_1_1) {
                multipart_ts_1 = multipart_ts_1_1;
            },
            function (charset_ts_1_1) {
                charset_ts_1 = charset_ts_1_1;
            },
            function (encoding_ts_1_1) {
                encoding_ts_1 = encoding_ts_1_1;
            },
            function (language_ts_1_1) {
                language_ts_1 = language_ts_1_1;
            },
            function (mediaType_ts_1_1) {
                mediaType_ts_1 = mediaType_ts_1_1;
            }
        ],
        execute: function () {
            decoder = new TextDecoder();
            defaultBodyContentTypes = {
                json: ["json", "application/*+json", "application/csp-report"],
                form: ["urlencoded"],
                formData: ["multipart"],
                text: ["text"],
            };
            /** An interface which provides information about the current request. */
            Request = class Request {
                constructor(serverRequest, proxy = false, secure = false) {
                    this.#proxy = proxy;
                    this.#secure = secure;
                    this.#serverRequest = serverRequest;
                }
                #body;
                #proxy;
                #rawBodyPromise;
                #secure;
                #serverRequest;
                #url;
                /** Is `true` if the request has a body, otherwise `false`. */
                get hasBody() {
                    return (this.headers.get("transfer-encoding") !== null ||
                        !!parseInt(this.headers.get("content-length") ?? ""));
                }
                /** The `Headers` supplied in the request. */
                get headers() {
                    return this.#serverRequest.headers;
                }
                /** Request remote address. When the application's `.proxy` is true, the
                 * `X-Forwarded-For` will be used to determine the requesting remote address.
                 */
                get ip() {
                    return this.#proxy
                        ? this.ips[0]
                        : this.#serverRequest.conn.remoteAddr.hostname;
                }
                /** When the application's `.proxy` is `true`, this will be set to an array of
                 * IPs, ordered from upstream to downstream, based on the value of the header
                 * `X-Forwarded-For`.  When `false` an empty array is returned. */
                get ips() {
                    return this.#proxy
                        ? (this.#serverRequest.headers.get("x-forwarded-for") ??
                            this.#serverRequest.conn.remoteAddr.hostname).split(/\s*,\s*/)
                        : [];
                }
                /** The HTTP Method used by the request. */
                get method() {
                    return this.#serverRequest.method;
                }
                /** Shortcut to `request.url.protocol === "https:"`. */
                get secure() {
                    return this.#secure;
                }
                /** Set to the value of the _original_ Deno server request. */
                get serverRequest() {
                    return this.#serverRequest;
                }
                /** A parsed URL for the request which complies with the browser standards.
                 * When the application's `.proxy` is `true`, this value will be based off of
                 * the `X-Forwarded-Proto` and `X-Forwarded-Host` header values if present in
                 * the request. */
                get url() {
                    if (!this.#url) {
                        const serverRequest = this.#serverRequest;
                        let proto;
                        let host;
                        if (this.#proxy) {
                            proto = serverRequest
                                .headers.get("x-forwarded-proto")?.split(/\s*,\s*/, 1)[0] ??
                                "http";
                            host = serverRequest.headers.get("x-forwarded-host") ??
                                serverRequest.headers.get("host") ?? "";
                        }
                        else {
                            proto = this.#secure ? "https" : "http";
                            host = serverRequest.headers.get("host") ?? "";
                        }
                        this.#url = new URL(`${proto}://${host}${serverRequest.url}`);
                    }
                    return this.#url;
                }
                accepts(...types) {
                    const acceptValue = this.#serverRequest.headers.get("Accept");
                    if (!acceptValue) {
                        return;
                    }
                    if (types.length) {
                        return mediaType_ts_1.preferredMediaTypes(acceptValue, types)[0];
                    }
                    return mediaType_ts_1.preferredMediaTypes(acceptValue);
                }
                acceptsCharsets(...charsets) {
                    const acceptCharsetValue = this.#serverRequest.headers.get("Accept-Charset");
                    if (!acceptCharsetValue) {
                        return;
                    }
                    if (charsets.length) {
                        return charset_ts_1.preferredCharsets(acceptCharsetValue, charsets)[0];
                    }
                    return charset_ts_1.preferredCharsets(acceptCharsetValue);
                }
                acceptsEncodings(...encodings) {
                    const acceptEncodingValue = this.#serverRequest.headers.get("Accept-Encoding");
                    if (!acceptEncodingValue) {
                        return;
                    }
                    if (encodings.length) {
                        return encoding_ts_1.preferredEncodings(acceptEncodingValue, encodings)[0];
                    }
                    return encoding_ts_1.preferredEncodings(acceptEncodingValue);
                }
                acceptsLanguages(...langs) {
                    const acceptLanguageValue = this.#serverRequest.headers.get("Accept-Language");
                    if (!acceptLanguageValue) {
                        return;
                    }
                    if (langs.length) {
                        return language_ts_1.preferredLanguages(acceptLanguageValue, langs)[0];
                    }
                    return language_ts_1.preferredLanguages(acceptLanguageValue);
                }
                async body({ asReader, contentTypes = {} } = {}) {
                    if (this.#body) {
                        if (asReader && this.#body.type !== "reader") {
                            return Promise.reject(new TypeError(`Body already consumed as type: "${this.#body.type}".`));
                        }
                        else if (this.#body.type === "reader") {
                            return Promise.reject(new TypeError(`Body already consumed as type: "reader".`));
                        }
                        return this.#body;
                    }
                    const encoding = this.headers.get("content-encoding") || "identity";
                    if (encoding !== "identity") {
                        throw new httpError_ts_4.httpErrors.UnsupportedMediaType(`Unsupported content-encoding: ${encoding}`);
                    }
                    if (!this.hasBody) {
                        return (this.#body = { type: "undefined", value: undefined });
                    }
                    const contentType = this.headers.get("content-type");
                    if (contentType) {
                        if (asReader) {
                            return (this.#body = {
                                type: "reader",
                                value: this.#serverRequest.body,
                            });
                        }
                        const contentTypesFormData = [
                            ...defaultBodyContentTypes.formData,
                            ...(contentTypes.formData ?? []),
                        ];
                        if (isMediaType_ts_1.isMediaType(contentType, contentTypesFormData)) {
                            return (this.#body = {
                                type: "form-data",
                                value: new multipart_ts_1.FormDataReader(contentType, this.#serverRequest.body),
                            });
                        }
                        const rawBody = await (this.#rawBodyPromise ??
                            (this.#rawBodyPromise = Deno.readAll(this.#serverRequest.body)));
                        const value = decoder.decode(rawBody);
                        const contentTypesRaw = contentTypes.raw;
                        const contentTypesJson = [
                            ...defaultBodyContentTypes.json,
                            ...(contentTypes.json ?? []),
                        ];
                        const contentTypesForm = [
                            ...defaultBodyContentTypes.form,
                            ...(contentTypes.form ?? []),
                        ];
                        const contentTypesText = [
                            ...defaultBodyContentTypes.text,
                            ...(contentTypes.text ?? []),
                        ];
                        console.log("contentType", contentType);
                        if (contentTypesRaw && isMediaType_ts_1.isMediaType(contentType, contentTypesRaw)) {
                            return (this.#body = { type: "raw", value: rawBody });
                        }
                        else if (isMediaType_ts_1.isMediaType(contentType, contentTypesJson)) {
                            return (this.#body = { type: "json", value: JSON.parse(value) });
                        }
                        else if (isMediaType_ts_1.isMediaType(contentType, contentTypesForm)) {
                            return (this.#body = {
                                type: "form",
                                value: new URLSearchParams(value.replace(/\+/g, " ")),
                            });
                        }
                        else if (isMediaType_ts_1.isMediaType(contentType, contentTypesText)) {
                            return (this.#body = { type: "text", value });
                        }
                        else {
                            return (this.#body = { type: "raw", value: rawBody });
                        }
                    }
                    throw new httpError_ts_4.httpErrors.UnsupportedMediaType(contentType
                        ? `Unsupported content-type: ${contentType}`
                        : "Missing content-type");
                }
            };
            exports_52("Request", Request);
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://linweiwei123.github.io/aok/response", ["https://linweiwei123.github.io/aok/deps", "https://linweiwei123.github.io/aok/util"], function (exports_53, context_53) {
    "use strict";
    var deps_ts_9, util_ts_7, REDIRECT_BACK, BODY_TYPES, encoder, Response;
    var __moduleName = context_53 && context_53.id;
    /** Guard for `Deno.Reader`. */
    function isReader(value) {
        return value && typeof value === "object" && "read" in value &&
            typeof value.read === "function";
    }
    function isPromiseLike(value) {
        return value && typeof value === "object" && "then" in value &&
            typeof value.then === "function";
    }
    async function convertBody(body, type) {
        let result;
        if (BODY_TYPES.includes(typeof body)) {
            const bodyText = String(body);
            result = encoder.encode(bodyText);
            type = type ?? (util_ts_7.isHtml(bodyText) ? "html" : "text/plain");
        }
        else if (body instanceof Uint8Array || isReader(body)) {
            result = body;
        }
        else if (body && typeof body === "object") {
            result = encoder.encode(JSON.stringify(body));
            type = type ?? "json";
        }
        else if (typeof body === "function") {
            const result = body.call(null);
            return convertBody(isPromiseLike(result) ? await result : result, type);
        }
        else if (body) {
            throw new TypeError("Response body was set but could not convert.");
        }
        return [result, type];
    }
    return {
        setters: [
            function (deps_ts_9_1) {
                deps_ts_9 = deps_ts_9_1;
            },
            function (util_ts_7_1) {
                util_ts_7 = util_ts_7_1;
            }
        ],
        execute: function () {
            /** A symbol that indicates to `response.redirect()` to attempt to redirect
             * back to the request referrer.  For example:
             *
             * ```ts
             * import { Application, REDIRECT_BACK } from "https://deno.land/x/oak/mod.ts";
             *
             * const app = new Application();
             *
             * app.use((ctx) => {
             *   if (ctx.request.url.pathName === "/back") {
             *     ctx.response.redirect(REDIRECT_BACK, "/");
             *   }
             * });
             *
             * await app.listen({ port: 80 });
             * ```
             */
            exports_53("REDIRECT_BACK", REDIRECT_BACK = Symbol("redirect backwards"));
            BODY_TYPES = ["string", "number", "bigint", "boolean", "symbol"];
            encoder = new TextEncoder();
            /** An interface to control what response will be sent when the middleware
             * finishes processing the request. */
            Response = class Response {
                constructor(request) {
                    this.#headers = new Headers();
                    this.#resources = [];
                    this.#writable = true;
                    this.#getBody = async () => {
                        const [body, type] = await convertBody(this.body, this.type);
                        this.type = type;
                        return body;
                    };
                    this.#setContentType = () => {
                        if (this.type) {
                            const contentTypeString = deps_ts_9.contentType(this.type);
                            if (contentTypeString && !this.headers.has("Content-Type")) {
                                this.headers.append("Content-Type", contentTypeString);
                            }
                        }
                    };
                    this.#request = request;
                }
                #body;
                #headers;
                #request;
                #resources;
                #serverResponse;
                #status;
                #type;
                #writable;
                #getBody;
                #setContentType;
                /** The body of the response.  The body will be automatically processed when
                 * the response is being sent and converted to a `Uint8Array` or a
                 * `Deno.Reader`. */
                get body() {
                    return this.#body;
                }
                /** The body of the response.  The body will be automatically processed when
                 * the response is being sent and converted to a `Uint8Array` or a
                 * `Deno.Reader`. */
                set body(value) {
                    if (!this.#writable) {
                        throw new Error("The response is not writable.");
                    }
                    this.#body = value;
                }
                /** Headers that will be returned in the response. */
                get headers() {
                    return this.#headers;
                }
                /** Headers that will be returned in the response. */
                set headers(value) {
                    if (!this.#writable) {
                        throw new Error("The response is not writable.");
                    }
                    this.#headers = value;
                }
                /** The HTTP status of the response.  If this has not been explicitly set,
                 * reading the value will return what would be the value of status if the
                 * response were sent at this point in processing the middleware.  If the body
                 * has been set, the status will be `200 OK`.  If a value for the body has
                 * not been set yet, the status will be `404 Not Found`. */
                get status() {
                    if (this.#status) {
                        return this.#status;
                    }
                    const typeofbody = typeof this.body;
                    return this.body &&
                        (BODY_TYPES.includes(typeofbody) || typeofbody === "object")
                        ? deps_ts_9.Status.OK
                        : deps_ts_9.Status.NotFound;
                }
                /** The HTTP status of the response.  If this has not been explicitly set,
                 * reading the value will return what would be the value of status if the
                 * response were sent at this point in processing the middleware.  If the body
                 * has been set, the status will be `200 OK`.  If a value for the body has
                 * not been set yet, the status will be `404 Not Found`. */
                set status(value) {
                    if (!this.#writable) {
                        throw new Error("The response is not writable.");
                    }
                    this.#status = value;
                }
                /** The media type, or extension of the response.  Setting this value will
                 * ensure an appropriate `Content-Type` header is added to the response. */
                get type() {
                    return this.#type;
                }
                /** The media type, or extension of the response.  Setting this value will
                 * ensure an appropriate `Content-Type` header is added to the response. */
                set type(value) {
                    if (!this.#writable) {
                        throw new Error("The response is not writable.");
                    }
                    this.#type = value;
                }
                /** A read-only property which determines if the response is writable or not.
                 * Once the response has been processed, this value is set to `false`. */
                get writable() {
                    return this.#writable;
                }
                /** Add a resource to the list of resources that will be closed when the
                 * request is destroyed. */
                addResource(rid) {
                    this.#resources.push(rid);
                }
                /** Release any resources that are being tracked by the response. */
                destroy() {
                    this.#writable = false;
                    this.#body = undefined;
                    this.#serverResponse = undefined;
                    for (const rid of this.#resources) {
                        Deno.close(rid);
                    }
                }
                redirect(url, alt = "/") {
                    if (url === REDIRECT_BACK) {
                        url = this.#request.headers.get("Referrer") ?? String(alt);
                    }
                    else if (typeof url === "object") {
                        url = String(url);
                    }
                    this.headers.set("Location", util_ts_7.encodeUrl(url));
                    if (!this.status || !util_ts_7.isRedirectStatus(this.status)) {
                        this.status = deps_ts_9.Status.Found;
                    }
                    if (this.#request.accepts("html")) {
                        url = encodeURI(url);
                        this.type = "text/html; charset=utf-8";
                        this.body = `Redirecting to <a href="${url}">${url}</a>.`;
                        return;
                    }
                    this.type = "text/plain; charset=utf-8";
                    this.body = `Redirecting to ${url}.`;
                }
                /** Take this response and convert it to the response used by the Deno net
                 * server.  Calling this will set the response to not be writable.
                 *
                 * Most users will have no need to call this method. */
                async toServerResponse() {
                    if (this.#serverResponse) {
                        return this.#serverResponse;
                    }
                    // Process the body
                    const body = await this.#getBody();
                    // If there is a response type, set the content type header
                    this.#setContentType();
                    const { headers } = this;
                    // If there is no body and no content type and no set length, then set the
                    // content length to 0
                    if (!(body ||
                        headers.has("Content-Type") ||
                        headers.has("Content-Length"))) {
                        headers.append("Content-Length", "0");
                    }
                    this.#writable = false;
                    return this.#serverResponse = {
                        status: this.#status ?? (body ? deps_ts_9.Status.OK : deps_ts_9.Status.NotFound),
                        body,
                        headers,
                    };
                }
            };
            exports_53("Response", Response);
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://linweiwei123.github.io/aok/cookies", [], function (exports_54, context_54) {
    "use strict";
    var matchCache, FIELD_CONTENT_REGEXP, KEY_REGEXP, SAME_SITE_REGEXP, Cookie, Cookies;
    var __moduleName = context_54 && context_54.id;
    function getPattern(name) {
        if (name in matchCache) {
            return matchCache[name];
        }
        return matchCache[name] = new RegExp(`(?:^|;) *${name.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")}=([^;]*)`);
    }
    function pushCookie(headers, cookie) {
        if (cookie.overwrite) {
            for (let i = headers.length - 1; i >= 0; i--) {
                if (headers[i].indexOf(`${cookie.name}=`) === 0) {
                    headers.splice(i, 1);
                }
            }
        }
        headers.push(cookie.toHeader());
    }
    function validateCookieProperty(key, value) {
        if (value && !FIELD_CONTENT_REGEXP.test(value)) {
            throw new TypeError(`The ${key} of the cookie (${value}) is invalid.`);
        }
    }
    return {
        setters: [],
        execute: function () {
            matchCache = {};
            FIELD_CONTENT_REGEXP = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
            KEY_REGEXP = /(?:^|;) *([^=]*)=[^;]*/g;
            SAME_SITE_REGEXP = /^(?:lax|none|strict)$/i;
            Cookie = class Cookie {
                /** A logical representation of a cookie, used to internally manage the
                 * cookie instances. */
                constructor(name, value, attributes) {
                    this.httpOnly = true;
                    this.overwrite = false;
                    this.path = "/";
                    this.sameSite = false;
                    this.secure = false;
                    validateCookieProperty("name", name);
                    validateCookieProperty("value", value);
                    this.name = name;
                    this.value = value ?? "";
                    Object.assign(this, attributes);
                    if (!this.value) {
                        this.expires = new Date(0);
                        this.maxAge = undefined;
                    }
                    validateCookieProperty("path", this.path);
                    validateCookieProperty("domain", this.domain);
                    if (this.sameSite && typeof this.sameSite === "string" &&
                        !SAME_SITE_REGEXP.test(this.sameSite)) {
                        throw new TypeError(`The sameSite of the cookie ("${this.sameSite}") is invalid.`);
                    }
                }
                toHeader() {
                    let header = this.toString();
                    if (this.maxAge) {
                        this.expires = new Date(Date.now() + this.maxAge);
                    }
                    if (this.path) {
                        header += `; path=${this.path}`;
                    }
                    if (this.expires) {
                        header += `; expires=${this.expires.toUTCString()}`;
                    }
                    if (this.domain) {
                        header += `; domain=${this.domain}`;
                    }
                    if (this.sameSite) {
                        header += `; samesite=${this.sameSite === true ? "strict" : this.sameSite.toLowerCase()}`;
                    }
                    if (this.secure) {
                        header += "; secure";
                    }
                    if (this.httpOnly) {
                        header += "; httponly";
                    }
                    return header;
                }
                toString() {
                    return `${this.name}=${this.value}`;
                }
            };
            /** An interface which allows setting and accessing cookies related to both the
             * current request and response. */
            Cookies = class Cookies {
                constructor(request, response, options = {}) {
                    this.#requestKeys = () => {
                        if (this.#cookieKeys) {
                            return this.#cookieKeys;
                        }
                        const result = this.#cookieKeys = [];
                        const header = this.#request.headers.get("cookie");
                        if (!header) {
                            return result;
                        }
                        let matches;
                        while ((matches = KEY_REGEXP.exec(header))) {
                            const [, key] = matches;
                            result.push(key);
                        }
                        return result;
                    };
                    const { keys, secure } = options;
                    this.#keys = keys;
                    this.#request = request;
                    this.#response = response;
                    this.#secure = secure;
                }
                #cookieKeys;
                #keys;
                #request;
                #response;
                #secure;
                #requestKeys;
                /** Set a cookie to be deleted in the response.  This is a "shortcut" to
                 * `.set(name, null, options?)`. */
                delete(name, options = {}) {
                    this.set(name, null, options);
                    return true;
                }
                /** Iterate over the request's cookies, yielding up a tuple containing the
                 * key and the value.
                 *
                 * If there are keys set on the application, only keys and values that are
                 * properly signed will be returned. */
                *entries() {
                    const keys = this.#requestKeys();
                    for (const key of keys) {
                        const value = this.get(key);
                        if (value) {
                            yield [key, value];
                        }
                    }
                }
                forEach(callback, thisArg = null) {
                    const keys = this.#requestKeys();
                    for (const key of keys) {
                        const value = this.get(key);
                        if (value) {
                            callback.call(thisArg, key, value, this);
                        }
                    }
                }
                /** Get the value of a cookie from the request.
                 *
                 * If the cookie is signed, and the signature is invalid, the cookie will
                 * be set to be deleted in the the response.  If the signature uses an "old"
                 * key, the cookie will be re-signed with the current key and be added to the
                 * response to be updated. */
                get(name, options = {}) {
                    const signed = options.signed ?? !!this.#keys;
                    const nameSig = `${name}.sig`;
                    const header = this.#request.headers.get("cookie");
                    if (!header) {
                        return;
                    }
                    const match = header.match(getPattern(name));
                    if (!match) {
                        return;
                    }
                    const [, value] = match;
                    if (!signed) {
                        return value;
                    }
                    const digest = this.get(nameSig, { signed: false });
                    if (!digest) {
                        return;
                    }
                    const data = `${name}=${value}`;
                    if (!this.#keys) {
                        throw new TypeError("keys required for signed cookies");
                    }
                    const index = this.#keys.indexOf(data, digest);
                    if (index < 0) {
                        this.delete(nameSig, { path: "/", signed: false });
                    }
                    else {
                        if (index) {
                            // the key has "aged" and needs to be re-signed
                            this.set(nameSig, this.#keys.sign(data), { signed: false });
                        }
                        return value;
                    }
                }
                /** Iterate over the request's cookies, yielding up the keys.
                 *
                 * If there are keys set on the application, only the keys that are properly
                 * signed will be returned. */
                *keys() {
                    const keys = this.#requestKeys();
                    for (const key of keys) {
                        const value = this.get(key);
                        if (value) {
                            yield key;
                        }
                    }
                }
                /** Set a cookie in the response.
                 *
                 * If there are keys set in the application, cookies will be automatically
                 * signed, unless overridden by the set options.  Cookies can be deleted by
                 * setting the value to `null`. */
                set(name, value, options = {}) {
                    const request = this.#request;
                    const response = this.#response;
                    let headers = response.headers.get("Set-Cookie") ?? [];
                    if (typeof headers === "string") {
                        headers = [headers];
                    }
                    const secure = this.#secure !== undefined ? this.#secure : request.secure;
                    const signed = options.signed ?? !!this.#keys;
                    if (!secure && options.secure) {
                        throw new TypeError("Cannot send secure cookie over unencrypted connection.");
                    }
                    const cookie = new Cookie(name, value, options);
                    cookie.secure = options.secure ?? secure;
                    pushCookie(headers, cookie);
                    if (signed) {
                        if (!this.#keys) {
                            throw new TypeError(".keys required for signed cookies.");
                        }
                        cookie.value = this.#keys.sign(cookie.toString());
                        cookie.name += ".sig";
                        pushCookie(headers, cookie);
                    }
                    for (const header of headers) {
                        response.headers.append("Set-Cookie", header);
                    }
                    return this;
                }
                /** Iterate over the request's cookies, yielding up each value.
                 *
                 * If there are keys set on the application, only the values that are
                 * properly signed will be returned. */
                *values() {
                    const keys = this.#requestKeys();
                    for (const key of keys) {
                        const value = this.get(key);
                        if (value) {
                            yield value;
                        }
                    }
                }
                /** Iterate over the request's cookies, yielding up a tuple containing the
                 * key and the value.
                 *
                 * If there are keys set on the application, only keys and values that are
                 * properly signed will be returned. */
                *[Symbol.iterator]() {
                    const keys = this.#requestKeys();
                    for (const key of keys) {
                        const value = this.get(key);
                        if (value) {
                            yield [key, value];
                        }
                    }
                }
            };
            exports_54("Cookies", Cookies);
        }
    };
});
/*!
 * Adapted from koa-send at https://github.com/koajs/send and which is licensed
 * with the MIT license.
 */
System.register("https://linweiwei123.github.io/aok/send", ["https://linweiwei123.github.io/aok/httpError", "https://linweiwei123.github.io/aok/deps", "https://linweiwei123.github.io/aok/util"], function (exports_55, context_55) {
    "use strict";
    var httpError_ts_5, deps_ts_10, util_ts_8;
    var __moduleName = context_55 && context_55.id;
    function isHidden(root, path) {
        const pathArr = path.substr(root.length).split(deps_ts_10.sep);
        for (const segment of pathArr) {
            if (segment[0] === ".") {
                return true;
            }
            return false;
        }
    }
    async function exists(path) {
        try {
            return (await Deno.stat(path)).isFile;
        }
        catch {
            return false;
        }
    }
    /** Asynchronously fulfill a response with a file from the local file
     * system.
     *
     * Requires Deno read permission. */
    async function send({ request, response }, path, options = { root: "" }) {
        const { brotli = true, extensions, format = true, gzip = true, hidden = false, immutable = false, index, maxage = 0, root, } = options;
        const trailingSlash = path[path.length - 1] === "/";
        path = util_ts_8.decodeComponent(path.substr(deps_ts_10.parse(path).root.length));
        if (index && trailingSlash) {
            path += index;
        }
        path = util_ts_8.resolvePath(root, path);
        if (!hidden && isHidden(root, path)) {
            return;
        }
        let encodingExt = "";
        if (brotli &&
            request.acceptsEncodings("br", "identity") === "br" &&
            (await exists(`${path}.br`))) {
            path = `${path}.br`;
            response.headers.set("Content-Encoding", "br");
            response.headers.delete("Content-Length");
            encodingExt = ".br";
        }
        else if (gzip &&
            request.acceptsEncodings("gzip", "identity") === "gzip" &&
            (await exists(`${path}.gz`))) {
            path = `${path}.gz`;
            response.headers.set("Content-Encoding", "gzip");
            response.headers.delete("Content-Length");
            encodingExt = ".gz";
        }
        if (extensions && !/\.[^/]*$/.exec(path)) {
            for (let ext of extensions) {
                if (!/^\./.exec(ext)) {
                    ext = `.${ext}`;
                }
                if (await exists(`${path}${ext}`)) {
                    path += ext;
                    break;
                }
            }
        }
        let stats;
        try {
            stats = await Deno.stat(path);
            if (stats.isDirectory) {
                if (format && index) {
                    path += `/${index}`;
                    stats = await Deno.stat(path);
                }
                else {
                    return;
                }
            }
        }
        catch (err) {
            if (err instanceof Deno.errors.NotFound) {
                throw httpError_ts_5.createHttpError(404, err.message);
            }
            throw httpError_ts_5.createHttpError(500, err.message);
        }
        response.headers.set("Content-Length", String(stats.size));
        if (!response.headers.has("Last-Modified") && stats.mtime) {
            response.headers.set("Last-Modified", stats.mtime.toUTCString());
        }
        if (!response.headers.has("Cache-Control")) {
            const directives = [`max-age=${(maxage / 1000) | 0}`];
            if (immutable) {
                directives.push("immutable");
            }
            response.headers.set("Cache-Control", directives.join(","));
        }
        if (!response.type) {
            response.type = encodingExt !== ""
                ? deps_ts_10.extname(deps_ts_10.basename(path, encodingExt))
                : deps_ts_10.extname(path);
        }
        const file = await Deno.open(path, { read: true });
        response.addResource(file.rid);
        response.body = file;
        return path;
    }
    exports_55("send", send);
    return {
        setters: [
            function (httpError_ts_5_1) {
                httpError_ts_5 = httpError_ts_5_1;
            },
            function (deps_ts_10_1) {
                deps_ts_10 = deps_ts_10_1;
            },
            function (util_ts_8_1) {
                util_ts_8 = util_ts_8_1;
            }
        ],
        execute: function () {
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://linweiwei123.github.io/aok/server_sent_event", ["https://linweiwei123.github.io/aok/deps"], function (exports_56, context_56) {
    "use strict";
    var deps_ts_11, encoder, CloseEvent, ServerSentEvent, response, responseHeaders, ServerSentEventTarget;
    var __moduleName = context_56 && context_56.id;
    return {
        setters: [
            function (deps_ts_11_1) {
                deps_ts_11 = deps_ts_11_1;
            }
        ],
        execute: function () {
            encoder = new TextEncoder();
            CloseEvent = class CloseEvent extends Event {
                constructor(eventInit) {
                    super("close", eventInit);
                }
            };
            /** An event which contains information which will be sent to the remote
             * connection and be made available in an `EventSource` as an event. */
            ServerSentEvent = class ServerSentEvent extends Event {
                constructor(type, data, { replacer, space, ...eventInit } = {}) {
                    super(type, eventInit);
                    this.#type = type;
                    try {
                        this.#data = typeof data === "string"
                            ? data
                            : JSON.stringify(data, replacer, space);
                    }
                    catch (e) {
                        deps_ts_11.assert(e instanceof Error);
                        throw new TypeError(`data could not be coerced into a serialized string.\n  ${e.message}`);
                    }
                    const { id } = eventInit;
                    this.#id = id;
                }
                #data;
                #id;
                #type;
                /** The data associated with the event, which will be sent to the client and
                 * be made available in the `EventSource`. */
                get data() {
                    return this.#data;
                }
                /** The optional ID associated with the event that will be sent to the client
                 * and be made available in the `EventSource`. */
                get id() {
                    return this.#id;
                }
                toString() {
                    const data = `data: ${this.#data.split("\n").join("\ndata: ")}\n`;
                    return `${this.#type === "__message" ? "" : `event: ${this.#type}\n`}${this.#id ? `id: ${String(this.#id)}\n` : ""}${data}\n`;
                }
            };
            exports_56("ServerSentEvent", ServerSentEvent);
            response = `HTTP/1.1 200 OK\n`;
            responseHeaders = new Headers([
                ["Connection", "Keep-Alive"],
                ["Content-Type", "text/event-stream"],
                ["Cache-Control", "no-cache"],
                ["Keep-Alive", `timeout=${Number.MAX_SAFE_INTEGER}`],
            ]);
            ServerSentEventTarget = class ServerSentEventTarget extends EventTarget {
                constructor(app, serverRequest, { headers } = {}) {
                    super();
                    this.#closed = false;
                    this.#send = async (payload) => {
                        if (this.#closed) {
                            return;
                        }
                        if (this.#ready !== true) {
                            await this.#ready;
                            this.#ready = true;
                        }
                        try {
                            await (this.#writing = this.#writer.write(encoder.encode(payload)));
                            await (this.#writing = this.#writer.flush());
                        }
                        catch (error) {
                            this.#writing = undefined;
                            this.dispatchEvent(new CloseEvent({ cancelable: false }));
                            const errorEvent = new ErrorEvent("error", { error });
                            this.dispatchEvent(errorEvent);
                            this.#app.dispatchEvent(errorEvent);
                        }
                    };
                    this.#setup = async (overrideHeaders) => {
                        const headers = new Headers(responseHeaders);
                        if (overrideHeaders) {
                            for (const [key, value] of overrideHeaders) {
                                headers.set(key, value);
                            }
                        }
                        let payload = response;
                        for (const [key, value] of headers) {
                            payload += `${key}: ${value}\n`;
                        }
                        payload += `\n`;
                        try {
                            await this.#writer.write(encoder.encode(payload));
                            await this.#writer.flush();
                        }
                        catch (error) {
                            this.dispatchEvent(new CloseEvent({ cancelable: false }));
                            const errorEvent = new ErrorEvent("error", { error });
                            this.dispatchEvent(errorEvent);
                            this.#app.dispatchEvent(errorEvent);
                            throw error;
                        }
                    };
                    this.#app = app;
                    this.#serverRequest = serverRequest;
                    this.#writer = this.#serverRequest.w;
                    this.addEventListener("close", () => {
                        this.#closed = true;
                        try {
                            this.#serverRequest.conn.close();
                        }
                        catch (error) {
                            if (!(error instanceof Deno.errors.BadResource)) {
                                const errorEvent = new ErrorEvent("error", { error });
                                this.dispatchEvent(errorEvent);
                                this.#app.dispatchEvent(errorEvent);
                            }
                        }
                    });
                    this.#ready = this.#setup(headers);
                }
                #app;
                #closed;
                #ready;
                #serverRequest;
                #writer;
                #writing;
                #send;
                #setup;
                /** Is set to `true` if events cannot be sent to the remote connection.
                 * Otherwise it is set to `false`.
                 *
                 * *Note*: This flag is lazily set, and might not reflect a closed state until
                 * another event, comment or message is attempted to be processed. */
                get closed() {
                    return this.#closed;
                }
                /** Stop sending events to the remote connection and close the connection. */
                async close() {
                    if (this.#ready !== true) {
                        await this.#ready;
                    }
                    if (this.#writing) {
                        await this.#writing;
                    }
                    this.dispatchEvent(new CloseEvent({ cancelable: false }));
                }
                /** Send a comment to the remote connection.  Comments are not exposed to the
                 * client `EventSource` but are used for diagnostics and helping ensure a
                 * connection is kept alive.
                 *
                 * ```ts
                 * import { Application } from "https://deno.land/x/oak/mod.ts";
                 *
                 * const app = new Application();
                 *
                 * app.use((ctx) => {
                 *    const sse = ctx.getSSETarget();
                 *    sse.dispatchComment("this is a comment");
                 * });
                 *
                 * await app.listen();
                 * ```
                 */
                dispatchComment(comment) {
                    this.#send(`: ${comment.split("\n").join("\n: ")}\n\n`);
                    return true;
                }
                /** Dispatch a message to the client.  This message will contain `data: ` only
                 * and be available on the client `EventSource` on the `onmessage` or an event
                 * listener of type `"message"`. */
                dispatchMessage(data) {
                    const event = new ServerSentEvent("__message", data);
                    return this.dispatchEvent(event);
                }
                dispatchEvent(event) {
                    let dispatched = super.dispatchEvent(event);
                    if (dispatched) {
                        this.#send(String(event));
                    }
                    return dispatched;
                }
            };
            exports_56("ServerSentEventTarget", ServerSentEventTarget);
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://linweiwei123.github.io/aok/context", ["https://linweiwei123.github.io/aok/cookies", "https://linweiwei123.github.io/aok/deps", "https://linweiwei123.github.io/aok/httpError", "https://linweiwei123.github.io/aok/request", "https://linweiwei123.github.io/aok/response", "https://linweiwei123.github.io/aok/send", "https://linweiwei123.github.io/aok/server_sent_event"], function (exports_57, context_57) {
    "use strict";
    var cookies_ts_1, deps_ts_12, httpError_ts_6, request_ts_1, response_ts_1, send_ts_1, server_sent_event_ts_1, Context;
    var __moduleName = context_57 && context_57.id;
    return {
        setters: [
            function (cookies_ts_1_1) {
                cookies_ts_1 = cookies_ts_1_1;
            },
            function (deps_ts_12_1) {
                deps_ts_12 = deps_ts_12_1;
            },
            function (httpError_ts_6_1) {
                httpError_ts_6 = httpError_ts_6_1;
            },
            function (request_ts_1_1) {
                request_ts_1 = request_ts_1_1;
            },
            function (response_ts_1_1) {
                response_ts_1 = response_ts_1_1;
            },
            function (send_ts_1_1) {
                send_ts_1 = send_ts_1_1;
            },
            function (server_sent_event_ts_1_1) {
                server_sent_event_ts_1 = server_sent_event_ts_1_1;
            }
        ],
        execute: function () {
            /** Provides context about the current request and response to middleware
             * functions. */
            Context = class Context {
                constructor(app, serverRequest, secure = false) {
                    this.app = app;
                    this.state = app.state;
                    this.request = new request_ts_1.Request(serverRequest, app.proxy, secure);
                    this.respond = true;
                    this.response = new response_ts_1.Response(this.request);
                    this.cookies = new cookies_ts_1.Cookies(this.request, this.response, {
                        keys: this.app.keys,
                        secure: this.request.secure,
                    });
                }
                #socket;
                #sse;
                /** Is `true` if the current connection is upgradeable to a web socket.
                 * Otherwise the value is `false`.  Use `.upgrade()` to upgrade the connection
                 * and return the web socket. */
                get isUpgradable() {
                    return deps_ts_12.acceptable(this.request);
                }
                /** If the the current context has been upgraded, then this will be set to
                 * with the web socket, otherwise it is `undefined`. */
                get socket() {
                    return this.#socket;
                }
                /** Asserts the condition and if the condition fails, creates an HTTP error
                 * with the provided status (which defaults to `500`).  The error status by
                 * default will be set on the `.response.status`.
                 */
                assert(condition, errorStatus = 500, message, props) {
                    if (condition) {
                        return;
                    }
                    const err = httpError_ts_6.createHttpError(errorStatus, message);
                    if (props) {
                        Object.assign(err, props);
                    }
                    throw err;
                }
                /** Asynchronously fulfill a response with a file from the local file
                 * system.
                 *
                 * If the `options.path` is not supplied, the file to be sent will default
                 * to this `.request.url.pathname`.
                 *
                 * Requires Deno read permission. */
                send(options) {
                    const { path = this.request.url.pathname, ...sendOptions } = options;
                    return send_ts_1.send(this, path, sendOptions);
                }
                /** Convert the connection to stream events, returning an event target for
                 * sending server sent events.  Events dispatched on the returned target will
                 * be sent to the client and be available in the client's `EventSource` that
                 * initiated the connection.
                 *
                 * This will set `.respond` to `false`. */
                sendEvents(options) {
                    if (this.#sse) {
                        return this.#sse;
                    }
                    this.respond = false;
                    return this.#sse = new server_sent_event_ts_1.ServerSentEventTarget(this.app, this.request.serverRequest, options);
                }
                /** Create and throw an HTTP Error, which can be used to pass status
                 * information which can be caught by other middleware to send more
                 * meaningful error messages back to the client.  The passed error status will
                 * be set on the `.response.status` by default as well.
                 */
                throw(errorStatus, message, props) {
                    const err = httpError_ts_6.createHttpError(errorStatus, message);
                    if (props) {
                        Object.assign(err, props);
                    }
                    throw err;
                }
                /** Take the current request and upgrade it to a web socket, resolving with
                 * the web socket object. This will set `.respond` to `false`. */
                async upgrade() {
                    if (this.#socket) {
                        return this.#socket;
                    }
                    const { conn, r: bufReader, w: bufWriter, headers } = this.request.serverRequest;
                    this.#socket = await deps_ts_12.acceptWebSocket({ conn, bufReader, bufWriter, headers });
                    this.respond = false;
                    return this.#socket;
                }
            };
            exports_57("Context", Context);
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://linweiwei123.github.io/aok/middleware", [], function (exports_58, context_58) {
    "use strict";
    var __moduleName = context_58 && context_58.id;
    /** Compose multiple middleware functions into a single middleware function. */
    function compose(middleware) {
        return function composedMiddleware(context, next) {
            let index = -1;
            function dispatch(i) {
                if (i <= index) {
                    Promise.reject(new Error("next() called multiple times."));
                }
                index = i;
                let fn = middleware[i];
                if (i === middleware.length) {
                    fn = next;
                }
                if (!fn) {
                    return Promise.resolve();
                }
                try {
                    return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
            return dispatch(0);
        };
    }
    exports_58("compose", compose);
    return {
        setters: [],
        execute: function () {
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://linweiwei123.github.io/aok/application", ["https://linweiwei123.github.io/aok/context", "https://linweiwei123.github.io/aok/deps", "https://linweiwei123.github.io/aok/keyStack", "https://linweiwei123.github.io/aok/middleware"], function (exports_59, context_59) {
    "use strict";
    var context_ts_1, deps_ts_13, keyStack_ts_1, middleware_ts_1, ADDR_REGEXP, ApplicationErrorEvent, ApplicationListenEvent, Application;
    var __moduleName = context_59 && context_59.id;
    function isOptionsTls(options) {
        return options.secure === true;
    }
    return {
        setters: [
            function (context_ts_1_1) {
                context_ts_1 = context_ts_1_1;
            },
            function (deps_ts_13_1) {
                deps_ts_13 = deps_ts_13_1;
            },
            function (keyStack_ts_1_1) {
                keyStack_ts_1 = keyStack_ts_1_1;
            },
            function (middleware_ts_1_1) {
                middleware_ts_1 = middleware_ts_1_1;
            }
        ],
        execute: function () {
            ADDR_REGEXP = /^\[?([^\]]*)\]?:([0-9]{1,5})$/;
            ApplicationErrorEvent = class ApplicationErrorEvent extends ErrorEvent {
                constructor(eventInitDict) {
                    super("error", eventInitDict);
                    this.context = eventInitDict.context;
                }
            };
            exports_59("ApplicationErrorEvent", ApplicationErrorEvent);
            ApplicationListenEvent = class ApplicationListenEvent extends Event {
                constructor(eventInitDict) {
                    super("listen", eventInitDict);
                    this.hostname = eventInitDict.hostname;
                    this.port = eventInitDict.port;
                    this.secure = eventInitDict.secure;
                }
            };
            exports_59("ApplicationListenEvent", ApplicationListenEvent);
            /** A class which registers middleware (via `.use()`) and then processes
             * inbound requests against that middleware (via `.listen()`).
             *
             * The `context.state` can be typed via passing a generic argument when
             * constructing an instance of `Application`.
             */
            Application = class Application extends EventTarget {
                constructor(options = {}) {
                    super();
                    this.#middleware = [];
                    /** Deal with uncaught errors in either the middleware or sending the
                     * response. */
                    this.#handleError = (context, error) => {
                        if (!(error instanceof Error)) {
                            error = new Error(`non-error thrown: ${JSON.stringify(error)}`);
                        }
                        const { message } = error;
                        this.dispatchEvent(new ApplicationErrorEvent({ context, message, error }));
                        if (!context.response.writable) {
                            return;
                        }
                        for (const key of context.response.headers.keys()) {
                            context.response.headers.delete(key);
                        }
                        if (error.headers && error.headers instanceof Headers) {
                            for (const [key, value] of error.headers) {
                                context.response.headers.set(key, value);
                            }
                        }
                        context.response.type = "text";
                        const status = context.response.status =
                            error instanceof Deno.errors.NotFound
                                ? 404
                                : error.status && typeof error.status === "number"
                                    ? error.status
                                    : 500;
                        context.response.body = error.expose
                            ? error.message
                            : deps_ts_13.STATUS_TEXT.get(status);
                    };
                    /** Processing registered middleware on each request. */
                    this.#handleRequest = async (request, secure, state) => {
                        const context = new context_ts_1.Context(this, request, secure);
                        if (!state.closing && !state.closed) {
                            state.handling = true;
                            try {
                                await state.middleware(context);
                            }
                            catch (err) {
                                this.#handleError(context, err);
                            }
                            finally {
                                state.handling = false;
                            }
                        }
                        if (context.respond === false) {
                            context.response.destroy();
                            return;
                        }
                        try {
                            await request.respond(await context.response.toServerResponse());
                            context.response.destroy();
                            if (state.closing) {
                                state.server.close();
                                state.closed = true;
                            }
                        }
                        catch (err) {
                            this.#handleError(context, err);
                        }
                    };
                    const { state, keys, proxy, serve = deps_ts_13.serve, serveTls = deps_ts_13.serveTLS, } = options;
                    this.proxy = proxy ?? false;
                    this.keys = keys;
                    this.state = state ?? {};
                    this.#serve = serve;
                    this.#serveTls = serveTls;
                }
                #keys;
                #middleware;
                #serve;
                #serveTls;
                /** A set of keys, or an instance of `KeyStack` which will be used to sign
                 * cookies read and set by the application to avoid tampering with the
                 * cookies. */
                get keys() {
                    return this.#keys;
                }
                set keys(keys) {
                    if (!keys) {
                        this.#keys = undefined;
                        return;
                    }
                    else if (Array.isArray(keys)) {
                        this.#keys = new keyStack_ts_1.KeyStack(keys);
                    }
                    else {
                        this.#keys = keys;
                    }
                }
                /** Deal with uncaught errors in either the middleware or sending the
                 * response. */
                #handleError;
                /** Processing registered middleware on each request. */
                #handleRequest;
                /** Add an event listener for an event.  Currently valid event types are
                 * `"error"` and `"listen"`. */
                addEventListener(type, listener, options) {
                    super.addEventListener(type, listener, options);
                }
                async listen(options) {
                    if (!this.#middleware.length) {
                        return Promise.reject(new TypeError("There is no middleware to process requests."));
                    }
                    if (typeof options === "string") {
                        const match = ADDR_REGEXP.exec(options);
                        if (!match) {
                            throw TypeError(`Invalid address passed: "${options}"`);
                        }
                        const [, hostname, portStr] = match;
                        options = { hostname, port: parseInt(portStr, 10) };
                    }
                    const middleware = middleware_ts_1.compose(this.#middleware);
                    const server = isOptionsTls(options)
                        ? this.#serveTls(options)
                        : this.#serve(options);
                    const { signal } = options;
                    const state = {
                        closed: false,
                        closing: false,
                        handling: false,
                        middleware,
                        server,
                    };
                    if (signal) {
                        signal.addEventListener("abort", () => {
                            if (!state.handling) {
                                server.close();
                                state.closed = true;
                            }
                            state.closing = true;
                        });
                    }
                    const { hostname, port, secure = false } = options;
                    this.dispatchEvent(new ApplicationListenEvent({ hostname, port, secure }));
                    try {
                        for await (const request of server) {
                            this.#handleRequest(request, secure, state);
                        }
                    }
                    catch (error) {
                        const message = error instanceof Error
                            ? error.message
                            : "Application Error";
                        this.dispatchEvent(new ApplicationErrorEvent({ message, error }));
                    }
                }
                /** Register middleware to be used with the application.  Middleware will
                 * be processed in the order it is added, but middleware can control the flow
                 * of execution via the use of the `next()` function that the middleware
                 * function will be called with.  The `context` object provides information
                 * about the current state of the application.
                 *
                 * Basic usage:
                 *
                 * ```ts
                 * const import { Application } from "https://deno.land/x/oak/mod.ts";
                 *
                 * const app = new Application();
                 *
                 * app.use((ctx, next) => {
                 *   ctx.request; // contains request information
                 *   ctx.response; // setups up information to use in the response;
                 *   await next(); // manages the flow control of the middleware execution
                 * });
                 *
                 * await app.listen({ port: 80 });
                 * ```
                 */
                use(...middleware) {
                    this.#middleware.push(...middleware);
                    return this;
                }
            };
            exports_59("Application", Application);
        }
    };
});
/**
 * Adapted directly from @koa/router at
 * https://github.com/koajs/router/ which is licensed as:
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Alexander C. Mingoia
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
System.register("https://linweiwei123.github.io/aok/router", ["https://linweiwei123.github.io/aok/deps", "https://linweiwei123.github.io/aok/httpError", "https://linweiwei123.github.io/aok/middleware", "https://linweiwei123.github.io/aok/util"], function (exports_60, context_60) {
    "use strict";
    var deps_ts_14, httpError_ts_7, middleware_ts_2, util_ts_9, Layer, Router;
    var __moduleName = context_60 && context_60.id;
    /** Generate a URL from a string, potentially replace route params with
     * values. */
    function toUrl(url, params = {}, options) {
        const tokens = deps_ts_14.pathParse(url);
        let replace = {};
        if (tokens.some((token) => typeof token === "object")) {
            replace = params;
        }
        else {
            options = params;
        }
        const toPath = deps_ts_14.compile(url, options);
        let replaced = toPath(replace);
        if (options && options.query) {
            const url = new URL(replaced, "http://oak");
            if (typeof options.query === "string") {
                url.search = options.query;
            }
            else {
                url.search = String(options.query instanceof URLSearchParams
                    ? options.query
                    : new URLSearchParams(options.query));
            }
            return `${url.pathname}${url.search}${url.hash}`;
        }
        return replaced;
    }
    return {
        setters: [
            function (deps_ts_14_1) {
                deps_ts_14 = deps_ts_14_1;
            },
            function (httpError_ts_7_1) {
                httpError_ts_7 = httpError_ts_7_1;
            },
            function (middleware_ts_2_1) {
                middleware_ts_2 = middleware_ts_2_1;
            },
            function (util_ts_9_1) {
                util_ts_9 = util_ts_9_1;
            }
        ],
        execute: function () {
            Layer = class Layer {
                constructor(path, methods, middleware, { name, ...opts } = {}) {
                    this.#paramNames = [];
                    this.#opts = opts;
                    this.name = name;
                    this.methods = [...methods];
                    if (this.methods.includes("GET")) {
                        this.methods.unshift("HEAD");
                    }
                    this.stack = Array.isArray(middleware) ? middleware : [middleware];
                    this.path = path;
                    this.#regexp = deps_ts_14.pathToRegexp(path, this.#paramNames, this.#opts);
                }
                #opts;
                #paramNames;
                #regexp;
                match(path) {
                    return this.#regexp.test(path);
                }
                params(captures, existingParams = {}) {
                    const params = existingParams;
                    for (let i = 0; i < captures.length; i++) {
                        if (this.#paramNames[i]) {
                            const c = captures[i];
                            params[this.#paramNames[i].name] = c ? util_ts_9.decodeComponent(c) : c;
                        }
                    }
                    return params;
                }
                captures(path) {
                    if (this.#opts.ignoreCaptures) {
                        return [];
                    }
                    return path.match(this.#regexp)?.slice(1) ?? [];
                }
                url(params = {}, options) {
                    const url = this.path.replace(/\(\.\*\)/g, "");
                    return toUrl(url, params, options);
                }
                param(param, fn) {
                    const stack = this.stack;
                    const params = this.#paramNames;
                    const middleware = function (ctx, next) {
                        const p = ctx.params[param];
                        deps_ts_14.assert(p);
                        return fn.call(this, p, ctx, next);
                    };
                    middleware.param = param;
                    const names = params.map((p) => p.name);
                    const x = names.indexOf(param);
                    if (x >= 0) {
                        for (let i = 0; i < stack.length; i++) {
                            const fn = stack[i];
                            if (!fn.param || names.indexOf(fn.param) > x) {
                                stack.splice(i, 0, middleware);
                                break;
                            }
                        }
                    }
                    return this;
                }
                setPrefix(prefix) {
                    if (this.path) {
                        this.path = this.path !== "/" || this.#opts.strict === true
                            ? `${prefix}${this.path}`
                            : prefix;
                        this.#paramNames = [];
                        this.#regexp = deps_ts_14.pathToRegexp(this.path, this.#paramNames, this.#opts);
                    }
                    return this;
                }
                toJSON() {
                    return {
                        methods: [...this.methods],
                        middleware: [...this.stack],
                        paramNames: this.#paramNames.map((key) => key.name),
                        path: this.path,
                        regexp: this.#regexp,
                        options: { ...this.#opts },
                    };
                }
            };
            /** An interface for registering middleware that will run when certain HTTP
             * methods and paths are requested, as well as provides a way to parameterize
             * parts of the requested path. */
            Router = class Router {
                constructor(opts = {}) {
                    this.#params = {};
                    this.#stack = [];
                    this.#match = (path, method) => {
                        const matches = {
                            path: [],
                            pathAndMethod: [],
                            route: false,
                        };
                        for (const route of this.#stack) {
                            if (route.match(path)) {
                                matches.path.push(route);
                                if (route.methods.length === 0 || route.methods.includes(method)) {
                                    matches.pathAndMethod.push(route);
                                    if (route.methods.length) {
                                        matches.route = true;
                                    }
                                }
                            }
                        }
                        return matches;
                    };
                    this.#register = (path, middleware, methods, options = {}) => {
                        if (Array.isArray(path)) {
                            for (const p of path) {
                                this.#register(p, middleware, methods, options);
                            }
                            return;
                        }
                        const { end, name, sensitive, strict, ignoreCaptures } = options;
                        const route = new Layer(path, methods, middleware, {
                            end: end === false ? end : true,
                            name,
                            sensitive: sensitive ?? this.#opts.sensitive ?? false,
                            strict: strict ?? this.#opts.strict ?? false,
                            ignoreCaptures,
                        });
                        if (this.#opts.prefix) {
                            route.setPrefix(this.#opts.prefix);
                        }
                        for (const [param, mw] of Object.entries(this.#params)) {
                            route.param(param, mw);
                        }
                        this.#stack.push(route);
                    };
                    this.#route = (name) => {
                        for (const route of this.#stack) {
                            if (route.name === name) {
                                return route;
                            }
                        }
                    };
                    this.#useVerb = (nameOrPath, pathOrMiddleware, middleware, methods) => {
                        let name = undefined;
                        let path;
                        if (typeof pathOrMiddleware === "string") {
                            name = nameOrPath;
                            path = pathOrMiddleware;
                        }
                        else {
                            path = nameOrPath;
                            middleware.unshift(pathOrMiddleware);
                        }
                        this.#register(path, middleware, methods, { name });
                    };
                    this.#opts = opts;
                    this.#methods = opts.methods ?? [
                        "DELETE",
                        "GET",
                        "HEAD",
                        "OPTIONS",
                        "PATCH",
                        "POST",
                        "PUT",
                    ];
                }
                #opts;
                #methods;
                #params;
                #stack;
                #match;
                #register;
                #route;
                #useVerb;
                all(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["DELETE", "GET", "POST", "PUT"]);
                    return this;
                }
                /** Middleware that handles requests for HTTP methods registered with the
                 * router.  If none of the routes handle a method, then "not allowed" logic
                 * will be used.  If a method is supported by some routes, but not the
                 * particular matched router, then "not implemented" will be returned.
                 *
                 * The middleware will also automatically handle the `OPTIONS` method,
                 * responding with a `200 OK` when the `Allowed` header sent to the allowed
                 * methods for a given route.
                 *
                 * By default, a "not allowed" request will respond with a `405 Not Allowed`
                 * and a "not implemented" will respond with a `501 Not Implemented`. Setting
                 * the option `.throw` to `true` will cause the middleware to throw an
                 * `HTTPError` instead of setting the response status.  The error can be
                 * overridden by providing a `.notImplemented` or `.notAllowed` method in the
                 * options, of which the value will be returned will be thrown instead of the
                 * HTTP error. */
                allowedMethods(options = {}) {
                    const implemented = this.#methods;
                    const allowedMethods = async (context, next) => {
                        const ctx = context;
                        await next();
                        if (!ctx.response.status || ctx.response.status === deps_ts_14.Status.NotFound) {
                            deps_ts_14.assert(ctx.matched);
                            const allowed = new Set();
                            for (const route of ctx.matched) {
                                for (const method of route.methods) {
                                    allowed.add(method);
                                }
                            }
                            const allowedStr = [...allowed].join(", ");
                            if (!implemented.includes(ctx.request.method)) {
                                if (options.throw) {
                                    throw options.notImplemented
                                        ? options.notImplemented()
                                        : new httpError_ts_7.httpErrors.NotImplemented();
                                }
                                else {
                                    ctx.response.status = deps_ts_14.Status.NotImplemented;
                                    ctx.response.headers.set("Allowed", allowedStr);
                                }
                            }
                            else if (allowed.size) {
                                if (ctx.request.method === "OPTIONS") {
                                    ctx.response.status = deps_ts_14.Status.OK;
                                    ctx.response.headers.set("Allowed", allowedStr);
                                }
                                else if (!allowed.has(ctx.request.method)) {
                                    if (options.throw) {
                                        throw options.methodNotAllowed
                                            ? options.methodNotAllowed()
                                            : new httpError_ts_7.httpErrors.MethodNotAllowed();
                                    }
                                    else {
                                        ctx.response.status = deps_ts_14.Status.MethodNotAllowed;
                                        ctx.response.headers.set("Allowed", allowedStr);
                                    }
                                }
                            }
                        }
                    };
                    return allowedMethods;
                }
                delete(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["DELETE"]);
                    return this;
                }
                /** Iterate over the routes currently added to the router.  To be compatible
                 * with the iterable interfaces, both the key and value are set to the value
                 * of the route. */
                *entries() {
                    for (const route of this.#stack) {
                        const value = route.toJSON();
                        yield [value, value];
                    }
                }
                /** Iterate over the routes currently added to the router, calling the
                 * `callback` function for each value. */
                forEach(callback, thisArg = null) {
                    for (const route of this.#stack) {
                        const value = route.toJSON();
                        callback.call(thisArg, value, value, this);
                    }
                }
                get(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["GET"]);
                    return this;
                }
                head(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["HEAD"]);
                    return this;
                }
                /** Iterate over the routes currently added to the router.  To be compatible
                 * with the iterable interfaces, the key is set to the value of the route. */
                *keys() {
                    for (const route of this.#stack) {
                        yield route.toJSON();
                    }
                }
                options(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["OPTIONS"]);
                    return this;
                }
                /** Register param middleware, which will be called when the particular param
                 * is parsed from the route. */
                param(param, middleware) {
                    this.#params[param] = middleware;
                    for (const route of this.#stack) {
                        route.param(param, middleware);
                    }
                    return this;
                }
                patch(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["PATCH"]);
                    return this;
                }
                post(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["POST"]);
                    return this;
                }
                /** Set the router prefix for this router. */
                prefix(prefix) {
                    prefix = prefix.replace(/\/$/, "");
                    this.#opts.prefix = prefix;
                    for (const route of this.#stack) {
                        route.setPrefix(prefix);
                    }
                    return this;
                }
                put(nameOrPath, pathOrMiddleware, ...middleware) {
                    this.#useVerb(nameOrPath, pathOrMiddleware, middleware, ["PUT"]);
                    return this;
                }
                /** Register a direction middleware, where when the `source` path is matched
                 * the router will redirect the request to the `destination` path.  A `status`
                 * of `302 Found` will be set by default.
                 *
                 * The `source` and `destination` can be named routes. */
                redirect(source, destination, status = deps_ts_14.Status.Found) {
                    if (source[0] !== "/") {
                        const s = this.url(source);
                        if (!s) {
                            throw new RangeError(`Could not resolve named route: "${source}"`);
                        }
                        source = s;
                    }
                    if (destination[0] !== "/") {
                        const d = this.url(destination);
                        if (!d) {
                            throw new RangeError(`Could not resolve named route: "${source}"`);
                        }
                        destination = d;
                    }
                    this.all(source, (ctx) => {
                        ctx.response.redirect(destination);
                        ctx.response.status = status;
                    });
                    return this;
                }
                /** Return middleware that will do all the route processing that the router
                 * has been configured to handle.  Typical usage would be something like this:
                 *
                 * ```ts
                 * import { Application, Router } from "https://deno.land/x/oak/mod.ts";
                 *
                 * const app = new Application();
                 * const router = new Router();
                 *
                 * // register routes
                 *
                 * app.use(router.routes());
                 * app.use(router.allowedMethods());
                 * await app.listen({ port: 80 });
                 * ```
                 */
                routes() {
                    const dispatch = (context, next) => {
                        const ctx = context;
                        const { url: { pathname }, method } = ctx.request;
                        const path = this.#opts.routerPath ?? ctx.routerPath ?? pathname;
                        const matches = this.#match(path, method);
                        if (ctx.matched) {
                            ctx.matched.push(...matches.path);
                        }
                        else {
                            ctx.matched = [...matches.path];
                        }
                        ctx.router = this;
                        if (!matches.route)
                            return next();
                        const { pathAndMethod: matchedRoutes } = matches;
                        const chain = matchedRoutes.reduce((prev, route) => [
                            ...prev,
                            (ctx, next) => {
                                ctx.captures = route.captures(path);
                                ctx.params = route.params(ctx.captures, ctx.params);
                                ctx.routeName = route.name;
                                return next();
                            },
                            ...route.stack,
                        ], []);
                        return middleware_ts_2.compose(chain)(ctx, next);
                    };
                    dispatch.router = this;
                    return dispatch;
                }
                /** Generate a URL pathname for a named route, interpolating the optional
                 * params provided.  Also accepts an optional set of options. */
                url(name, params, options) {
                    const route = this.#route(name);
                    if (route) {
                        return route.url(params, options);
                    }
                }
                use(pathOrMiddleware, ...middleware) {
                    let path;
                    if (typeof pathOrMiddleware === "string" || Array.isArray(pathOrMiddleware)) {
                        path = pathOrMiddleware;
                    }
                    else {
                        middleware.unshift(pathOrMiddleware);
                    }
                    this.#register(path ?? "(.*)", middleware, [], { end: false, ignoreCaptures: !path });
                    return this;
                }
                /** Iterate over the routes currently added to the router. */
                *values() {
                    for (const route of this.#stack) {
                        yield route.toJSON();
                    }
                }
                /** Provide an iterator interface that iterates over the routes registered
                 * with the router. */
                *[Symbol.iterator]() {
                    for (const route of this.#stack) {
                        yield route.toJSON();
                    }
                }
                /** Generate a URL pathname based on the provided path, interpolating the
                 * optional params provided.  Also accepts an optional set of options. */
                static url(path, params, options) {
                    return toUrl(path, params, options);
                }
            };
            exports_60("Router", Router);
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://linweiwei123.github.io/aok/helpers", [], function (exports_61, context_61) {
    "use strict";
    var __moduleName = context_61 && context_61.id;
    function isRouterContext(value) {
        return "params" in value;
    }
    function getQuery(ctx, { mergeParams, asMap } = {}) {
        const result = {};
        if (mergeParams && isRouterContext(ctx)) {
            Object.assign(result, ctx.params);
        }
        for (const [key, value] of ctx.request.url.searchParams) {
            result[key] = value;
        }
        return asMap ? new Map(Object.entries(result)) : result;
    }
    exports_61("getQuery", getQuery);
    return {
        setters: [],
        execute: function () {
        }
    };
});
// Copyright 2018-2020 the oak authors. All rights reserved. MIT license.
System.register("https://linweiwei123.github.io/aok/mod", ["https://linweiwei123.github.io/aok/application", "https://linweiwei123.github.io/aok/context", "https://linweiwei123.github.io/aok/helpers", "https://linweiwei123.github.io/aok/cookies", "https://linweiwei123.github.io/aok/httpError", "https://linweiwei123.github.io/aok/middleware", "https://linweiwei123.github.io/aok/multipart", "https://linweiwei123.github.io/aok/request", "https://linweiwei123.github.io/aok/response", "https://linweiwei123.github.io/aok/router", "https://linweiwei123.github.io/aok/send", "https://linweiwei123.github.io/aok/server_sent_event", "https://linweiwei123.github.io/aok/util", "https://linweiwei123.github.io/aok/deps"], function (exports_62, context_62) {
    "use strict";
    var __moduleName = context_62 && context_62.id;
    return {
        setters: [
            function (application_ts_1_1) {
                exports_62({
                    "Application": application_ts_1_1["Application"]
                });
            },
            function (context_ts_2_1) {
                exports_62({
                    "Context": context_ts_2_1["Context"]
                });
            },
            function (helpers_1) {
                exports_62("helpers", helpers_1);
            },
            function (cookies_ts_2_1) {
                exports_62({
                    "Cookies": cookies_ts_2_1["Cookies"]
                });
            },
            function (httpError_ts_8_1) {
                exports_62({
                    "HttpError": httpError_ts_8_1["HttpError"],
                    "httpErrors": httpError_ts_8_1["httpErrors"],
                    "isHttpError": httpError_ts_8_1["isHttpError"]
                });
            },
            function (middleware_ts_3_1) {
                exports_62({
                    "composeMiddleware": middleware_ts_3_1["compose"]
                });
            },
            function (multipart_ts_2_1) {
                exports_62({
                    "FormDataReader": multipart_ts_2_1["FormDataReader"]
                });
            },
            function (request_ts_2_1) {
                exports_62({
                    "Request": request_ts_2_1["Request"]
                });
            },
            function (response_ts_2_1) {
                exports_62({
                    "Response": response_ts_2_1["Response"],
                    "REDIRECT_BACK": response_ts_2_1["REDIRECT_BACK"]
                });
            },
            function (router_ts_1_1) {
                exports_62({
                    "Router": router_ts_1_1["Router"]
                });
            },
            function (send_ts_2_1) {
                exports_62({
                    "send": send_ts_2_1["send"]
                });
            },
            function (server_sent_event_ts_2_1) {
                exports_62({
                    "ServerSentEvent": server_sent_event_ts_2_1["ServerSentEvent"],
                    "ServerSentEventTarget": server_sent_event_ts_2_1["ServerSentEventTarget"]
                });
            },
            function (util_ts_10_1) {
                exports_62({
                    "isErrorStatus": util_ts_10_1["isErrorStatus"],
                    "isRedirectStatus": util_ts_10_1["isRedirectStatus"]
                });
            },
            function (deps_ts_15_1) {
                exports_62({
                    "Status": deps_ts_15_1["Status"],
                    "STATUS_TEXT": deps_ts_15_1["STATUS_TEXT"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("file:///Users/norbert/Documents/workspace/deno/deno-ssr/vue/vue.runtime.common.dev.dew", [], function (exports_63, context_63) {
    "use strict";
    var exports, _dewExec, _global;
    var __moduleName = context_63 && context_63.id;
    function dew() {
        if (_dewExec)
            return exports;
        _dewExec = true;
        /*  */
        var emptyObject = Object.freeze({}); // These helpers produce better VM code in JS engines due to their
        // explicitness and function inlining.
        function isUndef(v) {
            return v === undefined || v === null;
        }
        function isDef(v) {
            return v !== undefined && v !== null;
        }
        function isTrue(v) {
            return v === true;
        }
        function isFalse(v) {
            return v === false;
        }
        /**
         * Check if value is primitive.
         */
        function isPrimitive(value) {
            return typeof value === "string" || typeof value === "number" || // $flow-disable-line
                typeof value === "symbol" || typeof value === "boolean";
        }
        /**
         * Quick object check - this is primarily used to tell
         * Objects from primitive values when we know the value
         * is a JSON-compliant type.
         */
        function isObject(obj) {
            return obj !== null && typeof obj === "object";
        }
        /**
         * Get the raw type string of a value, e.g., [object Object].
         */
        var _toString = Object.prototype.toString;
        function toRawType(value) {
            return _toString.call(value).slice(8, -1);
        }
        /**
         * Strict object type check. Only returns true
         * for plain JavaScript objects.
         */
        function isPlainObject(obj) {
            return _toString.call(obj) === "[object Object]";
        }
        function isRegExp(v) {
            return _toString.call(v) === "[object RegExp]";
        }
        /**
         * Check if val is a valid array index.
         */
        function isValidArrayIndex(val) {
            var n = parseFloat(String(val));
            return n >= 0 && Math.floor(n) === n && isFinite(val);
        }
        function isPromise(val) {
            return isDef(val) && typeof val.then === "function" &&
                typeof val.catch === "function";
        }
        /**
         * Convert a value to a string that is actually rendered.
         */
        function toString(val) {
            return val == null
                ? ""
                : Array.isArray(val) || isPlainObject(val) && val.toString === _toString
                    ? JSON.stringify(val, null, 2)
                    : String(val);
        }
        /**
         * Convert an input value to a number for persistence.
         * If the conversion fails, return original string.
         */
        function toNumber(val) {
            var n = parseFloat(val);
            return isNaN(n) ? val : n;
        }
        /**
         * Make a map and return a function for checking if a key
         * is in that map.
         */
        function makeMap(str, expectsLowerCase) {
            var map = Object.create(null);
            var list = str.split(",");
            for (var i = 0; i < list.length; i++) {
                map[list[i]] = true;
            }
            return expectsLowerCase
                ? function (val) {
                    return map[val.toLowerCase()];
                }
                : function (val) {
                    return map[val];
                };
        }
        /**
         * Check if a tag is a built-in tag.
         */
        var isBuiltInTag = makeMap("slot,component", true);
        /**
         * Check if an attribute is a reserved attribute.
         */
        var isReservedAttribute = makeMap("key,ref,slot,slot-scope,is");
        /**
         * Remove an item from an array.
         */
        function remove(arr, item) {
            if (arr.length) {
                var index = arr.indexOf(item);
                if (index > -1) {
                    return arr.splice(index, 1);
                }
            }
        }
        /**
         * Check whether an object has the property.
         */
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        function hasOwn(obj, key) {
            return hasOwnProperty.call(obj, key);
        }
        /**
         * Create a cached version of a pure function.
         */
        function cached(fn) {
            var cache = Object.create(null);
            return function cachedFn(str) {
                var hit = cache[str];
                return hit || (cache[str] = fn(str));
            };
        }
        /**
         * Camelize a hyphen-delimited string.
         */
        var camelizeRE = /-(\w)/g;
        var camelize = cached(function (str) {
            return str.replace(camelizeRE, function (_, c) {
                return c ? c.toUpperCase() : "";
            });
        });
        /**
         * Capitalize a string.
         */
        var capitalize = cached(function (str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        });
        /**
         * Hyphenate a camelCase string.
         */
        var hyphenateRE = /\B([A-Z])/g;
        var hyphenate = cached(function (str) {
            return str.replace(hyphenateRE, "-$1").toLowerCase();
        });
        /**
         * Simple bind polyfill for environments that do not support it,
         * e.g., PhantomJS 1.x. Technically, we don't need this anymore
         * since native bind is now performant enough in most browsers.
         * But removing it would mean breaking code that was able to run in
         * PhantomJS 1.x, so this must be kept for backward compatibility.
         */
        /* istanbul ignore next */
        function polyfillBind(fn, ctx) {
            function boundFn(a) {
                var l = arguments.length;
                return l
                    ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a)
                    : fn.call(ctx);
            }
            boundFn._length = fn.length;
            return boundFn;
        }
        function nativeBind(fn, ctx) {
            return fn.bind(ctx);
        }
        var bind = Function.prototype.bind ? nativeBind : polyfillBind;
        /**
         * Convert an Array-like object to a real Array.
         */
        function toArray(list, start) {
            start = start || 0;
            var i = list.length - start;
            var ret = new Array(i);
            while (i--) {
                ret[i] = list[i + start];
            }
            return ret;
        }
        /**
         * Mix properties into target object.
         */
        function extend(to, _from) {
            for (var key in _from) {
                to[key] = _from[key];
            }
            return to;
        }
        /**
         * Merge an Array of Objects into a single Object.
         */
        function toObject(arr) {
            var res = {};
            for (var i = 0; i < arr.length; i++) {
                if (arr[i]) {
                    extend(res, arr[i]);
                }
            }
            return res;
        }
        /* eslint-disable no-unused-vars */
        /**
         * Perform no operation.
         * Stubbing args to make Flow happy without leaving useless transpiled code
         * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
         */
        function noop(a, b, c) { }
        /**
         * Always return false.
         */
        var no = function (a, b, c) {
            return false;
        };
        /* eslint-enable no-unused-vars */
        /**
         * Return the same value.
         */
        var identity = function (_) {
            return _;
        };
        /**
         * Check if two values are loosely equal - that is,
         * if they are plain objects, do they have the same shape?
         */
        function looseEqual(a, b) {
            if (a === b) {
                return true;
            }
            var isObjectA = isObject(a);
            var isObjectB = isObject(b);
            if (isObjectA && isObjectB) {
                try {
                    var isArrayA = Array.isArray(a);
                    var isArrayB = Array.isArray(b);
                    if (isArrayA && isArrayB) {
                        return a.length === b.length && a.every(function (e, i) {
                            return looseEqual(e, b[i]);
                        });
                    }
                    else if (a instanceof Date && b instanceof Date) {
                        return a.getTime() === b.getTime();
                    }
                    else if (!isArrayA && !isArrayB) {
                        var keysA = Object.keys(a);
                        var keysB = Object.keys(b);
                        return keysA.length === keysB.length && keysA.every(function (key) {
                            return looseEqual(a[key], b[key]);
                        });
                    }
                    else {
                        /* istanbul ignore next */
                        return false;
                    }
                }
                catch (e) {
                    /* istanbul ignore next */
                    return false;
                }
            }
            else if (!isObjectA && !isObjectB) {
                return String(a) === String(b);
            }
            else {
                return false;
            }
        }
        /**
         * Return the first index at which a loosely equal value can be
         * found in the array (if value is a plain object, the array must
         * contain an object of the same shape), or -1 if it is not present.
         */
        function looseIndexOf(arr, val) {
            for (var i = 0; i < arr.length; i++) {
                if (looseEqual(arr[i], val)) {
                    return i;
                }
            }
            return -1;
        }
        /**
         * Ensure a function is called only once.
         */
        function once(fn) {
            var called = false;
            return function () {
                if (!called) {
                    called = true;
                    fn.apply(this, arguments);
                }
            };
        }
        var SSR_ATTR = "data-server-rendered";
        var ASSET_TYPES = ["component", "directive", "filter"];
        var LIFECYCLE_HOOKS = [
            "beforeCreate",
            "created",
            "beforeMount",
            "mounted",
            "beforeUpdate",
            "updated",
            "beforeDestroy",
            "destroyed",
            "activated",
            "deactivated",
            "errorCaptured",
            "serverPrefetch",
        ];
        /*  */
        var config = {
            /**
             * Option merge strategies (used in core/util/options)
             */
            // $flow-disable-line
            optionMergeStrategies: Object.create(null),
            /**
             * Whether to suppress warnings.
             */
            silent: false,
            /**
             * Show production mode tip message on boot?
             */
            productionTip: "development" !== "production",
            /**
             * Whether to enable devtools
             */
            devtools: "development" !== "production",
            /**
             * Whether to record perf
             */
            performance: false,
            /**
             * Error handler for watcher errors
             */
            errorHandler: null,
            /**
             * Warn handler for watcher warns
             */
            warnHandler: null,
            /**
             * Ignore certain custom elements
             */
            ignoredElements: [],
            /**
             * Custom user key aliases for v-on
             */
            // $flow-disable-line
            keyCodes: Object.create(null),
            /**
             * Check if a tag is reserved so that it cannot be registered as a
             * component. This is platform-dependent and may be overwritten.
             */
            isReservedTag: no,
            /**
             * Check if an attribute is reserved so that it cannot be used as a component
             * prop. This is platform-dependent and may be overwritten.
             */
            isReservedAttr: no,
            /**
             * Check if a tag is an unknown element.
             * Platform-dependent.
             */
            isUnknownElement: no,
            /**
             * Get the namespace of an element
             */
            getTagNamespace: noop,
            /**
             * Parse the real tag name for the specific platform.
             */
            parsePlatformTagName: identity,
            /**
             * Check if an attribute must be bound using property, e.g. value
             * Platform-dependent.
             */
            mustUseProp: no,
            /**
             * Perform updates asynchronously. Intended to be used by Vue Test Utils
             * This will significantly reduce performance if set to false.
             */
            async: true,
            /**
             * Exposed for legacy reasons
             */
            _lifecycleHooks: LIFECYCLE_HOOKS,
        };
        /*  */
        /**
         * unicode letters used for parsing html tags, component names and property paths.
         * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
         * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
         */
        var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
        /**
         * Check if a string starts with $ or _
         */
        function isReserved(str) {
            var c = (str + "").charCodeAt(0);
            return c === 0x24 || c === 0x5F;
        }
        /**
         * Define a property.
         */
        function def(obj, key, val, enumerable) {
            Object.defineProperty(obj, key, {
                value: val,
                enumerable: !!enumerable,
                writable: true,
                configurable: true,
            });
        }
        /**
         * Parse simple path.
         */
        var bailRE = new RegExp("[^" + unicodeRegExp.source + ".$_\\d]");
        function parsePath(path) {
            if (bailRE.test(path)) {
                return;
            }
            var segments = path.split(".");
            return function (obj) {
                for (var i = 0; i < segments.length; i++) {
                    if (!obj) {
                        return;
                    }
                    obj = obj[segments[i]];
                }
                return obj;
            };
        }
        /*  */
        // can we use __proto__?
        var hasProto = "__proto__" in {}; // Browser environment sniffing
        var inBrowser = typeof window !== "undefined" &&
            window.toString() == "[object Window]";
        var inWeex = typeof WXEnvironment !== "undefined" && !!WXEnvironment.platform;
        var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
        var UA = inBrowser && "userAgent";
        var isIE = UA && /msie|trident/.test(UA);
        var isIE9 = UA && UA.indexOf("msie 9.0") > 0;
        var isEdge = UA && UA.indexOf("edge/") > 0;
        var isAndroid = UA && UA.indexOf("android") > 0 || weexPlatform === "android";
        var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === "ios";
        var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
        var isPhantomJS = UA && /phantomjs/.test(UA);
        var isFF = UA && UA.match(/firefox\/(\d+)/); // Firefox has a "watch" function on Object.prototype...
        var nativeWatch = {}.watch;
        var supportsPassive = false;
        if (inBrowser) {
            try {
                var opts = {};
                Object.defineProperty(opts, "passive", {
                    get: function get() {
                        /* istanbul ignore next */
                        supportsPassive = true;
                    },
                }); // https://github.com/facebook/flow/issues/285
                window.addEventListener("test-passive", null, opts);
            }
            catch (e) { }
        } // this needs to be lazy-evaled because vue may be required before
        // vue-server-renderer can set VUE_ENV
        var _isServer;
        var isServerRendering = function () {
            if (_isServer === undefined) {
                /* istanbul ignore if */
                if (!inBrowser && !inWeex && typeof _global !== "undefined") {
                    // detect presence of vue-server-renderer and avoid
                    // Webpack shimming the process
                    _isServer = _global["process"] &&
                        _global["process"].env.VUE_ENV === "server";
                }
                else {
                    _isServer = false;
                }
            }
            return _isServer;
        }; // detect devtools
        var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
        /* istanbul ignore next */
        function isNative(Ctor) {
            return typeof Ctor === "function" && /native code/.test(Ctor.toString());
        }
        var hasSymbol = typeof Symbol !== "undefined" && isNative(Symbol) &&
            typeof Reflect !== "undefined" && isNative(Reflect.ownKeys);
        var _Set;
        /* istanbul ignore if */
        // $flow-disable-line
        if (typeof Set !== "undefined" && isNative(Set)) {
            // use native Set when available.
            _Set = Set;
        }
        else {
            // a non-standard Set polyfill that only works with primitive keys.
            _Set =
                /*@__PURE__*/
                function () {
                    function Set() {
                        this.set = Object.create(null);
                    }
                    Set.prototype.has = function has(key) {
                        return this.set[key] === true;
                    };
                    Set.prototype.add = function add(key) {
                        this.set[key] = true;
                    };
                    Set.prototype.clear = function clear() {
                        this.set = Object.create(null);
                    };
                    return Set;
                }();
        }
        /*  */
        var warn = noop;
        var tip = noop;
        var generateComponentTrace = noop; // work around flow check
        var formatComponentName = noop;
        {
            var hasConsole = typeof console !== "undefined";
            var classifyRE = /(?:^|[-_])(\w)/g;
            var classify = function (str) {
                return str.replace(classifyRE, function (c) {
                    return c.toUpperCase();
                }).replace(/[-_]/g, "");
            };
            warn = function (msg, vm) {
                var trace = vm ? generateComponentTrace(vm) : "";
                if (config.warnHandler) {
                    config.warnHandler.call(null, msg, vm, trace);
                }
                else if (hasConsole && !config.silent) {
                    console.error("[Vue warn]: " + msg + trace);
                }
            };
            tip = function (msg, vm) {
                if (hasConsole && !config.silent) {
                    console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ""));
                }
            };
            formatComponentName = function (vm, includeFile) {
                if (vm.$root === vm) {
                    return "<Root>";
                }
                var options = typeof vm === "function" && vm.cid != null
                    ? vm.options
                    : vm._isVue
                        ? vm.$options || vm.constructor.options
                        : vm;
                var name = options.name || options._componentTag;
                var file = options.__file;
                if (!name && file) {
                    var match = file.match(/([^/\\]+)\.vue$/);
                    name = match && match[1];
                }
                return (name ? "<" + classify(name) + ">" : "<Anonymous>") +
                    (file && includeFile !== false ? " at " + file : "");
            };
            var repeat = function (str, n) {
                var res = "";
                while (n) {
                    if (n % 2 === 1) {
                        res += str;
                    }
                    if (n > 1) {
                        str += str;
                    }
                    n >>= 1;
                }
                return res;
            };
            generateComponentTrace = function (vm) {
                if (vm._isVue && vm.$parent) {
                    var tree = [];
                    var currentRecursiveSequence = 0;
                    while (vm) {
                        if (tree.length > 0) {
                            var last = tree[tree.length - 1];
                            if (last.constructor === vm.constructor) {
                                currentRecursiveSequence++;
                                vm = vm.$parent;
                                continue;
                            }
                            else if (currentRecursiveSequence > 0) {
                                tree[tree.length - 1] = [last, currentRecursiveSequence];
                                currentRecursiveSequence = 0;
                            }
                        }
                        tree.push(vm);
                        vm = vm.$parent;
                    }
                    return "\n\nfound in\n\n" + tree.map(function (vm, i) {
                        return "" + (i === 0 ? "---> " : repeat(" ", 5 + i * 2)) +
                            (Array.isArray(vm)
                                ? formatComponentName(vm[0]) + "... (" + vm[1] +
                                    " recursive calls)"
                                : formatComponentName(vm));
                    }).join("\n");
                }
                else {
                    return "\n\n(found in " + formatComponentName(vm) + ")";
                }
            };
        }
        /*  */
        var uid = 0;
        /**
         * A dep is an observable that can have multiple
         * directives subscribing to it.
         */
        var Dep = function Dep() {
            this.id = uid++;
            this.subs = [];
        };
        Dep.prototype.addSub = function addSub(sub) {
            this.subs.push(sub);
        };
        Dep.prototype.removeSub = function removeSub(sub) {
            remove(this.subs, sub);
        };
        Dep.prototype.depend = function depend() {
            if (Dep.target) {
                Dep.target.addDep(this);
            }
        };
        Dep.prototype.notify = function notify() {
            // stabilize the subscriber list first
            var subs = this.subs.slice();
            if (!config.async) {
                // subs aren't sorted in scheduler if not running async
                // we need to sort them now to make sure they fire in correct
                // order
                subs.sort(function (a, b) {
                    return a.id - b.id;
                });
            }
            for (var i = 0, l = subs.length; i < l; i++) {
                subs[i].update();
            }
        }; // The current target watcher being evaluated.
        // This is globally unique because only one watcher
        // can be evaluated at a time.
        Dep.target = null;
        var targetStack = [];
        function pushTarget(target) {
            targetStack.push(target);
            Dep.target = target;
        }
        function popTarget() {
            targetStack.pop();
            Dep.target = targetStack[targetStack.length - 1];
        }
        /*  */
        var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
            this.tag = tag;
            this.data = data;
            this.children = children;
            this.text = text;
            this.elm = elm;
            this.ns = undefined;
            this.context = context;
            this.fnContext = undefined;
            this.fnOptions = undefined;
            this.fnScopeId = undefined;
            this.key = data && data.key;
            this.componentOptions = componentOptions;
            this.componentInstance = undefined;
            this.parent = undefined;
            this.raw = false;
            this.isStatic = false;
            this.isRootInsert = true;
            this.isComment = false;
            this.isCloned = false;
            this.isOnce = false;
            this.asyncFactory = asyncFactory;
            this.asyncMeta = undefined;
            this.isAsyncPlaceholder = false;
        };
        var prototypeAccessors = {
            child: {
                configurable: true,
            },
        }; // DEPRECATED: alias for componentInstance for backwards compat.
        /* istanbul ignore next */
        prototypeAccessors.child.get = function () {
            return this.componentInstance;
        };
        Object.defineProperties(VNode.prototype, prototypeAccessors);
        var createEmptyVNode = function (text) {
            if (text === void 0)
                text = "";
            var node = new VNode();
            node.text = text;
            node.isComment = true;
            return node;
        };
        function createTextVNode(val) {
            return new VNode(undefined, undefined, undefined, String(val));
        } // optimized shallow clone
        // used for static nodes and slot nodes because they may be reused across
        // multiple renders, cloning them avoids errors when DOM manipulations rely
        // on their elm reference.
        function cloneVNode(vnode) {
            var cloned = new VNode(vnode.tag, vnode.data, // #7975
            // clone children array to avoid mutating original in case of cloning
            // a child.
            vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
            cloned.ns = vnode.ns;
            cloned.isStatic = vnode.isStatic;
            cloned.key = vnode.key;
            cloned.isComment = vnode.isComment;
            cloned.fnContext = vnode.fnContext;
            cloned.fnOptions = vnode.fnOptions;
            cloned.fnScopeId = vnode.fnScopeId;
            cloned.asyncMeta = vnode.asyncMeta;
            cloned.isCloned = true;
            return cloned;
        }
        /*
         * not type checking this file because flow doesn't play well with
         * dynamically accessing methods on Array prototype
         */
        var arrayProto = Array.prototype;
        var arrayMethods = Object.create(arrayProto);
        var methodsToPatch = [
            "push",
            "pop",
            "shift",
            "unshift",
            "splice",
            "sort",
            "reverse",
        ];
        /**
         * Intercept mutating methods and emit events
         */
        methodsToPatch.forEach(function (method) {
            // cache original method
            var original = arrayProto[method];
            def(arrayMethods, method, function mutator() {
                var args = [], len = arguments.length;
                while (len--)
                    args[len] = arguments[len];
                var result = original.apply(this, args);
                var ob = this.__ob__;
                var inserted;
                switch (method) {
                    case "push":
                    case "unshift":
                        inserted = args;
                        break;
                    case "splice":
                        inserted = args.slice(2);
                        break;
                }
                if (inserted) {
                    ob.observeArray(inserted);
                } // notify change
                ob.dep.notify();
                return result;
            });
        });
        /*  */
        var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
        /**
         * In some cases we may want to disable observation inside a component's
         * update computation.
         */
        var shouldObserve = true;
        function toggleObserving(value) {
            shouldObserve = value;
        }
        /**
         * Observer class that is attached to each observed
         * object. Once attached, the observer converts the target
         * object's property keys into getter/setters that
         * collect dependencies and dispatch updates.
         */
        var Observer = function Observer(value) {
            this.value = value;
            this.dep = new Dep();
            this.vmCount = 0;
            def(value, "__ob__", this);
            if (Array.isArray(value)) {
                if (hasProto) {
                    protoAugment(value, arrayMethods);
                }
                else {
                    copyAugment(value, arrayMethods, arrayKeys);
                }
                this.observeArray(value);
            }
            else {
                this.walk(value);
            }
        };
        /**
         * Walk through all properties and convert them into
         * getter/setters. This method should only be called when
         * value type is Object.
         */
        Observer.prototype.walk = function walk(obj) {
            var keys = Object.keys(obj);
            for (var i = 0; i < keys.length; i++) {
                defineReactive$$1(obj, keys[i]);
            }
        };
        /**
         * Observe a list of Array items.
         */
        Observer.prototype.observeArray = function observeArray(items) {
            for (var i = 0, l = items.length; i < l; i++) {
                observe(items[i]);
            }
        }; // helpers
        /**
         * Augment a target Object or Array by intercepting
         * the prototype chain using __proto__
         */
        function protoAugment(target, src) {
            /* eslint-disable no-proto */
            target.__proto__ = src;
            /* eslint-enable no-proto */
        }
        /**
         * Augment a target Object or Array by defining
         * hidden properties.
         */
        /* istanbul ignore next */
        function copyAugment(target, src, keys) {
            for (var i = 0, l = keys.length; i < l; i++) {
                var key = keys[i];
                def(target, key, src[key]);
            }
        }
        /**
         * Attempt to create an observer instance for a value,
         * returns the new observer if successfully observed,
         * or the existing observer if the value already has one.
         */
        function observe(value, asRootData) {
            if (!isObject(value) || value instanceof VNode) {
                return;
            }
            var ob;
            if (hasOwn(value, "__ob__") && value.__ob__ instanceof Observer) {
                ob = value.__ob__;
            }
            else if (shouldObserve && !isServerRendering() &&
                (Array.isArray(value) || isPlainObject(value)) &&
                Object.isExtensible(value) && !value._isVue) {
                ob = new Observer(value);
            }
            if (asRootData && ob) {
                ob.vmCount++;
            }
            return ob;
        }
        /**
         * Define a reactive property on an Object.
         */
        function defineReactive$$1(obj, key, val, customSetter, shallow) {
            var dep = new Dep();
            var property = Object.getOwnPropertyDescriptor(obj, key);
            if (property && property.configurable === false) {
                return;
            } // cater for pre-defined getter/setters
            var getter = property && property.get;
            var setter = property && property.set;
            if ((!getter || setter) && arguments.length === 2) {
                val = obj[key];
            }
            var childOb = !shallow && observe(val);
            Object.defineProperty(obj, key, {
                enumerable: true,
                configurable: true,
                get: function reactiveGetter() {
                    var value = getter ? getter.call(obj) : val;
                    if (Dep.target) {
                        dep.depend();
                        if (childOb) {
                            childOb.dep.depend();
                            if (Array.isArray(value)) {
                                dependArray(value);
                            }
                        }
                    }
                    return value;
                },
                set: function reactiveSetter(newVal) {
                    var value = getter ? getter.call(obj) : val;
                    /* eslint-disable no-self-compare */
                    if (newVal === value || newVal !== newVal && value !== value) {
                        return;
                    }
                    /* eslint-enable no-self-compare */
                    if (customSetter) {
                        customSetter();
                    } // #7981: for accessor properties without setter
                    if (getter && !setter) {
                        return;
                    }
                    if (setter) {
                        setter.call(obj, newVal);
                    }
                    else {
                        val = newVal;
                    }
                    childOb = !shallow && observe(newVal);
                    dep.notify();
                },
            });
        }
        /**
         * Set a property on an object. Adds the new property and
         * triggers change notification if the property doesn't
         * already exist.
         */
        function set(target, key, val) {
            if (isUndef(target) || isPrimitive(target)) {
                warn("Cannot set reactive property on undefined, null, or primitive value: " +
                    target);
            }
            if (Array.isArray(target) && isValidArrayIndex(key)) {
                target.length = Math.max(target.length, key);
                target.splice(key, 1, val);
                return val;
            }
            if (key in target && !(key in Object.prototype)) {
                target[key] = val;
                return val;
            }
            var ob = target.__ob__;
            if (target._isVue || ob && ob.vmCount) {
                warn("Avoid adding reactive properties to a Vue instance or its root $data " +
                    "at runtime - declare it upfront in the data option.");
                return val;
            }
            if (!ob) {
                target[key] = val;
                return val;
            }
            defineReactive$$1(ob.value, key, val);
            ob.dep.notify();
            return val;
        }
        /**
         * Delete a property and trigger change if necessary.
         */
        function del(target, key) {
            if (isUndef(target) || isPrimitive(target)) {
                warn("Cannot delete reactive property on undefined, null, or primitive value: " +
                    target);
            }
            if (Array.isArray(target) && isValidArrayIndex(key)) {
                target.splice(key, 1);
                return;
            }
            var ob = target.__ob__;
            if (target._isVue || ob && ob.vmCount) {
                warn("Avoid deleting properties on a Vue instance or its root $data " +
                    "- just set it to null.");
                return;
            }
            if (!hasOwn(target, key)) {
                return;
            }
            delete target[key];
            if (!ob) {
                return;
            }
            ob.dep.notify();
        }
        /**
         * Collect dependencies on array elements when the array is touched, since
         * we cannot intercept array element access like property getters.
         */
        function dependArray(value) {
            for (var e = void 0, i = 0, l = value.length; i < l; i++) {
                e = value[i];
                e && e.__ob__ && e.__ob__.dep.depend();
                if (Array.isArray(e)) {
                    dependArray(e);
                }
            }
        }
        /*  */
        /**
         * Option overwriting strategies are functions that handle
         * how to merge a parent option value and a child option
         * value into the final value.
         */
        var strats = config.optionMergeStrategies;
        /**
         * Options with restrictions
         */
        {
            strats.el = strats.propsData = function (parent, child, vm, key) {
                if (!vm) {
                    warn('option "' + key + '" can only be used during instance ' +
                        "creation with the `new` keyword.");
                }
                return defaultStrat(parent, child);
            };
        }
        /**
         * Helper that recursively merges two data objects together.
         */
        function mergeData(to, from) {
            if (!from) {
                return to;
            }
            var key, toVal, fromVal;
            var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);
            for (var i = 0; i < keys.length; i++) {
                key = keys[i]; // in case the object is already observed...
                if (key === "__ob__") {
                    continue;
                }
                toVal = to[key];
                fromVal = from[key];
                if (!hasOwn(to, key)) {
                    set(to, key, fromVal);
                }
                else if (toVal !== fromVal && isPlainObject(toVal) && isPlainObject(fromVal)) {
                    mergeData(toVal, fromVal);
                }
            }
            return to;
        }
        /**
         * Data
         */
        function mergeDataOrFn(parentVal, childVal, vm) {
            if (!vm) {
                // in a Vue.extend merge, both should be functions
                if (!childVal) {
                    return parentVal;
                }
                if (!parentVal) {
                    return childVal;
                } // when parentVal & childVal are both present,
                // we need to return a function that returns the
                // merged result of both functions... no need to
                // check if parentVal is a function here because
                // it has to be a function to pass previous merges.
                return function mergedDataFn() {
                    return mergeData(typeof childVal === "function" ? childVal.call(this, this) : childVal, typeof parentVal === "function"
                        ? parentVal.call(this, this)
                        : parentVal);
                };
            }
            else {
                return function mergedInstanceDataFn() {
                    // instance merge
                    var instanceData = typeof childVal === "function"
                        ? childVal.call(vm, vm)
                        : childVal;
                    var defaultData = typeof parentVal === "function"
                        ? parentVal.call(vm, vm)
                        : parentVal;
                    if (instanceData) {
                        return mergeData(instanceData, defaultData);
                    }
                    else {
                        return defaultData;
                    }
                };
            }
        }
        strats.data = function (parentVal, childVal, vm) {
            if (!vm) {
                if (childVal && typeof childVal !== "function") {
                    warn('The "data" option should be a function ' +
                        "that returns a per-instance value in component " + "definitions.", vm);
                    return parentVal;
                }
                return mergeDataOrFn(parentVal, childVal);
            }
            return mergeDataOrFn(parentVal, childVal, vm);
        };
        /**
         * Hooks and props are merged as arrays.
         */
        function mergeHook(parentVal, childVal) {
            var res = childVal
                ? parentVal
                    ? parentVal.concat(childVal)
                    : Array.isArray(childVal)
                        ? childVal
                        : [childVal]
                : parentVal;
            return res ? dedupeHooks(res) : res;
        }
        function dedupeHooks(hooks) {
            var res = [];
            for (var i = 0; i < hooks.length; i++) {
                if (res.indexOf(hooks[i]) === -1) {
                    res.push(hooks[i]);
                }
            }
            return res;
        }
        LIFECYCLE_HOOKS.forEach(function (hook) {
            strats[hook] = mergeHook;
        });
        /**
         * Assets
         *
         * When a vm is present (instance creation), we need to do
         * a three-way merge between constructor options, instance
         * options and parent options.
         */
        function mergeAssets(parentVal, childVal, vm, key) {
            var res = Object.create(parentVal || null);
            if (childVal) {
                assertObjectType(key, childVal, vm);
                return extend(res, childVal);
            }
            else {
                return res;
            }
        }
        ASSET_TYPES.forEach(function (type) {
            strats[type + "s"] = mergeAssets;
        });
        /**
         * Watchers.
         *
         * Watchers hashes should not overwrite one
         * another, so we merge them as arrays.
         */
        strats.watch = function (parentVal, childVal, vm, key) {
            // work around Firefox's Object.prototype.watch...
            if (parentVal === nativeWatch) {
                parentVal = undefined;
            }
            if (childVal === nativeWatch) {
                childVal = undefined;
            }
            /* istanbul ignore if */
            if (!childVal) {
                return Object.create(parentVal || null);
            }
            {
                assertObjectType(key, childVal, vm);
            }
            if (!parentVal) {
                return childVal;
            }
            var ret = {};
            extend(ret, parentVal);
            for (var key$1 in childVal) {
                var parent = ret[key$1];
                var child = childVal[key$1];
                if (parent && !Array.isArray(parent)) {
                    parent = [parent];
                }
                ret[key$1] = parent
                    ? parent.concat(child)
                    : Array.isArray(child)
                        ? child
                        : [child];
            }
            return ret;
        };
        /**
         * Other object hashes.
         */
        strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
            if (childVal && "development" !== "production") {
                assertObjectType(key, childVal, vm);
            }
            if (!parentVal) {
                return childVal;
            }
            var ret = Object.create(null);
            extend(ret, parentVal);
            if (childVal) {
                extend(ret, childVal);
            }
            return ret;
        };
        strats.provide = mergeDataOrFn;
        /**
         * Default strategy.
         */
        var defaultStrat = function (parentVal, childVal) {
            return childVal === undefined ? parentVal : childVal;
        };
        /**
         * Validate component names
         */
        function checkComponents(options) {
            for (var key in options.components) {
                validateComponentName(key);
            }
        }
        function validateComponentName(name) {
            if (!new RegExp("^[a-zA-Z][\\-\\.0-9_" + unicodeRegExp.source + "]*$").test(name)) {
                warn('Invalid component name: "' + name + '". Component names ' +
                    "should conform to valid custom element name in html5 specification.");
            }
            if (isBuiltInTag(name) || config.isReservedTag(name)) {
                warn("Do not use built-in or reserved HTML elements as component " + "id: " +
                    name);
            }
        }
        /**
         * Ensure all props option syntax are normalized into the
         * Object-based format.
         */
        function normalizeProps(options, vm) {
            var props = options.props;
            if (!props) {
                return;
            }
            var res = {};
            var i, val, name;
            if (Array.isArray(props)) {
                i = props.length;
                while (i--) {
                    val = props[i];
                    if (typeof val === "string") {
                        name = camelize(val);
                        res[name] = {
                            type: null,
                        };
                    }
                    else {
                        warn("props must be strings when using array syntax.");
                    }
                }
            }
            else if (isPlainObject(props)) {
                for (var key in props) {
                    val = props[key];
                    name = camelize(key);
                    res[name] = isPlainObject(val) ? val : {
                        type: val,
                    };
                }
            }
            else {
                warn('Invalid value for option "props": expected an Array or an Object, ' +
                    "but got " + toRawType(props) + ".", vm);
            }
            options.props = res;
        }
        /**
         * Normalize all injections into Object-based format
         */
        function normalizeInject(options, vm) {
            var inject = options.inject;
            if (!inject) {
                return;
            }
            var normalized = options.inject = {};
            if (Array.isArray(inject)) {
                for (var i = 0; i < inject.length; i++) {
                    normalized[inject[i]] = {
                        from: inject[i],
                    };
                }
            }
            else if (isPlainObject(inject)) {
                for (var key in inject) {
                    var val = inject[key];
                    normalized[key] = isPlainObject(val)
                        ? extend({
                            from: key,
                        }, val)
                        : {
                            from: val,
                        };
                }
            }
            else {
                warn('Invalid value for option "inject": expected an Array or an Object, ' +
                    "but got " + toRawType(inject) + ".", vm);
            }
        }
        /**
         * Normalize raw function directives into object format.
         */
        function normalizeDirectives(options) {
            var dirs = options.directives;
            if (dirs) {
                for (var key in dirs) {
                    var def$$1 = dirs[key];
                    if (typeof def$$1 === "function") {
                        dirs[key] = {
                            bind: def$$1,
                            update: def$$1,
                        };
                    }
                }
            }
        }
        function assertObjectType(name, value, vm) {
            if (!isPlainObject(value)) {
                warn('Invalid value for option "' + name + '": expected an Object, ' +
                    "but got " + toRawType(value) + ".", vm);
            }
        }
        /**
         * Merge two option objects into a new one.
         * Core utility used in both instantiation and inheritance.
         */
        function mergeOptions(parent, child, vm) {
            {
                checkComponents(child);
            }
            if (typeof child === "function") {
                child = child.options;
            }
            normalizeProps(child, vm);
            normalizeInject(child, vm);
            normalizeDirectives(child); // Apply extends and mixins on the child options,
            // but only if it is a raw options object that isn't
            // the result of another mergeOptions call.
            // Only merged options has the _base property.
            if (!child._base) {
                if (child.extends) {
                    parent = mergeOptions(parent, child.extends, vm);
                }
                if (child.mixins) {
                    for (var i = 0, l = child.mixins.length; i < l; i++) {
                        parent = mergeOptions(parent, child.mixins[i], vm);
                    }
                }
            }
            var options = {};
            var key;
            for (key in parent) {
                mergeField(key);
            }
            for (key in child) {
                if (!hasOwn(parent, key)) {
                    mergeField(key);
                }
            }
            function mergeField(key) {
                var strat = strats[key] || defaultStrat;
                options[key] = strat(parent[key], child[key], vm, key);
            }
            return options;
        }
        /**
         * Resolve an asset.
         * This function is used because child instances need access
         * to assets defined in its ancestor chain.
         */
        function resolveAsset(options, type, id, warnMissing) {
            /* istanbul ignore if */
            if (typeof id !== "string") {
                return;
            }
            var assets = options[type]; // check local registration variations first
            if (hasOwn(assets, id)) {
                return assets[id];
            }
            var camelizedId = camelize(id);
            if (hasOwn(assets, camelizedId)) {
                return assets[camelizedId];
            }
            var PascalCaseId = capitalize(camelizedId);
            if (hasOwn(assets, PascalCaseId)) {
                return assets[PascalCaseId];
            } // fallback to prototype chain
            var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
            if (warnMissing && !res) {
                warn("Failed to resolve " + type.slice(0, -1) + ": " + id, options);
            }
            return res;
        }
        /*  */
        function validateProp(key, propOptions, propsData, vm) {
            var prop = propOptions[key];
            var absent = !hasOwn(propsData, key);
            var value = propsData[key]; // boolean casting
            var booleanIndex = getTypeIndex(Boolean, prop.type);
            if (booleanIndex > -1) {
                if (absent && !hasOwn(prop, "default")) {
                    value = false;
                }
                else if (value === "" || value === hyphenate(key)) {
                    // only cast empty string / same name to boolean if
                    // boolean has higher priority
                    var stringIndex = getTypeIndex(String, prop.type);
                    if (stringIndex < 0 || booleanIndex < stringIndex) {
                        value = true;
                    }
                }
            } // check default value
            if (value === undefined) {
                value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,
                // make sure to observe it.
                var prevShouldObserve = shouldObserve;
                toggleObserving(true);
                observe(value);
                toggleObserving(prevShouldObserve);
            }
            {
                assertProp(prop, key, value, vm, absent);
            }
            return value;
        }
        /**
         * Get the default value of a prop.
         */
        function getPropDefaultValue(vm, prop, key) {
            // no default, return undefined
            if (!hasOwn(prop, "default")) {
                return undefined;
            }
            var def = prop.default; // warn against non-factory defaults for Object & Array
            if (isObject(def)) {
                warn('Invalid default value for prop "' + key + '": ' +
                    "Props with type Object/Array must use a factory function " +
                    "to return the default value.", vm);
            } // the raw prop value was also undefined from previous render,
            // return previous default value to avoid unnecessary watcher trigger
            if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined &&
                vm._props[key] !== undefined) {
                return vm._props[key];
            } // call factory function for non-Function types
            // a value is Function if its prototype is function even across different execution context
            return typeof def === "function" && getType(prop.type) !== "Function"
                ? def.call(vm)
                : def;
        }
        /**
         * Assert whether a prop is valid.
         */
        function assertProp(prop, name, value, vm, absent) {
            if (prop.required && absent) {
                warn('Missing required prop: "' + name + '"', vm);
                return;
            }
            if (value == null && !prop.required) {
                return;
            }
            var type = prop.type;
            var valid = !type || type === true;
            var expectedTypes = [];
            if (type) {
                if (!Array.isArray(type)) {
                    type = [type];
                }
                for (var i = 0; i < type.length && !valid; i++) {
                    var assertedType = assertType(value, type[i]);
                    expectedTypes.push(assertedType.expectedType || "");
                    valid = assertedType.valid;
                }
            }
            if (!valid) {
                warn(getInvalidTypeMessage(name, value, expectedTypes), vm);
                return;
            }
            var validator = prop.validator;
            if (validator) {
                if (!validator(value)) {
                    warn('Invalid prop: custom validator check failed for prop "' + name +
                        '".', vm);
                }
            }
        }
        var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;
        function assertType(value, type) {
            var valid;
            var expectedType = getType(type);
            if (simpleCheckRE.test(expectedType)) {
                var t = typeof value;
                valid = t === expectedType.toLowerCase(); // for primitive wrapper objects
                if (!valid && t === "object") {
                    valid = value instanceof type;
                }
            }
            else if (expectedType === "Object") {
                valid = isPlainObject(value);
            }
            else if (expectedType === "Array") {
                valid = Array.isArray(value);
            }
            else {
                valid = value instanceof type;
            }
            return {
                valid: valid,
                expectedType: expectedType,
            };
        }
        /**
         * Use function string name to check built-in types,
         * because a simple equality check will fail when running
         * across different vms / iframes.
         */
        function getType(fn) {
            var match = fn && fn.toString().match(/^\s*function (\w+)/);
            return match ? match[1] : "";
        }
        function isSameType(a, b) {
            return getType(a) === getType(b);
        }
        function getTypeIndex(type, expectedTypes) {
            if (!Array.isArray(expectedTypes)) {
                return isSameType(expectedTypes, type) ? 0 : -1;
            }
            for (var i = 0, len = expectedTypes.length; i < len; i++) {
                if (isSameType(expectedTypes[i], type)) {
                    return i;
                }
            }
            return -1;
        }
        function getInvalidTypeMessage(name, value, expectedTypes) {
            var message = 'Invalid prop: type check failed for prop "' + name + '".' +
                " Expected " + expectedTypes.map(capitalize).join(", ");
            var expectedType = expectedTypes[0];
            var receivedType = toRawType(value);
            var expectedValue = styleValue(value, expectedType);
            var receivedValue = styleValue(value, receivedType); // check if we need to specify expected value
            if (expectedTypes.length === 1 && isExplicable(expectedType) &&
                !isBoolean(expectedType, receivedType)) {
                message += " with value " + expectedValue;
            }
            message += ", got " + receivedType + " "; // check if we need to specify received value
            if (isExplicable(receivedType)) {
                message += "with value " + receivedValue + ".";
            }
            return message;
        }
        function styleValue(value, type) {
            if (type === "String") {
                return '"' + value + '"';
            }
            else if (type === "Number") {
                return "" + Number(value);
            }
            else {
                return "" + value;
            }
        }
        function isExplicable(value) {
            var explicitTypes = ["string", "number", "boolean"];
            return explicitTypes.some(function (elem) {
                return value.toLowerCase() === elem;
            });
        }
        function isBoolean() {
            var args = [], len = arguments.length;
            while (len--)
                args[len] = arguments[len];
            return args.some(function (elem) {
                return elem.toLowerCase() === "boolean";
            });
        }
        /*  */
        function handleError(err, vm, info) {
            // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
            // See: https://github.com/vuejs/vuex/issues/1505
            pushTarget();
            try {
                if (vm) {
                    var cur = vm;
                    while (cur = cur.$parent) {
                        var hooks = cur.$options.errorCaptured;
                        if (hooks) {
                            for (var i = 0; i < hooks.length; i++) {
                                try {
                                    var capture = hooks[i].call(cur, err, vm, info) === false;
                                    if (capture) {
                                        return;
                                    }
                                }
                                catch (e) {
                                    globalHandleError(e, cur, "errorCaptured hook");
                                }
                            }
                        }
                    }
                }
                globalHandleError(err, vm, info);
            }
            finally {
                popTarget();
            }
        }
        function invokeWithErrorHandling(handler, context, args, vm, info) {
            var res;
            try {
                res = args ? handler.apply(context, args) : handler.call(context);
                if (res && !res._isVue && isPromise(res) && !res._handled) {
                    res.catch(function (e) {
                        return handleError(e, vm, info + " (Promise/async)");
                    }); // issue #9511
                    // avoid catch triggering multiple times when nested calls
                    res._handled = true;
                }
            }
            catch (e) {
                handleError(e, vm, info);
            }
            return res;
        }
        function globalHandleError(err, vm, info) {
            if (config.errorHandler) {
                try {
                    return config.errorHandler.call(null, err, vm, info);
                }
                catch (e) {
                    // if the user intentionally throws the original error in the handler,
                    // do not log it twice
                    if (e !== err) {
                        logError(e, null, "config.errorHandler");
                    }
                }
            }
            logError(err, vm, info);
        }
        function logError(err, vm, info) {
            {
                warn("Error in " + info + ': "' + err.toString() + '"', vm);
            }
            /* istanbul ignore else */
            if ((inBrowser || inWeex) && typeof console !== "undefined") {
                console.error(err);
            }
            else {
                throw err;
            }
        }
        /*  */
        var isUsingMicroTask = false;
        var callbacks = [];
        var pending = false;
        function flushCallbacks() {
            pending = false;
            var copies = callbacks.slice(0);
            callbacks.length = 0;
            for (var i = 0; i < copies.length; i++) {
                copies[i]();
            }
        } // Here we have async deferring wrappers using microtasks.
        // In 2.5 we used (macro) tasks (in combination with microtasks).
        // However, it has subtle problems when state is changed right before repaint
        // (e.g. #6813, out-in transitions).
        // Also, using (macro) tasks in event handler would cause some weird behaviors
        // that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
        // So we now use microtasks everywhere, again.
        // A major drawback of this tradeoff is that there are some scenarios
        // where microtasks have too high a priority and fire in between supposedly
        // sequential events (e.g. #4521, #6690, which have workarounds)
        // or even between bubbling of the same event (#6566).
        var timerFunc; // The nextTick behavior leverages the microtask queue, which can be accessed
        // via either native Promise.then or MutationObserver.
        // MutationObserver has wider support, however it is seriously bugged in
        // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
        // completely stops working after triggering a few times... so, if native
        // Promise is available, we will use it:
        /* istanbul ignore next, $flow-disable-line */
        if (typeof Promise !== "undefined" && isNative(Promise)) {
            var p = Promise.resolve();
            timerFunc = function () {
                p.then(flushCallbacks); // In problematic UIWebViews, Promise.then doesn't completely break, but
                // it can get stuck in a weird state where callbacks are pushed into the
                // microtask queue but the queue isn't being flushed, until the browser
                // needs to do some other work, e.g. handle a timer. Therefore we can
                // "force" the microtask queue to be flushed by adding an empty timer.
                if (isIOS) {
                    setTimeout(noop);
                }
            };
            isUsingMicroTask = true;
        }
        else if (!isIE && typeof MutationObserver !== "undefined" &&
            (isNative(MutationObserver) || // PhantomJS and iOS 7.x
                MutationObserver.toString() === "[object MutationObserverConstructor]")) {
            // Use MutationObserver where native Promise is not available,
            // e.g. PhantomJS, iOS7, Android 4.4
            // (#6466 MutationObserver is unreliable in IE11)
            var counter = 1;
            var observer = new MutationObserver(flushCallbacks);
            var textNode = document.createTextNode(String(counter));
            observer.observe(textNode, {
                characterData: true,
            });
            timerFunc = function () {
                counter = (counter + 1) % 2;
                textNode.data = String(counter);
            };
            isUsingMicroTask = true;
        }
        else if (typeof setImmediate !== "undefined" && isNative(setImmediate)) {
            // Fallback to setImmediate.
            // Technically it leverages the (macro) task queue,
            // but it is still a better choice than setTimeout.
            timerFunc = function () {
                setImmediate(flushCallbacks);
            };
        }
        else {
            // Fallback to setTimeout.
            timerFunc = function () {
                setTimeout(flushCallbacks, 0);
            };
        }
        function nextTick(cb, ctx) {
            var _resolve;
            callbacks.push(function () {
                if (cb) {
                    try {
                        cb.call(ctx);
                    }
                    catch (e) {
                        handleError(e, ctx, "nextTick");
                    }
                }
                else if (_resolve) {
                    _resolve(ctx);
                }
            });
            if (!pending) {
                pending = true;
                timerFunc();
            } // $flow-disable-line
            if (!cb && typeof Promise !== "undefined") {
                return new Promise(function (resolve) {
                    _resolve = resolve;
                });
            }
        }
        /*  */
        /* not type checking this file because flow doesn't play well with Proxy */
        var initProxy;
        {
            var allowedGlobals = makeMap("Infinity,undefined,NaN,isFinite,isNaN," +
                "parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent," +
                "Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl," +
                "require");
            var warnNonPresent = function (target, key) {
                warn('Property or method "' + key + '" is not defined on the instance but ' +
                    "referenced during render. Make sure that this property is reactive, " +
                    "either in the data option, or for class-based components, by " +
                    "initializing the property. " +
                    "See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.", target);
            };
            var warnReservedPrefix = function (target, key) {
                warn('Property "' + key + '" must be accessed with "$data.' + key +
                    '" because ' +
                    'properties starting with "$" or "_" are not proxied in the Vue instance to ' +
                    "prevent conflicts with Vue internals. " +
                    "See: https://vuejs.org/v2/api/#data", target);
            };
            var hasProxy = typeof Proxy !== "undefined" && isNative(Proxy);
            if (hasProxy) {
                var isBuiltInModifier = makeMap("stop,prevent,self,ctrl,shift,alt,meta,exact");
                config.keyCodes = new Proxy(config.keyCodes, {
                    set: function set(target, key, value) {
                        if (isBuiltInModifier(key)) {
                            warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
                            return false;
                        }
                        else {
                            target[key] = value;
                            return true;
                        }
                    },
                });
            }
            var hasHandler = {
                has: function has(target, key) {
                    var has = key in target;
                    var isAllowed = allowedGlobals(key) ||
                        typeof key === "string" && key.charAt(0) === "_" &&
                            !(key in target.$data);
                    if (!has && !isAllowed) {
                        if (key in target.$data) {
                            warnReservedPrefix(target, key);
                        }
                        else {
                            warnNonPresent(target, key);
                        }
                    }
                    return has || !isAllowed;
                },
            };
            var getHandler = {
                get: function get(target, key) {
                    if (typeof key === "string" && !(key in target)) {
                        if (key in target.$data) {
                            warnReservedPrefix(target, key);
                        }
                        else {
                            warnNonPresent(target, key);
                        }
                    }
                    return target[key];
                },
            };
            initProxy = function initProxy(vm) {
                if (hasProxy) {
                    // determine which proxy handler to use
                    var options = vm.$options;
                    var handlers = options.render && options.render._withStripped
                        ? getHandler
                        : hasHandler;
                    vm._renderProxy = new Proxy(vm, handlers);
                }
                else {
                    vm._renderProxy = vm;
                }
            };
        }
        /*  */
        var seenObjects = new _Set();
        /**
         * Recursively traverse an object to evoke all converted
         * getters, so that every nested property inside the object
         * is collected as a "deep" dependency.
         */
        function traverse(val) {
            _traverse(val, seenObjects);
            seenObjects.clear();
        }
        function _traverse(val, seen) {
            var i, keys;
            var isA = Array.isArray(val);
            if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {
                return;
            }
            if (val.__ob__) {
                var depId = val.__ob__.dep.id;
                if (seen.has(depId)) {
                    return;
                }
                seen.add(depId);
            }
            if (isA) {
                i = val.length;
                while (i--) {
                    _traverse(val[i], seen);
                }
            }
            else {
                keys = Object.keys(val);
                i = keys.length;
                while (i--) {
                    _traverse(val[keys[i]], seen);
                }
            }
        }
        var mark;
        var measure;
        {
            var perf = inBrowser && window.performance;
            /* istanbul ignore if */
            if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
                mark = function (tag) {
                    return perf.mark(tag);
                };
                measure = function (name, startTag, endTag) {
                    perf.measure(name, startTag, endTag);
                    perf.clearMarks(startTag);
                    perf.clearMarks(endTag); // perf.clearMeasures(name)
                };
            }
        }
        /*  */
        var normalizeEvent = cached(function (name) {
            var passive = name.charAt(0) === "&";
            name = passive ? name.slice(1) : name;
            var once$$1 = name.charAt(0) === "~"; // Prefixed last, checked first
            name = once$$1 ? name.slice(1) : name;
            var capture = name.charAt(0) === "!";
            name = capture ? name.slice(1) : name;
            return {
                name: name,
                once: once$$1,
                capture: capture,
                passive: passive,
            };
        });
        function createFnInvoker(fns, vm) {
            function invoker() {
                var arguments$1 = arguments;
                var fns = invoker.fns;
                if (Array.isArray(fns)) {
                    var cloned = fns.slice();
                    for (var i = 0; i < cloned.length; i++) {
                        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
                    }
                }
                else {
                    // return handler return value for single handlers
                    return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler");
                }
            }
            invoker.fns = fns;
            return invoker;
        }
        function updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {
            var name, def$$1, cur, old, event;
            for (name in on) {
                def$$1 = cur = on[name];
                old = oldOn[name];
                event = normalizeEvent(name);
                if (isUndef(cur)) {
                    warn('Invalid handler for event "' + event.name + '": got ' + String(cur), vm);
                }
                else if (isUndef(old)) {
                    if (isUndef(cur.fns)) {
                        cur = on[name] = createFnInvoker(cur, vm);
                    }
                    if (isTrue(event.once)) {
                        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
                    }
                    add(event.name, cur, event.capture, event.passive, event.params);
                }
                else if (cur !== old) {
                    old.fns = cur;
                    on[name] = old;
                }
            }
            for (name in oldOn) {
                if (isUndef(on[name])) {
                    event = normalizeEvent(name);
                    remove$$1(event.name, oldOn[name], event.capture);
                }
            }
        }
        /*  */
        function mergeVNodeHook(def, hookKey, hook) {
            if (def instanceof VNode) {
                def = def.data.hook || (def.data.hook = {});
            }
            var invoker;
            var oldHook = def[hookKey];
            function wrappedHook() {
                hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once
                // and prevent memory leak
                remove(invoker.fns, wrappedHook);
            }
            if (isUndef(oldHook)) {
                // no existing hook
                invoker = createFnInvoker([wrappedHook]);
            }
            else {
                /* istanbul ignore if */
                if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
                    // already a merged invoker
                    invoker = oldHook;
                    invoker.fns.push(wrappedHook);
                }
                else {
                    // existing plain hook
                    invoker = createFnInvoker([oldHook, wrappedHook]);
                }
            }
            invoker.merged = true;
            def[hookKey] = invoker;
        }
        /*  */
        function extractPropsFromVNodeData(data, Ctor, tag) {
            // we are only extracting raw values here.
            // validation and default values are handled in the child
            // component itself.
            var propOptions = Ctor.options.props;
            if (isUndef(propOptions)) {
                return;
            }
            var res = {};
            var attrs = data.attrs;
            var props = data.props;
            if (isDef(attrs) || isDef(props)) {
                for (var key in propOptions) {
                    var altKey = hyphenate(key);
                    {
                        var keyInLowerCase = key.toLowerCase();
                        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
                            tip('Prop "' + keyInLowerCase + '" is passed to component ' +
                                formatComponentName(tag || Ctor) +
                                ", but the declared prop name is" + ' "' + key + '". ' +
                                "Note that HTML attributes are case-insensitive and camelCased " +
                                "props need to use their kebab-case equivalents when using in-DOM " +
                                'templates. You should probably use "' + altKey +
                                '" instead of "' + key + '".');
                        }
                    }
                    checkProp(res, props, key, altKey, true) ||
                        checkProp(res, attrs, key, altKey, false);
                }
            }
            return res;
        }
        function checkProp(res, hash, key, altKey, preserve) {
            if (isDef(hash)) {
                if (hasOwn(hash, key)) {
                    res[key] = hash[key];
                    if (!preserve) {
                        delete hash[key];
                    }
                    return true;
                }
                else if (hasOwn(hash, altKey)) {
                    res[key] = hash[altKey];
                    if (!preserve) {
                        delete hash[altKey];
                    }
                    return true;
                }
            }
            return false;
        }
        /*  */
        // The template compiler attempts to minimize the need for normalization by
        // statically analyzing the template at compile time.
        //
        // For plain HTML markup, normalization can be completely skipped because the
        // generated render function is guaranteed to return Array<VNode>. There are
        // two cases where extra normalization is needed:
        // 1. When the children contains components - because a functional component
        // may return an Array instead of a single root. In this case, just a simple
        // normalization is needed - if any child is an Array, we flatten the whole
        // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
        // because functional components already normalize their own children.
        function simpleNormalizeChildren(children) {
            for (var i = 0; i < children.length; i++) {
                if (Array.isArray(children[i])) {
                    return Array.prototype.concat.apply([], children);
                }
            }
            return children;
        } // 2. When the children contains constructs that always generated nested Arrays,
        // e.g. <template>, <slot>, v-for, or when the children is provided by user
        // with hand-written render functions / JSX. In such cases a full normalization
        // is needed to cater to all possible types of children values.
        function normalizeChildren(children) {
            return isPrimitive(children)
                ? [createTextVNode(children)]
                : Array.isArray(children)
                    ? normalizeArrayChildren(children)
                    : undefined;
        }
        function isTextNode(node) {
            return isDef(node) && isDef(node.text) && isFalse(node.isComment);
        }
        function normalizeArrayChildren(children, nestedIndex) {
            var res = [];
            var i, c, lastIndex, last;
            for (i = 0; i < children.length; i++) {
                c = children[i];
                if (isUndef(c) || typeof c === "boolean") {
                    continue;
                }
                lastIndex = res.length - 1;
                last = res[lastIndex]; //  nested
                if (Array.isArray(c)) {
                    if (c.length > 0) {
                        c = normalizeArrayChildren(c, (nestedIndex || "") + "_" + i); // merge adjacent text nodes
                        if (isTextNode(c[0]) && isTextNode(last)) {
                            res[lastIndex] = createTextVNode(last.text + c[0].text);
                            c.shift();
                        }
                        res.push.apply(res, c);
                    }
                }
                else if (isPrimitive(c)) {
                    if (isTextNode(last)) {
                        // merge adjacent text nodes
                        // this is necessary for SSR hydration because text nodes are
                        // essentially merged when rendered to HTML strings
                        res[lastIndex] = createTextVNode(last.text + c);
                    }
                    else if (c !== "") {
                        // convert primitive to vnode
                        res.push(createTextVNode(c));
                    }
                }
                else {
                    if (isTextNode(c) && isTextNode(last)) {
                        // merge adjacent text nodes
                        res[lastIndex] = createTextVNode(last.text + c.text);
                    }
                    else {
                        // default key for nested array children (likely generated by v-for)
                        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) &&
                            isDef(nestedIndex)) {
                            c.key = "__vlist" + nestedIndex + "_" + i + "__";
                        }
                        res.push(c);
                    }
                }
            }
            return res;
        }
        /*  */
        function initProvide(vm) {
            var provide = vm.$options.provide;
            if (provide) {
                vm._provided = typeof provide === "function" ? provide.call(vm) : provide;
            }
        }
        function initInjections(vm) {
            var result = resolveInject(vm.$options.inject, vm);
            if (result) {
                toggleObserving(false);
                Object.keys(result).forEach(function (key) {
                    /* istanbul ignore else */
                    {
                        defineReactive$$1(vm, key, result[key], function () {
                            warn("Avoid mutating an injected value directly since the changes will be " +
                                "overwritten whenever the provided component re-renders. " +
                                'injection being mutated: "' + key + '"', vm);
                        });
                    }
                });
                toggleObserving(true);
            }
        }
        function resolveInject(inject, vm) {
            if (inject) {
                // inject is :any because flow is not smart enough to figure out cached
                var result = Object.create(null);
                var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i]; // #6574 in case the inject object is observed...
                    if (key === "__ob__") {
                        continue;
                    }
                    var provideKey = inject[key].from;
                    var source = vm;
                    while (source) {
                        if (source._provided && hasOwn(source._provided, provideKey)) {
                            result[key] = source._provided[provideKey];
                            break;
                        }
                        source = source.$parent;
                    }
                    if (!source) {
                        if ("default" in inject[key]) {
                            var provideDefault = inject[key].default;
                            result[key] = typeof provideDefault === "function"
                                ? provideDefault.call(vm)
                                : provideDefault;
                        }
                        else {
                            warn('Injection "' + key + '" not found', vm);
                        }
                    }
                }
                return result;
            }
        }
        /*  */
        /**
         * Runtime helper for resolving raw children VNodes into a slot object.
         */
        function resolveSlots(children, context) {
            if (!children || !children.length) {
                return {};
            }
            var slots = {};
            for (var i = 0, l = children.length; i < l; i++) {
                var child = children[i];
                var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node
                if (data && data.attrs && data.attrs.slot) {
                    delete data.attrs.slot;
                } // named slots should only be respected if the vnode was rendered in the
                // same context.
                if ((child.context === context || child.fnContext === context) && data &&
                    data.slot != null) {
                    var name = data.slot;
                    var slot = slots[name] || (slots[name] = []);
                    if (child.tag === "template") {
                        slot.push.apply(slot, child.children || []);
                    }
                    else {
                        slot.push(child);
                    }
                }
                else {
                    (slots.default || (slots.default = [])).push(child);
                }
            } // ignore slots that contains only whitespace
            for (var name$1 in slots) {
                if (slots[name$1].every(isWhitespace)) {
                    delete slots[name$1];
                }
            }
            return slots;
        }
        function isWhitespace(node) {
            return node.isComment && !node.asyncFactory || node.text === " ";
        }
        /*  */
        function normalizeScopedSlots(slots, normalSlots, prevSlots) {
            var res;
            var hasNormalSlots = Object.keys(normalSlots).length > 0;
            var isStable = slots ? !!slots.$stable : !hasNormalSlots;
            var key = slots && slots.$key;
            if (!slots) {
                res = {};
            }
            else if (slots._normalized) {
                // fast path 1: child component re-render only, parent did not change
                return slots._normalized;
            }
            else if (isStable && prevSlots && prevSlots !== emptyObject &&
                key === prevSlots.$key && !hasNormalSlots && !prevSlots.$hasNormal) {
                // fast path 2: stable scoped slots w/ no normal slots to proxy,
                // only need to normalize once
                return prevSlots;
            }
            else {
                res = {};
                for (var key$1 in slots) {
                    if (slots[key$1] && key$1[0] !== "$") {
                        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
                    }
                }
            } // expose normal slots on scopedSlots
            for (var key$2 in normalSlots) {
                if (!(key$2 in res)) {
                    res[key$2] = proxyNormalSlot(normalSlots, key$2);
                }
            } // avoriaz seems to mock a non-extensible $scopedSlots object
            // and when that is passed down this would cause an error
            if (slots && Object.isExtensible(slots)) {
                slots._normalized = res;
            }
            def(res, "$stable", isStable);
            def(res, "$key", key);
            def(res, "$hasNormal", hasNormalSlots);
            return res;
        }
        function normalizeScopedSlot(normalSlots, key, fn) {
            var normalized = function () {
                var res = arguments.length ? fn.apply(null, arguments) : fn({});
                res = res && typeof res === "object" && !Array.isArray(res)
                    ? [res] // single vnode
                    : normalizeChildren(res);
                return res && (res.length === 0 || res.length === 1 && res[0].isComment // #9658
                )
                    ? undefined
                    : res;
            }; // this is a slot using the new v-slot syntax without scope. although it is
            // compiled as a scoped slot, render fn users would expect it to be present
            // on this.$slots because the usage is semantically a normal slot.
            if (fn.proxy) {
                Object.defineProperty(normalSlots, key, {
                    get: normalized,
                    enumerable: true,
                    configurable: true,
                });
            }
            return normalized;
        }
        function proxyNormalSlot(slots, key) {
            return function () {
                return slots[key];
            };
        }
        /*  */
        /**
         * Runtime helper for rendering v-for lists.
         */
        function renderList(val, render) {
            var ret, i, l, keys, key;
            if (Array.isArray(val) || typeof val === "string") {
                ret = new Array(val.length);
                for (i = 0, l = val.length; i < l; i++) {
                    ret[i] = render(val[i], i);
                }
            }
            else if (typeof val === "number") {
                ret = new Array(val);
                for (i = 0; i < val; i++) {
                    ret[i] = render(i + 1, i);
                }
            }
            else if (isObject(val)) {
                if (hasSymbol && val[Symbol.iterator]) {
                    ret = [];
                    var iterator = val[Symbol.iterator]();
                    var result = iterator.next();
                    while (!result.done) {
                        ret.push(render(result.value, ret.length));
                        result = iterator.next();
                    }
                }
                else {
                    keys = Object.keys(val);
                    ret = new Array(keys.length);
                    for (i = 0, l = keys.length; i < l; i++) {
                        key = keys[i];
                        ret[i] = render(val[key], key, i);
                    }
                }
            }
            if (!isDef(ret)) {
                ret = [];
            }
            ret._isVList = true;
            return ret;
        }
        /*  */
        /**
         * Runtime helper for rendering <slot>
         */
        function renderSlot(name, fallback, props, bindObject) {
            var scopedSlotFn = this.$scopedSlots[name];
            var nodes;
            if (scopedSlotFn) {
                // scoped slot
                props = props || {};
                if (bindObject) {
                    if (!isObject(bindObject)) {
                        warn("slot v-bind without argument expects an Object", this);
                    }
                    props = extend(extend({}, bindObject), props);
                }
                nodes = scopedSlotFn(props) || fallback;
            }
            else {
                nodes = this.$slots[name] || fallback;
            }
            var target = props && props.slot;
            if (target) {
                return this.$createElement("template", {
                    slot: target,
                }, nodes);
            }
            else {
                return nodes;
            }
        }
        /*  */
        /**
         * Runtime helper for resolving filters
         */
        function resolveFilter(id) {
            return resolveAsset(this.$options, "filters", id, true) || identity;
        }
        /*  */
        function isKeyNotMatch(expect, actual) {
            if (Array.isArray(expect)) {
                return expect.indexOf(actual) === -1;
            }
            else {
                return expect !== actual;
            }
        }
        /**
         * Runtime helper for checking keyCodes from config.
         * exposed as Vue.prototype._k
         * passing in eventKeyName as last argument separately for backwards compat
         */
        function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
            var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
            if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
                return isKeyNotMatch(builtInKeyName, eventKeyName);
            }
            else if (mappedKeyCode) {
                return isKeyNotMatch(mappedKeyCode, eventKeyCode);
            }
            else if (eventKeyName) {
                return hyphenate(eventKeyName) !== key;
            }
        }
        /*  */
        /**
         * Runtime helper for merging v-bind="object" into a VNode's data.
         */
        function bindObjectProps(data, tag, value, asProp, isSync) {
            if (value) {
                if (!isObject(value)) {
                    warn("v-bind without argument expects an Object or Array value", this);
                }
                else {
                    if (Array.isArray(value)) {
                        value = toObject(value);
                    }
                    var hash;
                    var loop = function (key) {
                        if (key === "class" || key === "style" || isReservedAttribute(key)) {
                            hash = data;
                        }
                        else {
                            var type = data.attrs && data.attrs.type;
                            hash = asProp || config.mustUseProp(tag, type, key)
                                ? data.domProps || (data.domProps = {})
                                : data.attrs || (data.attrs = {});
                        }
                        var camelizedKey = camelize(key);
                        var hyphenatedKey = hyphenate(key);
                        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
                            hash[key] = value[key];
                            if (isSync) {
                                var on = data.on || (data.on = {});
                                on["update:" + key] = function ($event) {
                                    value[key] = $event;
                                };
                            }
                        }
                    };
                    for (var key in value)
                        loop(key);
                }
            }
            return data;
        }
        /*  */
        /**
         * Runtime helper for rendering static trees.
         */
        function renderStatic(index, isInFor) {
            var cached = this._staticTrees || (this._staticTrees = []);
            var tree = cached[index]; // if has already-rendered static tree and not inside v-for,
            // we can reuse the same tree.
            if (tree && !isInFor) {
                return tree;
            } // otherwise, render a fresh tree.
            tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this);
            markStatic(tree, "__static__" + index, false);
            return tree;
        }
        /**
         * Runtime helper for v-once.
         * Effectively it means marking the node as static with a unique key.
         */
        function markOnce(tree, index, key) {
            markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
            return tree;
        }
        function markStatic(tree, key, isOnce) {
            if (Array.isArray(tree)) {
                for (var i = 0; i < tree.length; i++) {
                    if (tree[i] && typeof tree[i] !== "string") {
                        markStaticNode(tree[i], key + "_" + i, isOnce);
                    }
                }
            }
            else {
                markStaticNode(tree, key, isOnce);
            }
        }
        function markStaticNode(node, key, isOnce) {
            node.isStatic = true;
            node.key = key;
            node.isOnce = isOnce;
        }
        /*  */
        function bindObjectListeners(data, value) {
            if (value) {
                if (!isPlainObject(value)) {
                    warn("v-on without argument expects an Object value", this);
                }
                else {
                    var on = data.on = data.on ? extend({}, data.on) : {};
                    for (var key in value) {
                        var existing = on[key];
                        var ours = value[key];
                        on[key] = existing ? [].concat(existing, ours) : ours;
                    }
                }
            }
            return data;
        }
        /*  */
        function resolveScopedSlots(fns, // see flow/vnode
        res, // the following are added in 2.6
        hasDynamicKeys, contentHashKey) {
            res = res || {
                $stable: !hasDynamicKeys,
            };
            for (var i = 0; i < fns.length; i++) {
                var slot = fns[i];
                if (Array.isArray(slot)) {
                    resolveScopedSlots(slot, res, hasDynamicKeys);
                }
                else if (slot) {
                    // marker for reverse proxying v-slot without scope on this.$slots
                    if (slot.proxy) {
                        slot.fn.proxy = true;
                    }
                    res[slot.key] = slot.fn;
                }
            }
            if (contentHashKey) {
                res.$key = contentHashKey;
            }
            return res;
        }
        /*  */
        function bindDynamicKeys(baseObj, values) {
            for (var i = 0; i < values.length; i += 2) {
                var key = values[i];
                if (typeof key === "string" && key) {
                    baseObj[values[i]] = values[i + 1];
                }
                else if (key !== "" && key !== null) {
                    // null is a special value for explicitly removing a binding
                    warn("Invalid value for dynamic directive argument (expected string or null): " +
                        key, this);
                }
            }
            return baseObj;
        } // helper to dynamically append modifier runtime markers to event names.
        // ensure only append when value is already string, otherwise it will be cast
        // to string and cause the type check to miss.
        function prependModifier(value, symbol) {
            return typeof value === "string" ? symbol + value : value;
        }
        /*  */
        function installRenderHelpers(target) {
            target._o = markOnce;
            target._n = toNumber;
            target._s = toString;
            target._l = renderList;
            target._t = renderSlot;
            target._q = looseEqual;
            target._i = looseIndexOf;
            target._m = renderStatic;
            target._f = resolveFilter;
            target._k = checkKeyCodes;
            target._b = bindObjectProps;
            target._v = createTextVNode;
            target._e = createEmptyVNode;
            target._u = resolveScopedSlots;
            target._g = bindObjectListeners;
            target._d = bindDynamicKeys;
            target._p = prependModifier;
        }
        /*  */
        function FunctionalRenderContext(data, props, children, parent, Ctor) {
            var this$1 = this;
            var options = Ctor.options; // ensure the createElement function in functional components
            // gets a unique context - this is necessary for correct named slot check
            var contextVm;
            if (hasOwn(parent, "_uid")) {
                contextVm = Object.create(parent); // $flow-disable-line
                contextVm._original = parent;
            }
            else {
                // the context vm passed in is a functional context as well.
                // in this case we want to make sure we are able to get a hold to the
                // real context instance.
                contextVm = parent; // $flow-disable-line
                parent = parent._original;
            }
            var isCompiled = isTrue(options._compiled);
            var needNormalization = !isCompiled;
            this.data = data;
            this.props = props;
            this.children = children;
            this.parent = parent;
            this.listeners = data.on || emptyObject;
            this.injections = resolveInject(options.inject, parent);
            this.slots = function () {
                if (!this$1.$slots) {
                    normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));
                }
                return this$1.$slots;
            };
            Object.defineProperty(this, "scopedSlots", {
                enumerable: true,
                get: function get() {
                    return normalizeScopedSlots(data.scopedSlots, this.slots());
                },
            }); // support for compiled functional template
            if (isCompiled) {
                // exposing $options for renderStatic()
                this.$options = options; // pre-resolve slots for renderSlot()
                this.$slots = this.slots();
                this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
            }
            if (options._scopeId) {
                this._c = function (a, b, c, d) {
                    var vnode = createElement(contextVm, a, b, c, d, needNormalization);
                    if (vnode && !Array.isArray(vnode)) {
                        vnode.fnScopeId = options._scopeId;
                        vnode.fnContext = parent;
                    }
                    return vnode;
                };
            }
            else {
                this._c = function (a, b, c, d) {
                    return createElement(contextVm, a, b, c, d, needNormalization);
                };
            }
        }
        installRenderHelpers(FunctionalRenderContext.prototype);
        function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
            var options = Ctor.options;
            var props = {};
            var propOptions = options.props;
            if (isDef(propOptions)) {
                for (var key in propOptions) {
                    props[key] = validateProp(key, propOptions, propsData || emptyObject);
                }
            }
            else {
                if (isDef(data.attrs)) {
                    mergeProps(props, data.attrs);
                }
                if (isDef(data.props)) {
                    mergeProps(props, data.props);
                }
            }
            var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);
            var vnode = options.render.call(null, renderContext._c, renderContext);
            if (vnode instanceof VNode) {
                return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
            }
            else if (Array.isArray(vnode)) {
                var vnodes = normalizeChildren(vnode) || [];
                var res = new Array(vnodes.length);
                for (var i = 0; i < vnodes.length; i++) {
                    res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
                }
                return res;
            }
        }
        function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
            // #7817 clone node before setting fnContext, otherwise if the node is reused
            // (e.g. it was from a cached normal slot) the fnContext causes named slots
            // that should not be matched to match.
            var clone = cloneVNode(vnode);
            clone.fnContext = contextVm;
            clone.fnOptions = options;
            {
                (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext =
                    renderContext;
            }
            if (data.slot) {
                (clone.data || (clone.data = {})).slot = data.slot;
            }
            return clone;
        }
        function mergeProps(to, from) {
            for (var key in from) {
                to[camelize(key)] = from[key];
            }
        }
        /*  */
        /*  */
        /*  */
        /*  */
        // inline hooks to be invoked on component VNodes during patch
        var componentVNodeHooks = {
            init: function init(vnode, hydrating) {
                if (vnode.componentInstance && !vnode.componentInstance._isDestroyed &&
                    vnode.data.keepAlive) {
                    // kept-alive components, treat as a patch
                    var mountedNode = vnode; // work around flow
                    componentVNodeHooks.prepatch(mountedNode, mountedNode);
                }
                else {
                    var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);
                    child.$mount(hydrating ? vnode.elm : undefined, hydrating);
                }
            },
            prepatch: function prepatch(oldVnode, vnode) {
                var options = vnode.componentOptions;
                var child = vnode.componentInstance = oldVnode.componentInstance;
                updateChildComponent(child, options.propsData, // updated props
                options.listeners, // updated listeners
                vnode, // new parent vnode
                options.children);
            },
            insert: function insert(vnode) {
                var context = vnode.context;
                var componentInstance = vnode.componentInstance;
                if (!componentInstance._isMounted) {
                    componentInstance._isMounted = true;
                    callHook(componentInstance, "mounted");
                }
                if (vnode.data.keepAlive) {
                    if (context._isMounted) {
                        // vue-router#1212
                        // During updates, a kept-alive component's child components may
                        // change, so directly walking the tree here may call activated hooks
                        // on incorrect children. Instead we push them into a queue which will
                        // be processed after the whole patch process ended.
                        queueActivatedComponent(componentInstance);
                    }
                    else {
                        activateChildComponent(componentInstance, true /* direct */);
                    }
                }
            },
            destroy: function destroy(vnode) {
                var componentInstance = vnode.componentInstance;
                if (!componentInstance._isDestroyed) {
                    if (!vnode.data.keepAlive) {
                        componentInstance.$destroy();
                    }
                    else {
                        deactivateChildComponent(componentInstance, true /* direct */);
                    }
                }
            },
        };
        var hooksToMerge = Object.keys(componentVNodeHooks);
        function createComponent(Ctor, data, context, children, tag) {
            if (isUndef(Ctor)) {
                return;
            }
            var baseCtor = context.$options._base; // plain options object: turn it into a constructor
            if (isObject(Ctor)) {
                Ctor = baseCtor.extend(Ctor);
            } // if at this stage it's not a constructor or an async component factory,
            // reject.
            if (typeof Ctor !== "function") {
                {
                    warn("Invalid Component definition: " + String(Ctor), context);
                }
                return;
            } // async component
            var asyncFactory;
            if (isUndef(Ctor.cid)) {
                asyncFactory = Ctor;
                Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
                if (Ctor === undefined) {
                    // return a placeholder node for async component, which is rendered
                    // as a comment node but preserves all the raw information for the node.
                    // the information will be used for async server-rendering and hydration.
                    return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
                }
            }
            data = data || {}; // resolve constructor options in case global mixins are applied after
            // component constructor creation
            resolveConstructorOptions(Ctor); // transform component v-model data into props & events
            if (isDef(data.model)) {
                transformModel(Ctor.options, data);
            } // extract props
            var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component
            if (isTrue(Ctor.options.functional)) {
                return createFunctionalComponent(Ctor, propsData, data, context, children);
            } // extract listeners, since these needs to be treated as
            // child component listeners instead of DOM listeners
            var listeners = data.on; // replace with listeners with .native modifier
            // so it gets processed during parent component patch.
            data.on = data.nativeOn;
            if (isTrue(Ctor.options.abstract)) {
                // abstract components do not keep anything
                // other than props & listeners & slot
                // work around flow
                var slot = data.slot;
                data = {};
                if (slot) {
                    data.slot = slot;
                }
            } // install component management hooks onto the placeholder node
            installComponentHooks(data); // return a placeholder vnode
            var name = Ctor.options.name || tag;
            var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ""), data, undefined, undefined, undefined, context, {
                Ctor: Ctor,
                propsData: propsData,
                listeners: listeners,
                tag: tag,
                children: children,
            }, asyncFactory);
            return vnode;
        }
        function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
        parent) {
            var options = {
                _isComponent: true,
                _parentVnode: vnode,
                parent: parent,
            }; // check inline-template render functions
            var inlineTemplate = vnode.data.inlineTemplate;
            if (isDef(inlineTemplate)) {
                options.render = inlineTemplate.render;
                options.staticRenderFns = inlineTemplate.staticRenderFns;
            }
            return new vnode.componentOptions.Ctor(options);
        }
        function installComponentHooks(data) {
            var hooks = data.hook || (data.hook = {});
            for (var i = 0; i < hooksToMerge.length; i++) {
                var key = hooksToMerge[i];
                var existing = hooks[key];
                var toMerge = componentVNodeHooks[key];
                if (existing !== toMerge && !(existing && existing._merged)) {
                    hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
                }
            }
        }
        function mergeHook$1(f1, f2) {
            var merged = function (a, b) {
                // flow complains about extra args which is why we use any
                f1(a, b);
                f2(a, b);
            };
            merged._merged = true;
            return merged;
        } // transform component v-model info (value and callback) into
        // prop and event handler respectively.
        function transformModel(options, data) {
            var prop = options.model && options.model.prop || "value";
            var event = options.model && options.model.event || "input";
            (data.attrs || (data.attrs = {}))[prop] = data.model.value;
            var on = data.on || (data.on = {});
            var existing = on[event];
            var callback = data.model.callback;
            if (isDef(existing)) {
                if (Array.isArray(existing)
                    ? existing.indexOf(callback) === -1
                    : existing !== callback) {
                    on[event] = [callback].concat(existing);
                }
            }
            else {
                on[event] = callback;
            }
        }
        /*  */
        var SIMPLE_NORMALIZE = 1;
        var ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface
        // without getting yelled at by flow
        function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
            if (Array.isArray(data) || isPrimitive(data)) {
                normalizationType = children;
                children = data;
                data = undefined;
            }
            if (isTrue(alwaysNormalize)) {
                normalizationType = ALWAYS_NORMALIZE;
            }
            return _createElement(context, tag, data, children, normalizationType);
        }
        function _createElement(context, tag, data, children, normalizationType) {
            if (isDef(data) && isDef(data.__ob__)) {
                warn("Avoid using observed data object as vnode data: " +
                    JSON.stringify(data) + "\n" +
                    "Always create fresh vnode data objects in each render!", context);
                return createEmptyVNode();
            } // object syntax in v-bind
            if (isDef(data) && isDef(data.is)) {
                tag = data.is;
            }
            if (!tag) {
                // in case of component :is set to falsy value
                return createEmptyVNode();
            } // warn against non-primitive key
            if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
                {
                    warn("Avoid using non-primitive value as key, " +
                        "use string/number value instead.", context);
                }
            } // support single function children as default scoped slot
            if (Array.isArray(children) && typeof children[0] === "function") {
                data = data || {};
                data.scopedSlots = {
                    default: children[0],
                };
                children.length = 0;
            }
            if (normalizationType === ALWAYS_NORMALIZE) {
                children = normalizeChildren(children);
            }
            else if (normalizationType === SIMPLE_NORMALIZE) {
                children = simpleNormalizeChildren(children);
            }
            var vnode, ns;
            if (typeof tag === "string") {
                var Ctor;
                ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);
                if (config.isReservedTag(tag)) {
                    // platform built-in elements
                    if (isDef(data) && isDef(data.nativeOn)) {
                        warn("The .native modifier for v-on is only valid on components but it was used on <" +
                            tag + ">.", context);
                    }
                    vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
                }
                else if ((!data || !data.pre) &&
                    isDef(Ctor = resolveAsset(context.$options, "components", tag))) {
                    // component
                    vnode = createComponent(Ctor, data, context, children, tag);
                }
                else {
                    // unknown or unlisted namespaced elements
                    // check at runtime because it may get assigned a namespace when its
                    // parent normalizes children
                    vnode = new VNode(tag, data, children, undefined, undefined, context);
                }
            }
            else {
                // direct component options / constructor
                vnode = createComponent(tag, data, context, children);
            }
            if (Array.isArray(vnode)) {
                return vnode;
            }
            else if (isDef(vnode)) {
                if (isDef(ns)) {
                    applyNS(vnode, ns);
                }
                if (isDef(data)) {
                    registerDeepBindings(data);
                }
                return vnode;
            }
            else {
                return createEmptyVNode();
            }
        }
        function applyNS(vnode, ns, force) {
            vnode.ns = ns;
            if (vnode.tag === "foreignObject") {
                // use default namespace inside foreignObject
                ns = undefined;
                force = true;
            }
            if (isDef(vnode.children)) {
                for (var i = 0, l = vnode.children.length; i < l; i++) {
                    var child = vnode.children[i];
                    if (isDef(child.tag) &&
                        (isUndef(child.ns) || isTrue(force) && child.tag !== "svg")) {
                        applyNS(child, ns, force);
                    }
                }
            }
        } // ref #5318
        // necessary to ensure parent re-render when deep bindings like :style and
        // :class are used on slot nodes
        function registerDeepBindings(data) {
            if (isObject(data.style)) {
                traverse(data.style);
            }
            if (isObject(data.class)) {
                traverse(data.class);
            }
        }
        /*  */
        function initRender(vm) {
            vm._vnode = null; // the root of the child tree
            vm._staticTrees = null; // v-once cached trees
            var options = vm.$options;
            var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
            var renderContext = parentVnode && parentVnode.context;
            vm.$slots = resolveSlots(options._renderChildren, renderContext);
            vm.$scopedSlots = emptyObject; // bind the createElement fn to this instance
            // so that we get proper render context inside it.
            // args order: tag, data, children, normalizationType, alwaysNormalize
            // internal version is used by render functions compiled from templates
            vm._c = function (a, b, c, d) {
                return createElement(vm, a, b, c, d, false);
            }; // normalization is always applied for the public version, used in
            // user-written render functions.
            vm.$createElement = function (a, b, c, d) {
                return createElement(vm, a, b, c, d, true);
            }; // $attrs & $listeners are exposed for easier HOC creation.
            // they need to be reactive so that HOCs using them are always updated
            var parentData = parentVnode && parentVnode.data;
            /* istanbul ignore else */
            {
                defineReactive$$1(vm, "$attrs", parentData && parentData.attrs || emptyObject, function () {
                    !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
                }, true);
                defineReactive$$1(vm, "$listeners", options._parentListeners || emptyObject, function () {
                    !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
                }, true);
            }
        }
        var currentRenderingInstance = null;
        function renderMixin(Vue) {
            // install runtime convenience helpers
            installRenderHelpers(Vue.prototype);
            Vue.prototype.$nextTick = function (fn) {
                return nextTick(fn, this);
            };
            Vue.prototype._render = function () {
                var vm = this;
                var ref = vm.$options;
                var render = ref.render;
                var _parentVnode = ref._parentVnode;
                if (_parentVnode) {
                    vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
                } // set parent vnode. this allows render functions to have access
                // to the data on the placeholder node.
                vm.$vnode = _parentVnode; // render self
                var vnode;
                try {
                    // There's no need to maintain a stack because all render fns are called
                    // separately from one another. Nested component's render fns are called
                    // when parent component is patched.
                    currentRenderingInstance = vm;
                    vnode = render.call(vm._renderProxy, vm.$createElement);
                }
                catch (e) {
                    handleError(e, vm, "render"); // return error render result,
                    // or previous vnode to prevent render error causing blank component
                    /* istanbul ignore else */
                    if (vm.$options.renderError) {
                        try {
                            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
                        }
                        catch (e) {
                            handleError(e, vm, "renderError");
                            vnode = vm._vnode;
                        }
                    }
                    else {
                        vnode = vm._vnode;
                    }
                }
                finally {
                    currentRenderingInstance = null;
                } // if the returned array contains only a single node, allow it
                if (Array.isArray(vnode) && vnode.length === 1) {
                    vnode = vnode[0];
                } // return empty vnode in case the render function errored out
                if (!(vnode instanceof VNode)) {
                    if (Array.isArray(vnode)) {
                        warn("Multiple root nodes returned from render function. Render function " +
                            "should return a single root node.", vm);
                    }
                    vnode = createEmptyVNode();
                } // set parent
                vnode.parent = _parentVnode;
                return vnode;
            };
        }
        /*  */
        function ensureCtor(comp, base) {
            if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === "Module") {
                comp = comp.default;
            }
            return isObject(comp) ? base.extend(comp) : comp;
        }
        function createAsyncPlaceholder(factory, data, context, children, tag) {
            var node = createEmptyVNode();
            node.asyncFactory = factory;
            node.asyncMeta = {
                data: data,
                context: context,
                children: children,
                tag: tag,
            };
            return node;
        }
        function resolveAsyncComponent(factory, baseCtor) {
            if (isTrue(factory.error) && isDef(factory.errorComp)) {
                return factory.errorComp;
            }
            if (isDef(factory.resolved)) {
                return factory.resolved;
            }
            var owner = currentRenderingInstance;
            if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
                // already pending
                factory.owners.push(owner);
            }
            if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
                return factory.loadingComp;
            }
            if (owner && !isDef(factory.owners)) {
                var owners = factory.owners = [owner];
                var sync = true;
                var timerLoading = null;
                var timerTimeout = null;
                owner.$on("hook:destroyed", function () {
                    return remove(owners, owner);
                });
                var forceRender = function (renderCompleted) {
                    for (var i = 0, l = owners.length; i < l; i++) {
                        owners[i].$forceUpdate();
                    }
                    if (renderCompleted) {
                        owners.length = 0;
                        if (timerLoading !== null) {
                            clearTimeout(timerLoading);
                            timerLoading = null;
                        }
                        if (timerTimeout !== null) {
                            clearTimeout(timerTimeout);
                            timerTimeout = null;
                        }
                    }
                };
                var resolve = once(function (res) {
                    // cache resolved
                    factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve
                    // (async resolves are shimmed as synchronous during SSR)
                    if (!sync) {
                        forceRender(true);
                    }
                    else {
                        owners.length = 0;
                    }
                });
                var reject = once(function (reason) {
                    warn("Failed to resolve async component: " + String(factory) +
                        (reason ? "\nReason: " + reason : ""));
                    if (isDef(factory.errorComp)) {
                        factory.error = true;
                        forceRender(true);
                    }
                });
                var res = factory(resolve, reject);
                if (isObject(res)) {
                    if (isPromise(res)) {
                        // () => Promise
                        if (isUndef(factory.resolved)) {
                            res.then(resolve, reject);
                        }
                    }
                    else if (isPromise(res.component)) {
                        res.component.then(resolve, reject);
                        if (isDef(res.error)) {
                            factory.errorComp = ensureCtor(res.error, baseCtor);
                        }
                        if (isDef(res.loading)) {
                            factory.loadingComp = ensureCtor(res.loading, baseCtor);
                            if (res.delay === 0) {
                                factory.loading = true;
                            }
                            else {
                                timerLoading = setTimeout(function () {
                                    timerLoading = null;
                                    if (isUndef(factory.resolved) && isUndef(factory.error)) {
                                        factory.loading = true;
                                        forceRender(false);
                                    }
                                }, res.delay || 200);
                            }
                        }
                        if (isDef(res.timeout)) {
                            timerTimeout = setTimeout(function () {
                                timerTimeout = null;
                                if (isUndef(factory.resolved)) {
                                    reject("timeout (" + res.timeout + "ms)");
                                }
                            }, res.timeout);
                        }
                    }
                }
                sync = false; // return in case resolved synchronously
                return factory.loading ? factory.loadingComp : factory.resolved;
            }
        }
        /*  */
        function isAsyncPlaceholder(node) {
            return node.isComment && node.asyncFactory;
        }
        /*  */
        function getFirstComponentChild(children) {
            if (Array.isArray(children)) {
                for (var i = 0; i < children.length; i++) {
                    var c = children[i];
                    if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
                        return c;
                    }
                }
            }
        }
        /*  */
        /*  */
        function initEvents(vm) {
            vm._events = Object.create(null);
            vm._hasHookEvent = false; // init parent attached events
            var listeners = vm.$options._parentListeners;
            if (listeners) {
                updateComponentListeners(vm, listeners);
            }
        }
        var target;
        function add(event, fn) {
            target.$on(event, fn);
        }
        function remove$1(event, fn) {
            target.$off(event, fn);
        }
        function createOnceHandler(event, fn) {
            var _target = target;
            return function onceHandler() {
                var res = fn.apply(null, arguments);
                if (res !== null) {
                    _target.$off(event, onceHandler);
                }
            };
        }
        function updateComponentListeners(vm, listeners, oldListeners) {
            target = vm;
            updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
            target = undefined;
        }
        function eventsMixin(Vue) {
            var hookRE = /^hook:/;
            Vue.prototype.$on = function (event, fn) {
                var vm = this;
                if (Array.isArray(event)) {
                    for (var i = 0, l = event.length; i < l; i++) {
                        vm.$on(event[i], fn);
                    }
                }
                else {
                    (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration
                    // instead of a hash lookup
                    if (hookRE.test(event)) {
                        vm._hasHookEvent = true;
                    }
                }
                return vm;
            };
            Vue.prototype.$once = function (event, fn) {
                var vm = this;
                function on() {
                    vm.$off(event, on);
                    fn.apply(vm, arguments);
                }
                on.fn = fn;
                vm.$on(event, on);
                return vm;
            };
            Vue.prototype.$off = function (event, fn) {
                var vm = this; // all
                if (!arguments.length) {
                    vm._events = Object.create(null);
                    return vm;
                } // array of events
                if (Array.isArray(event)) {
                    for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
                        vm.$off(event[i$1], fn);
                    }
                    return vm;
                } // specific event
                var cbs = vm._events[event];
                if (!cbs) {
                    return vm;
                }
                if (!fn) {
                    vm._events[event] = null;
                    return vm;
                } // specific handler
                var cb;
                var i = cbs.length;
                while (i--) {
                    cb = cbs[i];
                    if (cb === fn || cb.fn === fn) {
                        cbs.splice(i, 1);
                        break;
                    }
                }
                return vm;
            };
            Vue.prototype.$emit = function (event) {
                var vm = this;
                {
                    var lowerCaseEvent = event.toLowerCase();
                    if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
                        tip('Event "' + lowerCaseEvent + '" is emitted in component ' +
                            formatComponentName(vm) + ' but the handler is registered for "' +
                            event + '". ' +
                            "Note that HTML attributes are case-insensitive and you cannot use " +
                            "v-on to listen to camelCase events when using in-DOM templates. " +
                            'You should probably use "' + hyphenate(event) +
                            '" instead of "' + event + '".');
                    }
                }
                var cbs = vm._events[event];
                if (cbs) {
                    cbs = cbs.length > 1 ? toArray(cbs) : cbs;
                    var args = toArray(arguments, 1);
                    var info = 'event handler for "' + event + '"';
                    for (var i = 0, l = cbs.length; i < l; i++) {
                        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
                    }
                }
                return vm;
            };
        }
        /*  */
        var activeInstance = null;
        var isUpdatingChildComponent = false;
        function setActiveInstance(vm) {
            var prevActiveInstance = activeInstance;
            activeInstance = vm;
            return function () {
                activeInstance = prevActiveInstance;
            };
        }
        function initLifecycle(vm) {
            var options = vm.$options; // locate first non-abstract parent
            var parent = options.parent;
            if (parent && !options.abstract) {
                while (parent.$options.abstract && parent.$parent) {
                    parent = parent.$parent;
                }
                parent.$children.push(vm);
            }
            vm.$parent = parent;
            vm.$root = parent ? parent.$root : vm;
            vm.$children = [];
            vm.$refs = {};
            vm._watcher = null;
            vm._inactive = null;
            vm._directInactive = false;
            vm._isMounted = false;
            vm._isDestroyed = false;
            vm._isBeingDestroyed = false;
        }
        function lifecycleMixin(Vue) {
            Vue.prototype._update = function (vnode, hydrating) {
                var vm = this;
                var prevEl = vm.$el;
                var prevVnode = vm._vnode;
                var restoreActiveInstance = setActiveInstance(vm);
                vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points
                // based on the rendering backend used.
                if (!prevVnode) {
                    // initial render
                    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
                }
                else {
                    // updates
                    vm.$el = vm.__patch__(prevVnode, vnode);
                }
                restoreActiveInstance(); // update __vue__ reference
                if (prevEl) {
                    prevEl.__vue__ = null;
                }
                if (vm.$el) {
                    vm.$el.__vue__ = vm;
                } // if parent is an HOC, update its $el as well
                if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
                    vm.$parent.$el = vm.$el;
                } // updated hook is called by the scheduler to ensure that children are
                // updated in a parent's updated hook.
            };
            Vue.prototype.$forceUpdate = function () {
                var vm = this;
                if (vm._watcher) {
                    vm._watcher.update();
                }
            };
            Vue.prototype.$destroy = function () {
                var vm = this;
                if (vm._isBeingDestroyed) {
                    return;
                }
                callHook(vm, "beforeDestroy");
                vm._isBeingDestroyed = true; // remove self from parent
                var parent = vm.$parent;
                if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
                    remove(parent.$children, vm);
                } // teardown watchers
                if (vm._watcher) {
                    vm._watcher.teardown();
                }
                var i = vm._watchers.length;
                while (i--) {
                    vm._watchers[i].teardown();
                } // remove reference from data ob
                // frozen object may not have observer.
                if (vm._data.__ob__) {
                    vm._data.__ob__.vmCount--;
                } // call the last hook...
                vm._isDestroyed = true; // invoke destroy hooks on current rendered tree
                vm.__patch__(vm._vnode, null); // fire destroyed hook
                callHook(vm, "destroyed"); // turn off all instance listeners.
                vm.$off(); // remove __vue__ reference
                if (vm.$el) {
                    vm.$el.__vue__ = null;
                } // release circular reference (#6759)
                if (vm.$vnode) {
                    vm.$vnode.parent = null;
                }
            };
        }
        function mountComponent(vm, el, hydrating) {
            vm.$el = el;
            if (!vm.$options.render) {
                vm.$options.render = createEmptyVNode;
                {
                    /* istanbul ignore if */
                    if (vm.$options.template && vm.$options.template.charAt(0) !== "#" ||
                        vm.$options.el || el) {
                        warn("You are using the runtime-only build of Vue where the template " +
                            "compiler is not available. Either pre-compile the templates into " +
                            "render functions, or use the compiler-included build.", vm);
                    }
                    else {
                        warn("Failed to mount component: template or render function not defined.", vm);
                    }
                }
            }
            callHook(vm, "beforeMount");
            var updateComponent;
            /* istanbul ignore if */
            if (config.performance && mark) {
                updateComponent = function () {
                    var name = vm._name;
                    var id = vm._uid;
                    var startTag = "vue-perf-start:" + id;
                    var endTag = "vue-perf-end:" + id;
                    mark(startTag);
                    var vnode = vm._render();
                    mark(endTag);
                    measure("vue " + name + " render", startTag, endTag);
                    mark(startTag);
                    vm._update(vnode, hydrating);
                    mark(endTag);
                    measure("vue " + name + " patch", startTag, endTag);
                };
            }
            else {
                updateComponent = function () {
                    vm._update(vm._render(), hydrating);
                };
            } // we set this to vm._watcher inside the watcher's constructor
            // since the watcher's initial patch may call $forceUpdate (e.g. inside child
            // component's mounted hook), which relies on vm._watcher being already defined
            new Watcher(vm, updateComponent, noop, {
                before: function before() {
                    if (vm._isMounted && !vm._isDestroyed) {
                        callHook(vm, "beforeUpdate");
                    }
                },
            }, true /* isRenderWatcher */);
            hydrating = false; // manually mounted instance, call mounted on self
            // mounted is called for render-created child components in its inserted hook
            if (vm.$vnode == null) {
                vm._isMounted = true;
                callHook(vm, "mounted");
            }
            return vm;
        }
        function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
            {
                isUpdatingChildComponent = true;
            } // determine whether component has slot children
            // we need to do this before overwriting $options._renderChildren.
            // check if there are dynamic scopedSlots (hand-written or compiled but with
            // dynamic slot names). Static scoped slots compiled from template has the
            // "$stable" marker.
            var newScopedSlots = parentVnode.data.scopedSlots;
            var oldScopedSlots = vm.$scopedSlots;
            var hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable ||
                oldScopedSlots !== emptyObject && !oldScopedSlots.$stable ||
                newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key); // Any static slot children from the parent may have changed during parent's
            // update. Dynamic scoped slots may also have changed. In such cases, a forced
            // update is necessary to ensure correctness.
            var needsForceUpdate = !!(renderChildren || // has new static slots
                vm.$options._renderChildren || // has old static slots
                hasDynamicScopedSlot);
            vm.$options._parentVnode = parentVnode;
            vm.$vnode = parentVnode; // update vm's placeholder node without re-render
            if (vm._vnode) {
                // update child tree's parent
                vm._vnode.parent = parentVnode;
            }
            vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash
            // these are also reactive so they may trigger child update if the child
            // used them during render
            vm.$attrs = parentVnode.data.attrs || emptyObject;
            vm.$listeners = listeners || emptyObject; // update props
            if (propsData && vm.$options.props) {
                toggleObserving(false);
                var props = vm._props;
                var propKeys = vm.$options._propKeys || [];
                for (var i = 0; i < propKeys.length; i++) {
                    var key = propKeys[i];
                    var propOptions = vm.$options.props; // wtf flow?
                    props[key] = validateProp(key, propOptions, propsData, vm);
                }
                toggleObserving(true); // keep a copy of raw propsData
                vm.$options.propsData = propsData;
            } // update listeners
            listeners = listeners || emptyObject;
            var oldListeners = vm.$options._parentListeners;
            vm.$options._parentListeners = listeners;
            updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children
            if (needsForceUpdate) {
                vm.$slots = resolveSlots(renderChildren, parentVnode.context);
                vm.$forceUpdate();
            }
            {
                isUpdatingChildComponent = false;
            }
        }
        function isInInactiveTree(vm) {
            while (vm && (vm = vm.$parent)) {
                if (vm._inactive) {
                    return true;
                }
            }
            return false;
        }
        function activateChildComponent(vm, direct) {
            if (direct) {
                vm._directInactive = false;
                if (isInInactiveTree(vm)) {
                    return;
                }
            }
            else if (vm._directInactive) {
                return;
            }
            if (vm._inactive || vm._inactive === null) {
                vm._inactive = false;
                for (var i = 0; i < vm.$children.length; i++) {
                    activateChildComponent(vm.$children[i]);
                }
                callHook(vm, "activated");
            }
        }
        function deactivateChildComponent(vm, direct) {
            if (direct) {
                vm._directInactive = true;
                if (isInInactiveTree(vm)) {
                    return;
                }
            }
            if (!vm._inactive) {
                vm._inactive = true;
                for (var i = 0; i < vm.$children.length; i++) {
                    deactivateChildComponent(vm.$children[i]);
                }
                callHook(vm, "deactivated");
            }
        }
        function callHook(vm, hook) {
            // #7573 disable dep collection when invoking lifecycle hooks
            pushTarget();
            var handlers = vm.$options[hook];
            var info = hook + " hook";
            if (handlers) {
                for (var i = 0, j = handlers.length; i < j; i++) {
                    invokeWithErrorHandling(handlers[i], vm, null, vm, info);
                }
            }
            if (vm._hasHookEvent) {
                vm.$emit("hook:" + hook);
            }
            popTarget();
        }
        /*  */
        var MAX_UPDATE_COUNT = 100;
        var queue = [];
        var activatedChildren = [];
        var has = {};
        var circular = {};
        var waiting = false;
        var flushing = false;
        var index = 0;
        /**
         * Reset the scheduler's state.
         */
        function resetSchedulerState() {
            index = queue.length = activatedChildren.length = 0;
            has = {};
            {
                circular = {};
            }
            waiting = flushing = false;
        } // Async edge case #6566 requires saving the timestamp when event listeners are
        // attached. However, calling performance.now() has a perf overhead especially
        // if the page has thousands of event listeners. Instead, we take a timestamp
        // every time the scheduler flushes and use that for all event listeners
        // attached during that flush.
        var currentFlushTimestamp = 0; // Async edge case fix requires storing an event listener's attach timestamp.
        var getNow = Date.now; // Determine what event timestamp the browser is using. Annoyingly, the
        // timestamp can either be hi-res (relative to page load) or low-res
        // (relative to UNIX epoch), so in order to compare time we have to use the
        // same timestamp type when saving the flush timestamp.
        // All IE versions use low-res event timestamps, and have problematic clock
        // implementations (#9632)
        if (inBrowser && !isIE) {
            var performance = window.performance;
            if (performance && typeof performance.now === "function" &&
                getNow() > document.createEvent("Event").timeStamp) {
                // if the event timestamp, although evaluated AFTER the Date.now(), is
                // smaller than it, it means the event is using a hi-res timestamp,
                // and we need to use the hi-res version for event listener timestamps as
                // well.
                getNow = function () {
                    return performance.now();
                };
            }
        }
        /**
         * Flush both queues and run the watchers.
         */
        function flushSchedulerQueue() {
            currentFlushTimestamp = getNow();
            flushing = true;
            var watcher, id; // Sort queue before flush.
            // This ensures that:
            // 1. Components are updated from parent to child. (because parent is always
            //    created before the child)
            // 2. A component's user watchers are run before its render watcher (because
            //    user watchers are created before the render watcher)
            // 3. If a component is destroyed during a parent component's watcher run,
            //    its watchers can be skipped.
            queue.sort(function (a, b) {
                return a.id - b.id;
            }); // do not cache length because more watchers might be pushed
            // as we run existing watchers
            for (index = 0; index < queue.length; index++) {
                watcher = queue[index];
                if (watcher.before) {
                    watcher.before();
                }
                id = watcher.id;
                has[id] = null;
                watcher.run(); // in dev build, check and stop circular updates.
                if (has[id] != null) {
                    circular[id] = (circular[id] || 0) + 1;
                    if (circular[id] > MAX_UPDATE_COUNT) {
                        warn("You may have an infinite update loop " +
                            (watcher.user
                                ? 'in watcher with expression "' + watcher.expression + '"'
                                : "in a component render function."), watcher.vm);
                        break;
                    }
                }
            } // keep copies of post queues before resetting state
            var activatedQueue = activatedChildren.slice();
            var updatedQueue = queue.slice();
            resetSchedulerState(); // call component updated and activated hooks
            callActivatedHooks(activatedQueue);
            callUpdatedHooks(updatedQueue); // devtool hook
            /* istanbul ignore if */
            if (devtools && config.devtools) {
                devtools.emit("flush");
            }
        }
        function callUpdatedHooks(queue) {
            var i = queue.length;
            while (i--) {
                var watcher = queue[i];
                var vm = watcher.vm;
                if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
                    callHook(vm, "updated");
                }
            }
        }
        /**
         * Queue a kept-alive component that was activated during patch.
         * The queue will be processed after the entire tree has been patched.
         */
        function queueActivatedComponent(vm) {
            // setting _inactive to false here so that a render function can
            // rely on checking whether it's in an inactive tree (e.g. router-view)
            vm._inactive = false;
            activatedChildren.push(vm);
        }
        function callActivatedHooks(queue) {
            for (var i = 0; i < queue.length; i++) {
                queue[i]._inactive = true;
                activateChildComponent(queue[i], true /* true */);
            }
        }
        /**
         * Push a watcher into the watcher queue.
         * Jobs with duplicate IDs will be skipped unless it's
         * pushed when the queue is being flushed.
         */
        function queueWatcher(watcher) {
            var id = watcher.id;
            if (has[id] == null) {
                has[id] = true;
                if (!flushing) {
                    queue.push(watcher);
                }
                else {
                    // if already flushing, splice the watcher based on its id
                    // if already past its id, it will be run next immediately.
                    var i = queue.length - 1;
                    while (i > index && queue[i].id > watcher.id) {
                        i--;
                    }
                    queue.splice(i + 1, 0, watcher);
                } // queue the flush
                if (!waiting) {
                    waiting = true;
                    if (!config.async) {
                        flushSchedulerQueue();
                        return;
                    }
                    nextTick(flushSchedulerQueue);
                }
            }
        }
        /*  */
        var uid$2 = 0;
        /**
         * A watcher parses an expression, collects dependencies,
         * and fires callback when the expression value changes.
         * This is used for both the $watch() api and directives.
         */
        var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
            this.vm = vm;
            if (isRenderWatcher) {
                vm._watcher = this;
            }
            vm._watchers.push(this); // options
            if (options) {
                this.deep = !!options.deep;
                this.user = !!options.user;
                this.lazy = !!options.lazy;
                this.sync = !!options.sync;
                this.before = options.before;
            }
            else {
                this.deep = this.user = this.lazy = this.sync = false;
            }
            this.cb = cb;
            this.id = ++uid$2; // uid for batching
            this.active = true;
            this.dirty = this.lazy; // for lazy watchers
            this.deps = [];
            this.newDeps = [];
            this.depIds = new _Set();
            this.newDepIds = new _Set();
            this.expression = expOrFn.toString(); // parse expression for getter
            if (typeof expOrFn === "function") {
                this.getter = expOrFn;
            }
            else {
                this.getter = parsePath(expOrFn);
                if (!this.getter) {
                    this.getter = noop;
                    warn('Failed watching path: "' + expOrFn + '" ' +
                        "Watcher only accepts simple dot-delimited paths. " +
                        "For full control, use a function instead.", vm);
                }
            }
            this.value = this.lazy ? undefined : this.get();
        };
        /**
         * Evaluate the getter, and re-collect dependencies.
         */
        Watcher.prototype.get = function get() {
            pushTarget(this);
            var value;
            var vm = this.vm;
            try {
                value = this.getter.call(vm, vm);
            }
            catch (e) {
                if (this.user) {
                    handleError(e, vm, 'getter for watcher "' + this.expression + '"');
                }
                else {
                    throw e;
                }
            }
            finally {
                // "touch" every property so they are all tracked as
                // dependencies for deep watching
                if (this.deep) {
                    traverse(value);
                }
                popTarget();
                this.cleanupDeps();
            }
            return value;
        };
        /**
         * Add a dependency to this directive.
         */
        Watcher.prototype.addDep = function addDep(dep) {
            var id = dep.id;
            if (!this.newDepIds.has(id)) {
                this.newDepIds.add(id);
                this.newDeps.push(dep);
                if (!this.depIds.has(id)) {
                    dep.addSub(this);
                }
            }
        };
        /**
         * Clean up for dependency collection.
         */
        Watcher.prototype.cleanupDeps = function cleanupDeps() {
            var i = this.deps.length;
            while (i--) {
                var dep = this.deps[i];
                if (!this.newDepIds.has(dep.id)) {
                    dep.removeSub(this);
                }
            }
            var tmp = this.depIds;
            this.depIds = this.newDepIds;
            this.newDepIds = tmp;
            this.newDepIds.clear();
            tmp = this.deps;
            this.deps = this.newDeps;
            this.newDeps = tmp;
            this.newDeps.length = 0;
        };
        /**
         * Subscriber interface.
         * Will be called when a dependency changes.
         */
        Watcher.prototype.update = function update() {
            /* istanbul ignore else */
            if (this.lazy) {
                this.dirty = true;
            }
            else if (this.sync) {
                this.run();
            }
            else {
                queueWatcher(this);
            }
        };
        /**
         * Scheduler job interface.
         * Will be called by the scheduler.
         */
        Watcher.prototype.run = function run() {
            if (this.active) {
                var value = this.get();
                if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even
                    // when the value is the same, because the value may
                    // have mutated.
                    isObject(value) || this.deep) {
                    // set new value
                    var oldValue = this.value;
                    this.value = value;
                    if (this.user) {
                        try {
                            this.cb.call(this.vm, value, oldValue);
                        }
                        catch (e) {
                            handleError(e, this.vm, 'callback for watcher "' + this.expression + '"');
                        }
                    }
                    else {
                        this.cb.call(this.vm, value, oldValue);
                    }
                }
            }
        };
        /**
         * Evaluate the value of the watcher.
         * This only gets called for lazy watchers.
         */
        Watcher.prototype.evaluate = function evaluate() {
            this.value = this.get();
            this.dirty = false;
        };
        /**
         * Depend on all deps collected by this watcher.
         */
        Watcher.prototype.depend = function depend() {
            var i = this.deps.length;
            while (i--) {
                this.deps[i].depend();
            }
        };
        /**
         * Remove self from all dependencies' subscriber list.
         */
        Watcher.prototype.teardown = function teardown() {
            if (this.active) {
                // remove self from vm's watcher list
                // this is a somewhat expensive operation so we skip it
                // if the vm is being destroyed.
                if (!this.vm._isBeingDestroyed) {
                    remove(this.vm._watchers, this);
                }
                var i = this.deps.length;
                while (i--) {
                    this.deps[i].removeSub(this);
                }
                this.active = false;
            }
        };
        /*  */
        var sharedPropertyDefinition = {
            enumerable: true,
            configurable: true,
            get: noop,
            set: noop,
        };
        function proxy(target, sourceKey, key) {
            sharedPropertyDefinition.get = function proxyGetter() {
                return this[sourceKey][key];
            };
            sharedPropertyDefinition.set = function proxySetter(val) {
                this[sourceKey][key] = val;
            };
            Object.defineProperty(target, key, sharedPropertyDefinition);
        }
        function initState(vm) {
            vm._watchers = [];
            var opts = vm.$options;
            if (opts.props) {
                initProps(vm, opts.props);
            }
            if (opts.methods) {
                initMethods(vm, opts.methods);
            }
            if (opts.data) {
                initData(vm);
            }
            else {
                observe(vm._data = {}, true /* asRootData */);
            }
            if (opts.computed) {
                initComputed(vm, opts.computed);
            }
            if (opts.watch && opts.watch !== nativeWatch) {
                initWatch(vm, opts.watch);
            }
        }
        function initProps(vm, propsOptions) {
            var propsData = vm.$options.propsData || {};
            var props = vm._props = {}; // cache prop keys so that future props updates can iterate using Array
            // instead of dynamic object key enumeration.
            var keys = vm.$options._propKeys = [];
            var isRoot = !vm.$parent; // root instance props should be converted
            if (!isRoot) {
                toggleObserving(false);
            }
            var loop = function (key) {
                keys.push(key);
                var value = validateProp(key, propsOptions, propsData, vm);
                /* istanbul ignore else */
                {
                    var hyphenatedKey = hyphenate(key);
                    if (isReservedAttribute(hyphenatedKey) ||
                        config.isReservedAttr(hyphenatedKey)) {
                        warn('"' + hyphenatedKey +
                            '" is a reserved attribute and cannot be used as component prop.', vm);
                    }
                    defineReactive$$1(props, key, value, function () {
                        if (!isRoot && !isUpdatingChildComponent) {
                            warn("Avoid mutating a prop directly since the value will be " +
                                "overwritten whenever the parent component re-renders. " +
                                "Instead, use a data or computed property based on the prop's " +
                                'value. Prop being mutated: "' + key + '"', vm);
                        }
                    });
                } // static props are already proxied on the component's prototype
                // during Vue.extend(). We only need to proxy props defined at
                // instantiation here.
                if (!(key in vm)) {
                    proxy(vm, "_props", key);
                }
            };
            for (var key in propsOptions)
                loop(key);
            toggleObserving(true);
        }
        function initData(vm) {
            var data = vm.$options.data;
            data = vm._data = typeof data === "function"
                ? getData(data, vm)
                : data || {};
            if (!isPlainObject(data)) {
                data = {};
                warn("data functions should return an object:\n" +
                    "https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function", vm);
            } // proxy data on instance
            var keys = Object.keys(data);
            var props = vm.$options.props;
            var methods = vm.$options.methods;
            var i = keys.length;
            while (i--) {
                var key = keys[i];
                {
                    if (methods && hasOwn(methods, key)) {
                        warn('Method "' + key + '" has already been defined as a data property.', vm);
                    }
                }
                if (props && hasOwn(props, key)) {
                    warn('The data property "' + key + '" is already declared as a prop. ' +
                        "Use prop default value instead.", vm);
                }
                else if (!isReserved(key)) {
                    proxy(vm, "_data", key);
                }
            } // observe data
            observe(data, true /* asRootData */);
        }
        function getData(data, vm) {
            // #7573 disable dep collection when invoking data getters
            pushTarget();
            try {
                return data.call(vm, vm);
            }
            catch (e) {
                handleError(e, vm, "data()");
                return {};
            }
            finally {
                popTarget();
            }
        }
        var computedWatcherOptions = {
            lazy: true,
        };
        function initComputed(vm, computed) {
            // $flow-disable-line
            var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR
            var isSSR = isServerRendering();
            for (var key in computed) {
                var userDef = computed[key];
                var getter = typeof userDef === "function" ? userDef : userDef.get;
                if (getter == null) {
                    warn('Getter is missing for computed property "' + key + '".', vm);
                }
                if (!isSSR) {
                    // create internal watcher for the computed property.
                    watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
                } // component-defined computed properties are already defined on the
                // component prototype. We only need to define computed properties defined
                // at instantiation here.
                if (!(key in vm)) {
                    defineComputed(vm, key, userDef);
                }
                else {
                    if (key in vm.$data) {
                        warn('The computed property "' + key + '" is already defined in data.', vm);
                    }
                    else if (vm.$options.props && key in vm.$options.props) {
                        warn('The computed property "' + key + '" is already defined as a prop.', vm);
                    }
                }
            }
        }
        function defineComputed(target, key, userDef) {
            var shouldCache = !isServerRendering();
            if (typeof userDef === "function") {
                sharedPropertyDefinition.get = shouldCache
                    ? createComputedGetter(key)
                    : createGetterInvoker(userDef);
                sharedPropertyDefinition.set = noop;
            }
            else {
                sharedPropertyDefinition.get = userDef.get
                    ? shouldCache && userDef.cache !== false
                        ? createComputedGetter(key)
                        : createGetterInvoker(userDef.get)
                    : noop;
                sharedPropertyDefinition.set = userDef.set || noop;
            }
            if (sharedPropertyDefinition.set === noop) {
                sharedPropertyDefinition.set = function () {
                    warn('Computed property "' + key +
                        '" was assigned to but it has no setter.', this);
                };
            }
            Object.defineProperty(target, key, sharedPropertyDefinition);
        }
        function createComputedGetter(key) {
            return function computedGetter() {
                var watcher = this._computedWatchers && this._computedWatchers[key];
                if (watcher) {
                    if (watcher.dirty) {
                        watcher.evaluate();
                    }
                    if (Dep.target) {
                        watcher.depend();
                    }
                    return watcher.value;
                }
            };
        }
        function createGetterInvoker(fn) {
            return function computedGetter() {
                return fn.call(this, this);
            };
        }
        function initMethods(vm, methods) {
            var props = vm.$options.props;
            for (var key in methods) {
                {
                    if (typeof methods[key] !== "function") {
                        warn('Method "' + key + '" has type "' + typeof methods[key] +
                            '" in the component definition. ' +
                            "Did you reference the function correctly?", vm);
                    }
                    if (props && hasOwn(props, key)) {
                        warn('Method "' + key + '" has already been defined as a prop.', vm);
                    }
                    if (key in vm && isReserved(key)) {
                        warn('Method "' + key +
                            '" conflicts with an existing Vue instance method. ' +
                            "Avoid defining component methods that start with _ or $.");
                    }
                }
                vm[key] = typeof methods[key] !== "function"
                    ? noop
                    : bind(methods[key], vm);
            }
        }
        function initWatch(vm, watch) {
            for (var key in watch) {
                var handler = watch[key];
                if (Array.isArray(handler)) {
                    for (var i = 0; i < handler.length; i++) {
                        createWatcher(vm, key, handler[i]);
                    }
                }
                else {
                    createWatcher(vm, key, handler);
                }
            }
        }
        function createWatcher(vm, expOrFn, handler, options) {
            if (isPlainObject(handler)) {
                options = handler;
                handler = handler.handler;
            }
            if (typeof handler === "string") {
                handler = vm[handler];
            }
            return vm.$watch(expOrFn, handler, options);
        }
        function stateMixin(Vue) {
            // flow somehow has problems with directly declared definition object
            // when using Object.defineProperty, so we have to procedurally build up
            // the object here.
            var dataDef = {};
            dataDef.get = function () {
                return this._data;
            };
            var propsDef = {};
            propsDef.get = function () {
                return this._props;
            };
            {
                dataDef.set = function () {
                    warn("Avoid replacing instance root $data. " +
                        "Use nested data properties instead.", this);
                };
                propsDef.set = function () {
                    warn("$props is readonly.", this);
                };
            }
            Object.defineProperty(Vue.prototype, "$data", dataDef);
            Object.defineProperty(Vue.prototype, "$props", propsDef);
            Vue.prototype.$set = set;
            Vue.prototype.$delete = del;
            Vue.prototype.$watch = function (expOrFn, cb, options) {
                var vm = this;
                if (isPlainObject(cb)) {
                    return createWatcher(vm, expOrFn, cb, options);
                }
                options = options || {};
                options.user = true;
                var watcher = new Watcher(vm, expOrFn, cb, options);
                if (options.immediate) {
                    try {
                        cb.call(vm, watcher.value);
                    }
                    catch (error) {
                        handleError(error, vm, 'callback for immediate watcher "' + watcher.expression + '"');
                    }
                }
                return function unwatchFn() {
                    watcher.teardown();
                };
            };
        }
        /*  */
        var uid$3 = 0;
        function initMixin(Vue) {
            Vue.prototype._init = function (options) {
                var vm = this; // a uid
                vm._uid = uid$3++;
                var startTag, endTag;
                /* istanbul ignore if */
                if (config.performance && mark) {
                    startTag = "vue-perf-start:" + vm._uid;
                    endTag = "vue-perf-end:" + vm._uid;
                    mark(startTag);
                } // a flag to avoid this being observed
                vm._isVue = true; // merge options
                if (options && options._isComponent) {
                    // optimize internal component instantiation
                    // since dynamic options merging is pretty slow, and none of the
                    // internal component options needs special treatment.
                    initInternalComponent(vm, options);
                }
                else {
                    vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
                }
                /* istanbul ignore else */
                {
                    initProxy(vm);
                } // expose real self
                vm._self = vm;
                initLifecycle(vm);
                initEvents(vm);
                initRender(vm);
                callHook(vm, "beforeCreate");
                initInjections(vm); // resolve injections before data/props
                initState(vm);
                initProvide(vm); // resolve provide after data/props
                callHook(vm, "created");
                /* istanbul ignore if */
                if (config.performance && mark) {
                    vm._name = formatComponentName(vm, false);
                    mark(endTag);
                    measure("vue " + vm._name + " init", startTag, endTag);
                }
                if (vm.$options.el) {
                    vm.$mount(vm.$options.el);
                }
            };
        }
        function initInternalComponent(vm, options) {
            var opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.
            var parentVnode = options._parentVnode;
            opts.parent = options.parent;
            opts._parentVnode = parentVnode;
            var vnodeComponentOptions = parentVnode.componentOptions;
            opts.propsData = vnodeComponentOptions.propsData;
            opts._parentListeners = vnodeComponentOptions.listeners;
            opts._renderChildren = vnodeComponentOptions.children;
            opts._componentTag = vnodeComponentOptions.tag;
            if (options.render) {
                opts.render = options.render;
                opts.staticRenderFns = options.staticRenderFns;
            }
        }
        function resolveConstructorOptions(Ctor) {
            var options = Ctor.options;
            if (Ctor.super) {
                var superOptions = resolveConstructorOptions(Ctor.super);
                var cachedSuperOptions = Ctor.superOptions;
                if (superOptions !== cachedSuperOptions) {
                    // super option changed,
                    // need to resolve new options.
                    Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)
                    var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options
                    if (modifiedOptions) {
                        extend(Ctor.extendOptions, modifiedOptions);
                    }
                    options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
                    if (options.name) {
                        options.components[options.name] = Ctor;
                    }
                }
            }
            return options;
        }
        function resolveModifiedOptions(Ctor) {
            var modified;
            var latest = Ctor.options;
            var sealed = Ctor.sealedOptions;
            for (var key in latest) {
                if (latest[key] !== sealed[key]) {
                    if (!modified) {
                        modified = {};
                    }
                    modified[key] = latest[key];
                }
            }
            return modified;
        }
        function Vue(options) {
            if (!(this instanceof Vue)) {
                warn("Vue is a constructor and should be called with the `new` keyword");
            }
            this._init(options);
        }
        initMixin(Vue);
        stateMixin(Vue);
        eventsMixin(Vue);
        lifecycleMixin(Vue);
        renderMixin(Vue);
        /*  */
        function initUse(Vue) {
            Vue.use = function (plugin) {
                var installedPlugins = this._installedPlugins ||
                    (this._installedPlugins = []);
                if (installedPlugins.indexOf(plugin) > -1) {
                    return this;
                } // additional parameters
                var args = toArray(arguments, 1);
                args.unshift(this);
                if (typeof plugin.install === "function") {
                    plugin.install.apply(plugin, args);
                }
                else if (typeof plugin === "function") {
                    plugin.apply(null, args);
                }
                installedPlugins.push(plugin);
                return this;
            };
        }
        /*  */
        function initMixin$1(Vue) {
            Vue.mixin = function (mixin) {
                this.options = mergeOptions(this.options, mixin);
                return this;
            };
        }
        /*  */
        function initExtend(Vue) {
            /**
             * Each instance constructor, including Vue, has a unique
             * cid. This enables us to create wrapped "child
             * constructors" for prototypal inheritance and cache them.
             */
            Vue.cid = 0;
            var cid = 1;
            /**
             * Class inheritance
             */
            Vue.extend = function (extendOptions) {
                extendOptions = extendOptions || {};
                var Super = this;
                var SuperId = Super.cid;
                var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
                if (cachedCtors[SuperId]) {
                    return cachedCtors[SuperId];
                }
                var name = extendOptions.name || Super.options.name;
                if (name) {
                    validateComponentName(name);
                }
                var Sub = function VueComponent(options) {
                    this._init(options);
                };
                Sub.prototype = Object.create(Super.prototype);
                Sub.prototype.constructor = Sub;
                Sub.cid = cid++;
                Sub.options = mergeOptions(Super.options, extendOptions);
                Sub["super"] = Super; // For props and computed properties, we define the proxy getters on
                // the Vue instances at extension time, on the extended prototype. This
                // avoids Object.defineProperty calls for each instance created.
                if (Sub.options.props) {
                    initProps$1(Sub);
                }
                if (Sub.options.computed) {
                    initComputed$1(Sub);
                } // allow further extension/mixin/plugin usage
                Sub.extend = Super.extend;
                Sub.mixin = Super.mixin;
                Sub.use = Super.use; // create asset registers, so extended classes
                // can have their private assets too.
                ASSET_TYPES.forEach(function (type) {
                    Sub[type] = Super[type];
                }); // enable recursive self-lookup
                if (name) {
                    Sub.options.components[name] = Sub;
                } // keep a reference to the super options at extension time.
                // later at instantiation we can check if Super's options have
                // been updated.
                Sub.superOptions = Super.options;
                Sub.extendOptions = extendOptions;
                Sub.sealedOptions = extend({}, Sub.options); // cache constructor
                cachedCtors[SuperId] = Sub;
                return Sub;
            };
        }
        function initProps$1(Comp) {
            var props = Comp.options.props;
            for (var key in props) {
                proxy(Comp.prototype, "_props", key);
            }
        }
        function initComputed$1(Comp) {
            var computed = Comp.options.computed;
            for (var key in computed) {
                defineComputed(Comp.prototype, key, computed[key]);
            }
        }
        /*  */
        function initAssetRegisters(Vue) {
            /**
             * Create asset registration methods.
             */
            ASSET_TYPES.forEach(function (type) {
                Vue[type] = function (id, definition) {
                    if (!definition) {
                        return this.options[type + "s"][id];
                    }
                    else {
                        /* istanbul ignore if */
                        if (type === "component") {
                            validateComponentName(id);
                        }
                        if (type === "component" && isPlainObject(definition)) {
                            definition.name = definition.name || id;
                            definition = this.options._base.extend(definition);
                        }
                        if (type === "directive" && typeof definition === "function") {
                            definition = {
                                bind: definition,
                                update: definition,
                            };
                        }
                        this.options[type + "s"][id] = definition;
                        return definition;
                    }
                };
            });
        }
        /*  */
        function getComponentName(opts) {
            return opts && (opts.Ctor.options.name || opts.tag);
        }
        function matches(pattern, name) {
            if (Array.isArray(pattern)) {
                return pattern.indexOf(name) > -1;
            }
            else if (typeof pattern === "string") {
                return pattern.split(",").indexOf(name) > -1;
            }
            else if (isRegExp(pattern)) {
                return pattern.test(name);
            }
            /* istanbul ignore next */
            return false;
        }
        function pruneCache(keepAliveInstance, filter) {
            var cache = keepAliveInstance.cache;
            var keys = keepAliveInstance.keys;
            var _vnode = keepAliveInstance._vnode;
            for (var key in cache) {
                var cachedNode = cache[key];
                if (cachedNode) {
                    var name = getComponentName(cachedNode.componentOptions);
                    if (name && !filter(name)) {
                        pruneCacheEntry(cache, key, keys, _vnode);
                    }
                }
            }
        }
        function pruneCacheEntry(cache, key, keys, current) {
            var cached$$1 = cache[key];
            if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
                cached$$1.componentInstance.$destroy();
            }
            cache[key] = null;
            remove(keys, key);
        }
        var patternTypes = [String, RegExp, Array];
        var KeepAlive = {
            name: "keep-alive",
            abstract: true,
            props: {
                include: patternTypes,
                exclude: patternTypes,
                max: [String, Number],
            },
            created: function created() {
                this.cache = Object.create(null);
                this.keys = [];
            },
            destroyed: function destroyed() {
                for (var key in this.cache) {
                    pruneCacheEntry(this.cache, key, this.keys);
                }
            },
            mounted: function mounted() {
                var this$1 = this;
                this.$watch("include", function (val) {
                    pruneCache(this$1, function (name) {
                        return matches(val, name);
                    });
                });
                this.$watch("exclude", function (val) {
                    pruneCache(this$1, function (name) {
                        return !matches(val, name);
                    });
                });
            },
            render: function render() {
                var slot = this.$slots.default;
                var vnode = getFirstComponentChild(slot);
                var componentOptions = vnode && vnode.componentOptions;
                if (componentOptions) {
                    // check pattern
                    var name = getComponentName(componentOptions);
                    var ref = this;
                    var include = ref.include;
                    var exclude = ref.exclude;
                    if (
                    // not included
                    include && (!name || !matches(include, name)) || // excluded
                        exclude && name && matches(exclude, name)) {
                        return vnode;
                    }
                    var ref$1 = this;
                    var cache = ref$1.cache;
                    var keys = ref$1.keys;
                    var key = vnode.key == null // same constructor may get registered as different local components
                        ? // so cid alone is not enough (#3269)
                            componentOptions.Ctor.cid +
                                (componentOptions.tag ? "::" + componentOptions.tag : "")
                        : vnode.key;
                    if (cache[key]) {
                        vnode.componentInstance = cache[key].componentInstance; // make current key freshest
                        remove(keys, key);
                        keys.push(key);
                    }
                    else {
                        cache[key] = vnode;
                        keys.push(key); // prune oldest entry
                        if (this.max && keys.length > parseInt(this.max)) {
                            pruneCacheEntry(cache, keys[0], keys, this._vnode);
                        }
                    }
                    vnode.data.keepAlive = true;
                }
                return vnode || slot && slot[0];
            },
        };
        var builtInComponents = {
            KeepAlive: KeepAlive,
        };
        /*  */
        function initGlobalAPI(Vue) {
            // config
            var configDef = {};
            configDef.get = function () {
                return config;
            };
            {
                configDef.set = function () {
                    warn("Do not replace the Vue.config object, set individual fields instead.");
                };
            }
            Object.defineProperty(Vue, "config", configDef); // exposed util methods.
            // NOTE: these are not considered part of the public API - avoid relying on
            // them unless you are aware of the risk.
            Vue.util = {
                warn: warn,
                extend: extend,
                mergeOptions: mergeOptions,
                defineReactive: defineReactive$$1,
            };
            Vue.set = set;
            Vue.delete = del;
            Vue.nextTick = nextTick; // 2.6 explicit observable API
            Vue.observable = function (obj) {
                observe(obj);
                return obj;
            };
            Vue.options = Object.create(null);
            ASSET_TYPES.forEach(function (type) {
                Vue.options[type + "s"] = Object.create(null);
            }); // this is used to identify the "base" constructor to extend all plain-object
            // components with in Weex's multi-instance scenarios.
            Vue.options._base = Vue;
            extend(Vue.options.components, builtInComponents);
            initUse(Vue);
            initMixin$1(Vue);
            initExtend(Vue);
            initAssetRegisters(Vue);
        }
        initGlobalAPI(Vue);
        Object.defineProperty(Vue.prototype, "$isServer", {
            get: isServerRendering,
        });
        Object.defineProperty(Vue.prototype, "$ssrContext", {
            get: function get() {
                /* istanbul ignore next */
                return this.$vnode && this.$vnode.ssrContext;
            },
        }); // expose FunctionalRenderContext for ssr runtime helper installation
        Object.defineProperty(Vue, "FunctionalRenderContext", {
            value: FunctionalRenderContext,
        });
        Vue.version = "2.6.11";
        /*  */
        // these are reserved for web because they are directly compiled away
        // during template compilation
        var isReservedAttr = makeMap("style,class"); // attributes that should be using props for binding
        var acceptValue = makeMap("input,textarea,option,select,progress");
        var mustUseProp = function (tag, type, attr) {
            return attr === "value" && acceptValue(tag) && type !== "button" ||
                attr === "selected" && tag === "option" ||
                attr === "checked" && tag === "input" ||
                attr === "muted" && tag === "video";
        };
        var isEnumeratedAttr = makeMap("contenteditable,draggable,spellcheck");
        var isValidContentEditableValue = makeMap("events,caret,typing,plaintext-only");
        var convertEnumeratedValue = function (key, value) {
            return isFalsyAttrValue(value) || value === "false"
                ? "false" // allow arbitrary string value for contenteditable
                : key === "contenteditable" && isValidContentEditableValue(value)
                    ? value
                    : "true";
        };
        var isBooleanAttr = makeMap("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare," +
            "default,defaultchecked,defaultmuted,defaultselected,defer,disabled," +
            "enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple," +
            "muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly," +
            "required,reversed,scoped,seamless,selected,sortable,translate," +
            "truespeed,typemustmatch,visible");
        var xlinkNS = "http://www.w3.org/1999/xlink";
        var isXlink = function (name) {
            return name.charAt(5) === ":" && name.slice(0, 5) === "xlink";
        };
        var getXlinkProp = function (name) {
            return isXlink(name) ? name.slice(6, name.length) : "";
        };
        var isFalsyAttrValue = function (val) {
            return val == null || val === false;
        };
        /*  */
        function genClassForVnode(vnode) {
            var data = vnode.data;
            var parentNode = vnode;
            var childNode = vnode;
            while (isDef(childNode.componentInstance)) {
                childNode = childNode.componentInstance._vnode;
                if (childNode && childNode.data) {
                    data = mergeClassData(childNode.data, data);
                }
            }
            while (isDef(parentNode = parentNode.parent)) {
                if (parentNode && parentNode.data) {
                    data = mergeClassData(data, parentNode.data);
                }
            }
            return renderClass(data.staticClass, data.class);
        }
        function mergeClassData(child, parent) {
            return {
                staticClass: concat(child.staticClass, parent.staticClass),
                class: isDef(child.class) ? [child.class, parent.class] : parent.class,
            };
        }
        function renderClass(staticClass, dynamicClass) {
            if (isDef(staticClass) || isDef(dynamicClass)) {
                return concat(staticClass, stringifyClass(dynamicClass));
            }
            /* istanbul ignore next */
            return "";
        }
        function concat(a, b) {
            return a ? b ? a + " " + b : a : b || "";
        }
        function stringifyClass(value) {
            if (Array.isArray(value)) {
                return stringifyArray(value);
            }
            if (isObject(value)) {
                return stringifyObject(value);
            }
            if (typeof value === "string") {
                return value;
            }
            /* istanbul ignore next */
            return "";
        }
        function stringifyArray(value) {
            var res = "";
            var stringified;
            for (var i = 0, l = value.length; i < l; i++) {
                if (isDef(stringified = stringifyClass(value[i])) && stringified !== "") {
                    if (res) {
                        res += " ";
                    }
                    res += stringified;
                }
            }
            return res;
        }
        function stringifyObject(value) {
            var res = "";
            for (var key in value) {
                if (value[key]) {
                    if (res) {
                        res += " ";
                    }
                    res += key;
                }
            }
            return res;
        }
        /*  */
        var namespaceMap = {
            svg: "http://www.w3.org/2000/svg",
            math: "http://www.w3.org/1998/Math/MathML",
        };
        var isHTMLTag = makeMap("html,body,base,head,link,meta,style,title," +
            "address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section," +
            "div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul," +
            "a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby," +
            "s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video," +
            "embed,object,param,source,canvas,script,noscript,del,ins," +
            "caption,col,colgroup,table,thead,tbody,td,th,tr," +
            "button,datalist,fieldset,form,input,label,legend,meter,optgroup,option," +
            "output,progress,select,textarea," +
            "details,dialog,menu,menuitem,summary," +
            "content,element,shadow,template,blockquote,iframe,tfoot"); // this map is intentionally selective, only covering SVG elements that may
        // contain child elements.
        var isSVG = makeMap("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face," +
            "foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern," +
            "polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", true);
        var isReservedTag = function (tag) {
            return isHTMLTag(tag) || isSVG(tag);
        };
        function getTagNamespace(tag) {
            if (isSVG(tag)) {
                return "svg";
            } // basic support for MathML
            // note it doesn't support other MathML elements being component roots
            if (tag === "math") {
                return "math";
            }
        }
        var unknownElementCache = Object.create(null);
        function isUnknownElement(tag) {
            /* istanbul ignore if */
            if (!inBrowser) {
                return true;
            }
            if (isReservedTag(tag)) {
                return false;
            }
            tag = tag.toLowerCase();
            /* istanbul ignore if */
            if (unknownElementCache[tag] != null) {
                return unknownElementCache[tag];
            }
            var el = document.createElement(tag);
            if (tag.indexOf("-") > -1) {
                // http://stackoverflow.com/a/28210364/1070244
                return unknownElementCache[tag] =
                    el.constructor === window.HTMLUnknownElement ||
                        el.constructor === window.HTMLElement;
            }
            else {
                return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
            }
        }
        var isTextInputType = makeMap("text,number,password,search,email,tel,url");
        /*  */
        /**
         * Query an element selector if it's not an element already.
         */
        function query(el) {
            if (typeof el === "string") {
                var selected = document.querySelector(el);
                if (!selected) {
                    warn("Cannot find element: " + el);
                    return document.createElement("div");
                }
                return selected;
            }
            else {
                return el;
            }
        }
        /*  */
        function createElement$1(tagName, vnode) {
            var elm = document.createElement(tagName);
            if (tagName !== "select") {
                return elm;
            } // false or null will remove the attribute but undefined will not
            if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
                elm.setAttribute("multiple", "multiple");
            }
            return elm;
        }
        function createElementNS(namespace, tagName) {
            return document.createElementNS(namespaceMap[namespace], tagName);
        }
        function createTextNode(text) {
            return document.createTextNode(text);
        }
        function createComment(text) {
            return document.createComment(text);
        }
        function insertBefore(parentNode, newNode, referenceNode) {
            parentNode.insertBefore(newNode, referenceNode);
        }
        function removeChild(node, child) {
            node.removeChild(child);
        }
        function appendChild(node, child) {
            node.appendChild(child);
        }
        function parentNode(node) {
            return node.parentNode;
        }
        function nextSibling(node) {
            return node.nextSibling;
        }
        function tagName(node) {
            return node.tagName;
        }
        function setTextContent(node, text) {
            node.textContent = text;
        }
        function setStyleScope(node, scopeId) {
            node.setAttribute(scopeId, "");
        }
        var nodeOps = 
        /*#__PURE__*/
        Object.freeze({
            createElement: createElement$1,
            createElementNS: createElementNS,
            createTextNode: createTextNode,
            createComment: createComment,
            insertBefore: insertBefore,
            removeChild: removeChild,
            appendChild: appendChild,
            parentNode: parentNode,
            nextSibling: nextSibling,
            tagName: tagName,
            setTextContent: setTextContent,
            setStyleScope: setStyleScope,
        });
        /*  */
        var ref = {
            create: function create(_, vnode) {
                registerRef(vnode);
            },
            update: function update(oldVnode, vnode) {
                if (oldVnode.data.ref !== vnode.data.ref) {
                    registerRef(oldVnode, true);
                    registerRef(vnode);
                }
            },
            destroy: function destroy(vnode) {
                registerRef(vnode, true);
            },
        };
        function registerRef(vnode, isRemoval) {
            var key = vnode.data.ref;
            if (!isDef(key)) {
                return;
            }
            var vm = vnode.context;
            var ref = vnode.componentInstance || vnode.elm;
            var refs = vm.$refs;
            if (isRemoval) {
                if (Array.isArray(refs[key])) {
                    remove(refs[key], ref);
                }
                else if (refs[key] === ref) {
                    refs[key] = undefined;
                }
            }
            else {
                if (vnode.data.refInFor) {
                    if (!Array.isArray(refs[key])) {
                        refs[key] = [ref];
                    }
                    else if (refs[key].indexOf(ref) < 0) {
                        // $flow-disable-line
                        refs[key].push(ref);
                    }
                }
                else {
                    refs[key] = ref;
                }
            }
        }
        /**
         * Virtual DOM patching algorithm based on Snabbdom by
         * Simon Friis Vindum (@paldepind)
         * Licensed under the MIT License
         * https://github.com/paldepind/snabbdom/blob/master/LICENSE
         *
         * modified by Evan You (@yyx990803)
         *
         * Not type-checking this because this file is perf-critical and the cost
         * of making flow understand it is not worth it.
         */
        var emptyNode = new VNode("", {}, []);
        var hooks = ["create", "activate", "update", "remove", "destroy"];
        function sameVnode(a, b) {
            return a.key === b.key &&
                (a.tag === b.tag && a.isComment === b.isComment &&
                    isDef(a.data) === isDef(b.data) && sameInputType(a, b) ||
                    isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory &&
                        isUndef(b.asyncFactory.error));
        }
        function sameInputType(a, b) {
            if (a.tag !== "input") {
                return true;
            }
            var i;
            var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
            var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
            return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
        }
        function createKeyToOldIdx(children, beginIdx, endIdx) {
            var i, key;
            var map = {};
            for (i = beginIdx; i <= endIdx; ++i) {
                key = children[i].key;
                if (isDef(key)) {
                    map[key] = i;
                }
            }
            return map;
        }
        function createPatchFunction(backend) {
            var i, j;
            var cbs = {};
            var modules = backend.modules;
            var nodeOps = backend.nodeOps;
            for (i = 0; i < hooks.length; ++i) {
                cbs[hooks[i]] = [];
                for (j = 0; j < modules.length; ++j) {
                    if (isDef(modules[j][hooks[i]])) {
                        cbs[hooks[i]].push(modules[j][hooks[i]]);
                    }
                }
            }
            function emptyNodeAt(elm) {
                return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
            }
            function createRmCb(childElm, listeners) {
                function remove$$1() {
                    if (--remove$$1.listeners === 0) {
                        removeNode(childElm);
                    }
                }
                remove$$1.listeners = listeners;
                return remove$$1;
            }
            function removeNode(el) {
                var parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text
                if (isDef(parent)) {
                    nodeOps.removeChild(parent, el);
                }
            }
            function isUnknownElement$$1(vnode, inVPre) {
                return !inVPre && !vnode.ns &&
                    !(config.ignoredElements.length &&
                        config.ignoredElements.some(function (ignore) {
                            return isRegExp(ignore)
                                ? ignore.test(vnode.tag)
                                : ignore === vnode.tag;
                        })) &&
                    config.isUnknownElement(vnode.tag);
            }
            var creatingElmInVPre = 0;
            function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
                if (isDef(vnode.elm) && isDef(ownerArray)) {
                    // This vnode was used in a previous render!
                    // now it's used as a new node, overwriting its elm would cause
                    // potential patch errors down the road when it's used as an insertion
                    // reference node. Instead, we clone the node on-demand before creating
                    // associated DOM element for it.
                    vnode = ownerArray[index] = cloneVNode(vnode);
                }
                vnode.isRootInsert = !nested; // for transition enter check
                if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
                    return;
                }
                var data = vnode.data;
                var children = vnode.children;
                var tag = vnode.tag;
                if (isDef(tag)) {
                    {
                        if (data && data.pre) {
                            creatingElmInVPre++;
                        }
                        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
                            warn("Unknown custom element: <" + tag + "> - did you " +
                                "register the component correctly? For recursive components, " +
                                'make sure to provide the "name" option.', vnode.context);
                        }
                    }
                    vnode.elm = vnode.ns
                        ? nodeOps.createElementNS(vnode.ns, tag)
                        : nodeOps.createElement(tag, vnode);
                    setScope(vnode);
                    /* istanbul ignore if */
                    {
                        createChildren(vnode, children, insertedVnodeQueue);
                        if (isDef(data)) {
                            invokeCreateHooks(vnode, insertedVnodeQueue);
                        }
                        insert(parentElm, vnode.elm, refElm);
                    }
                    if (data && data.pre) {
                        creatingElmInVPre--;
                    }
                }
                else if (isTrue(vnode.isComment)) {
                    vnode.elm = nodeOps.createComment(vnode.text);
                    insert(parentElm, vnode.elm, refElm);
                }
                else {
                    vnode.elm = nodeOps.createTextNode(vnode.text);
                    insert(parentElm, vnode.elm, refElm);
                }
            }
            function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
                var i = vnode.data;
                if (isDef(i)) {
                    var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
                    if (isDef(i = i.hook) && isDef(i = i.init)) {
                        i(vnode, false /* hydrating */);
                    } // after calling the init hook, if the vnode is a child component
                    // it should've created a child instance and mounted it. the child
                    // component also has set the placeholder vnode's elm.
                    // in that case we can just return the element and be done.
                    if (isDef(vnode.componentInstance)) {
                        initComponent(vnode, insertedVnodeQueue);
                        insert(parentElm, vnode.elm, refElm);
                        if (isTrue(isReactivated)) {
                            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
                        }
                        return true;
                    }
                }
            }
            function initComponent(vnode, insertedVnodeQueue) {
                if (isDef(vnode.data.pendingInsert)) {
                    insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
                    vnode.data.pendingInsert = null;
                }
                vnode.elm = vnode.componentInstance.$el;
                if (isPatchable(vnode)) {
                    invokeCreateHooks(vnode, insertedVnodeQueue);
                    setScope(vnode);
                }
                else {
                    // empty component root.
                    // skip all element-related modules except for ref (#3455)
                    registerRef(vnode); // make sure to invoke the insert hook
                    insertedVnodeQueue.push(vnode);
                }
            }
            function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
                var i; // hack for #4339: a reactivated component with inner transition
                // does not trigger because the inner node's created hooks are not called
                // again. It's not ideal to involve module-specific logic in here but
                // there doesn't seem to be a better way to do it.
                var innerNode = vnode;
                while (innerNode.componentInstance) {
                    innerNode = innerNode.componentInstance._vnode;
                    if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
                        for (i = 0; i < cbs.activate.length; ++i) {
                            cbs.activate[i](emptyNode, innerNode);
                        }
                        insertedVnodeQueue.push(innerNode);
                        break;
                    }
                } // unlike a newly created component,
                // a reactivated keep-alive component doesn't insert itself
                insert(parentElm, vnode.elm, refElm);
            }
            function insert(parent, elm, ref$$1) {
                if (isDef(parent)) {
                    if (isDef(ref$$1)) {
                        if (nodeOps.parentNode(ref$$1) === parent) {
                            nodeOps.insertBefore(parent, elm, ref$$1);
                        }
                    }
                    else {
                        nodeOps.appendChild(parent, elm);
                    }
                }
            }
            function createChildren(vnode, children, insertedVnodeQueue) {
                if (Array.isArray(children)) {
                    {
                        checkDuplicateKeys(children);
                    }
                    for (var i = 0; i < children.length; ++i) {
                        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
                    }
                }
                else if (isPrimitive(vnode.text)) {
                    nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
                }
            }
            function isPatchable(vnode) {
                while (vnode.componentInstance) {
                    vnode = vnode.componentInstance._vnode;
                }
                return isDef(vnode.tag);
            }
            function invokeCreateHooks(vnode, insertedVnodeQueue) {
                for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                    cbs.create[i$1](emptyNode, vnode);
                }
                i = vnode.data.hook; // Reuse variable
                if (isDef(i)) {
                    if (isDef(i.create)) {
                        i.create(emptyNode, vnode);
                    }
                    if (isDef(i.insert)) {
                        insertedVnodeQueue.push(vnode);
                    }
                }
            } // set scope id attribute for scoped CSS.
            // this is implemented as a special case to avoid the overhead
            // of going through the normal attribute patching process.
            function setScope(vnode) {
                var i;
                if (isDef(i = vnode.fnScopeId)) {
                    nodeOps.setStyleScope(vnode.elm, i);
                }
                else {
                    var ancestor = vnode;
                    while (ancestor) {
                        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
                            nodeOps.setStyleScope(vnode.elm, i);
                        }
                        ancestor = ancestor.parent;
                    }
                } // for slot content they should also get the scopeId from the host instance.
                if (isDef(i = activeInstance) && i !== vnode.context &&
                    i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {
                    nodeOps.setStyleScope(vnode.elm, i);
                }
            }
            function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
                for (; startIdx <= endIdx; ++startIdx) {
                    createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
                }
            }
            function invokeDestroyHook(vnode) {
                var i, j;
                var data = vnode.data;
                if (isDef(data)) {
                    if (isDef(i = data.hook) && isDef(i = i.destroy)) {
                        i(vnode);
                    }
                    for (i = 0; i < cbs.destroy.length; ++i) {
                        cbs.destroy[i](vnode);
                    }
                }
                if (isDef(i = vnode.children)) {
                    for (j = 0; j < vnode.children.length; ++j) {
                        invokeDestroyHook(vnode.children[j]);
                    }
                }
            }
            function removeVnodes(vnodes, startIdx, endIdx) {
                for (; startIdx <= endIdx; ++startIdx) {
                    var ch = vnodes[startIdx];
                    if (isDef(ch)) {
                        if (isDef(ch.tag)) {
                            removeAndInvokeRemoveHook(ch);
                            invokeDestroyHook(ch);
                        }
                        else {
                            // Text node
                            removeNode(ch.elm);
                        }
                    }
                }
            }
            function removeAndInvokeRemoveHook(vnode, rm) {
                if (isDef(rm) || isDef(vnode.data)) {
                    var i;
                    var listeners = cbs.remove.length + 1;
                    if (isDef(rm)) {
                        // we have a recursively passed down rm callback
                        // increase the listeners count
                        rm.listeners += listeners;
                    }
                    else {
                        // directly removing
                        rm = createRmCb(vnode.elm, listeners);
                    } // recursively invoke hooks on child component root node
                    if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) &&
                        isDef(i.data)) {
                        removeAndInvokeRemoveHook(i, rm);
                    }
                    for (i = 0; i < cbs.remove.length; ++i) {
                        cbs.remove[i](vnode, rm);
                    }
                    if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
                        i(vnode, rm);
                    }
                    else {
                        rm();
                    }
                }
                else {
                    removeNode(vnode.elm);
                }
            }
            function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
                var oldStartIdx = 0;
                var newStartIdx = 0;
                var oldEndIdx = oldCh.length - 1;
                var oldStartVnode = oldCh[0];
                var oldEndVnode = oldCh[oldEndIdx];
                var newEndIdx = newCh.length - 1;
                var newStartVnode = newCh[0];
                var newEndVnode = newCh[newEndIdx];
                var oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>
                // to ensure removed elements stay in correct relative positions
                // during leaving transitions
                var canMove = !removeOnly;
                {
                    checkDuplicateKeys(newCh);
                }
                while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
                    if (isUndef(oldStartVnode)) {
                        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
                    }
                    else if (isUndef(oldEndVnode)) {
                        oldEndVnode = oldCh[--oldEndIdx];
                    }
                    else if (sameVnode(oldStartVnode, newStartVnode)) {
                        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
                        oldStartVnode = oldCh[++oldStartIdx];
                        newStartVnode = newCh[++newStartIdx];
                    }
                    else if (sameVnode(oldEndVnode, newEndVnode)) {
                        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
                        oldEndVnode = oldCh[--oldEndIdx];
                        newEndVnode = newCh[--newEndIdx];
                    }
                    else if (sameVnode(oldStartVnode, newEndVnode)) {
                        // Vnode moved right
                        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
                        canMove &&
                            nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
                        oldStartVnode = oldCh[++oldStartIdx];
                        newEndVnode = newCh[--newEndIdx];
                    }
                    else if (sameVnode(oldEndVnode, newStartVnode)) {
                        // Vnode moved left
                        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
                        canMove &&
                            nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                        oldEndVnode = oldCh[--oldEndIdx];
                        newStartVnode = newCh[++newStartIdx];
                    }
                    else {
                        if (isUndef(oldKeyToIdx)) {
                            oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                        }
                        idxInOld = isDef(newStartVnode.key)
                            ? oldKeyToIdx[newStartVnode.key]
                            : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
                        if (isUndef(idxInOld)) {
                            // New element
                            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
                        }
                        else {
                            vnodeToMove = oldCh[idxInOld];
                            if (sameVnode(vnodeToMove, newStartVnode)) {
                                patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
                                oldCh[idxInOld] = undefined;
                                canMove &&
                                    nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
                            }
                            else {
                                // same key but different element. treat as new element
                                createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
                            }
                        }
                        newStartVnode = newCh[++newStartIdx];
                    }
                }
                if (oldStartIdx > oldEndIdx) {
                    refElm = isUndef(newCh[newEndIdx + 1])
                        ? null
                        : newCh[newEndIdx + 1].elm;
                    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
                }
                else if (newStartIdx > newEndIdx) {
                    removeVnodes(oldCh, oldStartIdx, oldEndIdx);
                }
            }
            function checkDuplicateKeys(children) {
                var seenKeys = {};
                for (var i = 0; i < children.length; i++) {
                    var vnode = children[i];
                    var key = vnode.key;
                    if (isDef(key)) {
                        if (seenKeys[key]) {
                            warn("Duplicate keys detected: '" + key +
                                "'. This may cause an update error.", vnode.context);
                        }
                        else {
                            seenKeys[key] = true;
                        }
                    }
                }
            }
            function findIdxInOld(node, oldCh, start, end) {
                for (var i = start; i < end; i++) {
                    var c = oldCh[i];
                    if (isDef(c) && sameVnode(node, c)) {
                        return i;
                    }
                }
            }
            function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {
                if (oldVnode === vnode) {
                    return;
                }
                if (isDef(vnode.elm) && isDef(ownerArray)) {
                    // clone reused vnode
                    vnode = ownerArray[index] = cloneVNode(vnode);
                }
                var elm = vnode.elm = oldVnode.elm;
                if (isTrue(oldVnode.isAsyncPlaceholder)) {
                    if (isDef(vnode.asyncFactory.resolved)) {
                        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
                    }
                    else {
                        vnode.isAsyncPlaceholder = true;
                    }
                    return;
                } // reuse element for static trees.
                // note we only do this if the vnode is cloned -
                // if the new node is not cloned it means the render functions have been
                // reset by the hot-reload-api and we need to do a proper re-render.
                if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) &&
                    vnode.key === oldVnode.key &&
                    (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
                    vnode.componentInstance = oldVnode.componentInstance;
                    return;
                }
                var i;
                var data = vnode.data;
                if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
                    i(oldVnode, vnode);
                }
                var oldCh = oldVnode.children;
                var ch = vnode.children;
                if (isDef(data) && isPatchable(vnode)) {
                    for (i = 0; i < cbs.update.length; ++i) {
                        cbs.update[i](oldVnode, vnode);
                    }
                    if (isDef(i = data.hook) && isDef(i = i.update)) {
                        i(oldVnode, vnode);
                    }
                }
                if (isUndef(vnode.text)) {
                    if (isDef(oldCh) && isDef(ch)) {
                        if (oldCh !== ch) {
                            updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
                        }
                    }
                    else if (isDef(ch)) {
                        {
                            checkDuplicateKeys(ch);
                        }
                        if (isDef(oldVnode.text)) {
                            nodeOps.setTextContent(elm, "");
                        }
                        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
                    }
                    else if (isDef(oldCh)) {
                        removeVnodes(oldCh, 0, oldCh.length - 1);
                    }
                    else if (isDef(oldVnode.text)) {
                        nodeOps.setTextContent(elm, "");
                    }
                }
                else if (oldVnode.text !== vnode.text) {
                    nodeOps.setTextContent(elm, vnode.text);
                }
                if (isDef(data)) {
                    if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
                        i(oldVnode, vnode);
                    }
                }
            }
            function invokeInsertHook(vnode, queue, initial) {
                // delay insert hooks for component root nodes, invoke them after the
                // element is really inserted
                if (isTrue(initial) && isDef(vnode.parent)) {
                    vnode.parent.data.pendingInsert = queue;
                }
                else {
                    for (var i = 0; i < queue.length; ++i) {
                        queue[i].data.hook.insert(queue[i]);
                    }
                }
            }
            var hydrationBailed = false; // list of modules that can skip create hook during hydration because they
            // are already rendered on the client or has no need for initialization
            // Note: style is excluded because it relies on initial clone for future
            // deep updates (#7063).
            var isRenderedModule = makeMap("attrs,class,staticClass,staticStyle,key"); // Note: this is a browser-only function so we can assume elms are DOM nodes.
            function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
                var i;
                var tag = vnode.tag;
                var data = vnode.data;
                var children = vnode.children;
                inVPre = inVPre || data && data.pre;
                vnode.elm = elm;
                if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
                    vnode.isAsyncPlaceholder = true;
                    return true;
                } // assert node match
                {
                    if (!assertNodeMatch(elm, vnode, inVPre)) {
                        return false;
                    }
                }
                if (isDef(data)) {
                    if (isDef(i = data.hook) && isDef(i = i.init)) {
                        i(vnode, true /* hydrating */);
                    }
                    if (isDef(i = vnode.componentInstance)) {
                        // child component. it should have hydrated its own tree.
                        initComponent(vnode, insertedVnodeQueue);
                        return true;
                    }
                }
                if (isDef(tag)) {
                    if (isDef(children)) {
                        // empty element, allow client to pick up and populate children
                        if (!elm.hasChildNodes()) {
                            createChildren(vnode, children, insertedVnodeQueue);
                        }
                        else {
                            // v-html and domProps: innerHTML
                            if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
                                if (i !== elm.innerHTML) {
                                    /* istanbul ignore if */
                                    if (typeof console !== "undefined" && !hydrationBailed) {
                                        hydrationBailed = true;
                                        console.warn("Parent: ", elm);
                                        console.warn("server innerHTML: ", i);
                                        console.warn("client innerHTML: ", elm.innerHTML);
                                    }
                                    return false;
                                }
                            }
                            else {
                                // iterate and compare children lists
                                var childrenMatch = true;
                                var childNode = elm.firstChild;
                                for (var i$1 = 0; i$1 < children.length; i$1++) {
                                    if (!childNode ||
                                        !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                                        childrenMatch = false;
                                        break;
                                    }
                                    childNode = childNode.nextSibling;
                                } // if childNode is not null, it means the actual childNodes list is
                                // longer than the virtual children list.
                                if (!childrenMatch || childNode) {
                                    /* istanbul ignore if */
                                    if (typeof console !== "undefined" && !hydrationBailed) {
                                        hydrationBailed = true;
                                        console.warn("Parent: ", elm);
                                        console.warn("Mismatching childNodes vs. VNodes: ", elm.childNodes, children);
                                    }
                                    return false;
                                }
                            }
                        }
                    }
                    if (isDef(data)) {
                        var fullInvoke = false;
                        for (var key in data) {
                            if (!isRenderedModule(key)) {
                                fullInvoke = true;
                                invokeCreateHooks(vnode, insertedVnodeQueue);
                                break;
                            }
                        }
                        if (!fullInvoke && data["class"]) {
                            // ensure collecting deps for deep class bindings for future updates
                            traverse(data["class"]);
                        }
                    }
                }
                else if (elm.data !== vnode.text) {
                    elm.data = vnode.text;
                }
                return true;
            }
            function assertNodeMatch(node, vnode, inVPre) {
                if (isDef(vnode.tag)) {
                    return vnode.tag.indexOf("vue-component") === 0 ||
                        !isUnknownElement$$1(vnode, inVPre) &&
                            vnode.tag.toLowerCase() ===
                                (node.tagName && node.tagName.toLowerCase());
                }
                else {
                    return node.nodeType === (vnode.isComment ? 8 : 3);
                }
            }
            return function patch(oldVnode, vnode, hydrating, removeOnly) {
                if (isUndef(vnode)) {
                    if (isDef(oldVnode)) {
                        invokeDestroyHook(oldVnode);
                    }
                    return;
                }
                var isInitialPatch = false;
                var insertedVnodeQueue = [];
                if (isUndef(oldVnode)) {
                    // empty mount (likely as component), create new root element
                    isInitialPatch = true;
                    createElm(vnode, insertedVnodeQueue);
                }
                else {
                    var isRealElement = isDef(oldVnode.nodeType);
                    if (!isRealElement && sameVnode(oldVnode, vnode)) {
                        // patch existing root node
                        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
                    }
                    else {
                        if (isRealElement) {
                            // mounting to a real element
                            // check if this is server-rendered content and if we can perform
                            // a successful hydration.
                            if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
                                oldVnode.removeAttribute(SSR_ATTR);
                                hydrating = true;
                            }
                            if (isTrue(hydrating)) {
                                if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
                                    invokeInsertHook(vnode, insertedVnodeQueue, true);
                                    return oldVnode;
                                }
                                else {
                                    warn("The client-side rendered virtual DOM tree is not matching " +
                                        "server-rendered content. This is likely caused by incorrect " +
                                        "HTML markup, for example nesting block-level elements inside " +
                                        "<p>, or missing <tbody>. Bailing hydration and performing " +
                                        "full client-side render.");
                                }
                            } // either not server-rendered, or hydration failed.
                            // create an empty node and replace it
                            oldVnode = emptyNodeAt(oldVnode);
                        } // replacing existing element
                        var oldElm = oldVnode.elm;
                        var parentElm = nodeOps.parentNode(oldElm); // create new node
                        createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a
                        // leaving transition. Only happens when combining transition +
                        // keep-alive + HOCs. (#4590)
                        oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively
                        if (isDef(vnode.parent)) {
                            var ancestor = vnode.parent;
                            var patchable = isPatchable(vnode);
                            while (ancestor) {
                                for (var i = 0; i < cbs.destroy.length; ++i) {
                                    cbs.destroy[i](ancestor);
                                }
                                ancestor.elm = vnode.elm;
                                if (patchable) {
                                    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                                        cbs.create[i$1](emptyNode, ancestor);
                                    } // #6513
                                    // invoke insert hooks that may have been merged by create hooks.
                                    // e.g. for directives that uses the "inserted" hook.
                                    var insert = ancestor.data.hook.insert;
                                    if (insert.merged) {
                                        // start at index 1 to avoid re-invoking component mounted hook
                                        for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                                            insert.fns[i$2]();
                                        }
                                    }
                                }
                                else {
                                    registerRef(ancestor);
                                }
                                ancestor = ancestor.parent;
                            }
                        } // destroy old node
                        if (isDef(parentElm)) {
                            removeVnodes([oldVnode], 0, 0);
                        }
                        else if (isDef(oldVnode.tag)) {
                            invokeDestroyHook(oldVnode);
                        }
                    }
                }
                invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
                return vnode.elm;
            };
        }
        /*  */
        var directives = {
            create: updateDirectives,
            update: updateDirectives,
            destroy: function unbindDirectives(vnode) {
                updateDirectives(vnode, emptyNode);
            },
        };
        function updateDirectives(oldVnode, vnode) {
            if (oldVnode.data.directives || vnode.data.directives) {
                _update(oldVnode, vnode);
            }
        }
        function _update(oldVnode, vnode) {
            var isCreate = oldVnode === emptyNode;
            var isDestroy = vnode === emptyNode;
            var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
            var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
            var dirsWithInsert = [];
            var dirsWithPostpatch = [];
            var key, oldDir, dir;
            for (key in newDirs) {
                oldDir = oldDirs[key];
                dir = newDirs[key];
                if (!oldDir) {
                    // new directive, bind
                    callHook$1(dir, "bind", vnode, oldVnode);
                    if (dir.def && dir.def.inserted) {
                        dirsWithInsert.push(dir);
                    }
                }
                else {
                    // existing directive, update
                    dir.oldValue = oldDir.value;
                    dir.oldArg = oldDir.arg;
                    callHook$1(dir, "update", vnode, oldVnode);
                    if (dir.def && dir.def.componentUpdated) {
                        dirsWithPostpatch.push(dir);
                    }
                }
            }
            if (dirsWithInsert.length) {
                var callInsert = function () {
                    for (var i = 0; i < dirsWithInsert.length; i++) {
                        callHook$1(dirsWithInsert[i], "inserted", vnode, oldVnode);
                    }
                };
                if (isCreate) {
                    mergeVNodeHook(vnode, "insert", callInsert);
                }
                else {
                    callInsert();
                }
            }
            if (dirsWithPostpatch.length) {
                mergeVNodeHook(vnode, "postpatch", function () {
                    for (var i = 0; i < dirsWithPostpatch.length; i++) {
                        callHook$1(dirsWithPostpatch[i], "componentUpdated", vnode, oldVnode);
                    }
                });
            }
            if (!isCreate) {
                for (key in oldDirs) {
                    if (!newDirs[key]) {
                        // no longer present, unbind
                        callHook$1(oldDirs[key], "unbind", oldVnode, oldVnode, isDestroy);
                    }
                }
            }
        }
        var emptyModifiers = Object.create(null);
        function normalizeDirectives$1(dirs, vm) {
            var res = Object.create(null);
            if (!dirs) {
                // $flow-disable-line
                return res;
            }
            var i, dir;
            for (i = 0; i < dirs.length; i++) {
                dir = dirs[i];
                if (!dir.modifiers) {
                    // $flow-disable-line
                    dir.modifiers = emptyModifiers;
                }
                res[getRawDirName(dir)] = dir;
                dir.def = resolveAsset(vm.$options, "directives", dir.name, true);
            } // $flow-disable-line
            return res;
        }
        function getRawDirName(dir) {
            return dir.rawName ||
                dir.name + "." + Object.keys(dir.modifiers || {}).join(".");
        }
        function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
            var fn = dir.def && dir.def[hook];
            if (fn) {
                try {
                    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
                }
                catch (e) {
                    handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
                }
            }
        }
        var baseModules = [ref, directives];
        /*  */
        function updateAttrs(oldVnode, vnode) {
            var opts = vnode.componentOptions;
            if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
                return;
            }
            if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
                return;
            }
            var key, cur, old;
            var elm = vnode.elm;
            var oldAttrs = oldVnode.data.attrs || {};
            var attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it
            if (isDef(attrs.__ob__)) {
                attrs = vnode.data.attrs = extend({}, attrs);
            }
            for (key in attrs) {
                cur = attrs[key];
                old = oldAttrs[key];
                if (old !== cur) {
                    setAttr(elm, key, cur);
                }
            } // #4391: in IE9, setting type can reset value for input[type=radio]
            // #6666: IE/Edge forces progress value down to 1 before setting a max
            /* istanbul ignore if */
            if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
                setAttr(elm, "value", attrs.value);
            }
            for (key in oldAttrs) {
                if (isUndef(attrs[key])) {
                    if (isXlink(key)) {
                        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
                    }
                    else if (!isEnumeratedAttr(key)) {
                        elm.removeAttribute(key);
                    }
                }
            }
        }
        function setAttr(el, key, value) {
            if (el.tagName.indexOf("-") > -1) {
                baseSetAttr(el, key, value);
            }
            else if (isBooleanAttr(key)) {
                // set attribute for blank value
                // e.g. <option disabled>Select one</option>
                if (isFalsyAttrValue(value)) {
                    el.removeAttribute(key);
                }
                else {
                    // technically allowfullscreen is a boolean attribute for <iframe>,
                    // but Flash expects a value of "true" when used on <embed> tag
                    value = key === "allowfullscreen" && el.tagName === "EMBED"
                        ? "true"
                        : key;
                    el.setAttribute(key, value);
                }
            }
            else if (isEnumeratedAttr(key)) {
                el.setAttribute(key, convertEnumeratedValue(key, value));
            }
            else if (isXlink(key)) {
                if (isFalsyAttrValue(value)) {
                    el.removeAttributeNS(xlinkNS, getXlinkProp(key));
                }
                else {
                    el.setAttributeNS(xlinkNS, key, value);
                }
            }
            else {
                baseSetAttr(el, key, value);
            }
        }
        function baseSetAttr(el, key, value) {
            if (isFalsyAttrValue(value)) {
                el.removeAttribute(key);
            }
            else {
                // #7138: IE10 & 11 fires input event when setting placeholder on
                // <textarea>... block the first input event and remove the blocker
                // immediately.
                /* istanbul ignore if */
                if (isIE && !isIE9 && el.tagName === "TEXTAREA" && key === "placeholder" &&
                    value !== "" && !el.__ieph) {
                    var blocker = function (e) {
                        e.stopImmediatePropagation();
                        el.removeEventListener("input", blocker);
                    };
                    el.addEventListener("input", blocker); // $flow-disable-line
                    el.__ieph = true;
                    /* IE placeholder patched */
                }
                el.setAttribute(key, value);
            }
        }
        var attrs = {
            create: updateAttrs,
            update: updateAttrs,
        };
        /*  */
        function updateClass(oldVnode, vnode) {
            var el = vnode.elm;
            var data = vnode.data;
            var oldData = oldVnode.data;
            if (isUndef(data.staticClass) && isUndef(data.class) &&
                (isUndef(oldData) ||
                    isUndef(oldData.staticClass) && isUndef(oldData.class))) {
                return;
            }
            var cls = genClassForVnode(vnode); // handle transition classes
            var transitionClass = el._transitionClasses;
            if (isDef(transitionClass)) {
                cls = concat(cls, stringifyClass(transitionClass));
            } // set the class
            if (cls !== el._prevClass) {
                el.setAttribute("class", cls);
                el._prevClass = cls;
            }
        }
        var klass = {
            create: updateClass,
            update: updateClass,
        };
        /*  */
        /*  */
        /*  */
        /*  */
        // in some cases, the event used has to be determined at runtime
        // so we used some reserved tokens during compile.
        var RANGE_TOKEN = "__r";
        var CHECKBOX_RADIO_TOKEN = "__c";
        /*  */
        // normalize v-model event tokens that can only be determined at runtime.
        // it's important to place the event as the first in the array because
        // the whole point is ensuring the v-model callback gets called before
        // user-attached handlers.
        function normalizeEvents(on) {
            /* istanbul ignore if */
            if (isDef(on[RANGE_TOKEN])) {
                // IE input[type=range] only supports `change` event
                var event = isIE ? "change" : "input";
                on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
                delete on[RANGE_TOKEN];
            } // This was originally intended to fix #4521 but no longer necessary
            // after 2.5. Keeping it for backwards compat with generated code from < 2.4
            /* istanbul ignore if */
            if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
                on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
                delete on[CHECKBOX_RADIO_TOKEN];
            }
        }
        var target$1;
        function createOnceHandler$1(event, handler, capture) {
            var _target = target$1; // save current target element in closure
            return function onceHandler() {
                var res = handler.apply(null, arguments);
                if (res !== null) {
                    remove$2(event, onceHandler, capture, _target);
                }
            };
        } // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
        // implementation and does not fire microtasks in between event propagation, so
        // safe to exclude.
        var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);
        function add$1(name, handler, capture, passive) {
            // async edge case #6566: inner click event triggers patch, event handler
            // attached to outer element during patch, and triggered again. This
            // happens because browsers fire microtask ticks between event propagation.
            // the solution is simple: we save the timestamp when a handler is attached,
            // and the handler would only fire if the event passed to it was fired
            // AFTER it was attached.
            if (useMicrotaskFix) {
                var attachedTimestamp = currentFlushTimestamp;
                var original = handler;
                handler = original._wrapper = function (e) {
                    if (
                    // no bubbling, should always fire.
                    // this is just a safety net in case event.timeStamp is unreliable in
                    // certain weird environments...
                    e.target === e.currentTarget || // event is fired after handler attachment
                        e.timeStamp >= attachedTimestamp || // bail for environments that have buggy event.timeStamp implementations
                        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
                        // #9681 QtWebEngine event.timeStamp is negative value
                        e.timeStamp <= 0 || // #9448 bail if event is fired in another document in a multi-page
                        // electron/nw.js app, since event.timeStamp will be using a different
                        // starting reference
                        e.target.ownerDocument !== document) {
                        return original.apply(this, arguments);
                    }
                };
            }
            target$1.addEventListener(name, handler, supportsPassive
                ? {
                    capture: capture,
                    passive: passive,
                }
                : capture);
        }
        function remove$2(name, handler, capture, _target) {
            (_target || target$1).removeEventListener(name, handler._wrapper || handler, capture);
        }
        function updateDOMListeners(oldVnode, vnode) {
            if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
                return;
            }
            var on = vnode.data.on || {};
            var oldOn = oldVnode.data.on || {};
            target$1 = vnode.elm;
            normalizeEvents(on);
            updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
            target$1 = undefined;
        }
        var events = {
            create: updateDOMListeners,
            update: updateDOMListeners,
        };
        /*  */
        var svgContainer;
        function updateDOMProps(oldVnode, vnode) {
            if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
                return;
            }
            var key, cur;
            var elm = vnode.elm;
            var oldProps = oldVnode.data.domProps || {};
            var props = vnode.data.domProps || {}; // clone observed objects, as the user probably wants to mutate it
            if (isDef(props.__ob__)) {
                props = vnode.data.domProps = extend({}, props);
            }
            for (key in oldProps) {
                if (!(key in props)) {
                    elm[key] = "";
                }
            }
            for (key in props) {
                cur = props[key]; // ignore children if the node has textContent or innerHTML,
                // as these will throw away existing DOM nodes and cause removal errors
                // on subsequent patches (#3360)
                if (key === "textContent" || key === "innerHTML") {
                    if (vnode.children) {
                        vnode.children.length = 0;
                    }
                    if (cur === oldProps[key]) {
                        continue;
                    } // #6601 work around Chrome version <= 55 bug where single textNode
                    // replaced by innerHTML/textContent retains its parentNode property
                    if (elm.childNodes.length === 1) {
                        elm.removeChild(elm.childNodes[0]);
                    }
                }
                if (key === "value" && elm.tagName !== "PROGRESS") {
                    // store value as _value as well since
                    // non-string values will be stringified
                    elm._value = cur; // avoid resetting cursor position when value is the same
                    var strCur = isUndef(cur) ? "" : String(cur);
                    if (shouldUpdateValue(elm, strCur)) {
                        elm.value = strCur;
                    }
                }
                else if (key === "innerHTML" && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
                    // IE doesn't support innerHTML for SVG elements
                    svgContainer = svgContainer || document.createElement("div");
                    svgContainer.innerHTML = "<svg>" + cur + "</svg>";
                    var svg = svgContainer.firstChild;
                    while (elm.firstChild) {
                        elm.removeChild(elm.firstChild);
                    }
                    while (svg.firstChild) {
                        elm.appendChild(svg.firstChild);
                    }
                }
                else if (
                // skip the update if old and new VDOM state is the same.
                // `value` is handled separately because the DOM value may be temporarily
                // out of sync with VDOM state due to focus, composition and modifiers.
                // This  #4521 by skipping the unnecesarry `checked` update.
                cur !== oldProps[key]) {
                    // some property updates can throw
                    // e.g. `value` on <progress> w/ non-finite value
                    try {
                        elm[key] = cur;
                    }
                    catch (e) { }
                }
            }
        } // check platforms/web/util/attrs.js acceptValue
        function shouldUpdateValue(elm, checkVal) {
            return !elm.composing &&
                (elm.tagName === "OPTION" || isNotInFocusAndDirty(elm, checkVal) ||
                    isDirtyWithModifiers(elm, checkVal));
        }
        function isNotInFocusAndDirty(elm, checkVal) {
            // return true when textbox (.number and .trim) loses focus and its value is
            // not equal to the updated value
            var notInFocus = true; // #6157
            // work around IE bug when accessing document.activeElement in an iframe
            try {
                notInFocus = document.activeElement !== elm;
            }
            catch (e) { }
            return notInFocus && elm.value !== checkVal;
        }
        function isDirtyWithModifiers(elm, newVal) {
            var value = elm.value;
            var modifiers = elm._vModifiers; // injected by v-model runtime
            if (isDef(modifiers)) {
                if (modifiers.number) {
                    return toNumber(value) !== toNumber(newVal);
                }
                if (modifiers.trim) {
                    return value.trim() !== newVal.trim();
                }
            }
            return value !== newVal;
        }
        var domProps = {
            create: updateDOMProps,
            update: updateDOMProps,
        };
        /*  */
        var parseStyleText = cached(function (cssText) {
            var res = {};
            var listDelimiter = /;(?![^(]*\))/g;
            var propertyDelimiter = /:(.+)/;
            cssText.split(listDelimiter).forEach(function (item) {
                if (item) {
                    var tmp = item.split(propertyDelimiter);
                    tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
                }
            });
            return res;
        }); // merge static and dynamic style data on the same vnode
        function normalizeStyleData(data) {
            var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation
            // and is always a fresh object, so it's safe to merge into it
            return data.staticStyle ? extend(data.staticStyle, style) : style;
        } // normalize possible array / string values into Object
        function normalizeStyleBinding(bindingStyle) {
            if (Array.isArray(bindingStyle)) {
                return toObject(bindingStyle);
            }
            if (typeof bindingStyle === "string") {
                return parseStyleText(bindingStyle);
            }
            return bindingStyle;
        }
        /**
         * parent component style should be after child's
         * so that parent component's style could override it
         */
        function getStyle(vnode, checkChild) {
            var res = {};
            var styleData;
            if (checkChild) {
                var childNode = vnode;
                while (childNode.componentInstance) {
                    childNode = childNode.componentInstance._vnode;
                    if (childNode && childNode.data &&
                        (styleData = normalizeStyleData(childNode.data))) {
                        extend(res, styleData);
                    }
                }
            }
            if (styleData = normalizeStyleData(vnode.data)) {
                extend(res, styleData);
            }
            var parentNode = vnode;
            while (parentNode = parentNode.parent) {
                if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
                    extend(res, styleData);
                }
            }
            return res;
        }
        /*  */
        var cssVarRE = /^--/;
        var importantRE = /\s*!important$/;
        var setProp = function (el, name, val) {
            /* istanbul ignore if */
            if (cssVarRE.test(name)) {
                el.style.setProperty(name, val);
            }
            else if (importantRE.test(val)) {
                el.style.setProperty(hyphenate(name), val.replace(importantRE, ""), "important");
            }
            else {
                var normalizedName = normalize(name);
                if (Array.isArray(val)) {
                    // Support values array created by autoprefixer, e.g.
                    // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
                    // Set them one by one, and the browser will only set those it can recognize
                    for (var i = 0, len = val.length; i < len; i++) {
                        el.style[normalizedName] = val[i];
                    }
                }
                else {
                    el.style[normalizedName] = val;
                }
            }
        };
        var vendorNames = ["Webkit", "Moz", "ms"];
        var emptyStyle;
        var normalize = cached(function (prop) {
            emptyStyle = emptyStyle || document.createElement("div").style;
            prop = camelize(prop);
            if (prop !== "filter" && prop in emptyStyle) {
                return prop;
            }
            var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
            for (var i = 0; i < vendorNames.length; i++) {
                var name = vendorNames[i] + capName;
                if (name in emptyStyle) {
                    return name;
                }
            }
        });
        function updateStyle(oldVnode, vnode) {
            var data = vnode.data;
            var oldData = oldVnode.data;
            if (isUndef(data.staticStyle) && isUndef(data.style) &&
                isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
                return;
            }
            var cur, name;
            var el = vnode.elm;
            var oldStaticStyle = oldData.staticStyle;
            var oldStyleBinding = oldData.normalizedStyle || oldData.style || {}; // if static style exists, stylebinding already merged into it when doing normalizeStyleData
            var oldStyle = oldStaticStyle || oldStyleBinding;
            var style = normalizeStyleBinding(vnode.data.style) || {}; // store normalized style under a different key for next diff
            // make sure to clone it if it's reactive, since the user likely wants
            // to mutate it.
            vnode.data.normalizedStyle = isDef(style.__ob__)
                ? extend({}, style)
                : style;
            var newStyle = getStyle(vnode, true);
            for (name in oldStyle) {
                if (isUndef(newStyle[name])) {
                    setProp(el, name, "");
                }
            }
            for (name in newStyle) {
                cur = newStyle[name];
                if (cur !== oldStyle[name]) {
                    // ie9 setting to null has no effect, must use empty string
                    setProp(el, name, cur == null ? "" : cur);
                }
            }
        }
        var style = {
            create: updateStyle,
            update: updateStyle,
        };
        /*  */
        var whitespaceRE = /\s+/;
        /**
         * Add class with compatibility for SVG since classList is not supported on
         * SVG elements in IE
         */
        function addClass(el, cls) {
            /* istanbul ignore if */
            if (!cls || !(cls = cls.trim())) {
                return;
            }
            /* istanbul ignore else */
            if (el.classList) {
                if (cls.indexOf(" ") > -1) {
                    cls.split(whitespaceRE).forEach(function (c) {
                        return el.classList.add(c);
                    });
                }
                else {
                    el.classList.add(cls);
                }
            }
            else {
                var cur = " " + (el.getAttribute("class") || "") + " ";
                if (cur.indexOf(" " + cls + " ") < 0) {
                    el.setAttribute("class", (cur + cls).trim());
                }
            }
        }
        /**
         * Remove class with compatibility for SVG since classList is not supported on
         * SVG elements in IE
         */
        function removeClass(el, cls) {
            /* istanbul ignore if */
            if (!cls || !(cls = cls.trim())) {
                return;
            }
            /* istanbul ignore else */
            if (el.classList) {
                if (cls.indexOf(" ") > -1) {
                    cls.split(whitespaceRE).forEach(function (c) {
                        return el.classList.remove(c);
                    });
                }
                else {
                    el.classList.remove(cls);
                }
                if (!el.classList.length) {
                    el.removeAttribute("class");
                }
            }
            else {
                var cur = " " + (el.getAttribute("class") || "") + " ";
                var tar = " " + cls + " ";
                while (cur.indexOf(tar) >= 0) {
                    cur = cur.replace(tar, " ");
                }
                cur = cur.trim();
                if (cur) {
                    el.setAttribute("class", cur);
                }
                else {
                    el.removeAttribute("class");
                }
            }
        }
        /*  */
        function resolveTransition(def$$1) {
            if (!def$$1) {
                return;
            }
            /* istanbul ignore else */
            if (typeof def$$1 === "object") {
                var res = {};
                if (def$$1.css !== false) {
                    extend(res, autoCssTransition(def$$1.name || "v"));
                }
                extend(res, def$$1);
                return res;
            }
            else if (typeof def$$1 === "string") {
                return autoCssTransition(def$$1);
            }
        }
        var autoCssTransition = cached(function (name) {
            return {
                enterClass: name + "-enter",
                enterToClass: name + "-enter-to",
                enterActiveClass: name + "-enter-active",
                leaveClass: name + "-leave",
                leaveToClass: name + "-leave-to",
                leaveActiveClass: name + "-leave-active",
            };
        });
        var hasTransition = inBrowser && !isIE9;
        var TRANSITION = "transition";
        var ANIMATION = "animation"; // Transition property/event sniffing
        var transitionProp = "transition";
        var transitionEndEvent = "transitionend";
        var animationProp = "animation";
        var animationEndEvent = "animationend";
        if (hasTransition) {
            /* istanbul ignore if */
            if (window.ontransitionend === undefined &&
                window.onwebkittransitionend !== undefined) {
                transitionProp = "WebkitTransition";
                transitionEndEvent = "webkitTransitionEnd";
            }
            if (window.onanimationend === undefined &&
                window.onwebkitanimationend !== undefined) {
                animationProp = "WebkitAnimation";
                animationEndEvent = "webkitAnimationEnd";
            }
        } // binding to window is necessary to make hot reload work in IE in strict mode
        var raf = inBrowser
            ? window.requestAnimationFrame
                ? window.requestAnimationFrame.bind(window)
                : setTimeout
            : /* istanbul ignore next */
                function (fn) {
                    return fn();
                };
        function nextFrame(fn) {
            raf(function () {
                raf(fn);
            });
        }
        function addTransitionClass(el, cls) {
            var transitionClasses = el._transitionClasses ||
                (el._transitionClasses = []);
            if (transitionClasses.indexOf(cls) < 0) {
                transitionClasses.push(cls);
                addClass(el, cls);
            }
        }
        function removeTransitionClass(el, cls) {
            if (el._transitionClasses) {
                remove(el._transitionClasses, cls);
            }
            removeClass(el, cls);
        }
        function whenTransitionEnds(el, expectedType, cb) {
            var ref = getTransitionInfo(el, expectedType);
            var type = ref.type;
            var timeout = ref.timeout;
            var propCount = ref.propCount;
            if (!type) {
                return cb();
            }
            var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
            var ended = 0;
            var end = function () {
                el.removeEventListener(event, onEnd);
                cb();
            };
            var onEnd = function (e) {
                if (e.target === el) {
                    if (++ended >= propCount) {
                        end();
                    }
                }
            };
            setTimeout(function () {
                if (ended < propCount) {
                    end();
                }
            }, timeout + 1);
            el.addEventListener(event, onEnd);
        }
        var transformRE = /\b(transform|all)(,|$)/;
        function getTransitionInfo(el, expectedType) {
            var styles = window.getComputedStyle(el); // JSDOM may return undefined for transition properties
            var transitionDelays = (styles[transitionProp + "Delay"] || "").split(", ");
            var transitionDurations = (styles[transitionProp + "Duration"] || "").split(", ");
            var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
            var animationDelays = (styles[animationProp + "Delay"] || "").split(", ");
            var animationDurations = (styles[animationProp + "Duration"] || "").split(", ");
            var animationTimeout = getTimeout(animationDelays, animationDurations);
            var type;
            var timeout = 0;
            var propCount = 0;
            /* istanbul ignore if */
            if (expectedType === TRANSITION) {
                if (transitionTimeout > 0) {
                    type = TRANSITION;
                    timeout = transitionTimeout;
                    propCount = transitionDurations.length;
                }
            }
            else if (expectedType === ANIMATION) {
                if (animationTimeout > 0) {
                    type = ANIMATION;
                    timeout = animationTimeout;
                    propCount = animationDurations.length;
                }
            }
            else {
                timeout = Math.max(transitionTimeout, animationTimeout);
                type = timeout > 0
                    ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION
                    : null;
                propCount = type
                    ? type === TRANSITION
                        ? transitionDurations.length
                        : animationDurations.length
                    : 0;
            }
            var hasTransform = type === TRANSITION &&
                transformRE.test(styles[transitionProp + "Property"]);
            return {
                type: type,
                timeout: timeout,
                propCount: propCount,
                hasTransform: hasTransform,
            };
        }
        function getTimeout(delays, durations) {
            /* istanbul ignore next */
            while (delays.length < durations.length) {
                delays = delays.concat(delays);
            }
            return Math.max.apply(null, durations.map(function (d, i) {
                return toMs(d) + toMs(delays[i]);
            }));
        } // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
        // in a locale-dependent way, using a comma instead of a dot.
        // If comma is not replaced with a dot, the input will be rounded down (i.e. acting
        // as a floor function) causing unexpected behaviors
        function toMs(s) {
            return Number(s.slice(0, -1).replace(",", ".")) * 1000;
        }
        /*  */
        function enter(vnode, toggleDisplay) {
            var el = vnode.elm; // call leave callback now
            if (isDef(el._leaveCb)) {
                el._leaveCb.cancelled = true;
                el._leaveCb();
            }
            var data = resolveTransition(vnode.data.transition);
            if (isUndef(data)) {
                return;
            }
            /* istanbul ignore if */
            if (isDef(el._enterCb) || el.nodeType !== 1) {
                return;
            }
            var css = data.css;
            var type = data.type;
            var enterClass = data.enterClass;
            var enterToClass = data.enterToClass;
            var enterActiveClass = data.enterActiveClass;
            var appearClass = data.appearClass;
            var appearToClass = data.appearToClass;
            var appearActiveClass = data.appearActiveClass;
            var beforeEnter = data.beforeEnter;
            var enter = data.enter;
            var afterEnter = data.afterEnter;
            var enterCancelled = data.enterCancelled;
            var beforeAppear = data.beforeAppear;
            var appear = data.appear;
            var afterAppear = data.afterAppear;
            var appearCancelled = data.appearCancelled;
            var duration = data.duration; // activeInstance will always be the <transition> component managing this
            // transition. One edge case to check is when the <transition> is placed
            // as the root node of a child component. In that case we need to check
            // <transition>'s parent for appear check.
            var context = activeInstance;
            var transitionNode = activeInstance.$vnode;
            while (transitionNode && transitionNode.parent) {
                context = transitionNode.context;
                transitionNode = transitionNode.parent;
            }
            var isAppear = !context._isMounted || !vnode.isRootInsert;
            if (isAppear && !appear && appear !== "") {
                return;
            }
            var startClass = isAppear && appearClass ? appearClass : enterClass;
            var activeClass = isAppear && appearActiveClass
                ? appearActiveClass
                : enterActiveClass;
            var toClass = isAppear && appearToClass ? appearToClass : enterToClass;
            var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
            var enterHook = isAppear
                ? typeof appear === "function" ? appear : enter
                : enter;
            var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
            var enterCancelledHook = isAppear
                ? appearCancelled || enterCancelled
                : enterCancelled;
            var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);
            if (explicitEnterDuration != null) {
                checkDuration(explicitEnterDuration, "enter", vnode);
            }
            var expectsCSS = css !== false && !isIE9;
            var userWantsControl = getHookArgumentsLength(enterHook);
            var cb = el._enterCb = once(function () {
                if (expectsCSS) {
                    removeTransitionClass(el, toClass);
                    removeTransitionClass(el, activeClass);
                }
                if (cb.cancelled) {
                    if (expectsCSS) {
                        removeTransitionClass(el, startClass);
                    }
                    enterCancelledHook && enterCancelledHook(el);
                }
                else {
                    afterEnterHook && afterEnterHook(el);
                }
                el._enterCb = null;
            });
            if (!vnode.data.show) {
                // remove pending leave element on enter by injecting an insert hook
                mergeVNodeHook(vnode, "insert", function () {
                    var parent = el.parentNode;
                    var pendingNode = parent && parent._pending &&
                        parent._pending[vnode.key];
                    if (pendingNode && pendingNode.tag === vnode.tag &&
                        pendingNode.elm._leaveCb) {
                        pendingNode.elm._leaveCb();
                    }
                    enterHook && enterHook(el, cb);
                });
            } // start enter transition
            beforeEnterHook && beforeEnterHook(el);
            if (expectsCSS) {
                addTransitionClass(el, startClass);
                addTransitionClass(el, activeClass);
                nextFrame(function () {
                    removeTransitionClass(el, startClass);
                    if (!cb.cancelled) {
                        addTransitionClass(el, toClass);
                        if (!userWantsControl) {
                            if (isValidDuration(explicitEnterDuration)) {
                                setTimeout(cb, explicitEnterDuration);
                            }
                            else {
                                whenTransitionEnds(el, type, cb);
                            }
                        }
                    }
                });
            }
            if (vnode.data.show) {
                toggleDisplay && toggleDisplay();
                enterHook && enterHook(el, cb);
            }
            if (!expectsCSS && !userWantsControl) {
                cb();
            }
        }
        function leave(vnode, rm) {
            var el = vnode.elm; // call enter callback now
            if (isDef(el._enterCb)) {
                el._enterCb.cancelled = true;
                el._enterCb();
            }
            var data = resolveTransition(vnode.data.transition);
            if (isUndef(data) || el.nodeType !== 1) {
                return rm();
            }
            /* istanbul ignore if */
            if (isDef(el._leaveCb)) {
                return;
            }
            var css = data.css;
            var type = data.type;
            var leaveClass = data.leaveClass;
            var leaveToClass = data.leaveToClass;
            var leaveActiveClass = data.leaveActiveClass;
            var beforeLeave = data.beforeLeave;
            var leave = data.leave;
            var afterLeave = data.afterLeave;
            var leaveCancelled = data.leaveCancelled;
            var delayLeave = data.delayLeave;
            var duration = data.duration;
            var expectsCSS = css !== false && !isIE9;
            var userWantsControl = getHookArgumentsLength(leave);
            var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);
            if (isDef(explicitLeaveDuration)) {
                checkDuration(explicitLeaveDuration, "leave", vnode);
            }
            var cb = el._leaveCb = once(function () {
                if (el.parentNode && el.parentNode._pending) {
                    el.parentNode._pending[vnode.key] = null;
                }
                if (expectsCSS) {
                    removeTransitionClass(el, leaveToClass);
                    removeTransitionClass(el, leaveActiveClass);
                }
                if (cb.cancelled) {
                    if (expectsCSS) {
                        removeTransitionClass(el, leaveClass);
                    }
                    leaveCancelled && leaveCancelled(el);
                }
                else {
                    rm();
                    afterLeave && afterLeave(el);
                }
                el._leaveCb = null;
            });
            if (delayLeave) {
                delayLeave(performLeave);
            }
            else {
                performLeave();
            }
            function performLeave() {
                // the delayed leave may have already been cancelled
                if (cb.cancelled) {
                    return;
                } // record leaving element
                if (!vnode.data.show && el.parentNode) {
                    (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] =
                        vnode;
                }
                beforeLeave && beforeLeave(el);
                if (expectsCSS) {
                    addTransitionClass(el, leaveClass);
                    addTransitionClass(el, leaveActiveClass);
                    nextFrame(function () {
                        removeTransitionClass(el, leaveClass);
                        if (!cb.cancelled) {
                            addTransitionClass(el, leaveToClass);
                            if (!userWantsControl) {
                                if (isValidDuration(explicitLeaveDuration)) {
                                    setTimeout(cb, explicitLeaveDuration);
                                }
                                else {
                                    whenTransitionEnds(el, type, cb);
                                }
                            }
                        }
                    });
                }
                leave && leave(el, cb);
                if (!expectsCSS && !userWantsControl) {
                    cb();
                }
            }
        } // only used in dev mode
        function checkDuration(val, name, vnode) {
            if (typeof val !== "number") {
                warn("<transition> explicit " + name + " duration is not a valid number - " +
                    "got " + JSON.stringify(val) + ".", vnode.context);
            }
            else if (isNaN(val)) {
                warn("<transition> explicit " + name + " duration is NaN - " +
                    "the duration expression might be incorrect.", vnode.context);
            }
        }
        function isValidDuration(val) {
            return typeof val === "number" && !isNaN(val);
        }
        /**
         * Normalize a transition hook's argument length. The hook may be:
         * - a merged hook (invoker) with the original in .fns
         * - a wrapped component method (check ._length)
         * - a plain function (.length)
         */
        function getHookArgumentsLength(fn) {
            if (isUndef(fn)) {
                return false;
            }
            var invokerFns = fn.fns;
            if (isDef(invokerFns)) {
                // invoker
                return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
            }
            else {
                return (fn._length || fn.length) > 1;
            }
        }
        function _enter(_, vnode) {
            if (vnode.data.show !== true) {
                enter(vnode);
            }
        }
        var transition = inBrowser
            ? {
                create: _enter,
                activate: _enter,
                remove: function remove$$1(vnode, rm) {
                    /* istanbul ignore else */
                    if (vnode.data.show !== true) {
                        leave(vnode, rm);
                    }
                    else {
                        rm();
                    }
                },
            }
            : {};
        var platformModules = [attrs, klass, events, domProps, style, transition];
        /*  */
        // the directive module should be applied last, after all
        // built-in modules have been applied.
        var modules = platformModules.concat(baseModules);
        var patch = createPatchFunction({
            nodeOps: nodeOps,
            modules: modules,
        });
        /**
         * Not type checking this file because flow doesn't like attaching
         * properties to Elements.
         */
        /* istanbul ignore if */
        if (isIE9) {
            // http://www.matts411.com/post/internet-explorer-9-oninput/
            document.addEventListener("selectionchange", function () {
                var el = document.activeElement;
                if (el && el.vmodel) {
                    trigger(el, "input");
                }
            });
        }
        var directive = {
            inserted: function inserted(el, binding, vnode, oldVnode) {
                if (vnode.tag === "select") {
                    // #6903
                    if (oldVnode.elm && !oldVnode.elm._vOptions) {
                        mergeVNodeHook(vnode, "postpatch", function () {
                            directive.componentUpdated(el, binding, vnode);
                        });
                    }
                    else {
                        setSelected(el, binding, vnode.context);
                    }
                    el._vOptions = [].map.call(el.options, getValue);
                }
                else if (vnode.tag === "textarea" || isTextInputType(el.type)) {
                    el._vModifiers = binding.modifiers;
                    if (!binding.modifiers.lazy) {
                        el.addEventListener("compositionstart", onCompositionStart);
                        el.addEventListener("compositionend", onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when
                        // switching focus before confirming composition choice
                        // this also fixes the issue where some browsers e.g. iOS Chrome
                        // fires "change" instead of "input" on autocomplete.
                        el.addEventListener("change", onCompositionEnd);
                        /* istanbul ignore if */
                        if (isIE9) {
                            el.vmodel = true;
                        }
                    }
                }
            },
            componentUpdated: function componentUpdated(el, binding, vnode) {
                if (vnode.tag === "select") {
                    setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed,
                    // it's possible that the value is out-of-sync with the rendered options.
                    // detect such cases and filter out values that no longer has a matching
                    // option in the DOM.
                    var prevOptions = el._vOptions;
                    var curOptions = el._vOptions = [].map.call(el.options, getValue);
                    if (curOptions.some(function (o, i) {
                        return !looseEqual(o, prevOptions[i]);
                    })) {
                        // trigger change event if
                        // no matching option found for at least one value
                        var needReset = el.multiple
                            ? binding.value.some(function (v) {
                                return hasNoMatchingOption(v, curOptions);
                            })
                            : binding.value !== binding.oldValue &&
                                hasNoMatchingOption(binding.value, curOptions);
                        if (needReset) {
                            trigger(el, "change");
                        }
                    }
                }
            },
        };
        function setSelected(el, binding, vm) {
            actuallySetSelected(el, binding, vm);
            /* istanbul ignore if */
            if (isIE || isEdge) {
                setTimeout(function () {
                    actuallySetSelected(el, binding, vm);
                }, 0);
            }
        }
        function actuallySetSelected(el, binding, vm) {
            var value = binding.value;
            var isMultiple = el.multiple;
            if (isMultiple && !Array.isArray(value)) {
                warn('<select multiple v-model="' + binding.expression + '"> ' +
                    "expects an Array value for its binding, but got " +
                    Object.prototype.toString.call(value).slice(8, -1), vm);
                return;
            }
            var selected, option;
            for (var i = 0, l = el.options.length; i < l; i++) {
                option = el.options[i];
                if (isMultiple) {
                    selected = looseIndexOf(value, getValue(option)) > -1;
                    if (option.selected !== selected) {
                        option.selected = selected;
                    }
                }
                else {
                    if (looseEqual(getValue(option), value)) {
                        if (el.selectedIndex !== i) {
                            el.selectedIndex = i;
                        }
                        return;
                    }
                }
            }
            if (!isMultiple) {
                el.selectedIndex = -1;
            }
        }
        function hasNoMatchingOption(value, options) {
            return options.every(function (o) {
                return !looseEqual(o, value);
            });
        }
        function getValue(option) {
            return "_value" in option ? option._value : option.value;
        }
        function onCompositionStart(e) {
            e.target.composing = true;
        }
        function onCompositionEnd(e) {
            // prevent triggering an input event for no reason
            if (!e.target.composing) {
                return;
            }
            e.target.composing = false;
            trigger(e.target, "input");
        }
        function trigger(el, type) {
            var e = document.createEvent("HTMLEvents");
            e.initEvent(type, true, true);
            el.dispatchEvent(e);
        }
        /*  */
        // recursively search for possible transition defined inside the component root
        function locateNode(vnode) {
            return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
                ? locateNode(vnode.componentInstance._vnode)
                : vnode;
        }
        var show = {
            bind: function bind(el, ref, vnode) {
                var value = ref.value;
                vnode = locateNode(vnode);
                var transition$$1 = vnode.data && vnode.data.transition;
                var originalDisplay = el.__vOriginalDisplay = el.style.display === "none"
                    ? ""
                    : el.style.display;
                if (value && transition$$1) {
                    vnode.data.show = true;
                    enter(vnode, function () {
                        el.style.display = originalDisplay;
                    });
                }
                else {
                    el.style.display = value ? originalDisplay : "none";
                }
            },
            update: function update(el, ref, vnode) {
                var value = ref.value;
                var oldValue = ref.oldValue;
                /* istanbul ignore if */
                if (!value === !oldValue) {
                    return;
                }
                vnode = locateNode(vnode);
                var transition$$1 = vnode.data && vnode.data.transition;
                if (transition$$1) {
                    vnode.data.show = true;
                    if (value) {
                        enter(vnode, function () {
                            el.style.display = el.__vOriginalDisplay;
                        });
                    }
                    else {
                        leave(vnode, function () {
                            el.style.display = "none";
                        });
                    }
                }
                else {
                    el.style.display = value ? el.__vOriginalDisplay : "none";
                }
            },
            unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
                if (!isDestroy) {
                    el.style.display = el.__vOriginalDisplay;
                }
            },
        };
        var platformDirectives = {
            model: directive,
            show: show,
        };
        /*  */
        var transitionProps = {
            name: String,
            appear: Boolean,
            css: Boolean,
            mode: String,
            type: String,
            enterClass: String,
            leaveClass: String,
            enterToClass: String,
            leaveToClass: String,
            enterActiveClass: String,
            leaveActiveClass: String,
            appearClass: String,
            appearActiveClass: String,
            appearToClass: String,
            duration: [Number, String, Object],
        }; // in case the child is also an abstract component, e.g. <keep-alive>
        // we want to recursively retrieve the real component to be rendered
        function getRealChild(vnode) {
            var compOptions = vnode && vnode.componentOptions;
            if (compOptions && compOptions.Ctor.options.abstract) {
                return getRealChild(getFirstComponentChild(compOptions.children));
            }
            else {
                return vnode;
            }
        }
        function extractTransitionData(comp) {
            var data = {};
            var options = comp.$options; // props
            for (var key in options.propsData) {
                data[key] = comp[key];
            } // events.
            // extract listeners and pass them directly to the transition methods
            var listeners = options._parentListeners;
            for (var key$1 in listeners) {
                data[camelize(key$1)] = listeners[key$1];
            }
            return data;
        }
        function placeholder(h, rawChild) {
            if (/\d-keep-alive$/.test(rawChild.tag)) {
                return h("keep-alive", {
                    props: rawChild.componentOptions.propsData,
                });
            }
        }
        function hasParentTransition(vnode) {
            while (vnode = vnode.parent) {
                if (vnode.data.transition) {
                    return true;
                }
            }
        }
        function isSameChild(child, oldChild) {
            return oldChild.key === child.key && oldChild.tag === child.tag;
        }
        var isNotTextNode = function (c) {
            return c.tag || isAsyncPlaceholder(c);
        };
        var isVShowDirective = function (d) {
            return d.name === "show";
        };
        var Transition = {
            name: "transition",
            props: transitionProps,
            abstract: true,
            render: function render(h) {
                var this$1 = this;
                var children = this.$slots.default;
                if (!children) {
                    return;
                } // filter out text nodes (possible whitespaces)
                children = children.filter(isNotTextNode);
                /* istanbul ignore if */
                if (!children.length) {
                    return;
                } // warn multiple elements
                if (children.length > 1) {
                    warn("<transition> can only be used on a single element. Use " +
                        "<transition-group> for lists.", this.$parent);
                }
                var mode = this.mode; // warn invalid mode
                if (mode && mode !== "in-out" && mode !== "out-in") {
                    warn("invalid <transition> mode: " + mode, this.$parent);
                }
                var rawChild = children[0]; // if this is a component root node and the component's
                // parent container node also has transition, skip.
                if (hasParentTransition(this.$vnode)) {
                    return rawChild;
                } // apply transition data to child
                // use getRealChild() to ignore abstract components e.g. keep-alive
                var child = getRealChild(rawChild);
                /* istanbul ignore if */
                if (!child) {
                    return rawChild;
                }
                if (this._leaving) {
                    return placeholder(h, rawChild);
                } // ensure a key that is unique to the vnode type and to this transition
                // component instance. This key will be used to remove pending leaving nodes
                // during entering.
                var id = "__transition-" + this._uid + "-";
                child.key = child.key == null
                    ? child.isComment ? id + "comment" : id + child.tag
                    : isPrimitive(child.key)
                        ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key
                        : child.key;
                var data = (child.data || (child.data = {})).transition =
                    extractTransitionData(this);
                var oldRawChild = this._vnode;
                var oldChild = getRealChild(oldRawChild); // mark v-show
                // so that the transition module can hand over the control to the directive
                if (child.data.directives && child.data.directives.some(isVShowDirective)) {
                    child.data.show = true;
                }
                if (oldChild && oldChild.data && !isSameChild(child, oldChild) &&
                    !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node
                    !(oldChild.componentInstance &&
                        oldChild.componentInstance._vnode.isComment)) {
                    // replace old child transition data with fresh one
                    // important for dynamic transitions!
                    var oldData = oldChild.data.transition = extend({}, data); // handle transition mode
                    if (mode === "out-in") {
                        // return placeholder node and queue update when leave finishes
                        this._leaving = true;
                        mergeVNodeHook(oldData, "afterLeave", function () {
                            this$1._leaving = false;
                            this$1.$forceUpdate();
                        });
                        return placeholder(h, rawChild);
                    }
                    else if (mode === "in-out") {
                        if (isAsyncPlaceholder(child)) {
                            return oldRawChild;
                        }
                        var delayedLeave;
                        var performLeave = function () {
                            delayedLeave();
                        };
                        mergeVNodeHook(data, "afterEnter", performLeave);
                        mergeVNodeHook(data, "enterCancelled", performLeave);
                        mergeVNodeHook(oldData, "delayLeave", function (leave) {
                            delayedLeave = leave;
                        });
                    }
                }
                return rawChild;
            },
        };
        /*  */
        var props = extend({
            tag: String,
            moveClass: String,
        }, transitionProps);
        delete props.mode;
        var TransitionGroup = {
            props: props,
            beforeMount: function beforeMount() {
                var this$1 = this;
                var update = this._update;
                this._update = function (vnode, hydrating) {
                    var restoreActiveInstance = setActiveInstance(this$1); // force removing pass
                    this$1.__patch__(this$1._vnode, this$1.kept, false, // hydrating
                    true);
                    this$1._vnode = this$1.kept;
                    restoreActiveInstance();
                    update.call(this$1, vnode, hydrating);
                };
            },
            render: function render(h) {
                var tag = this.tag || this.$vnode.data.tag || "span";
                var map = Object.create(null);
                var prevChildren = this.prevChildren = this.children;
                var rawChildren = this.$slots.default || [];
                var children = this.children = [];
                var transitionData = extractTransitionData(this);
                for (var i = 0; i < rawChildren.length; i++) {
                    var c = rawChildren[i];
                    if (c.tag) {
                        if (c.key != null && String(c.key).indexOf("__vlist") !== 0) {
                            children.push(c);
                            map[c.key] = c;
                            (c.data || (c.data = {})).transition = transitionData;
                        }
                        else {
                            var opts = c.componentOptions;
                            var name = opts ? opts.Ctor.options.name || opts.tag || "" : c.tag;
                            warn("<transition-group> children must be keyed: <" + name + ">");
                        }
                    }
                }
                if (prevChildren) {
                    var kept = [];
                    var removed = [];
                    for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
                        var c$1 = prevChildren[i$1];
                        c$1.data.transition = transitionData;
                        c$1.data.pos = c$1.elm.getBoundingClientRect();
                        if (map[c$1.key]) {
                            kept.push(c$1);
                        }
                        else {
                            removed.push(c$1);
                        }
                    }
                    this.kept = h(tag, null, kept);
                    this.removed = removed;
                }
                return h(tag, null, children);
            },
            updated: function updated() {
                var children = this.prevChildren;
                var moveClass = this.moveClass || (this.name || "v") + "-move";
                if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
                    return;
                } // we divide the work into three loops to avoid mixing DOM reads and writes
                // in each iteration - which helps prevent layout thrashing.
                children.forEach(callPendingCbs);
                children.forEach(recordPosition);
                children.forEach(applyTranslation); // force reflow to put everything in position
                // assign to this to avoid being removed in tree-shaking
                // $flow-disable-line
                this._reflow = document.body.offsetHeight;
                children.forEach(function (c) {
                    if (c.data.moved) {
                        var el = c.elm;
                        var s = el.style;
                        addTransitionClass(el, moveClass);
                        s.transform = s.WebkitTransform = s.transitionDuration = "";
                        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
                            if (e && e.target !== el) {
                                return;
                            }
                            if (!e || /transform$/.test(e.propertyName)) {
                                el.removeEventListener(transitionEndEvent, cb);
                                el._moveCb = null;
                                removeTransitionClass(el, moveClass);
                            }
                        });
                    }
                });
            },
            methods: {
                hasMove: function hasMove(el, moveClass) {
                    /* istanbul ignore if */
                    if (!hasTransition) {
                        return false;
                    }
                    /* istanbul ignore if */
                    if (this._hasMove) {
                        return this._hasMove;
                    } // Detect whether an element with the move class applied has
                    // CSS transitions. Since the element may be inside an entering
                    // transition at this very moment, we make a clone of it and remove
                    // all other transition classes applied to ensure only the move class
                    // is applied.
                    var clone = el.cloneNode();
                    if (el._transitionClasses) {
                        el._transitionClasses.forEach(function (cls) {
                            removeClass(clone, cls);
                        });
                    }
                    addClass(clone, moveClass);
                    clone.style.display = "none";
                    this.$el.appendChild(clone);
                    var info = getTransitionInfo(clone);
                    this.$el.removeChild(clone);
                    return this._hasMove = info.hasTransform;
                },
            },
        };
        function callPendingCbs(c) {
            /* istanbul ignore if */
            if (c.elm._moveCb) {
                c.elm._moveCb();
            }
            /* istanbul ignore if */
            if (c.elm._enterCb) {
                c.elm._enterCb();
            }
        }
        function recordPosition(c) {
            c.data.newPos = c.elm.getBoundingClientRect();
        }
        function applyTranslation(c) {
            var oldPos = c.data.pos;
            var newPos = c.data.newPos;
            var dx = oldPos.left - newPos.left;
            var dy = oldPos.top - newPos.top;
            if (dx || dy) {
                c.data.moved = true;
                var s = c.elm.style;
                s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
                s.transitionDuration = "0s";
            }
        }
        var platformComponents = {
            Transition: Transition,
            TransitionGroup: TransitionGroup,
        };
        /*  */
        // install platform specific utils
        Vue.config.mustUseProp = mustUseProp;
        Vue.config.isReservedTag = isReservedTag;
        Vue.config.isReservedAttr = isReservedAttr;
        Vue.config.getTagNamespace = getTagNamespace;
        Vue.config.isUnknownElement = isUnknownElement; // install platform runtime directives & components
        extend(Vue.options.directives, platformDirectives);
        extend(Vue.options.components, platformComponents); // install platform patch function
        Vue.prototype.__patch__ = inBrowser ? patch : noop; // public mount method
        Vue.prototype.$mount = function (el, hydrating) {
            el = el && inBrowser ? query(el) : undefined;
            return mountComponent(this, el, hydrating);
        }; // devtools global hook
        /* istanbul ignore next */
        if (inBrowser) {
            setTimeout(function () {
                if (config.devtools) {
                    if (devtools) {
                        devtools.emit("init", Vue);
                    }
                    else {
                        console[console.info ? "info" : "log"]("Download the Vue Devtools extension for a better development experience:\n" +
                            "https://github.com/vuejs/vue-devtools");
                    }
                }
                if (config.productionTip !== false && typeof console !== "undefined") {
                    console[console.info ? "info" : "log"]("You are running Vue in development mode.\n" +
                        "Make sure to turn on production mode when deploying for production.\n" +
                        "See more tips at https://vuejs.org/guide/deployment.html");
                }
            }, 0);
        }
        /*  */
        exports = Vue;
        return exports;
    }
    exports_63("dew", dew);
    return {
        setters: [],
        execute: function () {
            exports = {}, _dewExec = false;
            _global = typeof self !== "undefined" ? self : global;
        }
    };
});
System.register("file:///Users/norbert/Documents/workspace/deno/deno-ssr/vue/vue.runtime.common.dew", ["file:///Users/norbert/Documents/workspace/deno/deno-ssr/vue/vue.runtime.common.dev.dew"], function (exports_64, context_64) {
    "use strict";
    var vue_runtime_common_dev_dew_js_1, exports, _dewExec;
    var __moduleName = context_64 && context_64.id;
    function dew() {
        if (_dewExec)
            return exports;
        _dewExec = true;
        {
            exports = vue_runtime_common_dev_dew_js_1.dew();
        }
        return exports;
    }
    exports_64("dew", dew);
    return {
        setters: [
            function (vue_runtime_common_dev_dew_js_1_1) {
                vue_runtime_common_dev_dew_js_1 = vue_runtime_common_dev_dew_js_1_1;
            }
        ],
        execute: function () {
            exports = {}, _dewExec = false;
        }
    };
});
System.register("file:///Users/norbert/Documents/workspace/deno/deno-ssr/vue/vue", ["file:///Users/norbert/Documents/workspace/deno/deno-ssr/vue/vue.runtime.common.dew"], function (exports_65, context_65) {
    "use strict";
    var vue_runtime_common_dew_js_1;
    var __moduleName = context_65 && context_65.id;
    return {
        setters: [
            function (vue_runtime_common_dew_js_1_1) {
                vue_runtime_common_dew_js_1 = vue_runtime_common_dew_js_1_1;
            }
        ],
        execute: function () {
            exports_65("default", vue_runtime_common_dew_js_1.dew());
        }
    };
});
System.register("https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/@empty", [], function (exports_66, context_66) {
    "use strict";
    var empty;
    var __moduleName = context_66 && context_66.id;
    return {
        setters: [],
        execute: function () {
            empty = Object.freeze(Object.create(null));
            exports_66("default", empty);
        }
    };
});
System.register("https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/@empty.dew", ["https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/@empty"], function (exports_67, context_67) {
    "use strict";
    var _empty_js_1;
    var __moduleName = context_67 && context_67.id;
    function dew() {
        return _empty_js_1.default;
    }
    exports_67("dew", dew);
    return {
        setters: [
            function (_empty_js_1_1) {
                _empty_js_1 = _empty_js_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://dev.jspm.io/npm:@jspm/core@1/nodelibs/@empty.dew", ["https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/@empty.dew", "https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/@empty"], function (exports_68, context_68) {
    "use strict";
    var __moduleName = context_68 && context_68.id;
    function exportStar_3(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default") exports[n] = m[n];
        }
        exports_68(exports);
    }
    return {
        setters: [
            function (_empty_dew_js_1_1) {
                exportStar_3(_empty_dew_js_1_1);
            },
            function (_1) {
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://dev.jspm.io/npm:vue-server-renderer@2.6.11/package.json.dew", [], function (exports_69, context_69) {
    "use strict";
    var exports;
    var __moduleName = context_69 && context_69.id;
    function dew() { return exports; }
    exports_69("dew", dew);
    return {
        setters: [],
        execute: function () {
            exports = {
                "name": "vue-server-renderer",
                "version": "2.6.11",
                "description": "server renderer for Vue 2.0",
                "main": "index.js",
                "types": "types/index.d.ts",
                "repository": {
                    "type": "git",
                    "url": "git+https://github.com/vuejs/vue.git"
                },
                "keywords": [
                    "vue",
                    "server",
                    "ssr"
                ],
                "author": "Evan You",
                "license": "MIT",
                "bugs": {
                    "url": "https://github.com/vuejs/vue/issues"
                },
                "dependencies": {
                    "chalk": "^1.1.3",
                    "hash-sum": "^1.0.2",
                    "he": "^1.1.0",
                    "lodash.template": "^4.5.0",
                    "lodash.uniq": "^4.5.0",
                    "resolve": "^1.2.0",
                    "serialize-javascript": "^2.1.2",
                    "source-map": "0.5.6"
                },
                "devDependencies": {
                    "vue": "file:../.."
                },
                "homepage": "https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer#readme"
            };
        }
    };
});
System.register("https://dev.jspm.io/npm:he@1.2.0/he.dew", [], function (exports_70, context_70) {
    "use strict";
    var exports, _dewExec, module, _global;
    var __moduleName = context_70 && context_70.id;
    function dew() {
        if (_dewExec)
            return module.exports;
        _dewExec = true;
        /*! https://mths.be/he v1.2.0 by @mathias | MIT license */
        ;
        (function (root) {
            // Detect free variables `exports`.
            var freeExports = typeof exports == 'object' && exports; // Detect free variable `module`.
            var freeModule = true && module.exports == freeExports && module; // Detect free variable `global`, from Node.js or Browserified code,
            // and use it as `root`.
            var freeGlobal = typeof _global == 'object' && _global;
            if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
                root = freeGlobal;
            }
            /*--------------------------------------------------------------------------*/
            // All astral symbols.
            var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g; // All ASCII symbols (not just printable ASCII) except those listed in the
            // first column of the overrides table.
            // https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides
            var regexAsciiWhitelist = /[\x01-\x7F]/g; // All BMP symbols that are not ASCII newlines, printable ASCII symbols, or
            // code points listed in the first column of the overrides table on
            // https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides.
            var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
            var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
            var encodeMap = {
                '\xAD': 'shy',
                '\u200C': 'zwnj',
                '\u200D': 'zwj',
                '\u200E': 'lrm',
                '\u2063': 'ic',
                '\u2062': 'it',
                '\u2061': 'af',
                '\u200F': 'rlm',
                '\u200B': 'ZeroWidthSpace',
                '\u2060': 'NoBreak',
                '\u0311': 'DownBreve',
                '\u20DB': 'tdot',
                '\u20DC': 'DotDot',
                '\t': 'Tab',
                '\n': 'NewLine',
                '\u2008': 'puncsp',
                '\u205F': 'MediumSpace',
                '\u2009': 'thinsp',
                '\u200A': 'hairsp',
                '\u2004': 'emsp13',
                '\u2002': 'ensp',
                '\u2005': 'emsp14',
                '\u2003': 'emsp',
                '\u2007': 'numsp',
                '\xA0': 'nbsp',
                '\u205F\u200A': 'ThickSpace',
                '\u203E': 'oline',
                '_': 'lowbar',
                '\u2010': 'dash',
                '\u2013': 'ndash',
                '\u2014': 'mdash',
                '\u2015': 'horbar',
                ',': 'comma',
                ';': 'semi',
                '\u204F': 'bsemi',
                ':': 'colon',
                '\u2A74': 'Colone',
                '!': 'excl',
                '\xA1': 'iexcl',
                '?': 'quest',
                '\xBF': 'iquest',
                '.': 'period',
                '\u2025': 'nldr',
                '\u2026': 'mldr',
                '\xB7': 'middot',
                '\'': 'apos',
                '\u2018': 'lsquo',
                '\u2019': 'rsquo',
                '\u201A': 'sbquo',
                '\u2039': 'lsaquo',
                '\u203A': 'rsaquo',
                '"': 'quot',
                '\u201C': 'ldquo',
                '\u201D': 'rdquo',
                '\u201E': 'bdquo',
                '\xAB': 'laquo',
                '\xBB': 'raquo',
                '(': 'lpar',
                ')': 'rpar',
                '[': 'lsqb',
                ']': 'rsqb',
                '{': 'lcub',
                '}': 'rcub',
                '\u2308': 'lceil',
                '\u2309': 'rceil',
                '\u230A': 'lfloor',
                '\u230B': 'rfloor',
                '\u2985': 'lopar',
                '\u2986': 'ropar',
                '\u298B': 'lbrke',
                '\u298C': 'rbrke',
                '\u298D': 'lbrkslu',
                '\u298E': 'rbrksld',
                '\u298F': 'lbrksld',
                '\u2990': 'rbrkslu',
                '\u2991': 'langd',
                '\u2992': 'rangd',
                '\u2993': 'lparlt',
                '\u2994': 'rpargt',
                '\u2995': 'gtlPar',
                '\u2996': 'ltrPar',
                '\u27E6': 'lobrk',
                '\u27E7': 'robrk',
                '\u27E8': 'lang',
                '\u27E9': 'rang',
                '\u27EA': 'Lang',
                '\u27EB': 'Rang',
                '\u27EC': 'loang',
                '\u27ED': 'roang',
                '\u2772': 'lbbrk',
                '\u2773': 'rbbrk',
                '\u2016': 'Vert',
                '\xA7': 'sect',
                '\xB6': 'para',
                '@': 'commat',
                '*': 'ast',
                '/': 'sol',
                'undefined': null,
                '&': 'amp',
                '#': 'num',
                '%': 'percnt',
                '\u2030': 'permil',
                '\u2031': 'pertenk',
                '\u2020': 'dagger',
                '\u2021': 'Dagger',
                '\u2022': 'bull',
                '\u2043': 'hybull',
                '\u2032': 'prime',
                '\u2033': 'Prime',
                '\u2034': 'tprime',
                '\u2057': 'qprime',
                '\u2035': 'bprime',
                '\u2041': 'caret',
                '`': 'grave',
                '\xB4': 'acute',
                '\u02DC': 'tilde',
                '^': 'Hat',
                '\xAF': 'macr',
                '\u02D8': 'breve',
                '\u02D9': 'dot',
                '\xA8': 'die',
                '\u02DA': 'ring',
                '\u02DD': 'dblac',
                '\xB8': 'cedil',
                '\u02DB': 'ogon',
                '\u02C6': 'circ',
                '\u02C7': 'caron',
                '\xB0': 'deg',
                '\xA9': 'copy',
                '\xAE': 'reg',
                '\u2117': 'copysr',
                '\u2118': 'wp',
                '\u211E': 'rx',
                '\u2127': 'mho',
                '\u2129': 'iiota',
                '\u2190': 'larr',
                '\u219A': 'nlarr',
                '\u2192': 'rarr',
                '\u219B': 'nrarr',
                '\u2191': 'uarr',
                '\u2193': 'darr',
                '\u2194': 'harr',
                '\u21AE': 'nharr',
                '\u2195': 'varr',
                '\u2196': 'nwarr',
                '\u2197': 'nearr',
                '\u2198': 'searr',
                '\u2199': 'swarr',
                '\u219D': 'rarrw',
                '\u219D\u0338': 'nrarrw',
                '\u219E': 'Larr',
                '\u219F': 'Uarr',
                '\u21A0': 'Rarr',
                '\u21A1': 'Darr',
                '\u21A2': 'larrtl',
                '\u21A3': 'rarrtl',
                '\u21A4': 'mapstoleft',
                '\u21A5': 'mapstoup',
                '\u21A6': 'map',
                '\u21A7': 'mapstodown',
                '\u21A9': 'larrhk',
                '\u21AA': 'rarrhk',
                '\u21AB': 'larrlp',
                '\u21AC': 'rarrlp',
                '\u21AD': 'harrw',
                '\u21B0': 'lsh',
                '\u21B1': 'rsh',
                '\u21B2': 'ldsh',
                '\u21B3': 'rdsh',
                '\u21B5': 'crarr',
                '\u21B6': 'cularr',
                '\u21B7': 'curarr',
                '\u21BA': 'olarr',
                '\u21BB': 'orarr',
                '\u21BC': 'lharu',
                '\u21BD': 'lhard',
                '\u21BE': 'uharr',
                '\u21BF': 'uharl',
                '\u21C0': 'rharu',
                '\u21C1': 'rhard',
                '\u21C2': 'dharr',
                '\u21C3': 'dharl',
                '\u21C4': 'rlarr',
                '\u21C5': 'udarr',
                '\u21C6': 'lrarr',
                '\u21C7': 'llarr',
                '\u21C8': 'uuarr',
                '\u21C9': 'rrarr',
                '\u21CA': 'ddarr',
                '\u21CB': 'lrhar',
                '\u21CC': 'rlhar',
                '\u21D0': 'lArr',
                '\u21CD': 'nlArr',
                '\u21D1': 'uArr',
                '\u21D2': 'rArr',
                '\u21CF': 'nrArr',
                '\u21D3': 'dArr',
                '\u21D4': 'iff',
                '\u21CE': 'nhArr',
                '\u21D5': 'vArr',
                '\u21D6': 'nwArr',
                '\u21D7': 'neArr',
                '\u21D8': 'seArr',
                '\u21D9': 'swArr',
                '\u21DA': 'lAarr',
                '\u21DB': 'rAarr',
                '\u21DD': 'zigrarr',
                '\u21E4': 'larrb',
                '\u21E5': 'rarrb',
                '\u21F5': 'duarr',
                '\u21FD': 'loarr',
                '\u21FE': 'roarr',
                '\u21FF': 'hoarr',
                '\u2200': 'forall',
                '\u2201': 'comp',
                '\u2202': 'part',
                '\u2202\u0338': 'npart',
                '\u2203': 'exist',
                '\u2204': 'nexist',
                '\u2205': 'empty',
                '\u2207': 'Del',
                '\u2208': 'in',
                '\u2209': 'notin',
                '\u220B': 'ni',
                '\u220C': 'notni',
                '\u03F6': 'bepsi',
                '\u220F': 'prod',
                '\u2210': 'coprod',
                '\u2211': 'sum',
                '+': 'plus',
                '\xB1': 'pm',
                '\xF7': 'div',
                '\xD7': 'times',
                '<': 'lt',
                '\u226E': 'nlt',
                '<\u20D2': 'nvlt',
                '=': 'equals',
                '\u2260': 'ne',
                '=\u20E5': 'bne',
                '\u2A75': 'Equal',
                '>': 'gt',
                '\u226F': 'ngt',
                '>\u20D2': 'nvgt',
                '\xAC': 'not',
                '|': 'vert',
                '\xA6': 'brvbar',
                '\u2212': 'minus',
                '\u2213': 'mp',
                '\u2214': 'plusdo',
                '\u2044': 'frasl',
                '\u2216': 'setmn',
                '\u2217': 'lowast',
                '\u2218': 'compfn',
                '\u221A': 'Sqrt',
                '\u221D': 'prop',
                '\u221E': 'infin',
                '\u221F': 'angrt',
                '\u2220': 'ang',
                '\u2220\u20D2': 'nang',
                '\u2221': 'angmsd',
                '\u2222': 'angsph',
                '\u2223': 'mid',
                '\u2224': 'nmid',
                '\u2225': 'par',
                '\u2226': 'npar',
                '\u2227': 'and',
                '\u2228': 'or',
                '\u2229': 'cap',
                '\u2229\uFE00': 'caps',
                '\u222A': 'cup',
                '\u222A\uFE00': 'cups',
                '\u222B': 'int',
                '\u222C': 'Int',
                '\u222D': 'tint',
                '\u2A0C': 'qint',
                '\u222E': 'oint',
                '\u222F': 'Conint',
                '\u2230': 'Cconint',
                '\u2231': 'cwint',
                '\u2232': 'cwconint',
                '\u2233': 'awconint',
                '\u2234': 'there4',
                '\u2235': 'becaus',
                '\u2236': 'ratio',
                '\u2237': 'Colon',
                '\u2238': 'minusd',
                '\u223A': 'mDDot',
                '\u223B': 'homtht',
                '\u223C': 'sim',
                '\u2241': 'nsim',
                '\u223C\u20D2': 'nvsim',
                '\u223D': 'bsim',
                '\u223D\u0331': 'race',
                '\u223E': 'ac',
                '\u223E\u0333': 'acE',
                '\u223F': 'acd',
                '\u2240': 'wr',
                '\u2242': 'esim',
                '\u2242\u0338': 'nesim',
                '\u2243': 'sime',
                '\u2244': 'nsime',
                '\u2245': 'cong',
                '\u2247': 'ncong',
                '\u2246': 'simne',
                '\u2248': 'ap',
                '\u2249': 'nap',
                '\u224A': 'ape',
                '\u224B': 'apid',
                '\u224B\u0338': 'napid',
                '\u224C': 'bcong',
                '\u224D': 'CupCap',
                '\u226D': 'NotCupCap',
                '\u224D\u20D2': 'nvap',
                '\u224E': 'bump',
                '\u224E\u0338': 'nbump',
                '\u224F': 'bumpe',
                '\u224F\u0338': 'nbumpe',
                '\u2250': 'doteq',
                '\u2250\u0338': 'nedot',
                '\u2251': 'eDot',
                '\u2252': 'efDot',
                '\u2253': 'erDot',
                '\u2254': 'colone',
                '\u2255': 'ecolon',
                '\u2256': 'ecir',
                '\u2257': 'cire',
                '\u2259': 'wedgeq',
                '\u225A': 'veeeq',
                '\u225C': 'trie',
                '\u225F': 'equest',
                '\u2261': 'equiv',
                '\u2262': 'nequiv',
                '\u2261\u20E5': 'bnequiv',
                '\u2264': 'le',
                '\u2270': 'nle',
                '\u2264\u20D2': 'nvle',
                '\u2265': 'ge',
                '\u2271': 'nge',
                '\u2265\u20D2': 'nvge',
                '\u2266': 'lE',
                '\u2266\u0338': 'nlE',
                '\u2267': 'gE',
                '\u2267\u0338': 'ngE',
                '\u2268\uFE00': 'lvnE',
                '\u2268': 'lnE',
                '\u2269': 'gnE',
                '\u2269\uFE00': 'gvnE',
                '\u226A': 'll',
                '\u226A\u0338': 'nLtv',
                '\u226A\u20D2': 'nLt',
                '\u226B': 'gg',
                '\u226B\u0338': 'nGtv',
                '\u226B\u20D2': 'nGt',
                '\u226C': 'twixt',
                '\u2272': 'lsim',
                '\u2274': 'nlsim',
                '\u2273': 'gsim',
                '\u2275': 'ngsim',
                '\u2276': 'lg',
                '\u2278': 'ntlg',
                '\u2277': 'gl',
                '\u2279': 'ntgl',
                '\u227A': 'pr',
                '\u2280': 'npr',
                '\u227B': 'sc',
                '\u2281': 'nsc',
                '\u227C': 'prcue',
                '\u22E0': 'nprcue',
                '\u227D': 'sccue',
                '\u22E1': 'nsccue',
                '\u227E': 'prsim',
                '\u227F': 'scsim',
                '\u227F\u0338': 'NotSucceedsTilde',
                '\u2282': 'sub',
                '\u2284': 'nsub',
                '\u2282\u20D2': 'vnsub',
                '\u2283': 'sup',
                '\u2285': 'nsup',
                '\u2283\u20D2': 'vnsup',
                '\u2286': 'sube',
                '\u2288': 'nsube',
                '\u2287': 'supe',
                '\u2289': 'nsupe',
                '\u228A\uFE00': 'vsubne',
                '\u228A': 'subne',
                '\u228B\uFE00': 'vsupne',
                '\u228B': 'supne',
                '\u228D': 'cupdot',
                '\u228E': 'uplus',
                '\u228F': 'sqsub',
                '\u228F\u0338': 'NotSquareSubset',
                '\u2290': 'sqsup',
                '\u2290\u0338': 'NotSquareSuperset',
                '\u2291': 'sqsube',
                '\u22E2': 'nsqsube',
                '\u2292': 'sqsupe',
                '\u22E3': 'nsqsupe',
                '\u2293': 'sqcap',
                '\u2293\uFE00': 'sqcaps',
                '\u2294': 'sqcup',
                '\u2294\uFE00': 'sqcups',
                '\u2295': 'oplus',
                '\u2296': 'ominus',
                '\u2297': 'otimes',
                '\u2298': 'osol',
                '\u2299': 'odot',
                '\u229A': 'ocir',
                '\u229B': 'oast',
                '\u229D': 'odash',
                '\u229E': 'plusb',
                '\u229F': 'minusb',
                '\u22A0': 'timesb',
                '\u22A1': 'sdotb',
                '\u22A2': 'vdash',
                '\u22AC': 'nvdash',
                '\u22A3': 'dashv',
                '\u22A4': 'top',
                '\u22A5': 'bot',
                '\u22A7': 'models',
                '\u22A8': 'vDash',
                '\u22AD': 'nvDash',
                '\u22A9': 'Vdash',
                '\u22AE': 'nVdash',
                '\u22AA': 'Vvdash',
                '\u22AB': 'VDash',
                '\u22AF': 'nVDash',
                '\u22B0': 'prurel',
                '\u22B2': 'vltri',
                '\u22EA': 'nltri',
                '\u22B3': 'vrtri',
                '\u22EB': 'nrtri',
                '\u22B4': 'ltrie',
                '\u22EC': 'nltrie',
                '\u22B4\u20D2': 'nvltrie',
                '\u22B5': 'rtrie',
                '\u22ED': 'nrtrie',
                '\u22B5\u20D2': 'nvrtrie',
                '\u22B6': 'origof',
                '\u22B7': 'imof',
                '\u22B8': 'mumap',
                '\u22B9': 'hercon',
                '\u22BA': 'intcal',
                '\u22BB': 'veebar',
                '\u22BD': 'barvee',
                '\u22BE': 'angrtvb',
                '\u22BF': 'lrtri',
                '\u22C0': 'Wedge',
                '\u22C1': 'Vee',
                '\u22C2': 'xcap',
                '\u22C3': 'xcup',
                '\u22C4': 'diam',
                '\u22C5': 'sdot',
                '\u22C6': 'Star',
                '\u22C7': 'divonx',
                '\u22C8': 'bowtie',
                '\u22C9': 'ltimes',
                '\u22CA': 'rtimes',
                '\u22CB': 'lthree',
                '\u22CC': 'rthree',
                '\u22CD': 'bsime',
                '\u22CE': 'cuvee',
                '\u22CF': 'cuwed',
                '\u22D0': 'Sub',
                '\u22D1': 'Sup',
                '\u22D2': 'Cap',
                '\u22D3': 'Cup',
                '\u22D4': 'fork',
                '\u22D5': 'epar',
                '\u22D6': 'ltdot',
                '\u22D7': 'gtdot',
                '\u22D8': 'Ll',
                '\u22D8\u0338': 'nLl',
                '\u22D9': 'Gg',
                '\u22D9\u0338': 'nGg',
                '\u22DA\uFE00': 'lesg',
                '\u22DA': 'leg',
                '\u22DB': 'gel',
                '\u22DB\uFE00': 'gesl',
                '\u22DE': 'cuepr',
                '\u22DF': 'cuesc',
                '\u22E6': 'lnsim',
                '\u22E7': 'gnsim',
                '\u22E8': 'prnsim',
                '\u22E9': 'scnsim',
                '\u22EE': 'vellip',
                '\u22EF': 'ctdot',
                '\u22F0': 'utdot',
                '\u22F1': 'dtdot',
                '\u22F2': 'disin',
                '\u22F3': 'isinsv',
                '\u22F4': 'isins',
                '\u22F5': 'isindot',
                '\u22F5\u0338': 'notindot',
                '\u22F6': 'notinvc',
                '\u22F7': 'notinvb',
                '\u22F9': 'isinE',
                '\u22F9\u0338': 'notinE',
                '\u22FA': 'nisd',
                '\u22FB': 'xnis',
                '\u22FC': 'nis',
                '\u22FD': 'notnivc',
                '\u22FE': 'notnivb',
                '\u2305': 'barwed',
                '\u2306': 'Barwed',
                '\u230C': 'drcrop',
                '\u230D': 'dlcrop',
                '\u230E': 'urcrop',
                '\u230F': 'ulcrop',
                '\u2310': 'bnot',
                '\u2312': 'profline',
                '\u2313': 'profsurf',
                '\u2315': 'telrec',
                '\u2316': 'target',
                '\u231C': 'ulcorn',
                '\u231D': 'urcorn',
                '\u231E': 'dlcorn',
                '\u231F': 'drcorn',
                '\u2322': 'frown',
                '\u2323': 'smile',
                '\u232D': 'cylcty',
                '\u232E': 'profalar',
                '\u2336': 'topbot',
                '\u233D': 'ovbar',
                '\u233F': 'solbar',
                '\u237C': 'angzarr',
                '\u23B0': 'lmoust',
                '\u23B1': 'rmoust',
                '\u23B4': 'tbrk',
                '\u23B5': 'bbrk',
                '\u23B6': 'bbrktbrk',
                '\u23DC': 'OverParenthesis',
                '\u23DD': 'UnderParenthesis',
                '\u23DE': 'OverBrace',
                '\u23DF': 'UnderBrace',
                '\u23E2': 'trpezium',
                '\u23E7': 'elinters',
                '\u2423': 'blank',
                '\u2500': 'boxh',
                '\u2502': 'boxv',
                '\u250C': 'boxdr',
                '\u2510': 'boxdl',
                '\u2514': 'boxur',
                '\u2518': 'boxul',
                '\u251C': 'boxvr',
                '\u2524': 'boxvl',
                '\u252C': 'boxhd',
                '\u2534': 'boxhu',
                '\u253C': 'boxvh',
                '\u2550': 'boxH',
                '\u2551': 'boxV',
                '\u2552': 'boxdR',
                '\u2553': 'boxDr',
                '\u2554': 'boxDR',
                '\u2555': 'boxdL',
                '\u2556': 'boxDl',
                '\u2557': 'boxDL',
                '\u2558': 'boxuR',
                '\u2559': 'boxUr',
                '\u255A': 'boxUR',
                '\u255B': 'boxuL',
                '\u255C': 'boxUl',
                '\u255D': 'boxUL',
                '\u255E': 'boxvR',
                '\u255F': 'boxVr',
                '\u2560': 'boxVR',
                '\u2561': 'boxvL',
                '\u2562': 'boxVl',
                '\u2563': 'boxVL',
                '\u2564': 'boxHd',
                '\u2565': 'boxhD',
                '\u2566': 'boxHD',
                '\u2567': 'boxHu',
                '\u2568': 'boxhU',
                '\u2569': 'boxHU',
                '\u256A': 'boxvH',
                '\u256B': 'boxVh',
                '\u256C': 'boxVH',
                '\u2580': 'uhblk',
                '\u2584': 'lhblk',
                '\u2588': 'block',
                '\u2591': 'blk14',
                '\u2592': 'blk12',
                '\u2593': 'blk34',
                '\u25A1': 'squ',
                '\u25AA': 'squf',
                '\u25AB': 'EmptyVerySmallSquare',
                '\u25AD': 'rect',
                '\u25AE': 'marker',
                '\u25B1': 'fltns',
                '\u25B3': 'xutri',
                '\u25B4': 'utrif',
                '\u25B5': 'utri',
                '\u25B8': 'rtrif',
                '\u25B9': 'rtri',
                '\u25BD': 'xdtri',
                '\u25BE': 'dtrif',
                '\u25BF': 'dtri',
                '\u25C2': 'ltrif',
                '\u25C3': 'ltri',
                '\u25CA': 'loz',
                '\u25CB': 'cir',
                '\u25EC': 'tridot',
                '\u25EF': 'xcirc',
                '\u25F8': 'ultri',
                '\u25F9': 'urtri',
                '\u25FA': 'lltri',
                '\u25FB': 'EmptySmallSquare',
                '\u25FC': 'FilledSmallSquare',
                '\u2605': 'starf',
                '\u2606': 'star',
                '\u260E': 'phone',
                '\u2640': 'female',
                '\u2642': 'male',
                '\u2660': 'spades',
                '\u2663': 'clubs',
                '\u2665': 'hearts',
                '\u2666': 'diams',
                '\u266A': 'sung',
                '\u2713': 'check',
                '\u2717': 'cross',
                '\u2720': 'malt',
                '\u2736': 'sext',
                '\u2758': 'VerticalSeparator',
                '\u27C8': 'bsolhsub',
                '\u27C9': 'suphsol',
                '\u27F5': 'xlarr',
                '\u27F6': 'xrarr',
                '\u27F7': 'xharr',
                '\u27F8': 'xlArr',
                '\u27F9': 'xrArr',
                '\u27FA': 'xhArr',
                '\u27FC': 'xmap',
                '\u27FF': 'dzigrarr',
                '\u2902': 'nvlArr',
                '\u2903': 'nvrArr',
                '\u2904': 'nvHarr',
                '\u2905': 'Map',
                '\u290C': 'lbarr',
                '\u290D': 'rbarr',
                '\u290E': 'lBarr',
                '\u290F': 'rBarr',
                '\u2910': 'RBarr',
                '\u2911': 'DDotrahd',
                '\u2912': 'UpArrowBar',
                '\u2913': 'DownArrowBar',
                '\u2916': 'Rarrtl',
                '\u2919': 'latail',
                '\u291A': 'ratail',
                '\u291B': 'lAtail',
                '\u291C': 'rAtail',
                '\u291D': 'larrfs',
                '\u291E': 'rarrfs',
                '\u291F': 'larrbfs',
                '\u2920': 'rarrbfs',
                '\u2923': 'nwarhk',
                '\u2924': 'nearhk',
                '\u2925': 'searhk',
                '\u2926': 'swarhk',
                '\u2927': 'nwnear',
                '\u2928': 'toea',
                '\u2929': 'tosa',
                '\u292A': 'swnwar',
                '\u2933': 'rarrc',
                '\u2933\u0338': 'nrarrc',
                '\u2935': 'cudarrr',
                '\u2936': 'ldca',
                '\u2937': 'rdca',
                '\u2938': 'cudarrl',
                '\u2939': 'larrpl',
                '\u293C': 'curarrm',
                '\u293D': 'cularrp',
                '\u2945': 'rarrpl',
                '\u2948': 'harrcir',
                '\u2949': 'Uarrocir',
                '\u294A': 'lurdshar',
                '\u294B': 'ldrushar',
                '\u294E': 'LeftRightVector',
                '\u294F': 'RightUpDownVector',
                '\u2950': 'DownLeftRightVector',
                '\u2951': 'LeftUpDownVector',
                '\u2952': 'LeftVectorBar',
                '\u2953': 'RightVectorBar',
                '\u2954': 'RightUpVectorBar',
                '\u2955': 'RightDownVectorBar',
                '\u2956': 'DownLeftVectorBar',
                '\u2957': 'DownRightVectorBar',
                '\u2958': 'LeftUpVectorBar',
                '\u2959': 'LeftDownVectorBar',
                '\u295A': 'LeftTeeVector',
                '\u295B': 'RightTeeVector',
                '\u295C': 'RightUpTeeVector',
                '\u295D': 'RightDownTeeVector',
                '\u295E': 'DownLeftTeeVector',
                '\u295F': 'DownRightTeeVector',
                '\u2960': 'LeftUpTeeVector',
                '\u2961': 'LeftDownTeeVector',
                '\u2962': 'lHar',
                '\u2963': 'uHar',
                '\u2964': 'rHar',
                '\u2965': 'dHar',
                '\u2966': 'luruhar',
                '\u2967': 'ldrdhar',
                '\u2968': 'ruluhar',
                '\u2969': 'rdldhar',
                '\u296A': 'lharul',
                '\u296B': 'llhard',
                '\u296C': 'rharul',
                '\u296D': 'lrhard',
                '\u296E': 'udhar',
                '\u296F': 'duhar',
                '\u2970': 'RoundImplies',
                '\u2971': 'erarr',
                '\u2972': 'simrarr',
                '\u2973': 'larrsim',
                '\u2974': 'rarrsim',
                '\u2975': 'rarrap',
                '\u2976': 'ltlarr',
                '\u2978': 'gtrarr',
                '\u2979': 'subrarr',
                '\u297B': 'suplarr',
                '\u297C': 'lfisht',
                '\u297D': 'rfisht',
                '\u297E': 'ufisht',
                '\u297F': 'dfisht',
                '\u299A': 'vzigzag',
                '\u299C': 'vangrt',
                '\u299D': 'angrtvbd',
                '\u29A4': 'ange',
                '\u29A5': 'range',
                '\u29A6': 'dwangle',
                '\u29A7': 'uwangle',
                '\u29A8': 'angmsdaa',
                '\u29A9': 'angmsdab',
                '\u29AA': 'angmsdac',
                '\u29AB': 'angmsdad',
                '\u29AC': 'angmsdae',
                '\u29AD': 'angmsdaf',
                '\u29AE': 'angmsdag',
                '\u29AF': 'angmsdah',
                '\u29B0': 'bemptyv',
                '\u29B1': 'demptyv',
                '\u29B2': 'cemptyv',
                '\u29B3': 'raemptyv',
                '\u29B4': 'laemptyv',
                '\u29B5': 'ohbar',
                '\u29B6': 'omid',
                '\u29B7': 'opar',
                '\u29B9': 'operp',
                '\u29BB': 'olcross',
                '\u29BC': 'odsold',
                '\u29BE': 'olcir',
                '\u29BF': 'ofcir',
                '\u29C0': 'olt',
                '\u29C1': 'ogt',
                '\u29C2': 'cirscir',
                '\u29C3': 'cirE',
                '\u29C4': 'solb',
                '\u29C5': 'bsolb',
                '\u29C9': 'boxbox',
                '\u29CD': 'trisb',
                '\u29CE': 'rtriltri',
                '\u29CF': 'LeftTriangleBar',
                '\u29CF\u0338': 'NotLeftTriangleBar',
                '\u29D0': 'RightTriangleBar',
                '\u29D0\u0338': 'NotRightTriangleBar',
                '\u29DC': 'iinfin',
                '\u29DD': 'infintie',
                '\u29DE': 'nvinfin',
                '\u29E3': 'eparsl',
                '\u29E4': 'smeparsl',
                '\u29E5': 'eqvparsl',
                '\u29EB': 'lozf',
                '\u29F4': 'RuleDelayed',
                '\u29F6': 'dsol',
                '\u2A00': 'xodot',
                '\u2A01': 'xoplus',
                '\u2A02': 'xotime',
                '\u2A04': 'xuplus',
                '\u2A06': 'xsqcup',
                '\u2A0D': 'fpartint',
                '\u2A10': 'cirfnint',
                '\u2A11': 'awint',
                '\u2A12': 'rppolint',
                '\u2A13': 'scpolint',
                '\u2A14': 'npolint',
                '\u2A15': 'pointint',
                '\u2A16': 'quatint',
                '\u2A17': 'intlarhk',
                '\u2A22': 'pluscir',
                '\u2A23': 'plusacir',
                '\u2A24': 'simplus',
                '\u2A25': 'plusdu',
                '\u2A26': 'plussim',
                '\u2A27': 'plustwo',
                '\u2A29': 'mcomma',
                '\u2A2A': 'minusdu',
                '\u2A2D': 'loplus',
                '\u2A2E': 'roplus',
                '\u2A2F': 'Cross',
                '\u2A30': 'timesd',
                '\u2A31': 'timesbar',
                '\u2A33': 'smashp',
                '\u2A34': 'lotimes',
                '\u2A35': 'rotimes',
                '\u2A36': 'otimesas',
                '\u2A37': 'Otimes',
                '\u2A38': 'odiv',
                '\u2A39': 'triplus',
                '\u2A3A': 'triminus',
                '\u2A3B': 'tritime',
                '\u2A3C': 'iprod',
                '\u2A3F': 'amalg',
                '\u2A40': 'capdot',
                '\u2A42': 'ncup',
                '\u2A43': 'ncap',
                '\u2A44': 'capand',
                '\u2A45': 'cupor',
                '\u2A46': 'cupcap',
                '\u2A47': 'capcup',
                '\u2A48': 'cupbrcap',
                '\u2A49': 'capbrcup',
                '\u2A4A': 'cupcup',
                '\u2A4B': 'capcap',
                '\u2A4C': 'ccups',
                '\u2A4D': 'ccaps',
                '\u2A50': 'ccupssm',
                '\u2A53': 'And',
                '\u2A54': 'Or',
                '\u2A55': 'andand',
                '\u2A56': 'oror',
                '\u2A57': 'orslope',
                '\u2A58': 'andslope',
                '\u2A5A': 'andv',
                '\u2A5B': 'orv',
                '\u2A5C': 'andd',
                '\u2A5D': 'ord',
                '\u2A5F': 'wedbar',
                '\u2A66': 'sdote',
                '\u2A6A': 'simdot',
                '\u2A6D': 'congdot',
                '\u2A6D\u0338': 'ncongdot',
                '\u2A6E': 'easter',
                '\u2A6F': 'apacir',
                '\u2A70': 'apE',
                '\u2A70\u0338': 'napE',
                '\u2A71': 'eplus',
                '\u2A72': 'pluse',
                '\u2A73': 'Esim',
                '\u2A77': 'eDDot',
                '\u2A78': 'equivDD',
                '\u2A79': 'ltcir',
                '\u2A7A': 'gtcir',
                '\u2A7B': 'ltquest',
                '\u2A7C': 'gtquest',
                '\u2A7D': 'les',
                '\u2A7D\u0338': 'nles',
                '\u2A7E': 'ges',
                '\u2A7E\u0338': 'nges',
                '\u2A7F': 'lesdot',
                '\u2A80': 'gesdot',
                '\u2A81': 'lesdoto',
                '\u2A82': 'gesdoto',
                '\u2A83': 'lesdotor',
                '\u2A84': 'gesdotol',
                '\u2A85': 'lap',
                '\u2A86': 'gap',
                '\u2A87': 'lne',
                '\u2A88': 'gne',
                '\u2A89': 'lnap',
                '\u2A8A': 'gnap',
                '\u2A8B': 'lEg',
                '\u2A8C': 'gEl',
                '\u2A8D': 'lsime',
                '\u2A8E': 'gsime',
                '\u2A8F': 'lsimg',
                '\u2A90': 'gsiml',
                '\u2A91': 'lgE',
                '\u2A92': 'glE',
                '\u2A93': 'lesges',
                '\u2A94': 'gesles',
                '\u2A95': 'els',
                '\u2A96': 'egs',
                '\u2A97': 'elsdot',
                '\u2A98': 'egsdot',
                '\u2A99': 'el',
                '\u2A9A': 'eg',
                '\u2A9D': 'siml',
                '\u2A9E': 'simg',
                '\u2A9F': 'simlE',
                '\u2AA0': 'simgE',
                '\u2AA1': 'LessLess',
                '\u2AA1\u0338': 'NotNestedLessLess',
                '\u2AA2': 'GreaterGreater',
                '\u2AA2\u0338': 'NotNestedGreaterGreater',
                '\u2AA4': 'glj',
                '\u2AA5': 'gla',
                '\u2AA6': 'ltcc',
                '\u2AA7': 'gtcc',
                '\u2AA8': 'lescc',
                '\u2AA9': 'gescc',
                '\u2AAA': 'smt',
                '\u2AAB': 'lat',
                '\u2AAC': 'smte',
                '\u2AAC\uFE00': 'smtes',
                '\u2AAD': 'late',
                '\u2AAD\uFE00': 'lates',
                '\u2AAE': 'bumpE',
                '\u2AAF': 'pre',
                '\u2AAF\u0338': 'npre',
                '\u2AB0': 'sce',
                '\u2AB0\u0338': 'nsce',
                '\u2AB3': 'prE',
                '\u2AB4': 'scE',
                '\u2AB5': 'prnE',
                '\u2AB6': 'scnE',
                '\u2AB7': 'prap',
                '\u2AB8': 'scap',
                '\u2AB9': 'prnap',
                '\u2ABA': 'scnap',
                '\u2ABB': 'Pr',
                '\u2ABC': 'Sc',
                '\u2ABD': 'subdot',
                '\u2ABE': 'supdot',
                '\u2ABF': 'subplus',
                '\u2AC0': 'supplus',
                '\u2AC1': 'submult',
                '\u2AC2': 'supmult',
                '\u2AC3': 'subedot',
                '\u2AC4': 'supedot',
                '\u2AC5': 'subE',
                '\u2AC5\u0338': 'nsubE',
                '\u2AC6': 'supE',
                '\u2AC6\u0338': 'nsupE',
                '\u2AC7': 'subsim',
                '\u2AC8': 'supsim',
                '\u2ACB\uFE00': 'vsubnE',
                '\u2ACB': 'subnE',
                '\u2ACC\uFE00': 'vsupnE',
                '\u2ACC': 'supnE',
                '\u2ACF': 'csub',
                '\u2AD0': 'csup',
                '\u2AD1': 'csube',
                '\u2AD2': 'csupe',
                '\u2AD3': 'subsup',
                '\u2AD4': 'supsub',
                '\u2AD5': 'subsub',
                '\u2AD6': 'supsup',
                '\u2AD7': 'suphsub',
                '\u2AD8': 'supdsub',
                '\u2AD9': 'forkv',
                '\u2ADA': 'topfork',
                '\u2ADB': 'mlcp',
                '\u2AE4': 'Dashv',
                '\u2AE6': 'Vdashl',
                '\u2AE7': 'Barv',
                '\u2AE8': 'vBar',
                '\u2AE9': 'vBarv',
                '\u2AEB': 'Vbar',
                '\u2AEC': 'Not',
                '\u2AED': 'bNot',
                '\u2AEE': 'rnmid',
                '\u2AEF': 'cirmid',
                '\u2AF0': 'midcir',
                '\u2AF1': 'topcir',
                '\u2AF2': 'nhpar',
                '\u2AF3': 'parsim',
                '\u2AFD': 'parsl',
                '\u2AFD\u20E5': 'nparsl',
                '\u266D': 'flat',
                '\u266E': 'natur',
                '\u266F': 'sharp',
                '\xA4': 'curren',
                '\xA2': 'cent',
                '$': 'dollar',
                '\xA3': 'pound',
                '\xA5': 'yen',
                '\u20AC': 'euro',
                '\xB9': 'sup1',
                '\xBD': 'half',
                '\u2153': 'frac13',
                '\xBC': 'frac14',
                '\u2155': 'frac15',
                '\u2159': 'frac16',
                '\u215B': 'frac18',
                '\xB2': 'sup2',
                '\u2154': 'frac23',
                '\u2156': 'frac25',
                '\xB3': 'sup3',
                '\xBE': 'frac34',
                '\u2157': 'frac35',
                '\u215C': 'frac38',
                '\u2158': 'frac45',
                '\u215A': 'frac56',
                '\u215D': 'frac58',
                '\u215E': 'frac78',
                '\uD835\uDCB6': 'ascr',
                '\uD835\uDD52': 'aopf',
                '\uD835\uDD1E': 'afr',
                '\uD835\uDD38': 'Aopf',
                '\uD835\uDD04': 'Afr',
                '\uD835\uDC9C': 'Ascr',
                '\xAA': 'ordf',
                '\xE1': 'aacute',
                '\xC1': 'Aacute',
                '\xE0': 'agrave',
                '\xC0': 'Agrave',
                '\u0103': 'abreve',
                '\u0102': 'Abreve',
                '\xE2': 'acirc',
                '\xC2': 'Acirc',
                '\xE5': 'aring',
                '\xC5': 'angst',
                '\xE4': 'auml',
                '\xC4': 'Auml',
                '\xE3': 'atilde',
                '\xC3': 'Atilde',
                '\u0105': 'aogon',
                '\u0104': 'Aogon',
                '\u0101': 'amacr',
                '\u0100': 'Amacr',
                '\xE6': 'aelig',
                '\xC6': 'AElig',
                '\uD835\uDCB7': 'bscr',
                '\uD835\uDD53': 'bopf',
                '\uD835\uDD1F': 'bfr',
                '\uD835\uDD39': 'Bopf',
                '\u212C': 'Bscr',
                '\uD835\uDD05': 'Bfr',
                '\uD835\uDD20': 'cfr',
                '\uD835\uDCB8': 'cscr',
                '\uD835\uDD54': 'copf',
                '\u212D': 'Cfr',
                '\uD835\uDC9E': 'Cscr',
                '\u2102': 'Copf',
                '\u0107': 'cacute',
                '\u0106': 'Cacute',
                '\u0109': 'ccirc',
                '\u0108': 'Ccirc',
                '\u010D': 'ccaron',
                '\u010C': 'Ccaron',
                '\u010B': 'cdot',
                '\u010A': 'Cdot',
                '\xE7': 'ccedil',
                '\xC7': 'Ccedil',
                '\u2105': 'incare',
                '\uD835\uDD21': 'dfr',
                '\u2146': 'dd',
                '\uD835\uDD55': 'dopf',
                '\uD835\uDCB9': 'dscr',
                '\uD835\uDC9F': 'Dscr',
                '\uD835\uDD07': 'Dfr',
                '\u2145': 'DD',
                '\uD835\uDD3B': 'Dopf',
                '\u010F': 'dcaron',
                '\u010E': 'Dcaron',
                '\u0111': 'dstrok',
                '\u0110': 'Dstrok',
                '\xF0': 'eth',
                '\xD0': 'ETH',
                '\u2147': 'ee',
                '\u212F': 'escr',
                '\uD835\uDD22': 'efr',
                '\uD835\uDD56': 'eopf',
                '\u2130': 'Escr',
                '\uD835\uDD08': 'Efr',
                '\uD835\uDD3C': 'Eopf',
                '\xE9': 'eacute',
                '\xC9': 'Eacute',
                '\xE8': 'egrave',
                '\xC8': 'Egrave',
                '\xEA': 'ecirc',
                '\xCA': 'Ecirc',
                '\u011B': 'ecaron',
                '\u011A': 'Ecaron',
                '\xEB': 'euml',
                '\xCB': 'Euml',
                '\u0117': 'edot',
                '\u0116': 'Edot',
                '\u0119': 'eogon',
                '\u0118': 'Eogon',
                '\u0113': 'emacr',
                '\u0112': 'Emacr',
                '\uD835\uDD23': 'ffr',
                '\uD835\uDD57': 'fopf',
                '\uD835\uDCBB': 'fscr',
                '\uD835\uDD09': 'Ffr',
                '\uD835\uDD3D': 'Fopf',
                '\u2131': 'Fscr',
                '\uFB00': 'fflig',
                '\uFB03': 'ffilig',
                '\uFB04': 'ffllig',
                '\uFB01': 'filig',
                'fj': 'fjlig',
                '\uFB02': 'fllig',
                '\u0192': 'fnof',
                '\u210A': 'gscr',
                '\uD835\uDD58': 'gopf',
                '\uD835\uDD24': 'gfr',
                '\uD835\uDCA2': 'Gscr',
                '\uD835\uDD3E': 'Gopf',
                '\uD835\uDD0A': 'Gfr',
                '\u01F5': 'gacute',
                '\u011F': 'gbreve',
                '\u011E': 'Gbreve',
                '\u011D': 'gcirc',
                '\u011C': 'Gcirc',
                '\u0121': 'gdot',
                '\u0120': 'Gdot',
                '\u0122': 'Gcedil',
                '\uD835\uDD25': 'hfr',
                '\u210E': 'planckh',
                '\uD835\uDCBD': 'hscr',
                '\uD835\uDD59': 'hopf',
                '\u210B': 'Hscr',
                '\u210C': 'Hfr',
                '\u210D': 'Hopf',
                '\u0125': 'hcirc',
                '\u0124': 'Hcirc',
                '\u210F': 'hbar',
                '\u0127': 'hstrok',
                '\u0126': 'Hstrok',
                '\uD835\uDD5A': 'iopf',
                '\uD835\uDD26': 'ifr',
                '\uD835\uDCBE': 'iscr',
                '\u2148': 'ii',
                '\uD835\uDD40': 'Iopf',
                '\u2110': 'Iscr',
                '\u2111': 'Im',
                '\xED': 'iacute',
                '\xCD': 'Iacute',
                '\xEC': 'igrave',
                '\xCC': 'Igrave',
                '\xEE': 'icirc',
                '\xCE': 'Icirc',
                '\xEF': 'iuml',
                '\xCF': 'Iuml',
                '\u0129': 'itilde',
                '\u0128': 'Itilde',
                '\u0130': 'Idot',
                '\u012F': 'iogon',
                '\u012E': 'Iogon',
                '\u012B': 'imacr',
                '\u012A': 'Imacr',
                '\u0133': 'ijlig',
                '\u0132': 'IJlig',
                '\u0131': 'imath',
                '\uD835\uDCBF': 'jscr',
                '\uD835\uDD5B': 'jopf',
                '\uD835\uDD27': 'jfr',
                '\uD835\uDCA5': 'Jscr',
                '\uD835\uDD0D': 'Jfr',
                '\uD835\uDD41': 'Jopf',
                '\u0135': 'jcirc',
                '\u0134': 'Jcirc',
                '\u0237': 'jmath',
                '\uD835\uDD5C': 'kopf',
                '\uD835\uDCC0': 'kscr',
                '\uD835\uDD28': 'kfr',
                '\uD835\uDCA6': 'Kscr',
                '\uD835\uDD42': 'Kopf',
                '\uD835\uDD0E': 'Kfr',
                '\u0137': 'kcedil',
                '\u0136': 'Kcedil',
                '\uD835\uDD29': 'lfr',
                '\uD835\uDCC1': 'lscr',
                '\u2113': 'ell',
                '\uD835\uDD5D': 'lopf',
                '\u2112': 'Lscr',
                '\uD835\uDD0F': 'Lfr',
                '\uD835\uDD43': 'Lopf',
                '\u013A': 'lacute',
                '\u0139': 'Lacute',
                '\u013E': 'lcaron',
                '\u013D': 'Lcaron',
                '\u013C': 'lcedil',
                '\u013B': 'Lcedil',
                '\u0142': 'lstrok',
                '\u0141': 'Lstrok',
                '\u0140': 'lmidot',
                '\u013F': 'Lmidot',
                '\uD835\uDD2A': 'mfr',
                '\uD835\uDD5E': 'mopf',
                '\uD835\uDCC2': 'mscr',
                '\uD835\uDD10': 'Mfr',
                '\uD835\uDD44': 'Mopf',
                '\u2133': 'Mscr',
                '\uD835\uDD2B': 'nfr',
                '\uD835\uDD5F': 'nopf',
                '\uD835\uDCC3': 'nscr',
                '\u2115': 'Nopf',
                '\uD835\uDCA9': 'Nscr',
                '\uD835\uDD11': 'Nfr',
                '\u0144': 'nacute',
                '\u0143': 'Nacute',
                '\u0148': 'ncaron',
                '\u0147': 'Ncaron',
                '\xF1': 'ntilde',
                '\xD1': 'Ntilde',
                '\u0146': 'ncedil',
                '\u0145': 'Ncedil',
                '\u2116': 'numero',
                '\u014B': 'eng',
                '\u014A': 'ENG',
                '\uD835\uDD60': 'oopf',
                '\uD835\uDD2C': 'ofr',
                '\u2134': 'oscr',
                '\uD835\uDCAA': 'Oscr',
                '\uD835\uDD12': 'Ofr',
                '\uD835\uDD46': 'Oopf',
                '\xBA': 'ordm',
                '\xF3': 'oacute',
                '\xD3': 'Oacute',
                '\xF2': 'ograve',
                '\xD2': 'Ograve',
                '\xF4': 'ocirc',
                '\xD4': 'Ocirc',
                '\xF6': 'ouml',
                '\xD6': 'Ouml',
                '\u0151': 'odblac',
                '\u0150': 'Odblac',
                '\xF5': 'otilde',
                '\xD5': 'Otilde',
                '\xF8': 'oslash',
                '\xD8': 'Oslash',
                '\u014D': 'omacr',
                '\u014C': 'Omacr',
                '\u0153': 'oelig',
                '\u0152': 'OElig',
                '\uD835\uDD2D': 'pfr',
                '\uD835\uDCC5': 'pscr',
                '\uD835\uDD61': 'popf',
                '\u2119': 'Popf',
                '\uD835\uDD13': 'Pfr',
                '\uD835\uDCAB': 'Pscr',
                '\uD835\uDD62': 'qopf',
                '\uD835\uDD2E': 'qfr',
                '\uD835\uDCC6': 'qscr',
                '\uD835\uDCAC': 'Qscr',
                '\uD835\uDD14': 'Qfr',
                '\u211A': 'Qopf',
                '\u0138': 'kgreen',
                '\uD835\uDD2F': 'rfr',
                '\uD835\uDD63': 'ropf',
                '\uD835\uDCC7': 'rscr',
                '\u211B': 'Rscr',
                '\u211C': 'Re',
                '\u211D': 'Ropf',
                '\u0155': 'racute',
                '\u0154': 'Racute',
                '\u0159': 'rcaron',
                '\u0158': 'Rcaron',
                '\u0157': 'rcedil',
                '\u0156': 'Rcedil',
                '\uD835\uDD64': 'sopf',
                '\uD835\uDCC8': 'sscr',
                '\uD835\uDD30': 'sfr',
                '\uD835\uDD4A': 'Sopf',
                '\uD835\uDD16': 'Sfr',
                '\uD835\uDCAE': 'Sscr',
                '\u24C8': 'oS',
                '\u015B': 'sacute',
                '\u015A': 'Sacute',
                '\u015D': 'scirc',
                '\u015C': 'Scirc',
                '\u0161': 'scaron',
                '\u0160': 'Scaron',
                '\u015F': 'scedil',
                '\u015E': 'Scedil',
                '\xDF': 'szlig',
                '\uD835\uDD31': 'tfr',
                '\uD835\uDCC9': 'tscr',
                '\uD835\uDD65': 'topf',
                '\uD835\uDCAF': 'Tscr',
                '\uD835\uDD17': 'Tfr',
                '\uD835\uDD4B': 'Topf',
                '\u0165': 'tcaron',
                '\u0164': 'Tcaron',
                '\u0163': 'tcedil',
                '\u0162': 'Tcedil',
                '\u2122': 'trade',
                '\u0167': 'tstrok',
                '\u0166': 'Tstrok',
                '\uD835\uDCCA': 'uscr',
                '\uD835\uDD66': 'uopf',
                '\uD835\uDD32': 'ufr',
                '\uD835\uDD4C': 'Uopf',
                '\uD835\uDD18': 'Ufr',
                '\uD835\uDCB0': 'Uscr',
                '\xFA': 'uacute',
                '\xDA': 'Uacute',
                '\xF9': 'ugrave',
                '\xD9': 'Ugrave',
                '\u016D': 'ubreve',
                '\u016C': 'Ubreve',
                '\xFB': 'ucirc',
                '\xDB': 'Ucirc',
                '\u016F': 'uring',
                '\u016E': 'Uring',
                '\xFC': 'uuml',
                '\xDC': 'Uuml',
                '\u0171': 'udblac',
                '\u0170': 'Udblac',
                '\u0169': 'utilde',
                '\u0168': 'Utilde',
                '\u0173': 'uogon',
                '\u0172': 'Uogon',
                '\u016B': 'umacr',
                '\u016A': 'Umacr',
                '\uD835\uDD33': 'vfr',
                '\uD835\uDD67': 'vopf',
                '\uD835\uDCCB': 'vscr',
                '\uD835\uDD19': 'Vfr',
                '\uD835\uDD4D': 'Vopf',
                '\uD835\uDCB1': 'Vscr',
                '\uD835\uDD68': 'wopf',
                '\uD835\uDCCC': 'wscr',
                '\uD835\uDD34': 'wfr',
                '\uD835\uDCB2': 'Wscr',
                '\uD835\uDD4E': 'Wopf',
                '\uD835\uDD1A': 'Wfr',
                '\u0175': 'wcirc',
                '\u0174': 'Wcirc',
                '\uD835\uDD35': 'xfr',
                '\uD835\uDCCD': 'xscr',
                '\uD835\uDD69': 'xopf',
                '\uD835\uDD4F': 'Xopf',
                '\uD835\uDD1B': 'Xfr',
                '\uD835\uDCB3': 'Xscr',
                '\uD835\uDD36': 'yfr',
                '\uD835\uDCCE': 'yscr',
                '\uD835\uDD6A': 'yopf',
                '\uD835\uDCB4': 'Yscr',
                '\uD835\uDD1C': 'Yfr',
                '\uD835\uDD50': 'Yopf',
                '\xFD': 'yacute',
                '\xDD': 'Yacute',
                '\u0177': 'ycirc',
                '\u0176': 'Ycirc',
                '\xFF': 'yuml',
                '\u0178': 'Yuml',
                '\uD835\uDCCF': 'zscr',
                '\uD835\uDD37': 'zfr',
                '\uD835\uDD6B': 'zopf',
                '\u2128': 'Zfr',
                '\u2124': 'Zopf',
                '\uD835\uDCB5': 'Zscr',
                '\u017A': 'zacute',
                '\u0179': 'Zacute',
                '\u017E': 'zcaron',
                '\u017D': 'Zcaron',
                '\u017C': 'zdot',
                '\u017B': 'Zdot',
                '\u01B5': 'imped',
                '\xFE': 'thorn',
                '\xDE': 'THORN',
                '\u0149': 'napos',
                '\u03B1': 'alpha',
                '\u0391': 'Alpha',
                '\u03B2': 'beta',
                '\u0392': 'Beta',
                '\u03B3': 'gamma',
                '\u0393': 'Gamma',
                '\u03B4': 'delta',
                '\u0394': 'Delta',
                '\u03B5': 'epsi',
                '\u03F5': 'epsiv',
                '\u0395': 'Epsilon',
                '\u03DD': 'gammad',
                '\u03DC': 'Gammad',
                '\u03B6': 'zeta',
                '\u0396': 'Zeta',
                '\u03B7': 'eta',
                '\u0397': 'Eta',
                '\u03B8': 'theta',
                '\u03D1': 'thetav',
                '\u0398': 'Theta',
                '\u03B9': 'iota',
                '\u0399': 'Iota',
                '\u03BA': 'kappa',
                '\u03F0': 'kappav',
                '\u039A': 'Kappa',
                '\u03BB': 'lambda',
                '\u039B': 'Lambda',
                '\u03BC': 'mu',
                '\xB5': 'micro',
                '\u039C': 'Mu',
                '\u03BD': 'nu',
                '\u039D': 'Nu',
                '\u03BE': 'xi',
                '\u039E': 'Xi',
                '\u03BF': 'omicron',
                '\u039F': 'Omicron',
                '\u03C0': 'pi',
                '\u03D6': 'piv',
                '\u03A0': 'Pi',
                '\u03C1': 'rho',
                '\u03F1': 'rhov',
                '\u03A1': 'Rho',
                '\u03C3': 'sigma',
                '\u03A3': 'Sigma',
                '\u03C2': 'sigmaf',
                '\u03C4': 'tau',
                '\u03A4': 'Tau',
                '\u03C5': 'upsi',
                '\u03A5': 'Upsilon',
                '\u03D2': 'Upsi',
                '\u03C6': 'phi',
                '\u03D5': 'phiv',
                '\u03A6': 'Phi',
                '\u03C7': 'chi',
                '\u03A7': 'Chi',
                '\u03C8': 'psi',
                '\u03A8': 'Psi',
                '\u03C9': 'omega',
                '\u03A9': 'ohm',
                '\u0430': 'acy',
                '\u0410': 'Acy',
                '\u0431': 'bcy',
                '\u0411': 'Bcy',
                '\u0432': 'vcy',
                '\u0412': 'Vcy',
                '\u0433': 'gcy',
                '\u0413': 'Gcy',
                '\u0453': 'gjcy',
                '\u0403': 'GJcy',
                '\u0434': 'dcy',
                '\u0414': 'Dcy',
                '\u0452': 'djcy',
                '\u0402': 'DJcy',
                '\u0435': 'iecy',
                '\u0415': 'IEcy',
                '\u0451': 'iocy',
                '\u0401': 'IOcy',
                '\u0454': 'jukcy',
                '\u0404': 'Jukcy',
                '\u0436': 'zhcy',
                '\u0416': 'ZHcy',
                '\u0437': 'zcy',
                '\u0417': 'Zcy',
                '\u0455': 'dscy',
                '\u0405': 'DScy',
                '\u0438': 'icy',
                '\u0418': 'Icy',
                '\u0456': 'iukcy',
                '\u0406': 'Iukcy',
                '\u0457': 'yicy',
                '\u0407': 'YIcy',
                '\u0439': 'jcy',
                '\u0419': 'Jcy',
                '\u0458': 'jsercy',
                '\u0408': 'Jsercy',
                '\u043A': 'kcy',
                '\u041A': 'Kcy',
                '\u045C': 'kjcy',
                '\u040C': 'KJcy',
                '\u043B': 'lcy',
                '\u041B': 'Lcy',
                '\u0459': 'ljcy',
                '\u0409': 'LJcy',
                '\u043C': 'mcy',
                '\u041C': 'Mcy',
                '\u043D': 'ncy',
                '\u041D': 'Ncy',
                '\u045A': 'njcy',
                '\u040A': 'NJcy',
                '\u043E': 'ocy',
                '\u041E': 'Ocy',
                '\u043F': 'pcy',
                '\u041F': 'Pcy',
                '\u0440': 'rcy',
                '\u0420': 'Rcy',
                '\u0441': 'scy',
                '\u0421': 'Scy',
                '\u0442': 'tcy',
                '\u0422': 'Tcy',
                '\u045B': 'tshcy',
                '\u040B': 'TSHcy',
                '\u0443': 'ucy',
                '\u0423': 'Ucy',
                '\u045E': 'ubrcy',
                '\u040E': 'Ubrcy',
                '\u0444': 'fcy',
                '\u0424': 'Fcy',
                '\u0445': 'khcy',
                '\u0425': 'KHcy',
                '\u0446': 'tscy',
                '\u0426': 'TScy',
                '\u0447': 'chcy',
                '\u0427': 'CHcy',
                '\u045F': 'dzcy',
                '\u040F': 'DZcy',
                '\u0448': 'shcy',
                '\u0428': 'SHcy',
                '\u0449': 'shchcy',
                '\u0429': 'SHCHcy',
                '\u044A': 'hardcy',
                '\u042A': 'HARDcy',
                '\u044B': 'ycy',
                '\u042B': 'Ycy',
                '\u044C': 'softcy',
                '\u042C': 'SOFTcy',
                '\u044D': 'ecy',
                '\u042D': 'Ecy',
                '\u044E': 'yucy',
                '\u042E': 'YUcy',
                '\u044F': 'yacy',
                '\u042F': 'YAcy',
                '\u2135': 'aleph',
                '\u2136': 'beth',
                '\u2137': 'gimel',
                '\u2138': 'daleth'
            };
            var regexEscape = /["&'<>`]/g;
            var escapeMap = {
                '"': '&quot;',
                '&': '&amp;',
                '\'': '&#x27;',
                '<': '&lt;',
                // See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
                // following is not strictly necessary unless its part of a tag or an
                // unquoted attribute value. Were only escaping it to support those
                // situations, and for XML support.
                '>': '&gt;',
                // In Internet Explorer  8, the backtick character can be used
                // to break out of (un)quoted attribute values or HTML comments.
                // See http://html5sec.org/#102, http://html5sec.org/#108, and
                // http://html5sec.org/#133.
                '`': '&#x60;'
            };
            var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
            var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
            var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
            var decodeMap = {
                'aacute': '\xE1',
                'Aacute': '\xC1',
                'abreve': '\u0103',
                'Abreve': '\u0102',
                'ac': '\u223E',
                'acd': '\u223F',
                'acE': '\u223E\u0333',
                'acirc': '\xE2',
                'Acirc': '\xC2',
                'acute': '\xB4',
                'acy': '\u0430',
                'Acy': '\u0410',
                'aelig': '\xE6',
                'AElig': '\xC6',
                'af': '\u2061',
                'afr': '\uD835\uDD1E',
                'Afr': '\uD835\uDD04',
                'agrave': '\xE0',
                'Agrave': '\xC0',
                'alefsym': '\u2135',
                'aleph': '\u2135',
                'alpha': '\u03B1',
                'Alpha': '\u0391',
                'amacr': '\u0101',
                'Amacr': '\u0100',
                'amalg': '\u2A3F',
                'amp': '&',
                'AMP': '&',
                'and': '\u2227',
                'And': '\u2A53',
                'andand': '\u2A55',
                'andd': '\u2A5C',
                'andslope': '\u2A58',
                'andv': '\u2A5A',
                'ang': '\u2220',
                'ange': '\u29A4',
                'angle': '\u2220',
                'angmsd': '\u2221',
                'angmsdaa': '\u29A8',
                'angmsdab': '\u29A9',
                'angmsdac': '\u29AA',
                'angmsdad': '\u29AB',
                'angmsdae': '\u29AC',
                'angmsdaf': '\u29AD',
                'angmsdag': '\u29AE',
                'angmsdah': '\u29AF',
                'angrt': '\u221F',
                'angrtvb': '\u22BE',
                'angrtvbd': '\u299D',
                'angsph': '\u2222',
                'angst': '\xC5',
                'angzarr': '\u237C',
                'aogon': '\u0105',
                'Aogon': '\u0104',
                'aopf': '\uD835\uDD52',
                'Aopf': '\uD835\uDD38',
                'ap': '\u2248',
                'apacir': '\u2A6F',
                'ape': '\u224A',
                'apE': '\u2A70',
                'apid': '\u224B',
                'apos': '\'',
                'ApplyFunction': '\u2061',
                'approx': '\u2248',
                'approxeq': '\u224A',
                'aring': '\xE5',
                'Aring': '\xC5',
                'ascr': '\uD835\uDCB6',
                'Ascr': '\uD835\uDC9C',
                'Assign': '\u2254',
                'ast': '*',
                'asymp': '\u2248',
                'asympeq': '\u224D',
                'atilde': '\xE3',
                'Atilde': '\xC3',
                'auml': '\xE4',
                'Auml': '\xC4',
                'awconint': '\u2233',
                'awint': '\u2A11',
                'backcong': '\u224C',
                'backepsilon': '\u03F6',
                'backprime': '\u2035',
                'backsim': '\u223D',
                'backsimeq': '\u22CD',
                'Backslash': '\u2216',
                'Barv': '\u2AE7',
                'barvee': '\u22BD',
                'barwed': '\u2305',
                'Barwed': '\u2306',
                'barwedge': '\u2305',
                'bbrk': '\u23B5',
                'bbrktbrk': '\u23B6',
                'bcong': '\u224C',
                'bcy': '\u0431',
                'Bcy': '\u0411',
                'bdquo': '\u201E',
                'becaus': '\u2235',
                'because': '\u2235',
                'Because': '\u2235',
                'bemptyv': '\u29B0',
                'bepsi': '\u03F6',
                'bernou': '\u212C',
                'Bernoullis': '\u212C',
                'beta': '\u03B2',
                'Beta': '\u0392',
                'beth': '\u2136',
                'between': '\u226C',
                'bfr': '\uD835\uDD1F',
                'Bfr': '\uD835\uDD05',
                'bigcap': '\u22C2',
                'bigcirc': '\u25EF',
                'bigcup': '\u22C3',
                'bigodot': '\u2A00',
                'bigoplus': '\u2A01',
                'bigotimes': '\u2A02',
                'bigsqcup': '\u2A06',
                'bigstar': '\u2605',
                'bigtriangledown': '\u25BD',
                'bigtriangleup': '\u25B3',
                'biguplus': '\u2A04',
                'bigvee': '\u22C1',
                'bigwedge': '\u22C0',
                'bkarow': '\u290D',
                'blacklozenge': '\u29EB',
                'blacksquare': '\u25AA',
                'blacktriangle': '\u25B4',
                'blacktriangledown': '\u25BE',
                'blacktriangleleft': '\u25C2',
                'blacktriangleright': '\u25B8',
                'blank': '\u2423',
                'blk12': '\u2592',
                'blk14': '\u2591',
                'blk34': '\u2593',
                'block': '\u2588',
                'bne': '=\u20E5',
                'bnequiv': '\u2261\u20E5',
                'bnot': '\u2310',
                'bNot': '\u2AED',
                'bopf': '\uD835\uDD53',
                'Bopf': '\uD835\uDD39',
                'bot': '\u22A5',
                'bottom': '\u22A5',
                'bowtie': '\u22C8',
                'boxbox': '\u29C9',
                'boxdl': '\u2510',
                'boxdL': '\u2555',
                'boxDl': '\u2556',
                'boxDL': '\u2557',
                'boxdr': '\u250C',
                'boxdR': '\u2552',
                'boxDr': '\u2553',
                'boxDR': '\u2554',
                'boxh': '\u2500',
                'boxH': '\u2550',
                'boxhd': '\u252C',
                'boxhD': '\u2565',
                'boxHd': '\u2564',
                'boxHD': '\u2566',
                'boxhu': '\u2534',
                'boxhU': '\u2568',
                'boxHu': '\u2567',
                'boxHU': '\u2569',
                'boxminus': '\u229F',
                'boxplus': '\u229E',
                'boxtimes': '\u22A0',
                'boxul': '\u2518',
                'boxuL': '\u255B',
                'boxUl': '\u255C',
                'boxUL': '\u255D',
                'boxur': '\u2514',
                'boxuR': '\u2558',
                'boxUr': '\u2559',
                'boxUR': '\u255A',
                'boxv': '\u2502',
                'boxV': '\u2551',
                'boxvh': '\u253C',
                'boxvH': '\u256A',
                'boxVh': '\u256B',
                'boxVH': '\u256C',
                'boxvl': '\u2524',
                'boxvL': '\u2561',
                'boxVl': '\u2562',
                'boxVL': '\u2563',
                'boxvr': '\u251C',
                'boxvR': '\u255E',
                'boxVr': '\u255F',
                'boxVR': '\u2560',
                'bprime': '\u2035',
                'breve': '\u02D8',
                'Breve': '\u02D8',
                'brvbar': '\xA6',
                'bscr': '\uD835\uDCB7',
                'Bscr': '\u212C',
                'bsemi': '\u204F',
                'bsim': '\u223D',
                'bsime': '\u22CD',
                'bsol': '\\',
                'bsolb': '\u29C5',
                'bsolhsub': '\u27C8',
                'bull': '\u2022',
                'bullet': '\u2022',
                'bump': '\u224E',
                'bumpe': '\u224F',
                'bumpE': '\u2AAE',
                'bumpeq': '\u224F',
                'Bumpeq': '\u224E',
                'cacute': '\u0107',
                'Cacute': '\u0106',
                'cap': '\u2229',
                'Cap': '\u22D2',
                'capand': '\u2A44',
                'capbrcup': '\u2A49',
                'capcap': '\u2A4B',
                'capcup': '\u2A47',
                'capdot': '\u2A40',
                'CapitalDifferentialD': '\u2145',
                'caps': '\u2229\uFE00',
                'caret': '\u2041',
                'caron': '\u02C7',
                'Cayleys': '\u212D',
                'ccaps': '\u2A4D',
                'ccaron': '\u010D',
                'Ccaron': '\u010C',
                'ccedil': '\xE7',
                'Ccedil': '\xC7',
                'ccirc': '\u0109',
                'Ccirc': '\u0108',
                'Cconint': '\u2230',
                'ccups': '\u2A4C',
                'ccupssm': '\u2A50',
                'cdot': '\u010B',
                'Cdot': '\u010A',
                'cedil': '\xB8',
                'Cedilla': '\xB8',
                'cemptyv': '\u29B2',
                'cent': '\xA2',
                'centerdot': '\xB7',
                'CenterDot': '\xB7',
                'cfr': '\uD835\uDD20',
                'Cfr': '\u212D',
                'chcy': '\u0447',
                'CHcy': '\u0427',
                'check': '\u2713',
                'checkmark': '\u2713',
                'chi': '\u03C7',
                'Chi': '\u03A7',
                'cir': '\u25CB',
                'circ': '\u02C6',
                'circeq': '\u2257',
                'circlearrowleft': '\u21BA',
                'circlearrowright': '\u21BB',
                'circledast': '\u229B',
                'circledcirc': '\u229A',
                'circleddash': '\u229D',
                'CircleDot': '\u2299',
                'circledR': '\xAE',
                'circledS': '\u24C8',
                'CircleMinus': '\u2296',
                'CirclePlus': '\u2295',
                'CircleTimes': '\u2297',
                'cire': '\u2257',
                'cirE': '\u29C3',
                'cirfnint': '\u2A10',
                'cirmid': '\u2AEF',
                'cirscir': '\u29C2',
                'ClockwiseContourIntegral': '\u2232',
                'CloseCurlyDoubleQuote': '\u201D',
                'CloseCurlyQuote': '\u2019',
                'clubs': '\u2663',
                'clubsuit': '\u2663',
                'colon': ':',
                'Colon': '\u2237',
                'colone': '\u2254',
                'Colone': '\u2A74',
                'coloneq': '\u2254',
                'comma': ',',
                'commat': '@',
                'comp': '\u2201',
                'compfn': '\u2218',
                'complement': '\u2201',
                'complexes': '\u2102',
                'cong': '\u2245',
                'congdot': '\u2A6D',
                'Congruent': '\u2261',
                'conint': '\u222E',
                'Conint': '\u222F',
                'ContourIntegral': '\u222E',
                'copf': '\uD835\uDD54',
                'Copf': '\u2102',
                'coprod': '\u2210',
                'Coproduct': '\u2210',
                'copy': '\xA9',
                'COPY': '\xA9',
                'copysr': '\u2117',
                'CounterClockwiseContourIntegral': '\u2233',
                'crarr': '\u21B5',
                'cross': '\u2717',
                'Cross': '\u2A2F',
                'cscr': '\uD835\uDCB8',
                'Cscr': '\uD835\uDC9E',
                'csub': '\u2ACF',
                'csube': '\u2AD1',
                'csup': '\u2AD0',
                'csupe': '\u2AD2',
                'ctdot': '\u22EF',
                'cudarrl': '\u2938',
                'cudarrr': '\u2935',
                'cuepr': '\u22DE',
                'cuesc': '\u22DF',
                'cularr': '\u21B6',
                'cularrp': '\u293D',
                'cup': '\u222A',
                'Cup': '\u22D3',
                'cupbrcap': '\u2A48',
                'cupcap': '\u2A46',
                'CupCap': '\u224D',
                'cupcup': '\u2A4A',
                'cupdot': '\u228D',
                'cupor': '\u2A45',
                'cups': '\u222A\uFE00',
                'curarr': '\u21B7',
                'curarrm': '\u293C',
                'curlyeqprec': '\u22DE',
                'curlyeqsucc': '\u22DF',
                'curlyvee': '\u22CE',
                'curlywedge': '\u22CF',
                'curren': '\xA4',
                'curvearrowleft': '\u21B6',
                'curvearrowright': '\u21B7',
                'cuvee': '\u22CE',
                'cuwed': '\u22CF',
                'cwconint': '\u2232',
                'cwint': '\u2231',
                'cylcty': '\u232D',
                'dagger': '\u2020',
                'Dagger': '\u2021',
                'daleth': '\u2138',
                'darr': '\u2193',
                'dArr': '\u21D3',
                'Darr': '\u21A1',
                'dash': '\u2010',
                'dashv': '\u22A3',
                'Dashv': '\u2AE4',
                'dbkarow': '\u290F',
                'dblac': '\u02DD',
                'dcaron': '\u010F',
                'Dcaron': '\u010E',
                'dcy': '\u0434',
                'Dcy': '\u0414',
                'dd': '\u2146',
                'DD': '\u2145',
                'ddagger': '\u2021',
                'ddarr': '\u21CA',
                'DDotrahd': '\u2911',
                'ddotseq': '\u2A77',
                'deg': '\xB0',
                'Del': '\u2207',
                'delta': '\u03B4',
                'Delta': '\u0394',
                'demptyv': '\u29B1',
                'dfisht': '\u297F',
                'dfr': '\uD835\uDD21',
                'Dfr': '\uD835\uDD07',
                'dHar': '\u2965',
                'dharl': '\u21C3',
                'dharr': '\u21C2',
                'DiacriticalAcute': '\xB4',
                'DiacriticalDot': '\u02D9',
                'DiacriticalDoubleAcute': '\u02DD',
                'DiacriticalGrave': '`',
                'DiacriticalTilde': '\u02DC',
                'diam': '\u22C4',
                'diamond': '\u22C4',
                'Diamond': '\u22C4',
                'diamondsuit': '\u2666',
                'diams': '\u2666',
                'die': '\xA8',
                'DifferentialD': '\u2146',
                'digamma': '\u03DD',
                'disin': '\u22F2',
                'div': '\xF7',
                'divide': '\xF7',
                'divideontimes': '\u22C7',
                'divonx': '\u22C7',
                'djcy': '\u0452',
                'DJcy': '\u0402',
                'dlcorn': '\u231E',
                'dlcrop': '\u230D',
                'dollar': '$',
                'dopf': '\uD835\uDD55',
                'Dopf': '\uD835\uDD3B',
                'dot': '\u02D9',
                'Dot': '\xA8',
                'DotDot': '\u20DC',
                'doteq': '\u2250',
                'doteqdot': '\u2251',
                'DotEqual': '\u2250',
                'dotminus': '\u2238',
                'dotplus': '\u2214',
                'dotsquare': '\u22A1',
                'doublebarwedge': '\u2306',
                'DoubleContourIntegral': '\u222F',
                'DoubleDot': '\xA8',
                'DoubleDownArrow': '\u21D3',
                'DoubleLeftArrow': '\u21D0',
                'DoubleLeftRightArrow': '\u21D4',
                'DoubleLeftTee': '\u2AE4',
                'DoubleLongLeftArrow': '\u27F8',
                'DoubleLongLeftRightArrow': '\u27FA',
                'DoubleLongRightArrow': '\u27F9',
                'DoubleRightArrow': '\u21D2',
                'DoubleRightTee': '\u22A8',
                'DoubleUpArrow': '\u21D1',
                'DoubleUpDownArrow': '\u21D5',
                'DoubleVerticalBar': '\u2225',
                'downarrow': '\u2193',
                'Downarrow': '\u21D3',
                'DownArrow': '\u2193',
                'DownArrowBar': '\u2913',
                'DownArrowUpArrow': '\u21F5',
                'DownBreve': '\u0311',
                'downdownarrows': '\u21CA',
                'downharpoonleft': '\u21C3',
                'downharpoonright': '\u21C2',
                'DownLeftRightVector': '\u2950',
                'DownLeftTeeVector': '\u295E',
                'DownLeftVector': '\u21BD',
                'DownLeftVectorBar': '\u2956',
                'DownRightTeeVector': '\u295F',
                'DownRightVector': '\u21C1',
                'DownRightVectorBar': '\u2957',
                'DownTee': '\u22A4',
                'DownTeeArrow': '\u21A7',
                'drbkarow': '\u2910',
                'drcorn': '\u231F',
                'drcrop': '\u230C',
                'dscr': '\uD835\uDCB9',
                'Dscr': '\uD835\uDC9F',
                'dscy': '\u0455',
                'DScy': '\u0405',
                'dsol': '\u29F6',
                'dstrok': '\u0111',
                'Dstrok': '\u0110',
                'dtdot': '\u22F1',
                'dtri': '\u25BF',
                'dtrif': '\u25BE',
                'duarr': '\u21F5',
                'duhar': '\u296F',
                'dwangle': '\u29A6',
                'dzcy': '\u045F',
                'DZcy': '\u040F',
                'dzigrarr': '\u27FF',
                'eacute': '\xE9',
                'Eacute': '\xC9',
                'easter': '\u2A6E',
                'ecaron': '\u011B',
                'Ecaron': '\u011A',
                'ecir': '\u2256',
                'ecirc': '\xEA',
                'Ecirc': '\xCA',
                'ecolon': '\u2255',
                'ecy': '\u044D',
                'Ecy': '\u042D',
                'eDDot': '\u2A77',
                'edot': '\u0117',
                'eDot': '\u2251',
                'Edot': '\u0116',
                'ee': '\u2147',
                'efDot': '\u2252',
                'efr': '\uD835\uDD22',
                'Efr': '\uD835\uDD08',
                'eg': '\u2A9A',
                'egrave': '\xE8',
                'Egrave': '\xC8',
                'egs': '\u2A96',
                'egsdot': '\u2A98',
                'el': '\u2A99',
                'Element': '\u2208',
                'elinters': '\u23E7',
                'ell': '\u2113',
                'els': '\u2A95',
                'elsdot': '\u2A97',
                'emacr': '\u0113',
                'Emacr': '\u0112',
                'empty': '\u2205',
                'emptyset': '\u2205',
                'EmptySmallSquare': '\u25FB',
                'emptyv': '\u2205',
                'EmptyVerySmallSquare': '\u25AB',
                'emsp': '\u2003',
                'emsp13': '\u2004',
                'emsp14': '\u2005',
                'eng': '\u014B',
                'ENG': '\u014A',
                'ensp': '\u2002',
                'eogon': '\u0119',
                'Eogon': '\u0118',
                'eopf': '\uD835\uDD56',
                'Eopf': '\uD835\uDD3C',
                'epar': '\u22D5',
                'eparsl': '\u29E3',
                'eplus': '\u2A71',
                'epsi': '\u03B5',
                'epsilon': '\u03B5',
                'Epsilon': '\u0395',
                'epsiv': '\u03F5',
                'eqcirc': '\u2256',
                'eqcolon': '\u2255',
                'eqsim': '\u2242',
                'eqslantgtr': '\u2A96',
                'eqslantless': '\u2A95',
                'Equal': '\u2A75',
                'equals': '=',
                'EqualTilde': '\u2242',
                'equest': '\u225F',
                'Equilibrium': '\u21CC',
                'equiv': '\u2261',
                'equivDD': '\u2A78',
                'eqvparsl': '\u29E5',
                'erarr': '\u2971',
                'erDot': '\u2253',
                'escr': '\u212F',
                'Escr': '\u2130',
                'esdot': '\u2250',
                'esim': '\u2242',
                'Esim': '\u2A73',
                'eta': '\u03B7',
                'Eta': '\u0397',
                'eth': '\xF0',
                'ETH': '\xD0',
                'euml': '\xEB',
                'Euml': '\xCB',
                'euro': '\u20AC',
                'excl': '!',
                'exist': '\u2203',
                'Exists': '\u2203',
                'expectation': '\u2130',
                'exponentiale': '\u2147',
                'ExponentialE': '\u2147',
                'fallingdotseq': '\u2252',
                'fcy': '\u0444',
                'Fcy': '\u0424',
                'female': '\u2640',
                'ffilig': '\uFB03',
                'fflig': '\uFB00',
                'ffllig': '\uFB04',
                'ffr': '\uD835\uDD23',
                'Ffr': '\uD835\uDD09',
                'filig': '\uFB01',
                'FilledSmallSquare': '\u25FC',
                'FilledVerySmallSquare': '\u25AA',
                'fjlig': 'fj',
                'flat': '\u266D',
                'fllig': '\uFB02',
                'fltns': '\u25B1',
                'fnof': '\u0192',
                'fopf': '\uD835\uDD57',
                'Fopf': '\uD835\uDD3D',
                'forall': '\u2200',
                'ForAll': '\u2200',
                'fork': '\u22D4',
                'forkv': '\u2AD9',
                'Fouriertrf': '\u2131',
                'fpartint': '\u2A0D',
                'frac12': '\xBD',
                'frac13': '\u2153',
                'frac14': '\xBC',
                'frac15': '\u2155',
                'frac16': '\u2159',
                'frac18': '\u215B',
                'frac23': '\u2154',
                'frac25': '\u2156',
                'frac34': '\xBE',
                'frac35': '\u2157',
                'frac38': '\u215C',
                'frac45': '\u2158',
                'frac56': '\u215A',
                'frac58': '\u215D',
                'frac78': '\u215E',
                'frasl': '\u2044',
                'frown': '\u2322',
                'fscr': '\uD835\uDCBB',
                'Fscr': '\u2131',
                'gacute': '\u01F5',
                'gamma': '\u03B3',
                'Gamma': '\u0393',
                'gammad': '\u03DD',
                'Gammad': '\u03DC',
                'gap': '\u2A86',
                'gbreve': '\u011F',
                'Gbreve': '\u011E',
                'Gcedil': '\u0122',
                'gcirc': '\u011D',
                'Gcirc': '\u011C',
                'gcy': '\u0433',
                'Gcy': '\u0413',
                'gdot': '\u0121',
                'Gdot': '\u0120',
                'ge': '\u2265',
                'gE': '\u2267',
                'gel': '\u22DB',
                'gEl': '\u2A8C',
                'geq': '\u2265',
                'geqq': '\u2267',
                'geqslant': '\u2A7E',
                'ges': '\u2A7E',
                'gescc': '\u2AA9',
                'gesdot': '\u2A80',
                'gesdoto': '\u2A82',
                'gesdotol': '\u2A84',
                'gesl': '\u22DB\uFE00',
                'gesles': '\u2A94',
                'gfr': '\uD835\uDD24',
                'Gfr': '\uD835\uDD0A',
                'gg': '\u226B',
                'Gg': '\u22D9',
                'ggg': '\u22D9',
                'gimel': '\u2137',
                'gjcy': '\u0453',
                'GJcy': '\u0403',
                'gl': '\u2277',
                'gla': '\u2AA5',
                'glE': '\u2A92',
                'glj': '\u2AA4',
                'gnap': '\u2A8A',
                'gnapprox': '\u2A8A',
                'gne': '\u2A88',
                'gnE': '\u2269',
                'gneq': '\u2A88',
                'gneqq': '\u2269',
                'gnsim': '\u22E7',
                'gopf': '\uD835\uDD58',
                'Gopf': '\uD835\uDD3E',
                'grave': '`',
                'GreaterEqual': '\u2265',
                'GreaterEqualLess': '\u22DB',
                'GreaterFullEqual': '\u2267',
                'GreaterGreater': '\u2AA2',
                'GreaterLess': '\u2277',
                'GreaterSlantEqual': '\u2A7E',
                'GreaterTilde': '\u2273',
                'gscr': '\u210A',
                'Gscr': '\uD835\uDCA2',
                'gsim': '\u2273',
                'gsime': '\u2A8E',
                'gsiml': '\u2A90',
                'gt': '>',
                'Gt': '\u226B',
                'GT': '>',
                'gtcc': '\u2AA7',
                'gtcir': '\u2A7A',
                'gtdot': '\u22D7',
                'gtlPar': '\u2995',
                'gtquest': '\u2A7C',
                'gtrapprox': '\u2A86',
                'gtrarr': '\u2978',
                'gtrdot': '\u22D7',
                'gtreqless': '\u22DB',
                'gtreqqless': '\u2A8C',
                'gtrless': '\u2277',
                'gtrsim': '\u2273',
                'gvertneqq': '\u2269\uFE00',
                'gvnE': '\u2269\uFE00',
                'Hacek': '\u02C7',
                'hairsp': '\u200A',
                'half': '\xBD',
                'hamilt': '\u210B',
                'hardcy': '\u044A',
                'HARDcy': '\u042A',
                'harr': '\u2194',
                'hArr': '\u21D4',
                'harrcir': '\u2948',
                'harrw': '\u21AD',
                'Hat': '^',
                'hbar': '\u210F',
                'hcirc': '\u0125',
                'Hcirc': '\u0124',
                'hearts': '\u2665',
                'heartsuit': '\u2665',
                'hellip': '\u2026',
                'hercon': '\u22B9',
                'hfr': '\uD835\uDD25',
                'Hfr': '\u210C',
                'HilbertSpace': '\u210B',
                'hksearow': '\u2925',
                'hkswarow': '\u2926',
                'hoarr': '\u21FF',
                'homtht': '\u223B',
                'hookleftarrow': '\u21A9',
                'hookrightarrow': '\u21AA',
                'hopf': '\uD835\uDD59',
                'Hopf': '\u210D',
                'horbar': '\u2015',
                'HorizontalLine': '\u2500',
                'hscr': '\uD835\uDCBD',
                'Hscr': '\u210B',
                'hslash': '\u210F',
                'hstrok': '\u0127',
                'Hstrok': '\u0126',
                'HumpDownHump': '\u224E',
                'HumpEqual': '\u224F',
                'hybull': '\u2043',
                'hyphen': '\u2010',
                'iacute': '\xED',
                'Iacute': '\xCD',
                'ic': '\u2063',
                'icirc': '\xEE',
                'Icirc': '\xCE',
                'icy': '\u0438',
                'Icy': '\u0418',
                'Idot': '\u0130',
                'iecy': '\u0435',
                'IEcy': '\u0415',
                'iexcl': '\xA1',
                'iff': '\u21D4',
                'ifr': '\uD835\uDD26',
                'Ifr': '\u2111',
                'igrave': '\xEC',
                'Igrave': '\xCC',
                'ii': '\u2148',
                'iiiint': '\u2A0C',
                'iiint': '\u222D',
                'iinfin': '\u29DC',
                'iiota': '\u2129',
                'ijlig': '\u0133',
                'IJlig': '\u0132',
                'Im': '\u2111',
                'imacr': '\u012B',
                'Imacr': '\u012A',
                'image': '\u2111',
                'ImaginaryI': '\u2148',
                'imagline': '\u2110',
                'imagpart': '\u2111',
                'imath': '\u0131',
                'imof': '\u22B7',
                'imped': '\u01B5',
                'Implies': '\u21D2',
                'in': '\u2208',
                'incare': '\u2105',
                'infin': '\u221E',
                'infintie': '\u29DD',
                'inodot': '\u0131',
                'int': '\u222B',
                'Int': '\u222C',
                'intcal': '\u22BA',
                'integers': '\u2124',
                'Integral': '\u222B',
                'intercal': '\u22BA',
                'Intersection': '\u22C2',
                'intlarhk': '\u2A17',
                'intprod': '\u2A3C',
                'InvisibleComma': '\u2063',
                'InvisibleTimes': '\u2062',
                'iocy': '\u0451',
                'IOcy': '\u0401',
                'iogon': '\u012F',
                'Iogon': '\u012E',
                'iopf': '\uD835\uDD5A',
                'Iopf': '\uD835\uDD40',
                'iota': '\u03B9',
                'Iota': '\u0399',
                'iprod': '\u2A3C',
                'iquest': '\xBF',
                'iscr': '\uD835\uDCBE',
                'Iscr': '\u2110',
                'isin': '\u2208',
                'isindot': '\u22F5',
                'isinE': '\u22F9',
                'isins': '\u22F4',
                'isinsv': '\u22F3',
                'isinv': '\u2208',
                'it': '\u2062',
                'itilde': '\u0129',
                'Itilde': '\u0128',
                'iukcy': '\u0456',
                'Iukcy': '\u0406',
                'iuml': '\xEF',
                'Iuml': '\xCF',
                'jcirc': '\u0135',
                'Jcirc': '\u0134',
                'jcy': '\u0439',
                'Jcy': '\u0419',
                'jfr': '\uD835\uDD27',
                'Jfr': '\uD835\uDD0D',
                'jmath': '\u0237',
                'jopf': '\uD835\uDD5B',
                'Jopf': '\uD835\uDD41',
                'jscr': '\uD835\uDCBF',
                'Jscr': '\uD835\uDCA5',
                'jsercy': '\u0458',
                'Jsercy': '\u0408',
                'jukcy': '\u0454',
                'Jukcy': '\u0404',
                'kappa': '\u03BA',
                'Kappa': '\u039A',
                'kappav': '\u03F0',
                'kcedil': '\u0137',
                'Kcedil': '\u0136',
                'kcy': '\u043A',
                'Kcy': '\u041A',
                'kfr': '\uD835\uDD28',
                'Kfr': '\uD835\uDD0E',
                'kgreen': '\u0138',
                'khcy': '\u0445',
                'KHcy': '\u0425',
                'kjcy': '\u045C',
                'KJcy': '\u040C',
                'kopf': '\uD835\uDD5C',
                'Kopf': '\uD835\uDD42',
                'kscr': '\uD835\uDCC0',
                'Kscr': '\uD835\uDCA6',
                'lAarr': '\u21DA',
                'lacute': '\u013A',
                'Lacute': '\u0139',
                'laemptyv': '\u29B4',
                'lagran': '\u2112',
                'lambda': '\u03BB',
                'Lambda': '\u039B',
                'lang': '\u27E8',
                'Lang': '\u27EA',
                'langd': '\u2991',
                'langle': '\u27E8',
                'lap': '\u2A85',
                'Laplacetrf': '\u2112',
                'laquo': '\xAB',
                'larr': '\u2190',
                'lArr': '\u21D0',
                'Larr': '\u219E',
                'larrb': '\u21E4',
                'larrbfs': '\u291F',
                'larrfs': '\u291D',
                'larrhk': '\u21A9',
                'larrlp': '\u21AB',
                'larrpl': '\u2939',
                'larrsim': '\u2973',
                'larrtl': '\u21A2',
                'lat': '\u2AAB',
                'latail': '\u2919',
                'lAtail': '\u291B',
                'late': '\u2AAD',
                'lates': '\u2AAD\uFE00',
                'lbarr': '\u290C',
                'lBarr': '\u290E',
                'lbbrk': '\u2772',
                'lbrace': '{',
                'lbrack': '[',
                'lbrke': '\u298B',
                'lbrksld': '\u298F',
                'lbrkslu': '\u298D',
                'lcaron': '\u013E',
                'Lcaron': '\u013D',
                'lcedil': '\u013C',
                'Lcedil': '\u013B',
                'lceil': '\u2308',
                'lcub': '{',
                'lcy': '\u043B',
                'Lcy': '\u041B',
                'ldca': '\u2936',
                'ldquo': '\u201C',
                'ldquor': '\u201E',
                'ldrdhar': '\u2967',
                'ldrushar': '\u294B',
                'ldsh': '\u21B2',
                'le': '\u2264',
                'lE': '\u2266',
                'LeftAngleBracket': '\u27E8',
                'leftarrow': '\u2190',
                'Leftarrow': '\u21D0',
                'LeftArrow': '\u2190',
                'LeftArrowBar': '\u21E4',
                'LeftArrowRightArrow': '\u21C6',
                'leftarrowtail': '\u21A2',
                'LeftCeiling': '\u2308',
                'LeftDoubleBracket': '\u27E6',
                'LeftDownTeeVector': '\u2961',
                'LeftDownVector': '\u21C3',
                'LeftDownVectorBar': '\u2959',
                'LeftFloor': '\u230A',
                'leftharpoondown': '\u21BD',
                'leftharpoonup': '\u21BC',
                'leftleftarrows': '\u21C7',
                'leftrightarrow': '\u2194',
                'Leftrightarrow': '\u21D4',
                'LeftRightArrow': '\u2194',
                'leftrightarrows': '\u21C6',
                'leftrightharpoons': '\u21CB',
                'leftrightsquigarrow': '\u21AD',
                'LeftRightVector': '\u294E',
                'LeftTee': '\u22A3',
                'LeftTeeArrow': '\u21A4',
                'LeftTeeVector': '\u295A',
                'leftthreetimes': '\u22CB',
                'LeftTriangle': '\u22B2',
                'LeftTriangleBar': '\u29CF',
                'LeftTriangleEqual': '\u22B4',
                'LeftUpDownVector': '\u2951',
                'LeftUpTeeVector': '\u2960',
                'LeftUpVector': '\u21BF',
                'LeftUpVectorBar': '\u2958',
                'LeftVector': '\u21BC',
                'LeftVectorBar': '\u2952',
                'leg': '\u22DA',
                'lEg': '\u2A8B',
                'leq': '\u2264',
                'leqq': '\u2266',
                'leqslant': '\u2A7D',
                'les': '\u2A7D',
                'lescc': '\u2AA8',
                'lesdot': '\u2A7F',
                'lesdoto': '\u2A81',
                'lesdotor': '\u2A83',
                'lesg': '\u22DA\uFE00',
                'lesges': '\u2A93',
                'lessapprox': '\u2A85',
                'lessdot': '\u22D6',
                'lesseqgtr': '\u22DA',
                'lesseqqgtr': '\u2A8B',
                'LessEqualGreater': '\u22DA',
                'LessFullEqual': '\u2266',
                'LessGreater': '\u2276',
                'lessgtr': '\u2276',
                'LessLess': '\u2AA1',
                'lesssim': '\u2272',
                'LessSlantEqual': '\u2A7D',
                'LessTilde': '\u2272',
                'lfisht': '\u297C',
                'lfloor': '\u230A',
                'lfr': '\uD835\uDD29',
                'Lfr': '\uD835\uDD0F',
                'lg': '\u2276',
                'lgE': '\u2A91',
                'lHar': '\u2962',
                'lhard': '\u21BD',
                'lharu': '\u21BC',
                'lharul': '\u296A',
                'lhblk': '\u2584',
                'ljcy': '\u0459',
                'LJcy': '\u0409',
                'll': '\u226A',
                'Ll': '\u22D8',
                'llarr': '\u21C7',
                'llcorner': '\u231E',
                'Lleftarrow': '\u21DA',
                'llhard': '\u296B',
                'lltri': '\u25FA',
                'lmidot': '\u0140',
                'Lmidot': '\u013F',
                'lmoust': '\u23B0',
                'lmoustache': '\u23B0',
                'lnap': '\u2A89',
                'lnapprox': '\u2A89',
                'lne': '\u2A87',
                'lnE': '\u2268',
                'lneq': '\u2A87',
                'lneqq': '\u2268',
                'lnsim': '\u22E6',
                'loang': '\u27EC',
                'loarr': '\u21FD',
                'lobrk': '\u27E6',
                'longleftarrow': '\u27F5',
                'Longleftarrow': '\u27F8',
                'LongLeftArrow': '\u27F5',
                'longleftrightarrow': '\u27F7',
                'Longleftrightarrow': '\u27FA',
                'LongLeftRightArrow': '\u27F7',
                'longmapsto': '\u27FC',
                'longrightarrow': '\u27F6',
                'Longrightarrow': '\u27F9',
                'LongRightArrow': '\u27F6',
                'looparrowleft': '\u21AB',
                'looparrowright': '\u21AC',
                'lopar': '\u2985',
                'lopf': '\uD835\uDD5D',
                'Lopf': '\uD835\uDD43',
                'loplus': '\u2A2D',
                'lotimes': '\u2A34',
                'lowast': '\u2217',
                'lowbar': '_',
                'LowerLeftArrow': '\u2199',
                'LowerRightArrow': '\u2198',
                'loz': '\u25CA',
                'lozenge': '\u25CA',
                'lozf': '\u29EB',
                'lpar': '(',
                'lparlt': '\u2993',
                'lrarr': '\u21C6',
                'lrcorner': '\u231F',
                'lrhar': '\u21CB',
                'lrhard': '\u296D',
                'lrm': '\u200E',
                'lrtri': '\u22BF',
                'lsaquo': '\u2039',
                'lscr': '\uD835\uDCC1',
                'Lscr': '\u2112',
                'lsh': '\u21B0',
                'Lsh': '\u21B0',
                'lsim': '\u2272',
                'lsime': '\u2A8D',
                'lsimg': '\u2A8F',
                'lsqb': '[',
                'lsquo': '\u2018',
                'lsquor': '\u201A',
                'lstrok': '\u0142',
                'Lstrok': '\u0141',
                'lt': '<',
                'Lt': '\u226A',
                'LT': '<',
                'ltcc': '\u2AA6',
                'ltcir': '\u2A79',
                'ltdot': '\u22D6',
                'lthree': '\u22CB',
                'ltimes': '\u22C9',
                'ltlarr': '\u2976',
                'ltquest': '\u2A7B',
                'ltri': '\u25C3',
                'ltrie': '\u22B4',
                'ltrif': '\u25C2',
                'ltrPar': '\u2996',
                'lurdshar': '\u294A',
                'luruhar': '\u2966',
                'lvertneqq': '\u2268\uFE00',
                'lvnE': '\u2268\uFE00',
                'macr': '\xAF',
                'male': '\u2642',
                'malt': '\u2720',
                'maltese': '\u2720',
                'map': '\u21A6',
                'Map': '\u2905',
                'mapsto': '\u21A6',
                'mapstodown': '\u21A7',
                'mapstoleft': '\u21A4',
                'mapstoup': '\u21A5',
                'marker': '\u25AE',
                'mcomma': '\u2A29',
                'mcy': '\u043C',
                'Mcy': '\u041C',
                'mdash': '\u2014',
                'mDDot': '\u223A',
                'measuredangle': '\u2221',
                'MediumSpace': '\u205F',
                'Mellintrf': '\u2133',
                'mfr': '\uD835\uDD2A',
                'Mfr': '\uD835\uDD10',
                'mho': '\u2127',
                'micro': '\xB5',
                'mid': '\u2223',
                'midast': '*',
                'midcir': '\u2AF0',
                'middot': '\xB7',
                'minus': '\u2212',
                'minusb': '\u229F',
                'minusd': '\u2238',
                'minusdu': '\u2A2A',
                'MinusPlus': '\u2213',
                'mlcp': '\u2ADB',
                'mldr': '\u2026',
                'mnplus': '\u2213',
                'models': '\u22A7',
                'mopf': '\uD835\uDD5E',
                'Mopf': '\uD835\uDD44',
                'mp': '\u2213',
                'mscr': '\uD835\uDCC2',
                'Mscr': '\u2133',
                'mstpos': '\u223E',
                'mu': '\u03BC',
                'Mu': '\u039C',
                'multimap': '\u22B8',
                'mumap': '\u22B8',
                'nabla': '\u2207',
                'nacute': '\u0144',
                'Nacute': '\u0143',
                'nang': '\u2220\u20D2',
                'nap': '\u2249',
                'napE': '\u2A70\u0338',
                'napid': '\u224B\u0338',
                'napos': '\u0149',
                'napprox': '\u2249',
                'natur': '\u266E',
                'natural': '\u266E',
                'naturals': '\u2115',
                'nbsp': '\xA0',
                'nbump': '\u224E\u0338',
                'nbumpe': '\u224F\u0338',
                'ncap': '\u2A43',
                'ncaron': '\u0148',
                'Ncaron': '\u0147',
                'ncedil': '\u0146',
                'Ncedil': '\u0145',
                'ncong': '\u2247',
                'ncongdot': '\u2A6D\u0338',
                'ncup': '\u2A42',
                'ncy': '\u043D',
                'Ncy': '\u041D',
                'ndash': '\u2013',
                'ne': '\u2260',
                'nearhk': '\u2924',
                'nearr': '\u2197',
                'neArr': '\u21D7',
                'nearrow': '\u2197',
                'nedot': '\u2250\u0338',
                'NegativeMediumSpace': '\u200B',
                'NegativeThickSpace': '\u200B',
                'NegativeThinSpace': '\u200B',
                'NegativeVeryThinSpace': '\u200B',
                'nequiv': '\u2262',
                'nesear': '\u2928',
                'nesim': '\u2242\u0338',
                'NestedGreaterGreater': '\u226B',
                'NestedLessLess': '\u226A',
                'NewLine': '\n',
                'nexist': '\u2204',
                'nexists': '\u2204',
                'nfr': '\uD835\uDD2B',
                'Nfr': '\uD835\uDD11',
                'nge': '\u2271',
                'ngE': '\u2267\u0338',
                'ngeq': '\u2271',
                'ngeqq': '\u2267\u0338',
                'ngeqslant': '\u2A7E\u0338',
                'nges': '\u2A7E\u0338',
                'nGg': '\u22D9\u0338',
                'ngsim': '\u2275',
                'ngt': '\u226F',
                'nGt': '\u226B\u20D2',
                'ngtr': '\u226F',
                'nGtv': '\u226B\u0338',
                'nharr': '\u21AE',
                'nhArr': '\u21CE',
                'nhpar': '\u2AF2',
                'ni': '\u220B',
                'nis': '\u22FC',
                'nisd': '\u22FA',
                'niv': '\u220B',
                'njcy': '\u045A',
                'NJcy': '\u040A',
                'nlarr': '\u219A',
                'nlArr': '\u21CD',
                'nldr': '\u2025',
                'nle': '\u2270',
                'nlE': '\u2266\u0338',
                'nleftarrow': '\u219A',
                'nLeftarrow': '\u21CD',
                'nleftrightarrow': '\u21AE',
                'nLeftrightarrow': '\u21CE',
                'nleq': '\u2270',
                'nleqq': '\u2266\u0338',
                'nleqslant': '\u2A7D\u0338',
                'nles': '\u2A7D\u0338',
                'nless': '\u226E',
                'nLl': '\u22D8\u0338',
                'nlsim': '\u2274',
                'nlt': '\u226E',
                'nLt': '\u226A\u20D2',
                'nltri': '\u22EA',
                'nltrie': '\u22EC',
                'nLtv': '\u226A\u0338',
                'nmid': '\u2224',
                'NoBreak': '\u2060',
                'NonBreakingSpace': '\xA0',
                'nopf': '\uD835\uDD5F',
                'Nopf': '\u2115',
                'not': '\xAC',
                'Not': '\u2AEC',
                'NotCongruent': '\u2262',
                'NotCupCap': '\u226D',
                'NotDoubleVerticalBar': '\u2226',
                'NotElement': '\u2209',
                'NotEqual': '\u2260',
                'NotEqualTilde': '\u2242\u0338',
                'NotExists': '\u2204',
                'NotGreater': '\u226F',
                'NotGreaterEqual': '\u2271',
                'NotGreaterFullEqual': '\u2267\u0338',
                'NotGreaterGreater': '\u226B\u0338',
                'NotGreaterLess': '\u2279',
                'NotGreaterSlantEqual': '\u2A7E\u0338',
                'NotGreaterTilde': '\u2275',
                'NotHumpDownHump': '\u224E\u0338',
                'NotHumpEqual': '\u224F\u0338',
                'notin': '\u2209',
                'notindot': '\u22F5\u0338',
                'notinE': '\u22F9\u0338',
                'notinva': '\u2209',
                'notinvb': '\u22F7',
                'notinvc': '\u22F6',
                'NotLeftTriangle': '\u22EA',
                'NotLeftTriangleBar': '\u29CF\u0338',
                'NotLeftTriangleEqual': '\u22EC',
                'NotLess': '\u226E',
                'NotLessEqual': '\u2270',
                'NotLessGreater': '\u2278',
                'NotLessLess': '\u226A\u0338',
                'NotLessSlantEqual': '\u2A7D\u0338',
                'NotLessTilde': '\u2274',
                'NotNestedGreaterGreater': '\u2AA2\u0338',
                'NotNestedLessLess': '\u2AA1\u0338',
                'notni': '\u220C',
                'notniva': '\u220C',
                'notnivb': '\u22FE',
                'notnivc': '\u22FD',
                'NotPrecedes': '\u2280',
                'NotPrecedesEqual': '\u2AAF\u0338',
                'NotPrecedesSlantEqual': '\u22E0',
                'NotReverseElement': '\u220C',
                'NotRightTriangle': '\u22EB',
                'NotRightTriangleBar': '\u29D0\u0338',
                'NotRightTriangleEqual': '\u22ED',
                'NotSquareSubset': '\u228F\u0338',
                'NotSquareSubsetEqual': '\u22E2',
                'NotSquareSuperset': '\u2290\u0338',
                'NotSquareSupersetEqual': '\u22E3',
                'NotSubset': '\u2282\u20D2',
                'NotSubsetEqual': '\u2288',
                'NotSucceeds': '\u2281',
                'NotSucceedsEqual': '\u2AB0\u0338',
                'NotSucceedsSlantEqual': '\u22E1',
                'NotSucceedsTilde': '\u227F\u0338',
                'NotSuperset': '\u2283\u20D2',
                'NotSupersetEqual': '\u2289',
                'NotTilde': '\u2241',
                'NotTildeEqual': '\u2244',
                'NotTildeFullEqual': '\u2247',
                'NotTildeTilde': '\u2249',
                'NotVerticalBar': '\u2224',
                'npar': '\u2226',
                'nparallel': '\u2226',
                'nparsl': '\u2AFD\u20E5',
                'npart': '\u2202\u0338',
                'npolint': '\u2A14',
                'npr': '\u2280',
                'nprcue': '\u22E0',
                'npre': '\u2AAF\u0338',
                'nprec': '\u2280',
                'npreceq': '\u2AAF\u0338',
                'nrarr': '\u219B',
                'nrArr': '\u21CF',
                'nrarrc': '\u2933\u0338',
                'nrarrw': '\u219D\u0338',
                'nrightarrow': '\u219B',
                'nRightarrow': '\u21CF',
                'nrtri': '\u22EB',
                'nrtrie': '\u22ED',
                'nsc': '\u2281',
                'nsccue': '\u22E1',
                'nsce': '\u2AB0\u0338',
                'nscr': '\uD835\uDCC3',
                'Nscr': '\uD835\uDCA9',
                'nshortmid': '\u2224',
                'nshortparallel': '\u2226',
                'nsim': '\u2241',
                'nsime': '\u2244',
                'nsimeq': '\u2244',
                'nsmid': '\u2224',
                'nspar': '\u2226',
                'nsqsube': '\u22E2',
                'nsqsupe': '\u22E3',
                'nsub': '\u2284',
                'nsube': '\u2288',
                'nsubE': '\u2AC5\u0338',
                'nsubset': '\u2282\u20D2',
                'nsubseteq': '\u2288',
                'nsubseteqq': '\u2AC5\u0338',
                'nsucc': '\u2281',
                'nsucceq': '\u2AB0\u0338',
                'nsup': '\u2285',
                'nsupe': '\u2289',
                'nsupE': '\u2AC6\u0338',
                'nsupset': '\u2283\u20D2',
                'nsupseteq': '\u2289',
                'nsupseteqq': '\u2AC6\u0338',
                'ntgl': '\u2279',
                'ntilde': '\xF1',
                'Ntilde': '\xD1',
                'ntlg': '\u2278',
                'ntriangleleft': '\u22EA',
                'ntrianglelefteq': '\u22EC',
                'ntriangleright': '\u22EB',
                'ntrianglerighteq': '\u22ED',
                'nu': '\u03BD',
                'Nu': '\u039D',
                'num': '#',
                'numero': '\u2116',
                'numsp': '\u2007',
                'nvap': '\u224D\u20D2',
                'nvdash': '\u22AC',
                'nvDash': '\u22AD',
                'nVdash': '\u22AE',
                'nVDash': '\u22AF',
                'nvge': '\u2265\u20D2',
                'nvgt': '>\u20D2',
                'nvHarr': '\u2904',
                'nvinfin': '\u29DE',
                'nvlArr': '\u2902',
                'nvle': '\u2264\u20D2',
                'nvlt': '<\u20D2',
                'nvltrie': '\u22B4\u20D2',
                'nvrArr': '\u2903',
                'nvrtrie': '\u22B5\u20D2',
                'nvsim': '\u223C\u20D2',
                'nwarhk': '\u2923',
                'nwarr': '\u2196',
                'nwArr': '\u21D6',
                'nwarrow': '\u2196',
                'nwnear': '\u2927',
                'oacute': '\xF3',
                'Oacute': '\xD3',
                'oast': '\u229B',
                'ocir': '\u229A',
                'ocirc': '\xF4',
                'Ocirc': '\xD4',
                'ocy': '\u043E',
                'Ocy': '\u041E',
                'odash': '\u229D',
                'odblac': '\u0151',
                'Odblac': '\u0150',
                'odiv': '\u2A38',
                'odot': '\u2299',
                'odsold': '\u29BC',
                'oelig': '\u0153',
                'OElig': '\u0152',
                'ofcir': '\u29BF',
                'ofr': '\uD835\uDD2C',
                'Ofr': '\uD835\uDD12',
                'ogon': '\u02DB',
                'ograve': '\xF2',
                'Ograve': '\xD2',
                'ogt': '\u29C1',
                'ohbar': '\u29B5',
                'ohm': '\u03A9',
                'oint': '\u222E',
                'olarr': '\u21BA',
                'olcir': '\u29BE',
                'olcross': '\u29BB',
                'oline': '\u203E',
                'olt': '\u29C0',
                'omacr': '\u014D',
                'Omacr': '\u014C',
                'omega': '\u03C9',
                'Omega': '\u03A9',
                'omicron': '\u03BF',
                'Omicron': '\u039F',
                'omid': '\u29B6',
                'ominus': '\u2296',
                'oopf': '\uD835\uDD60',
                'Oopf': '\uD835\uDD46',
                'opar': '\u29B7',
                'OpenCurlyDoubleQuote': '\u201C',
                'OpenCurlyQuote': '\u2018',
                'operp': '\u29B9',
                'oplus': '\u2295',
                'or': '\u2228',
                'Or': '\u2A54',
                'orarr': '\u21BB',
                'ord': '\u2A5D',
                'order': '\u2134',
                'orderof': '\u2134',
                'ordf': '\xAA',
                'ordm': '\xBA',
                'origof': '\u22B6',
                'oror': '\u2A56',
                'orslope': '\u2A57',
                'orv': '\u2A5B',
                'oS': '\u24C8',
                'oscr': '\u2134',
                'Oscr': '\uD835\uDCAA',
                'oslash': '\xF8',
                'Oslash': '\xD8',
                'osol': '\u2298',
                'otilde': '\xF5',
                'Otilde': '\xD5',
                'otimes': '\u2297',
                'Otimes': '\u2A37',
                'otimesas': '\u2A36',
                'ouml': '\xF6',
                'Ouml': '\xD6',
                'ovbar': '\u233D',
                'OverBar': '\u203E',
                'OverBrace': '\u23DE',
                'OverBracket': '\u23B4',
                'OverParenthesis': '\u23DC',
                'par': '\u2225',
                'para': '\xB6',
                'parallel': '\u2225',
                'parsim': '\u2AF3',
                'parsl': '\u2AFD',
                'part': '\u2202',
                'PartialD': '\u2202',
                'pcy': '\u043F',
                'Pcy': '\u041F',
                'percnt': '%',
                'period': '.',
                'permil': '\u2030',
                'perp': '\u22A5',
                'pertenk': '\u2031',
                'pfr': '\uD835\uDD2D',
                'Pfr': '\uD835\uDD13',
                'phi': '\u03C6',
                'Phi': '\u03A6',
                'phiv': '\u03D5',
                'phmmat': '\u2133',
                'phone': '\u260E',
                'pi': '\u03C0',
                'Pi': '\u03A0',
                'pitchfork': '\u22D4',
                'piv': '\u03D6',
                'planck': '\u210F',
                'planckh': '\u210E',
                'plankv': '\u210F',
                'plus': '+',
                'plusacir': '\u2A23',
                'plusb': '\u229E',
                'pluscir': '\u2A22',
                'plusdo': '\u2214',
                'plusdu': '\u2A25',
                'pluse': '\u2A72',
                'PlusMinus': '\xB1',
                'plusmn': '\xB1',
                'plussim': '\u2A26',
                'plustwo': '\u2A27',
                'pm': '\xB1',
                'Poincareplane': '\u210C',
                'pointint': '\u2A15',
                'popf': '\uD835\uDD61',
                'Popf': '\u2119',
                'pound': '\xA3',
                'pr': '\u227A',
                'Pr': '\u2ABB',
                'prap': '\u2AB7',
                'prcue': '\u227C',
                'pre': '\u2AAF',
                'prE': '\u2AB3',
                'prec': '\u227A',
                'precapprox': '\u2AB7',
                'preccurlyeq': '\u227C',
                'Precedes': '\u227A',
                'PrecedesEqual': '\u2AAF',
                'PrecedesSlantEqual': '\u227C',
                'PrecedesTilde': '\u227E',
                'preceq': '\u2AAF',
                'precnapprox': '\u2AB9',
                'precneqq': '\u2AB5',
                'precnsim': '\u22E8',
                'precsim': '\u227E',
                'prime': '\u2032',
                'Prime': '\u2033',
                'primes': '\u2119',
                'prnap': '\u2AB9',
                'prnE': '\u2AB5',
                'prnsim': '\u22E8',
                'prod': '\u220F',
                'Product': '\u220F',
                'profalar': '\u232E',
                'profline': '\u2312',
                'profsurf': '\u2313',
                'prop': '\u221D',
                'Proportion': '\u2237',
                'Proportional': '\u221D',
                'propto': '\u221D',
                'prsim': '\u227E',
                'prurel': '\u22B0',
                'pscr': '\uD835\uDCC5',
                'Pscr': '\uD835\uDCAB',
                'psi': '\u03C8',
                'Psi': '\u03A8',
                'puncsp': '\u2008',
                'qfr': '\uD835\uDD2E',
                'Qfr': '\uD835\uDD14',
                'qint': '\u2A0C',
                'qopf': '\uD835\uDD62',
                'Qopf': '\u211A',
                'qprime': '\u2057',
                'qscr': '\uD835\uDCC6',
                'Qscr': '\uD835\uDCAC',
                'quaternions': '\u210D',
                'quatint': '\u2A16',
                'quest': '?',
                'questeq': '\u225F',
                'quot': '"',
                'QUOT': '"',
                'rAarr': '\u21DB',
                'race': '\u223D\u0331',
                'racute': '\u0155',
                'Racute': '\u0154',
                'radic': '\u221A',
                'raemptyv': '\u29B3',
                'rang': '\u27E9',
                'Rang': '\u27EB',
                'rangd': '\u2992',
                'range': '\u29A5',
                'rangle': '\u27E9',
                'raquo': '\xBB',
                'rarr': '\u2192',
                'rArr': '\u21D2',
                'Rarr': '\u21A0',
                'rarrap': '\u2975',
                'rarrb': '\u21E5',
                'rarrbfs': '\u2920',
                'rarrc': '\u2933',
                'rarrfs': '\u291E',
                'rarrhk': '\u21AA',
                'rarrlp': '\u21AC',
                'rarrpl': '\u2945',
                'rarrsim': '\u2974',
                'rarrtl': '\u21A3',
                'Rarrtl': '\u2916',
                'rarrw': '\u219D',
                'ratail': '\u291A',
                'rAtail': '\u291C',
                'ratio': '\u2236',
                'rationals': '\u211A',
                'rbarr': '\u290D',
                'rBarr': '\u290F',
                'RBarr': '\u2910',
                'rbbrk': '\u2773',
                'rbrace': '}',
                'rbrack': ']',
                'rbrke': '\u298C',
                'rbrksld': '\u298E',
                'rbrkslu': '\u2990',
                'rcaron': '\u0159',
                'Rcaron': '\u0158',
                'rcedil': '\u0157',
                'Rcedil': '\u0156',
                'rceil': '\u2309',
                'rcub': '}',
                'rcy': '\u0440',
                'Rcy': '\u0420',
                'rdca': '\u2937',
                'rdldhar': '\u2969',
                'rdquo': '\u201D',
                'rdquor': '\u201D',
                'rdsh': '\u21B3',
                'Re': '\u211C',
                'real': '\u211C',
                'realine': '\u211B',
                'realpart': '\u211C',
                'reals': '\u211D',
                'rect': '\u25AD',
                'reg': '\xAE',
                'REG': '\xAE',
                'ReverseElement': '\u220B',
                'ReverseEquilibrium': '\u21CB',
                'ReverseUpEquilibrium': '\u296F',
                'rfisht': '\u297D',
                'rfloor': '\u230B',
                'rfr': '\uD835\uDD2F',
                'Rfr': '\u211C',
                'rHar': '\u2964',
                'rhard': '\u21C1',
                'rharu': '\u21C0',
                'rharul': '\u296C',
                'rho': '\u03C1',
                'Rho': '\u03A1',
                'rhov': '\u03F1',
                'RightAngleBracket': '\u27E9',
                'rightarrow': '\u2192',
                'Rightarrow': '\u21D2',
                'RightArrow': '\u2192',
                'RightArrowBar': '\u21E5',
                'RightArrowLeftArrow': '\u21C4',
                'rightarrowtail': '\u21A3',
                'RightCeiling': '\u2309',
                'RightDoubleBracket': '\u27E7',
                'RightDownTeeVector': '\u295D',
                'RightDownVector': '\u21C2',
                'RightDownVectorBar': '\u2955',
                'RightFloor': '\u230B',
                'rightharpoondown': '\u21C1',
                'rightharpoonup': '\u21C0',
                'rightleftarrows': '\u21C4',
                'rightleftharpoons': '\u21CC',
                'rightrightarrows': '\u21C9',
                'rightsquigarrow': '\u219D',
                'RightTee': '\u22A2',
                'RightTeeArrow': '\u21A6',
                'RightTeeVector': '\u295B',
                'rightthreetimes': '\u22CC',
                'RightTriangle': '\u22B3',
                'RightTriangleBar': '\u29D0',
                'RightTriangleEqual': '\u22B5',
                'RightUpDownVector': '\u294F',
                'RightUpTeeVector': '\u295C',
                'RightUpVector': '\u21BE',
                'RightUpVectorBar': '\u2954',
                'RightVector': '\u21C0',
                'RightVectorBar': '\u2953',
                'ring': '\u02DA',
                'risingdotseq': '\u2253',
                'rlarr': '\u21C4',
                'rlhar': '\u21CC',
                'rlm': '\u200F',
                'rmoust': '\u23B1',
                'rmoustache': '\u23B1',
                'rnmid': '\u2AEE',
                'roang': '\u27ED',
                'roarr': '\u21FE',
                'robrk': '\u27E7',
                'ropar': '\u2986',
                'ropf': '\uD835\uDD63',
                'Ropf': '\u211D',
                'roplus': '\u2A2E',
                'rotimes': '\u2A35',
                'RoundImplies': '\u2970',
                'rpar': ')',
                'rpargt': '\u2994',
                'rppolint': '\u2A12',
                'rrarr': '\u21C9',
                'Rrightarrow': '\u21DB',
                'rsaquo': '\u203A',
                'rscr': '\uD835\uDCC7',
                'Rscr': '\u211B',
                'rsh': '\u21B1',
                'Rsh': '\u21B1',
                'rsqb': ']',
                'rsquo': '\u2019',
                'rsquor': '\u2019',
                'rthree': '\u22CC',
                'rtimes': '\u22CA',
                'rtri': '\u25B9',
                'rtrie': '\u22B5',
                'rtrif': '\u25B8',
                'rtriltri': '\u29CE',
                'RuleDelayed': '\u29F4',
                'ruluhar': '\u2968',
                'rx': '\u211E',
                'sacute': '\u015B',
                'Sacute': '\u015A',
                'sbquo': '\u201A',
                'sc': '\u227B',
                'Sc': '\u2ABC',
                'scap': '\u2AB8',
                'scaron': '\u0161',
                'Scaron': '\u0160',
                'sccue': '\u227D',
                'sce': '\u2AB0',
                'scE': '\u2AB4',
                'scedil': '\u015F',
                'Scedil': '\u015E',
                'scirc': '\u015D',
                'Scirc': '\u015C',
                'scnap': '\u2ABA',
                'scnE': '\u2AB6',
                'scnsim': '\u22E9',
                'scpolint': '\u2A13',
                'scsim': '\u227F',
                'scy': '\u0441',
                'Scy': '\u0421',
                'sdot': '\u22C5',
                'sdotb': '\u22A1',
                'sdote': '\u2A66',
                'searhk': '\u2925',
                'searr': '\u2198',
                'seArr': '\u21D8',
                'searrow': '\u2198',
                'sect': '\xA7',
                'semi': ';',
                'seswar': '\u2929',
                'setminus': '\u2216',
                'setmn': '\u2216',
                'sext': '\u2736',
                'sfr': '\uD835\uDD30',
                'Sfr': '\uD835\uDD16',
                'sfrown': '\u2322',
                'sharp': '\u266F',
                'shchcy': '\u0449',
                'SHCHcy': '\u0429',
                'shcy': '\u0448',
                'SHcy': '\u0428',
                'ShortDownArrow': '\u2193',
                'ShortLeftArrow': '\u2190',
                'shortmid': '\u2223',
                'shortparallel': '\u2225',
                'ShortRightArrow': '\u2192',
                'ShortUpArrow': '\u2191',
                'shy': '\xAD',
                'sigma': '\u03C3',
                'Sigma': '\u03A3',
                'sigmaf': '\u03C2',
                'sigmav': '\u03C2',
                'sim': '\u223C',
                'simdot': '\u2A6A',
                'sime': '\u2243',
                'simeq': '\u2243',
                'simg': '\u2A9E',
                'simgE': '\u2AA0',
                'siml': '\u2A9D',
                'simlE': '\u2A9F',
                'simne': '\u2246',
                'simplus': '\u2A24',
                'simrarr': '\u2972',
                'slarr': '\u2190',
                'SmallCircle': '\u2218',
                'smallsetminus': '\u2216',
                'smashp': '\u2A33',
                'smeparsl': '\u29E4',
                'smid': '\u2223',
                'smile': '\u2323',
                'smt': '\u2AAA',
                'smte': '\u2AAC',
                'smtes': '\u2AAC\uFE00',
                'softcy': '\u044C',
                'SOFTcy': '\u042C',
                'sol': '/',
                'solb': '\u29C4',
                'solbar': '\u233F',
                'sopf': '\uD835\uDD64',
                'Sopf': '\uD835\uDD4A',
                'spades': '\u2660',
                'spadesuit': '\u2660',
                'spar': '\u2225',
                'sqcap': '\u2293',
                'sqcaps': '\u2293\uFE00',
                'sqcup': '\u2294',
                'sqcups': '\u2294\uFE00',
                'Sqrt': '\u221A',
                'sqsub': '\u228F',
                'sqsube': '\u2291',
                'sqsubset': '\u228F',
                'sqsubseteq': '\u2291',
                'sqsup': '\u2290',
                'sqsupe': '\u2292',
                'sqsupset': '\u2290',
                'sqsupseteq': '\u2292',
                'squ': '\u25A1',
                'square': '\u25A1',
                'Square': '\u25A1',
                'SquareIntersection': '\u2293',
                'SquareSubset': '\u228F',
                'SquareSubsetEqual': '\u2291',
                'SquareSuperset': '\u2290',
                'SquareSupersetEqual': '\u2292',
                'SquareUnion': '\u2294',
                'squarf': '\u25AA',
                'squf': '\u25AA',
                'srarr': '\u2192',
                'sscr': '\uD835\uDCC8',
                'Sscr': '\uD835\uDCAE',
                'ssetmn': '\u2216',
                'ssmile': '\u2323',
                'sstarf': '\u22C6',
                'star': '\u2606',
                'Star': '\u22C6',
                'starf': '\u2605',
                'straightepsilon': '\u03F5',
                'straightphi': '\u03D5',
                'strns': '\xAF',
                'sub': '\u2282',
                'Sub': '\u22D0',
                'subdot': '\u2ABD',
                'sube': '\u2286',
                'subE': '\u2AC5',
                'subedot': '\u2AC3',
                'submult': '\u2AC1',
                'subne': '\u228A',
                'subnE': '\u2ACB',
                'subplus': '\u2ABF',
                'subrarr': '\u2979',
                'subset': '\u2282',
                'Subset': '\u22D0',
                'subseteq': '\u2286',
                'subseteqq': '\u2AC5',
                'SubsetEqual': '\u2286',
                'subsetneq': '\u228A',
                'subsetneqq': '\u2ACB',
                'subsim': '\u2AC7',
                'subsub': '\u2AD5',
                'subsup': '\u2AD3',
                'succ': '\u227B',
                'succapprox': '\u2AB8',
                'succcurlyeq': '\u227D',
                'Succeeds': '\u227B',
                'SucceedsEqual': '\u2AB0',
                'SucceedsSlantEqual': '\u227D',
                'SucceedsTilde': '\u227F',
                'succeq': '\u2AB0',
                'succnapprox': '\u2ABA',
                'succneqq': '\u2AB6',
                'succnsim': '\u22E9',
                'succsim': '\u227F',
                'SuchThat': '\u220B',
                'sum': '\u2211',
                'Sum': '\u2211',
                'sung': '\u266A',
                'sup': '\u2283',
                'Sup': '\u22D1',
                'sup1': '\xB9',
                'sup2': '\xB2',
                'sup3': '\xB3',
                'supdot': '\u2ABE',
                'supdsub': '\u2AD8',
                'supe': '\u2287',
                'supE': '\u2AC6',
                'supedot': '\u2AC4',
                'Superset': '\u2283',
                'SupersetEqual': '\u2287',
                'suphsol': '\u27C9',
                'suphsub': '\u2AD7',
                'suplarr': '\u297B',
                'supmult': '\u2AC2',
                'supne': '\u228B',
                'supnE': '\u2ACC',
                'supplus': '\u2AC0',
                'supset': '\u2283',
                'Supset': '\u22D1',
                'supseteq': '\u2287',
                'supseteqq': '\u2AC6',
                'supsetneq': '\u228B',
                'supsetneqq': '\u2ACC',
                'supsim': '\u2AC8',
                'supsub': '\u2AD4',
                'supsup': '\u2AD6',
                'swarhk': '\u2926',
                'swarr': '\u2199',
                'swArr': '\u21D9',
                'swarrow': '\u2199',
                'swnwar': '\u292A',
                'szlig': '\xDF',
                'Tab': '\t',
                'target': '\u2316',
                'tau': '\u03C4',
                'Tau': '\u03A4',
                'tbrk': '\u23B4',
                'tcaron': '\u0165',
                'Tcaron': '\u0164',
                'tcedil': '\u0163',
                'Tcedil': '\u0162',
                'tcy': '\u0442',
                'Tcy': '\u0422',
                'tdot': '\u20DB',
                'telrec': '\u2315',
                'tfr': '\uD835\uDD31',
                'Tfr': '\uD835\uDD17',
                'there4': '\u2234',
                'therefore': '\u2234',
                'Therefore': '\u2234',
                'theta': '\u03B8',
                'Theta': '\u0398',
                'thetasym': '\u03D1',
                'thetav': '\u03D1',
                'thickapprox': '\u2248',
                'thicksim': '\u223C',
                'ThickSpace': '\u205F\u200A',
                'thinsp': '\u2009',
                'ThinSpace': '\u2009',
                'thkap': '\u2248',
                'thksim': '\u223C',
                'thorn': '\xFE',
                'THORN': '\xDE',
                'tilde': '\u02DC',
                'Tilde': '\u223C',
                'TildeEqual': '\u2243',
                'TildeFullEqual': '\u2245',
                'TildeTilde': '\u2248',
                'times': '\xD7',
                'timesb': '\u22A0',
                'timesbar': '\u2A31',
                'timesd': '\u2A30',
                'tint': '\u222D',
                'toea': '\u2928',
                'top': '\u22A4',
                'topbot': '\u2336',
                'topcir': '\u2AF1',
                'topf': '\uD835\uDD65',
                'Topf': '\uD835\uDD4B',
                'topfork': '\u2ADA',
                'tosa': '\u2929',
                'tprime': '\u2034',
                'trade': '\u2122',
                'TRADE': '\u2122',
                'triangle': '\u25B5',
                'triangledown': '\u25BF',
                'triangleleft': '\u25C3',
                'trianglelefteq': '\u22B4',
                'triangleq': '\u225C',
                'triangleright': '\u25B9',
                'trianglerighteq': '\u22B5',
                'tridot': '\u25EC',
                'trie': '\u225C',
                'triminus': '\u2A3A',
                'TripleDot': '\u20DB',
                'triplus': '\u2A39',
                'trisb': '\u29CD',
                'tritime': '\u2A3B',
                'trpezium': '\u23E2',
                'tscr': '\uD835\uDCC9',
                'Tscr': '\uD835\uDCAF',
                'tscy': '\u0446',
                'TScy': '\u0426',
                'tshcy': '\u045B',
                'TSHcy': '\u040B',
                'tstrok': '\u0167',
                'Tstrok': '\u0166',
                'twixt': '\u226C',
                'twoheadleftarrow': '\u219E',
                'twoheadrightarrow': '\u21A0',
                'uacute': '\xFA',
                'Uacute': '\xDA',
                'uarr': '\u2191',
                'uArr': '\u21D1',
                'Uarr': '\u219F',
                'Uarrocir': '\u2949',
                'ubrcy': '\u045E',
                'Ubrcy': '\u040E',
                'ubreve': '\u016D',
                'Ubreve': '\u016C',
                'ucirc': '\xFB',
                'Ucirc': '\xDB',
                'ucy': '\u0443',
                'Ucy': '\u0423',
                'udarr': '\u21C5',
                'udblac': '\u0171',
                'Udblac': '\u0170',
                'udhar': '\u296E',
                'ufisht': '\u297E',
                'ufr': '\uD835\uDD32',
                'Ufr': '\uD835\uDD18',
                'ugrave': '\xF9',
                'Ugrave': '\xD9',
                'uHar': '\u2963',
                'uharl': '\u21BF',
                'uharr': '\u21BE',
                'uhblk': '\u2580',
                'ulcorn': '\u231C',
                'ulcorner': '\u231C',
                'ulcrop': '\u230F',
                'ultri': '\u25F8',
                'umacr': '\u016B',
                'Umacr': '\u016A',
                'uml': '\xA8',
                'UnderBar': '_',
                'UnderBrace': '\u23DF',
                'UnderBracket': '\u23B5',
                'UnderParenthesis': '\u23DD',
                'Union': '\u22C3',
                'UnionPlus': '\u228E',
                'uogon': '\u0173',
                'Uogon': '\u0172',
                'uopf': '\uD835\uDD66',
                'Uopf': '\uD835\uDD4C',
                'uparrow': '\u2191',
                'Uparrow': '\u21D1',
                'UpArrow': '\u2191',
                'UpArrowBar': '\u2912',
                'UpArrowDownArrow': '\u21C5',
                'updownarrow': '\u2195',
                'Updownarrow': '\u21D5',
                'UpDownArrow': '\u2195',
                'UpEquilibrium': '\u296E',
                'upharpoonleft': '\u21BF',
                'upharpoonright': '\u21BE',
                'uplus': '\u228E',
                'UpperLeftArrow': '\u2196',
                'UpperRightArrow': '\u2197',
                'upsi': '\u03C5',
                'Upsi': '\u03D2',
                'upsih': '\u03D2',
                'upsilon': '\u03C5',
                'Upsilon': '\u03A5',
                'UpTee': '\u22A5',
                'UpTeeArrow': '\u21A5',
                'upuparrows': '\u21C8',
                'urcorn': '\u231D',
                'urcorner': '\u231D',
                'urcrop': '\u230E',
                'uring': '\u016F',
                'Uring': '\u016E',
                'urtri': '\u25F9',
                'uscr': '\uD835\uDCCA',
                'Uscr': '\uD835\uDCB0',
                'utdot': '\u22F0',
                'utilde': '\u0169',
                'Utilde': '\u0168',
                'utri': '\u25B5',
                'utrif': '\u25B4',
                'uuarr': '\u21C8',
                'uuml': '\xFC',
                'Uuml': '\xDC',
                'uwangle': '\u29A7',
                'vangrt': '\u299C',
                'varepsilon': '\u03F5',
                'varkappa': '\u03F0',
                'varnothing': '\u2205',
                'varphi': '\u03D5',
                'varpi': '\u03D6',
                'varpropto': '\u221D',
                'varr': '\u2195',
                'vArr': '\u21D5',
                'varrho': '\u03F1',
                'varsigma': '\u03C2',
                'varsubsetneq': '\u228A\uFE00',
                'varsubsetneqq': '\u2ACB\uFE00',
                'varsupsetneq': '\u228B\uFE00',
                'varsupsetneqq': '\u2ACC\uFE00',
                'vartheta': '\u03D1',
                'vartriangleleft': '\u22B2',
                'vartriangleright': '\u22B3',
                'vBar': '\u2AE8',
                'Vbar': '\u2AEB',
                'vBarv': '\u2AE9',
                'vcy': '\u0432',
                'Vcy': '\u0412',
                'vdash': '\u22A2',
                'vDash': '\u22A8',
                'Vdash': '\u22A9',
                'VDash': '\u22AB',
                'Vdashl': '\u2AE6',
                'vee': '\u2228',
                'Vee': '\u22C1',
                'veebar': '\u22BB',
                'veeeq': '\u225A',
                'vellip': '\u22EE',
                'verbar': '|',
                'Verbar': '\u2016',
                'vert': '|',
                'Vert': '\u2016',
                'VerticalBar': '\u2223',
                'VerticalLine': '|',
                'VerticalSeparator': '\u2758',
                'VerticalTilde': '\u2240',
                'VeryThinSpace': '\u200A',
                'vfr': '\uD835\uDD33',
                'Vfr': '\uD835\uDD19',
                'vltri': '\u22B2',
                'vnsub': '\u2282\u20D2',
                'vnsup': '\u2283\u20D2',
                'vopf': '\uD835\uDD67',
                'Vopf': '\uD835\uDD4D',
                'vprop': '\u221D',
                'vrtri': '\u22B3',
                'vscr': '\uD835\uDCCB',
                'Vscr': '\uD835\uDCB1',
                'vsubne': '\u228A\uFE00',
                'vsubnE': '\u2ACB\uFE00',
                'vsupne': '\u228B\uFE00',
                'vsupnE': '\u2ACC\uFE00',
                'Vvdash': '\u22AA',
                'vzigzag': '\u299A',
                'wcirc': '\u0175',
                'Wcirc': '\u0174',
                'wedbar': '\u2A5F',
                'wedge': '\u2227',
                'Wedge': '\u22C0',
                'wedgeq': '\u2259',
                'weierp': '\u2118',
                'wfr': '\uD835\uDD34',
                'Wfr': '\uD835\uDD1A',
                'wopf': '\uD835\uDD68',
                'Wopf': '\uD835\uDD4E',
                'wp': '\u2118',
                'wr': '\u2240',
                'wreath': '\u2240',
                'wscr': '\uD835\uDCCC',
                'Wscr': '\uD835\uDCB2',
                'xcap': '\u22C2',
                'xcirc': '\u25EF',
                'xcup': '\u22C3',
                'xdtri': '\u25BD',
                'xfr': '\uD835\uDD35',
                'Xfr': '\uD835\uDD1B',
                'xharr': '\u27F7',
                'xhArr': '\u27FA',
                'xi': '\u03BE',
                'Xi': '\u039E',
                'xlarr': '\u27F5',
                'xlArr': '\u27F8',
                'xmap': '\u27FC',
                'xnis': '\u22FB',
                'xodot': '\u2A00',
                'xopf': '\uD835\uDD69',
                'Xopf': '\uD835\uDD4F',
                'xoplus': '\u2A01',
                'xotime': '\u2A02',
                'xrarr': '\u27F6',
                'xrArr': '\u27F9',
                'xscr': '\uD835\uDCCD',
                'Xscr': '\uD835\uDCB3',
                'xsqcup': '\u2A06',
                'xuplus': '\u2A04',
                'xutri': '\u25B3',
                'xvee': '\u22C1',
                'xwedge': '\u22C0',
                'yacute': '\xFD',
                'Yacute': '\xDD',
                'yacy': '\u044F',
                'YAcy': '\u042F',
                'ycirc': '\u0177',
                'Ycirc': '\u0176',
                'ycy': '\u044B',
                'Ycy': '\u042B',
                'yen': '\xA5',
                'yfr': '\uD835\uDD36',
                'Yfr': '\uD835\uDD1C',
                'yicy': '\u0457',
                'YIcy': '\u0407',
                'yopf': '\uD835\uDD6A',
                'Yopf': '\uD835\uDD50',
                'yscr': '\uD835\uDCCE',
                'Yscr': '\uD835\uDCB4',
                'yucy': '\u044E',
                'YUcy': '\u042E',
                'yuml': '\xFF',
                'Yuml': '\u0178',
                'zacute': '\u017A',
                'Zacute': '\u0179',
                'zcaron': '\u017E',
                'Zcaron': '\u017D',
                'zcy': '\u0437',
                'Zcy': '\u0417',
                'zdot': '\u017C',
                'Zdot': '\u017B',
                'zeetrf': '\u2128',
                'ZeroWidthSpace': '\u200B',
                'zeta': '\u03B6',
                'Zeta': '\u0396',
                'zfr': '\uD835\uDD37',
                'Zfr': '\u2128',
                'zhcy': '\u0436',
                'ZHcy': '\u0416',
                'zigrarr': '\u21DD',
                'zopf': '\uD835\uDD6B',
                'Zopf': '\u2124',
                'zscr': '\uD835\uDCCF',
                'Zscr': '\uD835\uDCB5',
                'zwj': '\u200D',
                'zwnj': '\u200C'
            };
            var decodeMapLegacy = {
                'aacute': '\xE1',
                'Aacute': '\xC1',
                'acirc': '\xE2',
                'Acirc': '\xC2',
                'acute': '\xB4',
                'aelig': '\xE6',
                'AElig': '\xC6',
                'agrave': '\xE0',
                'Agrave': '\xC0',
                'amp': '&',
                'AMP': '&',
                'aring': '\xE5',
                'Aring': '\xC5',
                'atilde': '\xE3',
                'Atilde': '\xC3',
                'auml': '\xE4',
                'Auml': '\xC4',
                'brvbar': '\xA6',
                'ccedil': '\xE7',
                'Ccedil': '\xC7',
                'cedil': '\xB8',
                'cent': '\xA2',
                'copy': '\xA9',
                'COPY': '\xA9',
                'curren': '\xA4',
                'deg': '\xB0',
                'divide': '\xF7',
                'eacute': '\xE9',
                'Eacute': '\xC9',
                'ecirc': '\xEA',
                'Ecirc': '\xCA',
                'egrave': '\xE8',
                'Egrave': '\xC8',
                'eth': '\xF0',
                'ETH': '\xD0',
                'euml': '\xEB',
                'Euml': '\xCB',
                'frac12': '\xBD',
                'frac14': '\xBC',
                'frac34': '\xBE',
                'gt': '>',
                'GT': '>',
                'iacute': '\xED',
                'Iacute': '\xCD',
                'icirc': '\xEE',
                'Icirc': '\xCE',
                'iexcl': '\xA1',
                'igrave': '\xEC',
                'Igrave': '\xCC',
                'iquest': '\xBF',
                'iuml': '\xEF',
                'Iuml': '\xCF',
                'laquo': '\xAB',
                'lt': '<',
                'LT': '<',
                'macr': '\xAF',
                'micro': '\xB5',
                'middot': '\xB7',
                'nbsp': '\xA0',
                'not': '\xAC',
                'ntilde': '\xF1',
                'Ntilde': '\xD1',
                'oacute': '\xF3',
                'Oacute': '\xD3',
                'ocirc': '\xF4',
                'Ocirc': '\xD4',
                'ograve': '\xF2',
                'Ograve': '\xD2',
                'ordf': '\xAA',
                'ordm': '\xBA',
                'oslash': '\xF8',
                'Oslash': '\xD8',
                'otilde': '\xF5',
                'Otilde': '\xD5',
                'ouml': '\xF6',
                'Ouml': '\xD6',
                'para': '\xB6',
                'plusmn': '\xB1',
                'pound': '\xA3',
                'quot': '"',
                'QUOT': '"',
                'raquo': '\xBB',
                'reg': '\xAE',
                'REG': '\xAE',
                'sect': '\xA7',
                'shy': '\xAD',
                'sup1': '\xB9',
                'sup2': '\xB2',
                'sup3': '\xB3',
                'szlig': '\xDF',
                'thorn': '\xFE',
                'THORN': '\xDE',
                'times': '\xD7',
                'uacute': '\xFA',
                'Uacute': '\xDA',
                'ucirc': '\xFB',
                'Ucirc': '\xDB',
                'ugrave': '\xF9',
                'Ugrave': '\xD9',
                'uml': '\xA8',
                'uuml': '\xFC',
                'Uuml': '\xDC',
                'yacute': '\xFD',
                'Yacute': '\xDD',
                'yen': '\xA5',
                'yuml': '\xFF'
            };
            var decodeMapNumeric = {
                '0': '\uFFFD',
                '128': '\u20AC',
                '130': '\u201A',
                '131': '\u0192',
                '132': '\u201E',
                '133': '\u2026',
                '134': '\u2020',
                '135': '\u2021',
                '136': '\u02C6',
                '137': '\u2030',
                '138': '\u0160',
                '139': '\u2039',
                '140': '\u0152',
                '142': '\u017D',
                '145': '\u2018',
                '146': '\u2019',
                '147': '\u201C',
                '148': '\u201D',
                '149': '\u2022',
                '150': '\u2013',
                '151': '\u2014',
                '152': '\u02DC',
                '153': '\u2122',
                '154': '\u0161',
                '155': '\u203A',
                '156': '\u0153',
                '158': '\u017E',
                '159': '\u0178'
            };
            var invalidReferenceCodePoints = [1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991, 64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65000, 65001, 65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111];
            /*--------------------------------------------------------------------------*/
            var stringFromCharCode = String.fromCharCode;
            var object = {};
            var hasOwnProperty = object.hasOwnProperty;
            var has = function (object, propertyName) {
                return hasOwnProperty.call(object, propertyName);
            };
            var contains = function (array, value) {
                var index = -1;
                var length = array.length;
                while (++index < length) {
                    if (array[index] == value) {
                        return true;
                    }
                }
                return false;
            };
            var merge = function (options, defaults) {
                if (!options) {
                    return defaults;
                }
                var result = {};
                var key;
                for (key in defaults) {
                    // A `hasOwnProperty` check is not needed here, since only recognized
                    // option names are used anyway. Any others are ignored.
                    result[key] = has(options, key) ? options[key] : defaults[key];
                }
                return result;
            }; // Modified version of `ucs2encode`; see https://mths.be/punycode.
            var codePointToSymbol = function (codePoint, strict) {
                var output = '';
                if (codePoint >= 0xD800 && codePoint <= 0xDFFF || codePoint > 0x10FFFF) {
                    // See issue #4:
                    // Otherwise, if the number is in the range 0xD800 to 0xDFFF or is
                    // greater than 0x10FFFF, then this is a parse error. Return a U+FFFD
                    // REPLACEMENT CHARACTER.
                    if (strict) {
                        parseError('character reference outside the permissible Unicode range');
                    }
                    return '\uFFFD';
                }
                if (has(decodeMapNumeric, codePoint)) {
                    if (strict) {
                        parseError('disallowed character reference');
                    }
                    return decodeMapNumeric[codePoint];
                }
                if (strict && contains(invalidReferenceCodePoints, codePoint)) {
                    parseError('disallowed character reference');
                }
                if (codePoint > 0xFFFF) {
                    codePoint -= 0x10000;
                    output += stringFromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);
                    codePoint = 0xDC00 | codePoint & 0x3FF;
                }
                output += stringFromCharCode(codePoint);
                return output;
            };
            var hexEscape = function (codePoint) {
                return '&#x' + codePoint.toString(16).toUpperCase() + ';';
            };
            var decEscape = function (codePoint) {
                return '&#' + codePoint + ';';
            };
            var parseError = function (message) {
                throw Error('Parse error: ' + message);
            };
            /*--------------------------------------------------------------------------*/
            var encode = function (string, options) {
                options = merge(options, encode.options);
                var strict = options.strict;
                if (strict && regexInvalidRawCodePoint.test(string)) {
                    parseError('forbidden code point');
                }
                var encodeEverything = options.encodeEverything;
                var useNamedReferences = options.useNamedReferences;
                var allowUnsafeSymbols = options.allowUnsafeSymbols;
                var escapeCodePoint = options.decimal ? decEscape : hexEscape;
                var escapeBmpSymbol = function (symbol) {
                    return escapeCodePoint(symbol.charCodeAt(0));
                };
                if (encodeEverything) {
                    // Encode ASCII symbols.
                    string = string.replace(regexAsciiWhitelist, function (symbol) {
                        // Use named references if requested & possible.
                        if (useNamedReferences && has(encodeMap, symbol)) {
                            return '&' + encodeMap[symbol] + ';';
                        }
                        return escapeBmpSymbol(symbol);
                    }); // Shorten a few escapes that represent two symbols, of which at least one
                    // is within the ASCII range.
                    if (useNamedReferences) {
                        string = string.replace(/&gt;\u20D2/g, '&nvgt;').replace(/&lt;\u20D2/g, '&nvlt;').replace(/&#x66;&#x6A;/g, '&fjlig;');
                    } // Encode non-ASCII symbols.
                    if (useNamedReferences) {
                        // Encode non-ASCII symbols that can be replaced with a named reference.
                        string = string.replace(regexEncodeNonAscii, function (string) {
                            // Note: there is no need to check `has(encodeMap, string)` here.
                            return '&' + encodeMap[string] + ';';
                        });
                    } // Note: any remaining non-ASCII symbols are handled outside of the `if`.
                }
                else if (useNamedReferences) {
                    // Apply named character references.
                    // Encode `<>"'&` using named character references.
                    if (!allowUnsafeSymbols) {
                        string = string.replace(regexEscape, function (string) {
                            return '&' + encodeMap[string] + ';'; // no need to check `has()` here
                        });
                    } // Shorten escapes that represent two symbols, of which at least one is
                    // `<>"'&`.
                    string = string.replace(/&gt;\u20D2/g, '&nvgt;').replace(/&lt;\u20D2/g, '&nvlt;'); // Encode non-ASCII symbols that can be replaced with a named reference.
                    string = string.replace(regexEncodeNonAscii, function (string) {
                        // Note: there is no need to check `has(encodeMap, string)` here.
                        return '&' + encodeMap[string] + ';';
                    });
                }
                else if (!allowUnsafeSymbols) {
                    // Encode `<>"'&` using hexadecimal escapes, now that theyre not handled
                    // using named character references.
                    string = string.replace(regexEscape, escapeBmpSymbol);
                }
                return string // Encode astral symbols.
                    .replace(regexAstralSymbols, function ($0) {
                    // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                    var high = $0.charCodeAt(0);
                    var low = $0.charCodeAt(1);
                    var codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;
                    return escapeCodePoint(codePoint);
                }) // Encode any remaining BMP symbols that are not printable ASCII symbols
                    // using a hexadecimal escape.
                    .replace(regexBmpWhitelist, escapeBmpSymbol);
            }; // Expose default options (so they can be overridden globally).
            encode.options = {
                'allowUnsafeSymbols': false,
                'encodeEverything': false,
                'strict': false,
                'useNamedReferences': false,
                'decimal': false
            };
            var decode = function (html, options) {
                options = merge(options, decode.options);
                var strict = options.strict;
                if (strict && regexInvalidEntity.test(html)) {
                    parseError('malformed character reference');
                }
                return html.replace(regexDecode, function ($0, $1, $2, $3, $4, $5, $6, $7, $8) {
                    var codePoint;
                    var semicolon;
                    var decDigits;
                    var hexDigits;
                    var reference;
                    var next;
                    if ($1) {
                        reference = $1; // Note: there is no need to check `has(decodeMap, reference)`.
                        return decodeMap[reference];
                    }
                    if ($2) {
                        // Decode named character references without trailing `;`, e.g. `&amp`.
                        // This is only a parse error if it gets converted to `&`, or if it is
                        // followed by `=` in an attribute context.
                        reference = $2;
                        next = $3;
                        if (next && options.isAttributeValue) {
                            if (strict && next == '=') {
                                parseError('`&` did not start a character reference');
                            }
                            return $0;
                        }
                        else {
                            if (strict) {
                                parseError('named character reference was not terminated by a semicolon');
                            } // Note: there is no need to check `has(decodeMapLegacy, reference)`.
                            return decodeMapLegacy[reference] + (next || '');
                        }
                    }
                    if ($4) {
                        // Decode decimal escapes, e.g. `&#119558;`.
                        decDigits = $4;
                        semicolon = $5;
                        if (strict && !semicolon) {
                            parseError('character reference was not terminated by a semicolon');
                        }
                        codePoint = parseInt(decDigits, 10);
                        return codePointToSymbol(codePoint, strict);
                    }
                    if ($6) {
                        // Decode hexadecimal escapes, e.g. `&#x1D306;`.
                        hexDigits = $6;
                        semicolon = $7;
                        if (strict && !semicolon) {
                            parseError('character reference was not terminated by a semicolon');
                        }
                        codePoint = parseInt(hexDigits, 16);
                        return codePointToSymbol(codePoint, strict);
                    } // If were still here, `if ($7)` is implied; its an ambiguous
                    // ampersand for sure. https://mths.be/notes/ambiguous-ampersands
                    if (strict) {
                        parseError('named character reference was not terminated by a semicolon');
                    }
                    return $0;
                });
            }; // Expose default options (so they can be overridden globally).
            decode.options = {
                'isAttributeValue': false,
                'strict': false
            };
            var escape = function (string) {
                return string.replace(regexEscape, function ($0) {
                    // Note: there is no need to check `has(escapeMap, $0)` here.
                    return escapeMap[$0];
                });
            };
            /*--------------------------------------------------------------------------*/
            var he = {
                'version': '1.2.0',
                'encode': encode,
                'decode': decode,
                'escape': escape,
                'unescape': decode
            }; // Some AMD build optimizers, like r.js, check for specific condition patterns
            // like the following:
            if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
                define(function () {
                    return he;
                });
            }
            else if (freeExports && !freeExports.nodeType) {
                if (freeModule) {
                    // in Node.js, io.js, or RingoJS v0.8.0+
                    freeModule.exports = he;
                }
                else {
                    // in Narwhal or RingoJS v0.7.0-
                    for (var key in he) {
                        has(he, key) && (freeExports[key] = he[key]);
                    }
                }
            }
            else {
                // in Rhino or a web browser
                root.he = he;
            }
        })(exports);
        return module.exports;
    }
    exports_70("dew", dew);
    return {
        setters: [],
        execute: function () {
            exports = {}, _dewExec = false;
            module = {
                exports: exports
            };
            _global = typeof self !== "undefined" ? self : global;
        }
    };
});
System.register("https://dev.jspm.io/npm:he@1?dew", ["https://dev.jspm.io/npm:he@1.2.0/he.dew"], function (exports_71, context_71) {
    "use strict";
    var __moduleName = context_71 && context_71.id;
    return {
        setters: [
            function (he_dew_js_1_1) {
                exports_71({
                    "dew": he_dew_js_1_1["dew"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/chunk-0c2d1322", [], function (exports_72, context_72) {
    "use strict";
    var e, t, n, r, o, l, s, f, a, T, addListener, argv, binding, browser, chdir, cwd, emit, env, listeners, nextTick, off, on, once, prependListener, prependOnceListener, removeAllListeners, removeListener, title, umask, version, versions;
    var __moduleName = context_72 && context_72.id;
    function i() { throw new Error("setTimeout has not been defined"); }
    function u() { throw new Error("clearTimeout has not been defined"); }
    function c(e) { if (t === setTimeout)
        return setTimeout(e, 0); if ((t === i || !t) && setTimeout)
        return t = setTimeout, setTimeout(e, 0); try {
        return t(e, 0);
    }
    catch (n) {
        try {
            return t.call(null, e, 0);
        }
        catch (n) {
            return t.call(this || r, e, 0);
        }
    } }
    function h() { f && l && (f = !1, l.length ? s = l.concat(s) : a = -1, s.length && d()); }
    function d() { if (!f) {
        var e = c(h);
        f = !0;
        for (var t = s.length; t;) {
            for (l = s, s = []; ++a < t;)
                l && l[a].run();
            a = -1, t = s.length;
        }
        l = null, f = !1, function (e) { if (n === clearTimeout)
            return clearTimeout(e); if ((n === u || !n) && clearTimeout)
            return n = clearTimeout, clearTimeout(e); try {
            n(e);
        }
        catch (t) {
            try {
                return n.call(null, e);
            }
            catch (t) {
                return n.call(this || r, e);
            }
        } }(e);
    } }
    function m(e, t) { (this || r).fun = e, (this || r).array = t; }
    function p() { }
    return {
        setters: [],
        execute: function () {
            r = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global, o = e = {};
            !function () { try {
                t = "function" == typeof setTimeout ? setTimeout : i;
            }
            catch (e) {
                t = i;
            } try {
                n = "function" == typeof clearTimeout ? clearTimeout : u;
            }
            catch (e) {
                n = u;
            } }();
            s = [], f = !1, a = -1;
            o.nextTick = function (e) { var t = new Array(arguments.length - 1); if (arguments.length > 1)
                for (var n = 1; n < arguments.length; n++)
                    t[n - 1] = arguments[n]; s.push(new m(e, t)), 1 !== s.length || f || c(d); }, m.prototype.run = function () { (this || r).fun.apply(null, (this || r).array); }, o.title = "browser", o.browser = !0, o.env = {}, o.argv = [], o.version = "", o.versions = {}, o.on = p, o.addListener = p, o.once = p, o.off = p, o.removeListener = p, o.removeAllListeners = p, o.emit = p, o.prependListener = p, o.prependOnceListener = p, o.listeners = function (e) { return []; }, o.binding = function (e) { throw new Error("process.binding is not supported"); }, o.cwd = function () { return "/"; }, o.chdir = function (e) { throw new Error("process.chdir is not supported"); }, o.umask = function () { return 0; };
            T = e;
            exports_72("h", T);
            exports_72("w", T);
            addListener = T.addListener;
            exports_72("a", addListener);
            argv = T.argv;
            exports_72("b", argv);
            binding = T.binding;
            exports_72("c", binding);
            browser = T.browser;
            exports_72("d", browser);
            chdir = T.chdir;
            exports_72("e", chdir);
            cwd = T.cwd;
            exports_72("f", cwd);
            emit = T.emit;
            exports_72("g", emit);
            env = T.env;
            exports_72("i", env);
            listeners = T.listeners;
            exports_72("l", listeners);
            nextTick = T.nextTick;
            exports_72("n", nextTick);
            off = T.off;
            exports_72("o", off);
            on = T.on;
            exports_72("j", on);
            once = T.once;
            exports_72("k", once);
            prependListener = T.prependListener;
            exports_72("p", prependListener);
            prependOnceListener = T.prependOnceListener;
            exports_72("m", prependOnceListener);
            removeAllListeners = T.removeAllListeners;
            exports_72("r", removeAllListeners);
            removeListener = T.removeListener;
            exports_72("q", removeListener);
            title = T.title;
            exports_72("t", title);
            umask = T.umask;
            exports_72("u", umask);
            version = T.version;
            exports_72("v", version);
            versions = T.versions;
            exports_72("s", versions);
        }
    };
});
System.register("https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/chunk-dac557ba", ["https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/chunk-0c2d1322"], function (exports_73, context_73) {
    "use strict";
    var chunk_0c2d1322_js_1, t, e, o, n, r, l, t$1, o$1, n$1, e$1, r$1, c, u, i, t$2, i$1, o$2, u$1, f, a, s, p, y, l$1, d, m, h, j, A, Q, X, Y, ee, te, re, ne, Se, Ee;
    var __moduleName = context_73 && context_73.id;
    function c$1(e) {
        return e.call.bind(e);
    }
    function O(e, t) {
        if ("object" != typeof e)
            return !1;
        try {
            return t(e), !0;
        }
        catch (e) {
            return !1;
        }
    }
    function S(e) {
        return l$1 && y ? void 0 !== b(e) : B(e) || k(e) || E(e) || D(e) || U(e) || P(e) || x(e) || I(e) || M(e) || z(e) || F(e);
    }
    function B(e) {
        return l$1 && y ? "Uint8Array" === b(e) : "[object Uint8Array]" === m(e) || u$1(e) && void 0 !== e.buffer;
    }
    function k(e) {
        return l$1 && y ? "Uint8ClampedArray" === b(e) : "[object Uint8ClampedArray]" === m(e);
    }
    function E(e) {
        return l$1 && y ? "Uint16Array" === b(e) : "[object Uint16Array]" === m(e);
    }
    function D(e) {
        return l$1 && y ? "Uint32Array" === b(e) : "[object Uint32Array]" === m(e);
    }
    function U(e) {
        return l$1 && y ? "Int8Array" === b(e) : "[object Int8Array]" === m(e);
    }
    function P(e) {
        return l$1 && y ? "Int16Array" === b(e) : "[object Int16Array]" === m(e);
    }
    function x(e) {
        return l$1 && y ? "Int32Array" === b(e) : "[object Int32Array]" === m(e);
    }
    function I(e) {
        return l$1 && y ? "Float32Array" === b(e) : "[object Float32Array]" === m(e);
    }
    function M(e) {
        return l$1 && y ? "Float64Array" === b(e) : "[object Float64Array]" === m(e);
    }
    function z(e) {
        return l$1 && y ? "BigInt64Array" === b(e) : "[object BigInt64Array]" === m(e);
    }
    function F(e) {
        return l$1 && y ? "BigUint64Array" === b(e) : "[object BigUint64Array]" === m(e);
    }
    function T(e) {
        return "[object Map]" === m(e);
    }
    function N(e) {
        return "[object Set]" === m(e);
    }
    function W(e) {
        return "[object WeakMap]" === m(e);
    }
    function $(e) {
        return "[object WeakSet]" === m(e);
    }
    function C(e) {
        return "[object ArrayBuffer]" === m(e);
    }
    function V(e) {
        return "undefined" != typeof ArrayBuffer && (C.working ? C(e) : e instanceof ArrayBuffer);
    }
    function G(e) {
        return "[object DataView]" === m(e);
    }
    function R(e) {
        return "undefined" != typeof DataView && (G.working ? G(e) : e instanceof DataView);
    }
    function J(e) {
        return "[object SharedArrayBuffer]" === m(e);
    }
    function _(e) {
        return "undefined" != typeof SharedArrayBuffer && (J.working ? J(e) : e instanceof SharedArrayBuffer);
    }
    function H(e) {
        return O(e, h);
    }
    function Z(e) {
        return O(e, j);
    }
    function q(e) {
        return O(e, A);
    }
    function K(e) {
        return s && O(e, w);
    }
    function L(e) {
        return p && O(e, v);
    }
    function oe(e, t) {
        var r = {
            seen: [],
            stylize: fe
        };
        return arguments.length >= 3 && (r.depth = arguments[2]), arguments.length >= 4 && (r.colors = arguments[3]), ye(t) ? r.showHidden = t : t && X._extend(r, t), be(r.showHidden) && (r.showHidden = !1), be(r.depth) && (r.depth = 2), be(r.colors) && (r.colors = !1), be(r.customInspect) && (r.customInspect = !0), r.colors && (r.stylize = ue), ae(r, e, r.depth);
    }
    function ue(e, t) {
        var r = oe.styles[t];
        return r ? "[" + oe.colors[r][0] + "m" + e + "[" + oe.colors[r][1] + "m" : e;
    }
    function fe(e, t) {
        return e;
    }
    function ae(e, t, r) {
        if (e.customInspect && t && we(t.inspect) && t.inspect !== X.inspect && (!t.constructor || t.constructor.prototype !== t)) {
            var n = t.inspect(r, e);
            return ge(n) || (n = ae(e, n, r)), n;
        }
        var i = function (e, t) {
            if (be(t))
                return e.stylize("undefined", "undefined");
            if (ge(t)) {
                var r = "'" + JSON.stringify(t).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                return e.stylize(r, "string");
            }
            if (de(t))
                return e.stylize("" + t, "number");
            if (ye(t))
                return e.stylize("" + t, "boolean");
            if (le(t))
                return e.stylize("null", "null");
        }(e, t);
        if (i)
            return i;
        var o = Object.keys(t), u = function (e) {
            var t = {};
            return e.forEach(function (e, r) {
                t[e] = !0;
            }), t;
        }(o);
        if (e.showHidden && (o = Object.getOwnPropertyNames(t)), Ae(t) && (o.indexOf("message") >= 0 || o.indexOf("description") >= 0))
            return ce(t);
        if (0 === o.length) {
            if (we(t)) {
                var f = t.name ? ": " + t.name : "";
                return e.stylize("[Function" + f + "]", "special");
            }
            if (me(t))
                return e.stylize(RegExp.prototype.toString.call(t), "regexp");
            if (je(t))
                return e.stylize(Date.prototype.toString.call(t), "date");
            if (Ae(t))
                return ce(t);
        }
        var a, c = "", s = !1, p = ["{", "}"];
        (pe(t) && (s = !0, p = ["[", "]"]), we(t)) && (c = " [Function" + (t.name ? ": " + t.name : "") + "]");
        return me(t) && (c = " " + RegExp.prototype.toString.call(t)), je(t) && (c = " " + Date.prototype.toUTCString.call(t)), Ae(t) && (c = " " + ce(t)), 0 !== o.length || s && 0 != t.length ? r < 0 ? me(t) ? e.stylize(RegExp.prototype.toString.call(t), "regexp") : e.stylize("[Object]", "special") : (e.seen.push(t), a = s ? function (e, t, r, n, i) {
            for (var o = [], u = 0, f = t.length; u < f; ++u)
                ke(t, String(u)) ? o.push(se(e, t, r, n, String(u), !0)) : o.push("");
            return i.forEach(function (i) {
                i.match(/^\d+$/) || o.push(se(e, t, r, n, i, !0));
            }), o;
        }(e, t, r, u, o) : o.map(function (n) {
            return se(e, t, r, u, n, s);
        }), e.seen.pop(), function (e, t, r) {
            var n = 0;
            if (e.reduce(function (e, t) {
                return n++, t.indexOf("\n") >= 0 && n++, e + t.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0) > 60)
                return r[0] + ("" === t ? "" : t + "\n ") + " " + e.join(",\n  ") + " " + r[1];
            return r[0] + t + " " + e.join(", ") + " " + r[1];
        }(a, c, p)) : p[0] + c + p[1];
    }
    function ce(e) {
        return "[" + Error.prototype.toString.call(e) + "]";
    }
    function se(e, t, r, n, i, o) {
        var u, f, a;
        if ((a = Object.getOwnPropertyDescriptor(t, i) || {
            value: t[i]
        }).get ? f = a.set ? e.stylize("[Getter/Setter]", "special") : e.stylize("[Getter]", "special") : a.set && (f = e.stylize("[Setter]", "special")), ke(n, i) || (u = "[" + i + "]"), f || (e.seen.indexOf(a.value) < 0 ? (f = le(r) ? ae(e, a.value, null) : ae(e, a.value, r - 1)).indexOf("\n") > -1 && (f = o ? f.split("\n").map(function (e) {
            return "  " + e;
        }).join("\n").substr(2) : "\n" + f.split("\n").map(function (e) {
            return "   " + e;
        }).join("\n")) : f = e.stylize("[Circular]", "special")), be(u)) {
            if (o && i.match(/^\d+$/))
                return f;
            (u = JSON.stringify("" + i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (u = u.substr(1, u.length - 2), u = e.stylize(u, "name")) : (u = u.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), u = e.stylize(u, "string"));
        }
        return u + ": " + f;
    }
    function pe(e) {
        return Array.isArray(e);
    }
    function ye(e) {
        return "boolean" == typeof e;
    }
    function le(e) {
        return null === e;
    }
    function de(e) {
        return "number" == typeof e;
    }
    function ge(e) {
        return "string" == typeof e;
    }
    function be(e) {
        return void 0 === e;
    }
    function me(e) {
        return he(e) && "[object RegExp]" === ve(e);
    }
    function he(e) {
        return "object" == typeof e && null !== e;
    }
    function je(e) {
        return he(e) && "[object Date]" === ve(e);
    }
    function Ae(e) {
        return he(e) && ("[object Error]" === ve(e) || e instanceof Error);
    }
    function we(e) {
        return "function" == typeof e;
    }
    function ve(e) {
        return Object.prototype.toString.call(e);
    }
    function Oe(e) {
        return e < 10 ? "0" + e.toString(10) : e.toString(10);
    }
    function Be() {
        var e = new Date(), t = [Oe(e.getHours()), Oe(e.getMinutes()), Oe(e.getSeconds())].join(":");
        return [e.getDate(), Se[e.getMonth()], t].join(" ");
    }
    function ke(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t);
    }
    function De(e, t) {
        if (!e) {
            var r = new Error("Promise was rejected with a falsy value");
            r.reason = e, e = r;
        }
        return t(e);
    }
    return {
        setters: [
            function (chunk_0c2d1322_js_1_1) {
                chunk_0c2d1322_js_1 = chunk_0c2d1322_js_1_1;
            }
        ],
        execute: function () {
            t = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag, e = Object.prototype.toString, o = function (o) {
                return !(t && o && "object" == typeof o && Symbol.toStringTag in o) && "[object Arguments]" === e.call(o);
            }, n = function (t) {
                return !!o(t) || null !== t && "object" == typeof t && "number" == typeof t.length && t.length >= 0 && "[object Array]" !== e.call(t) && "[object Function]" === e.call(t.callee);
            }, r = function () {
                return o(arguments);
            }();
            o.isLegacyArguments = n;
            l = r ? o : n;
            t$1 = Object.prototype.toString, o$1 = Function.prototype.toString, n$1 = /^\s*(?:function)?\*/, e$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag, r$1 = Object.getPrototypeOf, c = function () {
                if (!e$1)
                    return !1;
                try {
                    return Function("return function*() {}")();
                }
                catch (t) { }
            }(), u = c ? r$1(c) : {}, i = function (c) {
                return "function" == typeof c && (!!n$1.test(o$1.call(c)) || (e$1 ? r$1(c) === u : "[object GeneratorFunction]" === t$1.call(c)));
            };
            t$2 = "function" == typeof Object.create ? function (t, e) {
                e && (t.super_ = e, t.prototype = Object.create(e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }));
            } : function (t, e) {
                if (e) {
                    t.super_ = e;
                    var o = function () { };
                    o.prototype = e.prototype, t.prototype = new o(), t.prototype.constructor = t;
                }
            };
            exports_73("t", t$2);
            i$1 = function (e) {
                return e && "object" == typeof e && "function" == typeof e.copy && "function" == typeof e.fill && "function" == typeof e.readUInt8;
            }, o$2 = {}, u$1 = i$1, f = l, a = i;
            s = "undefined" != typeof BigInt, p = "undefined" != typeof Symbol, y = p && void 0 !== Symbol.toStringTag, l$1 = "undefined" != typeof Uint8Array, d = "undefined" != typeof ArrayBuffer;
            if (l$1 && y)
                var g = Object.getPrototypeOf(Uint8Array.prototype), b = c$1(Object.getOwnPropertyDescriptor(g, Symbol.toStringTag).get);
            m = c$1(Object.prototype.toString), h = c$1(Number.prototype.valueOf), j = c$1(String.prototype.valueOf), A = c$1(Boolean.prototype.valueOf);
            if (s)
                var w = c$1(BigInt.prototype.valueOf);
            if (p)
                var v = c$1(Symbol.prototype.valueOf);
            o$2.isArgumentsObject = f, o$2.isGeneratorFunction = a, o$2.isPromise = function (e) {
                return "undefined" != typeof Promise && e instanceof Promise || null !== e && "object" == typeof e && "function" == typeof e.then && "function" == typeof e.catch;
            }, o$2.isArrayBufferView = function (e) {
                return d && ArrayBuffer.isView ? ArrayBuffer.isView(e) : S(e) || R(e);
            }, o$2.isTypedArray = S, o$2.isUint8Array = B, o$2.isUint8ClampedArray = k, o$2.isUint16Array = E, o$2.isUint32Array = D, o$2.isInt8Array = U, o$2.isInt16Array = P, o$2.isInt32Array = x, o$2.isFloat32Array = I, o$2.isFloat64Array = M, o$2.isBigInt64Array = z, o$2.isBigUint64Array = F, T.working = "undefined" != typeof Map && T(new Map()), o$2.isMap = function (e) {
                return "undefined" != typeof Map && (T.working ? T(e) : e instanceof Map);
            }, N.working = "undefined" != typeof Set && N(new Set()), o$2.isSet = function (e) {
                return "undefined" != typeof Set && (N.working ? N(e) : e instanceof Set);
            }, W.working = "undefined" != typeof WeakMap && W(new WeakMap()), o$2.isWeakMap = function (e) {
                return "undefined" != typeof WeakMap && (W.working ? W(e) : e instanceof WeakMap);
            }, $.working = "undefined" != typeof WeakSet && $(new WeakSet()), o$2.isWeakSet = function (e) {
                return $(e);
            }, C.working = "undefined" != typeof ArrayBuffer && C(new ArrayBuffer()), o$2.isArrayBuffer = V, G.working = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView && G(new DataView(new ArrayBuffer(1), 0, 1)), o$2.isDataView = R, J.working = "undefined" != typeof SharedArrayBuffer && J(new SharedArrayBuffer()), o$2.isSharedArrayBuffer = _, o$2.isAsyncFunction = function (e) {
                return "[object AsyncFunction]" === m(e);
            }, o$2.isMapIterator = function (e) {
                return "[object Map Iterator]" === m(e);
            }, o$2.isSetIterator = function (e) {
                return "[object Set Iterator]" === m(e);
            }, o$2.isGeneratorObject = function (e) {
                return "[object Generator]" === m(e);
            }, o$2.isWebAssemblyCompiledModule = function (e) {
                return "[object WebAssembly.Module]" === m(e);
            }, o$2.isNumberObject = H, o$2.isStringObject = Z, o$2.isBooleanObject = q, o$2.isBigIntObject = K, o$2.isSymbolObject = L, o$2.isBoxedPrimitive = function (e) {
                return H(e) || Z(e) || q(e) || K(e) || L(e);
            }, o$2.isAnyArrayBuffer = function (e) {
                return l$1 && (V(e) || _(e));
            }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function (e) {
                Object.defineProperty(o$2, e, {
                    enumerable: !1,
                    value: function () {
                        throw new Error(e + " is not supported in userland");
                    }
                });
            });
            Q = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global, X = {}, Y = chunk_0c2d1322_js_1.h, ee = Object.getOwnPropertyDescriptors || function (e) {
                for (var t = Object.keys(e), r = {}, n = 0; n < t.length; n++)
                    r[t[n]] = Object.getOwnPropertyDescriptor(e, t[n]);
                return r;
            }, te = /%[sdj%]/g;
            exports_73("u", X);
            X.format = function (e) {
                if (!ge(e)) {
                    for (var t = [], r = 0; r < arguments.length; r++)
                        t.push(oe(arguments[r]));
                    return t.join(" ");
                }
                r = 1;
                for (var n = arguments, i = n.length, o = String(e).replace(te, function (e) {
                    if ("%%" === e)
                        return "%";
                    if (r >= i)
                        return e;
                    switch (e) {
                        case "%s":
                            return String(n[r++]);
                        case "%d":
                            return Number(n[r++]);
                        case "%j":
                            try {
                                return JSON.stringify(n[r++]);
                            }
                            catch (e) {
                                return "[Circular]";
                            }
                        default:
                            return e;
                    }
                }), u = n[r]; r < i; u = n[++r])
                    le(u) || !he(u) ? o += " " + u : o += " " + oe(u);
                return o;
            }, X.deprecate = function (e, t) {
                if (void 0 !== Y && !0 === Y.noDeprecation)
                    return e;
                if (void 0 === Y)
                    return function () {
                        return X.deprecate(e, t).apply(this || Q, arguments);
                    };
                var r = !1;
                return function () {
                    if (!r) {
                        if (Y.throwDeprecation)
                            throw new Error(t);
                        Y.traceDeprecation ? console.trace(t) : console.error(t), r = !0;
                    }
                    return e.apply(this || Q, arguments);
                };
            };
            re = {}, ne = /^$/;
            if (Y.env.NODE_DEBUG) {
                var ie = Y.env.NODE_DEBUG;
                ie = ie.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ne = new RegExp("^" + ie + "$", "i");
            }
            X.debuglog = function (e) {
                if (e = e.toUpperCase(), !re[e])
                    if (ne.test(e)) {
                        var t = Y.pid;
                        re[e] = function () {
                            var r = X.format.apply(X, arguments);
                            console.error("%s %d: %s", e, t, r);
                        };
                    }
                    else
                        re[e] = function () { };
                return re[e];
            }, X.inspect = oe, oe.colors = {
                bold: [1, 22],
                italic: [3, 23],
                underline: [4, 24],
                inverse: [7, 27],
                white: [37, 39],
                grey: [90, 39],
                black: [30, 39],
                blue: [34, 39],
                cyan: [36, 39],
                green: [32, 39],
                magenta: [35, 39],
                red: [31, 39],
                yellow: [33, 39]
            }, oe.styles = {
                special: "cyan",
                number: "yellow",
                boolean: "yellow",
                undefined: "grey",
                null: "bold",
                string: "green",
                date: "magenta",
                regexp: "red"
            }, X.types = o$2, X.isArray = pe, X.isBoolean = ye, X.isNull = le, X.isNullOrUndefined = function (e) {
                return null == e;
            }, X.isNumber = de, X.isString = ge, X.isSymbol = function (e) {
                return "symbol" == typeof e;
            }, X.isUndefined = be, X.isRegExp = me, X.types.isRegExp = me, X.isObject = he, X.isDate = je, X.types.isDate = je, X.isError = Ae, X.types.isNativeError = Ae, X.isFunction = we, X.isPrimitive = function (e) {
                return null === e || "boolean" == typeof e || "number" == typeof e || "string" == typeof e || "symbol" == typeof e || void 0 === e;
            }, X.isBuffer = i$1;
            Se = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            X.log = function () {
                console.log("%s - %s", Be(), X.format.apply(X, arguments));
            }, X.inherits = t$2, X._extend = function (e, t) {
                if (!t || !he(t))
                    return e;
                for (var r = Object.keys(t), n = r.length; n--;)
                    e[r[n]] = t[r[n]];
                return e;
            };
            Ee = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
            X.promisify = function (e) {
                if ("function" != typeof e)
                    throw new TypeError('The "original" argument must be of type Function');
                if (Ee && e[Ee]) {
                    var t;
                    if ("function" != typeof (t = e[Ee]))
                        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                    return Object.defineProperty(t, Ee, {
                        value: t,
                        enumerable: !1,
                        writable: !1,
                        configurable: !0
                    }), t;
                }
                function t() {
                    for (var t, r, n = new Promise(function (e, n) {
                        t = e, r = n;
                    }), i = [], o = 0; o < arguments.length; o++)
                        i.push(arguments[o]);
                    i.push(function (e, n) {
                        e ? r(e) : t(n);
                    });
                    try {
                        e.apply(this || Q, i);
                    }
                    catch (e) {
                        r(e);
                    }
                    return n;
                }
                return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), Ee && Object.defineProperty(t, Ee, {
                    value: t,
                    enumerable: !1,
                    writable: !1,
                    configurable: !0
                }), Object.defineProperties(t, ee(e));
            }, X.promisify.custom = Ee, X.callbackify = function (e) {
                if ("function" != typeof e)
                    throw new TypeError('The "original" argument must be of type Function');
                function t() {
                    for (var t = [], r = 0; r < arguments.length; r++)
                        t.push(arguments[r]);
                    var n = t.pop();
                    if ("function" != typeof n)
                        throw new TypeError("The last argument must be of type Function");
                    var i = this || Q, o = function () {
                        return n.apply(i, arguments);
                    };
                    e.apply(this || Q, t).then(function (e) {
                        Y.nextTick(o.bind(null, null, e));
                    }, function (e) {
                        Y.nextTick(De.bind(null, e, o));
                    });
                }
                return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), Object.defineProperties(t, ee(e)), t;
            };
        }
    };
});
System.register("https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/buffer", [], function (exports_74, context_74) {
    "use strict";
    var r, t, e, n, o, a, h, a$1, e$1, n$1, i, o$1, j, Y, Buffer, INSPECT_MAX_BYTES, kMaxLength;
    var __moduleName = context_74 && context_74.id;
    function u(r) { var t = r.length; if (t % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4"); var e = r.indexOf("="); return -1 === e && (e = t), [e, e === t ? 0 : 4 - e % 4]; }
    function c(r, e, n) { for (var o, a, h = [], u = e; u < n; u += 3)
        o = (r[u] << 16 & 16711680) + (r[u + 1] << 8 & 65280) + (255 & r[u + 2]), h.push(t[(a = o) >> 18 & 63] + t[a >> 12 & 63] + t[a >> 6 & 63] + t[63 & a]); return h.join(""); }
    function f(t) { if (t > 2147483647)
        throw new RangeError('The value "' + t + '" is invalid for option "size"'); var r = new Uint8Array(t); return Object.setPrototypeOf(r, u$1.prototype), r; }
    function u$1(t, r, e) { if ("number" == typeof t) {
        if ("string" == typeof r)
            throw new TypeError('The "string" argument must be of type string. Received type number');
        return a$2(t);
    } return s(t, r, e); }
    function s(t, r, e) { if ("string" == typeof t)
        return function (t, r) { "string" == typeof r && "" !== r || (r = "utf8"); if (!u$1.isEncoding(r))
            throw new TypeError("Unknown encoding: " + r); var e = 0 | y(t, r), n = f(e), i = n.write(t, r); i !== e && (n = n.slice(0, i)); return n; }(t, r); if (ArrayBuffer.isView(t))
        return p(t); if (null == t)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t); if (F(t, ArrayBuffer) || t && F(t.buffer, ArrayBuffer))
        return c$1(t, r, e); if ("undefined" != typeof SharedArrayBuffer && (F(t, SharedArrayBuffer) || t && F(t.buffer, SharedArrayBuffer)))
        return c$1(t, r, e); if ("number" == typeof t)
        throw new TypeError('The "value" argument must not be of type number. Received type number'); var n = t.valueOf && t.valueOf(); if (null != n && n !== t)
        return u$1.from(n, r, e); var i = function (t) { if (u$1.isBuffer(t)) {
        var r = 0 | l(t.length), e = f(r);
        return 0 === e.length || t.copy(e, 0, 0, r), e;
    } if (void 0 !== t.length)
        return "number" != typeof t.length || N(t.length) ? f(0) : p(t); if ("Buffer" === t.type && Array.isArray(t.data))
        return p(t.data); }(t); if (i)
        return i; if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t[Symbol.toPrimitive])
        return u$1.from(t[Symbol.toPrimitive]("string"), r, e); throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t); }
    function h$1(t) { if ("number" != typeof t)
        throw new TypeError('"size" argument must be of type number'); if (t < 0)
        throw new RangeError('The value "' + t + '" is invalid for option "size"'); }
    function a$2(t) { return h$1(t), f(t < 0 ? 0 : 0 | l(t)); }
    function p(t) { for (var r = t.length < 0 ? 0 : 0 | l(t.length), e = f(r), n = 0; n < r; n += 1)
        e[n] = 255 & t[n]; return e; }
    function c$1(t, r, e) { if (r < 0 || t.byteLength < r)
        throw new RangeError('"offset" is outside of buffer bounds'); if (t.byteLength < r + (e || 0))
        throw new RangeError('"length" is outside of buffer bounds'); var n; return n = void 0 === r && void 0 === e ? new Uint8Array(t) : void 0 === e ? new Uint8Array(t, r) : new Uint8Array(t, r, e), Object.setPrototypeOf(n, u$1.prototype), n; }
    function l(t) { if (t >= 2147483647)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647..toString(16) + " bytes"); return 0 | t; }
    function y(t, r) { if (u$1.isBuffer(t))
        return t.length; if (ArrayBuffer.isView(t) || F(t, ArrayBuffer))
        return t.byteLength; if ("string" != typeof t)
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t); var e = t.length, n = arguments.length > 2 && !0 === arguments[2]; if (!n && 0 === e)
        return 0; for (var i = !1;;)
        switch (r) {
            case "ascii":
            case "latin1":
            case "binary": return e;
            case "utf8":
            case "utf-8": return _(t).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le": return 2 * e;
            case "hex": return e >>> 1;
            case "base64": return z(t).length;
            default:
                if (i)
                    return n ? -1 : _(t).length;
                r = ("" + r).toLowerCase(), i = !0;
        } }
    function g(t, r, e) { var n = !1; if ((void 0 === r || r < 0) && (r = 0), r > this.length)
        return ""; if ((void 0 === e || e > this.length) && (e = this.length), e <= 0)
        return ""; if ((e >>>= 0) <= (r >>>= 0))
        return ""; for (t || (t = "utf8");;)
        switch (t) {
            case "hex": return O(this, r, e);
            case "utf8":
            case "utf-8": return I(this, r, e);
            case "ascii": return S(this, r, e);
            case "latin1":
            case "binary": return R(this, r, e);
            case "base64": return T(this, r, e);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le": return L(this, r, e);
            default:
                if (n)
                    throw new TypeError("Unknown encoding: " + t);
                t = (t + "").toLowerCase(), n = !0;
        } }
    function w(t, r, e) { var n = t[r]; t[r] = t[e], t[e] = n; }
    function d(t, r, e, n, i) { if (0 === t.length)
        return -1; if ("string" == typeof e ? (n = e, e = 0) : e > 2147483647 ? e = 2147483647 : e < -2147483648 && (e = -2147483648), N(e = +e) && (e = i ? 0 : t.length - 1), e < 0 && (e = t.length + e), e >= t.length) {
        if (i)
            return -1;
        e = t.length - 1;
    }
    else if (e < 0) {
        if (!i)
            return -1;
        e = 0;
    } if ("string" == typeof r && (r = u$1.from(r, n)), u$1.isBuffer(r))
        return 0 === r.length ? -1 : v(t, r, e, n, i); if ("number" == typeof r)
        return r &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(t, r, e) : Uint8Array.prototype.lastIndexOf.call(t, r, e) : v(t, [r], e, n, i); throw new TypeError("val must be string, number or Buffer"); }
    function v(t, r, e, n, i) { var o, f = 1, u = t.length, s = r.length; if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
        if (t.length < 2 || r.length < 2)
            return -1;
        f = 2, u /= 2, s /= 2, e /= 2;
    } function h(t, r) { return 1 === f ? t[r] : t.readUInt16BE(r * f); } if (i) {
        var a = -1;
        for (o = e; o < u; o++)
            if (h(t, o) === h(r, -1 === a ? 0 : o - a)) {
                if (-1 === a && (a = o), o - a + 1 === s)
                    return a * f;
            }
            else
                -1 !== a && (o -= o - a), a = -1;
    }
    else
        for (e + s > u && (e = u - s), o = e; o >= 0; o--) {
            for (var p = !0, c = 0; c < s; c++)
                if (h(t, o + c) !== h(r, c)) {
                    p = !1;
                    break;
                }
            if (p)
                return o;
        } return -1; }
    function b(t, r, e, n) { e = Number(e) || 0; var i = t.length - e; n ? (n = Number(n)) > i && (n = i) : n = i; var o = r.length; n > o / 2 && (n = o / 2); for (var f = 0; f < n; ++f) {
        var u = parseInt(r.substr(2 * f, 2), 16);
        if (N(u))
            return f;
        t[e + f] = u;
    } return f; }
    function m(t, r, e, n) { return D(_(r, t.length - e), t, e, n); }
    function E(t, r, e, n) { return D(function (t) { for (var r = [], e = 0; e < t.length; ++e)
        r.push(255 & t.charCodeAt(e)); return r; }(r), t, e, n); }
    function B(t, r, e, n) { return E(t, r, e, n); }
    function A(t, r, e, n) { return D(z(r), t, e, n); }
    function U(t, r, e, n) { return D(function (t, r) { for (var e, n, i, o = [], f = 0; f < t.length && !((r -= 2) < 0); ++f)
        e = t.charCodeAt(f), n = e >> 8, i = e % 256, o.push(i), o.push(n); return o; }(r, t.length - e), t, e, n); }
    function T(t, r, e) { return 0 === r && e === t.length ? n$1.fromByteArray(t) : n$1.fromByteArray(t.slice(r, e)); }
    function I(t, r, e) { e = Math.min(t.length, e); for (var n = [], i = r; i < e;) {
        var o, f, u, s, h = t[i], a = null, p = h > 239 ? 4 : h > 223 ? 3 : h > 191 ? 2 : 1;
        if (i + p <= e)
            switch (p) {
                case 1:
                    h < 128 && (a = h);
                    break;
                case 2:
                    128 == (192 & (o = t[i + 1])) && (s = (31 & h) << 6 | 63 & o) > 127 && (a = s);
                    break;
                case 3:
                    o = t[i + 1], f = t[i + 2], 128 == (192 & o) && 128 == (192 & f) && (s = (15 & h) << 12 | (63 & o) << 6 | 63 & f) > 2047 && (s < 55296 || s > 57343) && (a = s);
                    break;
                case 4: o = t[i + 1], f = t[i + 2], u = t[i + 3], 128 == (192 & o) && 128 == (192 & f) && 128 == (192 & u) && (s = (15 & h) << 18 | (63 & o) << 12 | (63 & f) << 6 | 63 & u) > 65535 && s < 1114112 && (a = s);
            }
        null === a ? (a = 65533, p = 1) : a > 65535 && (a -= 65536, n.push(a >>> 10 & 1023 | 55296), a = 56320 | 1023 & a), n.push(a), i += p;
    } return function (t) { var r = t.length; if (r <= 4096)
        return String.fromCharCode.apply(String, t); var e = "", n = 0; for (; n < r;)
        e += String.fromCharCode.apply(String, t.slice(n, n += 4096)); return e; }(n); }
    function S(t, r, e) { var n = ""; e = Math.min(t.length, e); for (var i = r; i < e; ++i)
        n += String.fromCharCode(127 & t[i]); return n; }
    function R(t, r, e) { var n = ""; e = Math.min(t.length, e); for (var i = r; i < e; ++i)
        n += String.fromCharCode(t[i]); return n; }
    function O(t, r, e) { var n = t.length; (!r || r < 0) && (r = 0), (!e || e < 0 || e > n) && (e = n); for (var i = "", o = r; o < e; ++o)
        i += Y[t[o]]; return i; }
    function L(t, r, e) { for (var n = t.slice(r, e), i = "", o = 0; o < n.length; o += 2)
        i += String.fromCharCode(n[o] + 256 * n[o + 1]); return i; }
    function x(t, r, e) { if (t % 1 != 0 || t < 0)
        throw new RangeError("offset is not uint"); if (t + r > e)
        throw new RangeError("Trying to access beyond buffer length"); }
    function C(t, r, e, n, i, o) { if (!u$1.isBuffer(t))
        throw new TypeError('"buffer" argument must be a Buffer instance'); if (r > i || r < o)
        throw new RangeError('"value" argument is out of bounds'); if (e + n > t.length)
        throw new RangeError("Index out of range"); }
    function P(t, r, e, n, i, o) { if (e + n > t.length)
        throw new RangeError("Index out of range"); if (e < 0)
        throw new RangeError("Index out of range"); }
    function k(t, r, e, n, o) { return r = +r, e >>>= 0, o || P(t, 0, e, 4), i.write(t, r, e, n, 23, 4), e + 4; }
    function M(t, r, e, n, o) { return r = +r, e >>>= 0, o || P(t, 0, e, 8), i.write(t, r, e, n, 52, 8), e + 8; }
    function _(t, r) { var e; r = r || 1 / 0; for (var n = t.length, i = null, o = [], f = 0; f < n; ++f) {
        if ((e = t.charCodeAt(f)) > 55295 && e < 57344) {
            if (!i) {
                if (e > 56319) {
                    (r -= 3) > -1 && o.push(239, 191, 189);
                    continue;
                }
                if (f + 1 === n) {
                    (r -= 3) > -1 && o.push(239, 191, 189);
                    continue;
                }
                i = e;
                continue;
            }
            if (e < 56320) {
                (r -= 3) > -1 && o.push(239, 191, 189), i = e;
                continue;
            }
            e = 65536 + (i - 55296 << 10 | e - 56320);
        }
        else
            i && (r -= 3) > -1 && o.push(239, 191, 189);
        if (i = null, e < 128) {
            if ((r -= 1) < 0)
                break;
            o.push(e);
        }
        else if (e < 2048) {
            if ((r -= 2) < 0)
                break;
            o.push(e >> 6 | 192, 63 & e | 128);
        }
        else if (e < 65536) {
            if ((r -= 3) < 0)
                break;
            o.push(e >> 12 | 224, e >> 6 & 63 | 128, 63 & e | 128);
        }
        else {
            if (!(e < 1114112))
                throw new Error("Invalid code point");
            if ((r -= 4) < 0)
                break;
            o.push(e >> 18 | 240, e >> 12 & 63 | 128, e >> 6 & 63 | 128, 63 & e | 128);
        }
    } return o; }
    function z(t) { return n$1.toByteArray(function (t) { if ((t = (t = t.split("=")[0]).trim().replace(j, "")).length < 2)
        return ""; for (; t.length % 4 != 0;)
        t += "="; return t; }(t)); }
    function D(t, r, e, n) { for (var i = 0; i < n && !(i + e >= r.length || i >= t.length); ++i)
        r[i + e] = t[i]; return i; }
    function F(t, r) { return t instanceof r || null != t && null != t.constructor && null != t.constructor.name && t.constructor.name === r.name; }
    function N(t) { return t != t; }
    return {
        setters: [],
        execute: function () {
            for (r = { byteLength: function (r) { var t = u(r), e = t[0], n = t[1]; return 3 * (e + n) / 4 - n; }, toByteArray: function (r) { var t, o, a = u(r), h = a[0], c = a[1], d = new n(function (r, t, e) { return 3 * (t + e) / 4 - e; }(0, h, c)), f = 0, A = c > 0 ? h - 4 : h; for (o = 0; o < A; o += 4)
                    t = e[r.charCodeAt(o)] << 18 | e[r.charCodeAt(o + 1)] << 12 | e[r.charCodeAt(o + 2)] << 6 | e[r.charCodeAt(o + 3)], d[f++] = t >> 16 & 255, d[f++] = t >> 8 & 255, d[f++] = 255 & t; 2 === c && (t = e[r.charCodeAt(o)] << 2 | e[r.charCodeAt(o + 1)] >> 4, d[f++] = 255 & t); 1 === c && (t = e[r.charCodeAt(o)] << 10 | e[r.charCodeAt(o + 1)] << 4 | e[r.charCodeAt(o + 2)] >> 2, d[f++] = t >> 8 & 255, d[f++] = 255 & t); return d; }, fromByteArray: function (r) { for (var e, n = r.length, o = n % 3, a = [], h = 0, u = n - o; h < u; h += 16383)
                    a.push(c(r, h, h + 16383 > u ? u : h + 16383)); 1 === o ? (e = r[n - 1], a.push(t[e >> 2] + t[e << 4 & 63] + "==")) : 2 === o && (e = (r[n - 2] << 8) + r[n - 1], a.push(t[e >> 10] + t[e >> 4 & 63] + t[e << 2 & 63] + "=")); return a.join(""); } }, t = [], e = [], n = "undefined" != typeof Uint8Array ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0, h = o.length; a < h; ++a)
                t[a] = o[a], e[o.charCodeAt(a)] = a;
            e["-".charCodeAt(0)] = 62, e["_".charCodeAt(0)] = 63;
            a$1 = { read: function (a, t, o, r, h) { var M, f, p = 8 * h - r - 1, w = (1 << p) - 1, e = w >> 1, i = -7, N = o ? h - 1 : 0, n = o ? -1 : 1, u = a[t + N]; for (N += n, M = u & (1 << -i) - 1, u >>= -i, i += p; i > 0; M = 256 * M + a[t + N], N += n, i -= 8)
                    ; for (f = M & (1 << -i) - 1, M >>= -i, i += r; i > 0; f = 256 * f + a[t + N], N += n, i -= 8)
                    ; if (0 === M)
                    M = 1 - e;
                else {
                    if (M === w)
                        return f ? NaN : 1 / 0 * (u ? -1 : 1);
                    f += Math.pow(2, r), M -= e;
                } return (u ? -1 : 1) * f * Math.pow(2, M - r); }, write: function (a, t, o, r, h, M) { var f, p, w, e = 8 * M - h - 1, i = (1 << e) - 1, N = i >> 1, n = 23 === h ? Math.pow(2, -24) - Math.pow(2, -77) : 0, u = r ? 0 : M - 1, l = r ? 1 : -1, s = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0; for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (p = isNaN(t) ? 1 : 0, f = i) : (f = Math.floor(Math.log(t) / Math.LN2), t * (w = Math.pow(2, -f)) < 1 && (f--, w *= 2), (t += f + N >= 1 ? n / w : n * Math.pow(2, 1 - N)) * w >= 2 && (f++, w /= 2), f + N >= i ? (p = 0, f = i) : f + N >= 1 ? (p = (t * w - 1) * Math.pow(2, h), f += N) : (p = t * Math.pow(2, N - 1) * Math.pow(2, h), f = 0)); h >= 8; a[o + u] = 255 & p, u += l, p /= 256, h -= 8)
                    ; for (f = f << h | p, e += h; e > 0; a[o + u] = 255 & f, u += l, f /= 256, e -= 8)
                    ; a[o + u - l] |= 128 * s; } };
            e$1 = {}, n$1 = r, i = a$1, o$1 = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
            e$1.Buffer = u$1, e$1.SlowBuffer = function (t) { +t != t && (t = 0); return u$1.alloc(+t); }, e$1.INSPECT_MAX_BYTES = 50;
            e$1.kMaxLength = 2147483647, u$1.TYPED_ARRAY_SUPPORT = function () { try {
                var t = new Uint8Array(1), r = { foo: function () { return 42; } };
                return Object.setPrototypeOf(r, Uint8Array.prototype), Object.setPrototypeOf(t, r), 42 === t.foo();
            }
            catch (t) {
                return !1;
            } }(), u$1.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(u$1.prototype, "parent", { enumerable: !0, get: function () { if (u$1.isBuffer(this))
                    return this.buffer; } }), Object.defineProperty(u$1.prototype, "offset", { enumerable: !0, get: function () { if (u$1.isBuffer(this))
                    return this.byteOffset; } }), u$1.poolSize = 8192, u$1.from = function (t, r, e) { return s(t, r, e); }, Object.setPrototypeOf(u$1.prototype, Uint8Array.prototype), Object.setPrototypeOf(u$1, Uint8Array), u$1.alloc = function (t, r, e) { return function (t, r, e) { return h$1(t), t <= 0 ? f(t) : void 0 !== r ? "string" == typeof e ? f(t).fill(r, e) : f(t).fill(r) : f(t); }(t, r, e); }, u$1.allocUnsafe = function (t) { return a$2(t); }, u$1.allocUnsafeSlow = function (t) { return a$2(t); }, u$1.isBuffer = function (t) { return null != t && !0 === t._isBuffer && t !== u$1.prototype; }, u$1.compare = function (t, r) { if (F(t, Uint8Array) && (t = u$1.from(t, t.offset, t.byteLength)), F(r, Uint8Array) && (r = u$1.from(r, r.offset, r.byteLength)), !u$1.isBuffer(t) || !u$1.isBuffer(r))
                throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'); if (t === r)
                return 0; for (var e = t.length, n = r.length, i = 0, o = Math.min(e, n); i < o; ++i)
                if (t[i] !== r[i]) {
                    e = t[i], n = r[i];
                    break;
                } return e < n ? -1 : n < e ? 1 : 0; }, u$1.isEncoding = function (t) { switch (String(t).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le": return !0;
                default: return !1;
            } }, u$1.concat = function (t, r) { if (!Array.isArray(t))
                throw new TypeError('"list" argument must be an Array of Buffers'); if (0 === t.length)
                return u$1.alloc(0); var e; if (void 0 === r)
                for (r = 0, e = 0; e < t.length; ++e)
                    r += t[e].length; var n = u$1.allocUnsafe(r), i = 0; for (e = 0; e < t.length; ++e) {
                var o = t[e];
                if (F(o, Uint8Array) && (o = u$1.from(o)), !u$1.isBuffer(o))
                    throw new TypeError('"list" argument must be an Array of Buffers');
                o.copy(n, i), i += o.length;
            } return n; }, u$1.byteLength = y, u$1.prototype._isBuffer = !0, u$1.prototype.swap16 = function () { var t = this.length; if (t % 2 != 0)
                throw new RangeError("Buffer size must be a multiple of 16-bits"); for (var r = 0; r < t; r += 2)
                w(this, r, r + 1); return this; }, u$1.prototype.swap32 = function () { var t = this.length; if (t % 4 != 0)
                throw new RangeError("Buffer size must be a multiple of 32-bits"); for (var r = 0; r < t; r += 4)
                w(this, r, r + 3), w(this, r + 1, r + 2); return this; }, u$1.prototype.swap64 = function () { var t = this.length; if (t % 8 != 0)
                throw new RangeError("Buffer size must be a multiple of 64-bits"); for (var r = 0; r < t; r += 8)
                w(this, r, r + 7), w(this, r + 1, r + 6), w(this, r + 2, r + 5), w(this, r + 3, r + 4); return this; }, u$1.prototype.toString = function () { var t = this.length; return 0 === t ? "" : 0 === arguments.length ? I(this, 0, t) : g.apply(this, arguments); }, u$1.prototype.toLocaleString = u$1.prototype.toString, u$1.prototype.equals = function (t) { if (!u$1.isBuffer(t))
                throw new TypeError("Argument must be a Buffer"); return this === t || 0 === u$1.compare(this, t); }, u$1.prototype.inspect = function () { var t = "", r = e$1.INSPECT_MAX_BYTES; return t = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (t += " ... "), "<Buffer " + t + ">"; }, o$1 && (u$1.prototype[o$1] = u$1.prototype.inspect), u$1.prototype.compare = function (t, r, e, n, i) { if (F(t, Uint8Array) && (t = u$1.from(t, t.offset, t.byteLength)), !u$1.isBuffer(t))
                throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t); if (void 0 === r && (r = 0), void 0 === e && (e = t ? t.length : 0), void 0 === n && (n = 0), void 0 === i && (i = this.length), r < 0 || e > t.length || n < 0 || i > this.length)
                throw new RangeError("out of range index"); if (n >= i && r >= e)
                return 0; if (n >= i)
                return -1; if (r >= e)
                return 1; if (this === t)
                return 0; for (var o = (i >>>= 0) - (n >>>= 0), f = (e >>>= 0) - (r >>>= 0), s = Math.min(o, f), h = this.slice(n, i), a = t.slice(r, e), p = 0; p < s; ++p)
                if (h[p] !== a[p]) {
                    o = h[p], f = a[p];
                    break;
                } return o < f ? -1 : f < o ? 1 : 0; }, u$1.prototype.includes = function (t, r, e) { return -1 !== this.indexOf(t, r, e); }, u$1.prototype.indexOf = function (t, r, e) { return d(this, t, r, e, !0); }, u$1.prototype.lastIndexOf = function (t, r, e) { return d(this, t, r, e, !1); }, u$1.prototype.write = function (t, r, e, n) { if (void 0 === r)
                n = "utf8", e = this.length, r = 0;
            else if (void 0 === e && "string" == typeof r)
                n = r, e = this.length, r = 0;
            else {
                if (!isFinite(r))
                    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                r >>>= 0, isFinite(e) ? (e >>>= 0, void 0 === n && (n = "utf8")) : (n = e, e = void 0);
            } var i = this.length - r; if ((void 0 === e || e > i) && (e = i), t.length > 0 && (e < 0 || r < 0) || r > this.length)
                throw new RangeError("Attempt to write outside buffer bounds"); n || (n = "utf8"); for (var o = !1;;)
                switch (n) {
                    case "hex": return b(this, t, r, e);
                    case "utf8":
                    case "utf-8": return m(this, t, r, e);
                    case "ascii": return E(this, t, r, e);
                    case "latin1":
                    case "binary": return B(this, t, r, e);
                    case "base64": return A(this, t, r, e);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le": return U(this, t, r, e);
                    default:
                        if (o)
                            throw new TypeError("Unknown encoding: " + n);
                        n = ("" + n).toLowerCase(), o = !0;
                } }, u$1.prototype.toJSON = function () { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) }; };
            u$1.prototype.slice = function (t, r) { var e = this.length; (t = ~~t) < 0 ? (t += e) < 0 && (t = 0) : t > e && (t = e), (r = void 0 === r ? e : ~~r) < 0 ? (r += e) < 0 && (r = 0) : r > e && (r = e), r < t && (r = t); var n = this.subarray(t, r); return Object.setPrototypeOf(n, u$1.prototype), n; }, u$1.prototype.readUIntLE = function (t, r, e) { t >>>= 0, r >>>= 0, e || x(t, r, this.length); for (var n = this[t], i = 1, o = 0; ++o < r && (i *= 256);)
                n += this[t + o] * i; return n; }, u$1.prototype.readUIntBE = function (t, r, e) { t >>>= 0, r >>>= 0, e || x(t, r, this.length); for (var n = this[t + --r], i = 1; r > 0 && (i *= 256);)
                n += this[t + --r] * i; return n; }, u$1.prototype.readUInt8 = function (t, r) { return t >>>= 0, r || x(t, 1, this.length), this[t]; }, u$1.prototype.readUInt16LE = function (t, r) { return t >>>= 0, r || x(t, 2, this.length), this[t] | this[t + 1] << 8; }, u$1.prototype.readUInt16BE = function (t, r) { return t >>>= 0, r || x(t, 2, this.length), this[t] << 8 | this[t + 1]; }, u$1.prototype.readUInt32LE = function (t, r) { return t >>>= 0, r || x(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3]; }, u$1.prototype.readUInt32BE = function (t, r) { return t >>>= 0, r || x(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]); }, u$1.prototype.readIntLE = function (t, r, e) { t >>>= 0, r >>>= 0, e || x(t, r, this.length); for (var n = this[t], i = 1, o = 0; ++o < r && (i *= 256);)
                n += this[t + o] * i; return n >= (i *= 128) && (n -= Math.pow(2, 8 * r)), n; }, u$1.prototype.readIntBE = function (t, r, e) { t >>>= 0, r >>>= 0, e || x(t, r, this.length); for (var n = r, i = 1, o = this[t + --n]; n > 0 && (i *= 256);)
                o += this[t + --n] * i; return o >= (i *= 128) && (o -= Math.pow(2, 8 * r)), o; }, u$1.prototype.readInt8 = function (t, r) { return t >>>= 0, r || x(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]; }, u$1.prototype.readInt16LE = function (t, r) { t >>>= 0, r || x(t, 2, this.length); var e = this[t] | this[t + 1] << 8; return 32768 & e ? 4294901760 | e : e; }, u$1.prototype.readInt16BE = function (t, r) { t >>>= 0, r || x(t, 2, this.length); var e = this[t + 1] | this[t] << 8; return 32768 & e ? 4294901760 | e : e; }, u$1.prototype.readInt32LE = function (t, r) { return t >>>= 0, r || x(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24; }, u$1.prototype.readInt32BE = function (t, r) { return t >>>= 0, r || x(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]; }, u$1.prototype.readFloatLE = function (t, r) { return t >>>= 0, r || x(t, 4, this.length), i.read(this, t, !0, 23, 4); }, u$1.prototype.readFloatBE = function (t, r) { return t >>>= 0, r || x(t, 4, this.length), i.read(this, t, !1, 23, 4); }, u$1.prototype.readDoubleLE = function (t, r) { return t >>>= 0, r || x(t, 8, this.length), i.read(this, t, !0, 52, 8); }, u$1.prototype.readDoubleBE = function (t, r) { return t >>>= 0, r || x(t, 8, this.length), i.read(this, t, !1, 52, 8); }, u$1.prototype.writeUIntLE = function (t, r, e, n) { (t = +t, r >>>= 0, e >>>= 0, n) || C(this, t, r, e, Math.pow(2, 8 * e) - 1, 0); var i = 1, o = 0; for (this[r] = 255 & t; ++o < e && (i *= 256);)
                this[r + o] = t / i & 255; return r + e; }, u$1.prototype.writeUIntBE = function (t, r, e, n) { (t = +t, r >>>= 0, e >>>= 0, n) || C(this, t, r, e, Math.pow(2, 8 * e) - 1, 0); var i = e - 1, o = 1; for (this[r + i] = 255 & t; --i >= 0 && (o *= 256);)
                this[r + i] = t / o & 255; return r + e; }, u$1.prototype.writeUInt8 = function (t, r, e) { return t = +t, r >>>= 0, e || C(this, t, r, 1, 255, 0), this[r] = 255 & t, r + 1; }, u$1.prototype.writeUInt16LE = function (t, r, e) { return t = +t, r >>>= 0, e || C(this, t, r, 2, 65535, 0), this[r] = 255 & t, this[r + 1] = t >>> 8, r + 2; }, u$1.prototype.writeUInt16BE = function (t, r, e) { return t = +t, r >>>= 0, e || C(this, t, r, 2, 65535, 0), this[r] = t >>> 8, this[r + 1] = 255 & t, r + 2; }, u$1.prototype.writeUInt32LE = function (t, r, e) { return t = +t, r >>>= 0, e || C(this, t, r, 4, 4294967295, 0), this[r + 3] = t >>> 24, this[r + 2] = t >>> 16, this[r + 1] = t >>> 8, this[r] = 255 & t, r + 4; }, u$1.prototype.writeUInt32BE = function (t, r, e) { return t = +t, r >>>= 0, e || C(this, t, r, 4, 4294967295, 0), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = 255 & t, r + 4; }, u$1.prototype.writeIntLE = function (t, r, e, n) { if (t = +t, r >>>= 0, !n) {
                var i = Math.pow(2, 8 * e - 1);
                C(this, t, r, e, i - 1, -i);
            } var o = 0, f = 1, u = 0; for (this[r] = 255 & t; ++o < e && (f *= 256);)
                t < 0 && 0 === u && 0 !== this[r + o - 1] && (u = 1), this[r + o] = (t / f >> 0) - u & 255; return r + e; }, u$1.prototype.writeIntBE = function (t, r, e, n) { if (t = +t, r >>>= 0, !n) {
                var i = Math.pow(2, 8 * e - 1);
                C(this, t, r, e, i - 1, -i);
            } var o = e - 1, f = 1, u = 0; for (this[r + o] = 255 & t; --o >= 0 && (f *= 256);)
                t < 0 && 0 === u && 0 !== this[r + o + 1] && (u = 1), this[r + o] = (t / f >> 0) - u & 255; return r + e; }, u$1.prototype.writeInt8 = function (t, r, e) { return t = +t, r >>>= 0, e || C(this, t, r, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[r] = 255 & t, r + 1; }, u$1.prototype.writeInt16LE = function (t, r, e) { return t = +t, r >>>= 0, e || C(this, t, r, 2, 32767, -32768), this[r] = 255 & t, this[r + 1] = t >>> 8, r + 2; }, u$1.prototype.writeInt16BE = function (t, r, e) { return t = +t, r >>>= 0, e || C(this, t, r, 2, 32767, -32768), this[r] = t >>> 8, this[r + 1] = 255 & t, r + 2; }, u$1.prototype.writeInt32LE = function (t, r, e) { return t = +t, r >>>= 0, e || C(this, t, r, 4, 2147483647, -2147483648), this[r] = 255 & t, this[r + 1] = t >>> 8, this[r + 2] = t >>> 16, this[r + 3] = t >>> 24, r + 4; }, u$1.prototype.writeInt32BE = function (t, r, e) { return t = +t, r >>>= 0, e || C(this, t, r, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = 255 & t, r + 4; }, u$1.prototype.writeFloatLE = function (t, r, e) { return k(this, t, r, !0, e); }, u$1.prototype.writeFloatBE = function (t, r, e) { return k(this, t, r, !1, e); }, u$1.prototype.writeDoubleLE = function (t, r, e) { return M(this, t, r, !0, e); }, u$1.prototype.writeDoubleBE = function (t, r, e) { return M(this, t, r, !1, e); }, u$1.prototype.copy = function (t, r, e, n) { if (!u$1.isBuffer(t))
                throw new TypeError("argument should be a Buffer"); if (e || (e = 0), n || 0 === n || (n = this.length), r >= t.length && (r = t.length), r || (r = 0), n > 0 && n < e && (n = e), n === e)
                return 0; if (0 === t.length || 0 === this.length)
                return 0; if (r < 0)
                throw new RangeError("targetStart out of bounds"); if (e < 0 || e >= this.length)
                throw new RangeError("Index out of range"); if (n < 0)
                throw new RangeError("sourceEnd out of bounds"); n > this.length && (n = this.length), t.length - r < n - e && (n = t.length - r + e); var i = n - e; if (this === t && "function" == typeof Uint8Array.prototype.copyWithin)
                this.copyWithin(r, e, n);
            else if (this === t && e < r && r < n)
                for (var o = i - 1; o >= 0; --o)
                    t[o + r] = this[o + e];
            else
                Uint8Array.prototype.set.call(t, this.subarray(e, n), r); return i; }, u$1.prototype.fill = function (t, r, e, n) { if ("string" == typeof t) {
                if ("string" == typeof r ? (n = r, r = 0, e = this.length) : "string" == typeof e && (n = e, e = this.length), void 0 !== n && "string" != typeof n)
                    throw new TypeError("encoding must be a string");
                if ("string" == typeof n && !u$1.isEncoding(n))
                    throw new TypeError("Unknown encoding: " + n);
                if (1 === t.length) {
                    var i = t.charCodeAt(0);
                    ("utf8" === n && i < 128 || "latin1" === n) && (t = i);
                }
            }
            else
                "number" == typeof t ? t &= 255 : "boolean" == typeof t && (t = Number(t)); if (r < 0 || this.length < r || this.length < e)
                throw new RangeError("Out of range index"); if (e <= r)
                return this; var o; if (r >>>= 0, e = void 0 === e ? this.length : e >>> 0, t || (t = 0), "number" == typeof t)
                for (o = r; o < e; ++o)
                    this[o] = t;
            else {
                var f = u$1.isBuffer(t) ? t : u$1.from(t, n), s = f.length;
                if (0 === s)
                    throw new TypeError('The value "' + t + '" is invalid for argument "value"');
                for (o = 0; o < e - r; ++o)
                    this[o + r] = f[o % s];
            } return this; };
            j = /[^+/0-9A-Za-z-_]/g;
            Y = function () { for (var t = new Array(256), r = 0; r < 16; ++r)
                for (var e = 16 * r, n = 0; n < 16; ++n)
                    t[e + n] = "0123456789abcdef"[r] + "0123456789abcdef"[n]; return t; }();
            Buffer = e$1.Buffer;
            exports_74("Buffer", Buffer);
            INSPECT_MAX_BYTES = e$1.INSPECT_MAX_BYTES;
            exports_74("INSPECT_MAX_BYTES", INSPECT_MAX_BYTES);
            kMaxLength = e$1.kMaxLength;
            exports_74("kMaxLength", kMaxLength);
            exports_74("default", e$1);
        }
    };
});
System.register("https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/util", ["https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/chunk-dac557ba", "https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/chunk-0c2d1322"], function (exports_75, context_75) {
    "use strict";
    var chunk_dac557ba_js_1, _extend, callbackify, debuglog, deprecate, format, inherits, inspect, isArray, isBoolean, isBuffer, isDate, isError, isFunction, isNull, isNullOrUndefined, isNumber, isObject, isPrimitive, isRegExp, isString, isSymbol, isUndefined, log, promisify;
    var __moduleName = context_75 && context_75.id;
    return {
        setters: [
            function (chunk_dac557ba_js_1_1) {
                chunk_dac557ba_js_1 = chunk_dac557ba_js_1_1;
            },
            function (_2) {
            }
        ],
        execute: function () {
            _extend = chunk_dac557ba_js_1.u._extend;
            exports_75("_extend", _extend);
            callbackify = chunk_dac557ba_js_1.u.callbackify;
            exports_75("callbackify", callbackify);
            debuglog = chunk_dac557ba_js_1.u.debuglog;
            exports_75("debuglog", debuglog);
            deprecate = chunk_dac557ba_js_1.u.deprecate;
            exports_75("deprecate", deprecate);
            format = chunk_dac557ba_js_1.u.format;
            exports_75("format", format);
            inherits = chunk_dac557ba_js_1.u.inherits;
            exports_75("inherits", inherits);
            inspect = chunk_dac557ba_js_1.u.inspect;
            exports_75("inspect", inspect);
            isArray = chunk_dac557ba_js_1.u.isArray;
            exports_75("isArray", isArray);
            isBoolean = chunk_dac557ba_js_1.u.isBoolean;
            exports_75("isBoolean", isBoolean);
            isBuffer = chunk_dac557ba_js_1.u.isBuffer;
            exports_75("isBuffer", isBuffer);
            isDate = chunk_dac557ba_js_1.u.isDate;
            exports_75("isDate", isDate);
            isError = chunk_dac557ba_js_1.u.isError;
            exports_75("isError", isError);
            isFunction = chunk_dac557ba_js_1.u.isFunction;
            exports_75("isFunction", isFunction);
            isNull = chunk_dac557ba_js_1.u.isNull;
            exports_75("isNull", isNull);
            isNullOrUndefined = chunk_dac557ba_js_1.u.isNullOrUndefined;
            exports_75("isNullOrUndefined", isNullOrUndefined);
            isNumber = chunk_dac557ba_js_1.u.isNumber;
            exports_75("isNumber", isNumber);
            isObject = chunk_dac557ba_js_1.u.isObject;
            exports_75("isObject", isObject);
            isPrimitive = chunk_dac557ba_js_1.u.isPrimitive;
            exports_75("isPrimitive", isPrimitive);
            isRegExp = chunk_dac557ba_js_1.u.isRegExp;
            exports_75("isRegExp", isRegExp);
            isString = chunk_dac557ba_js_1.u.isString;
            exports_75("isString", isString);
            isSymbol = chunk_dac557ba_js_1.u.isSymbol;
            exports_75("isSymbol", isSymbol);
            isUndefined = chunk_dac557ba_js_1.u.isUndefined;
            exports_75("isUndefined", isUndefined);
            log = chunk_dac557ba_js_1.u.log;
            exports_75("log", log);
            promisify = chunk_dac557ba_js_1.u.promisify;
            exports_75("promisify", promisify);
            exports_75("default", chunk_dac557ba_js_1.u);
        }
    };
});
System.register("https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/chunk-6e68c801", ["https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/buffer"], function (exports_76, context_76) {
    "use strict";
    var buffer_js_1, e, n, o, u, e$1, s, i;
    var __moduleName = context_76 && context_76.id;
    function t(r, e) {
        for (var n in r)
            e[n] = r[n];
    }
    function f(r, e, n) {
        return o(r, e, n);
    }
    function a(t) {
        var e;
        switch (this.encoding = function (t) {
            var e = function (t) {
                if (!t)
                    return "utf8";
                for (var e;;)
                    switch (t) {
                        case "utf8":
                        case "utf-8":
                            return "utf8";
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return "utf16le";
                        case "latin1":
                        case "binary":
                            return "latin1";
                        case "base64":
                        case "ascii":
                        case "hex":
                            return t;
                        default:
                            if (e)
                                return;
                            t = ("" + t).toLowerCase(), e = !0;
                    }
            }(t);
            if ("string" != typeof e && (s.isEncoding === i || !i(t)))
                throw new Error("Unknown encoding: " + t);
            return e || t;
        }(t), this.encoding) {
            case "utf16le":
                this.text = h, this.end = l, e = 4;
                break;
            case "utf8":
                this.fillLast = n$1, e = 4;
                break;
            case "base64":
                this.text = u$1, this.end = o$1, e = 3;
                break;
            default:
                return this.write = f$1, this.end = c, void 0;
        }
        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = s.allocUnsafe(e);
    }
    function r(t) {
        return t <= 127 ? 0 : t >> 5 == 6 ? 2 : t >> 4 == 14 ? 3 : t >> 3 == 30 ? 4 : t >> 6 == 2 ? -1 : -2;
    }
    function n$1(t) {
        var e = this.lastTotal - this.lastNeed, s = function (t, e, s) {
            if (128 != (192 & e[0]))
                return t.lastNeed = 0, "";
            if (t.lastNeed > 1 && e.length > 1) {
                if (128 != (192 & e[1]))
                    return t.lastNeed = 1, "";
                if (t.lastNeed > 2 && e.length > 2 && 128 != (192 & e[2]))
                    return t.lastNeed = 2, "";
            }
        }(this, t);
        return void 0 !== s ? s : this.lastNeed <= t.length ? (t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (t.copy(this.lastChar, e, 0, t.length), this.lastNeed -= t.length, void 0);
    }
    function h(t, e) {
        if ((t.length - e) % 2 == 0) {
            var s = t.toString("utf16le", e);
            if (s) {
                var i = s.charCodeAt(s.length - 1);
                if (i >= 55296 && i <= 56319)
                    return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], s.slice(0, -1);
            }
            return s;
        }
        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1);
    }
    function l(t) {
        var e = t && t.length ? this.write(t) : "";
        if (this.lastNeed) {
            var s = this.lastTotal - this.lastNeed;
            return e + this.lastChar.toString("utf16le", 0, s);
        }
        return e;
    }
    function u$1(t, e) {
        var s = (t.length - e) % 3;
        return 0 === s ? t.toString("base64", e) : (this.lastNeed = 3 - s, this.lastTotal = 3, 1 === s ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - s));
    }
    function o$1(t) {
        var e = t && t.length ? this.write(t) : "";
        return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e;
    }
    function f$1(t) {
        return t.toString(this.encoding);
    }
    function c(t) {
        return t && t.length ? this.write(t) : "";
    }
    return {
        setters: [
            function (buffer_js_1_1) {
                buffer_js_1 = buffer_js_1_1;
            }
        ],
        execute: function () {
            e = {}, n = buffer_js_1.default, o = n.Buffer;
            o.from && o.alloc && o.allocUnsafe && o.allocUnsafeSlow ? e = n : (t(n, e), e.Buffer = f), f.prototype = Object.create(o.prototype), t(o, f), f.from = function (r, e, n) {
                if ("number" == typeof r)
                    throw new TypeError("Argument must not be a number");
                return o(r, e, n);
            }, f.alloc = function (r, e, n) {
                if ("number" != typeof r)
                    throw new TypeError("Argument must be a number");
                var t = o(r);
                return void 0 !== e ? "string" == typeof n ? t.fill(e, n) : t.fill(e) : t.fill(0), t;
            }, f.allocUnsafe = function (r) {
                if ("number" != typeof r)
                    throw new TypeError("Argument must be a number");
                return o(r);
            }, f.allocUnsafeSlow = function (r) {
                if ("number" != typeof r)
                    throw new TypeError("Argument must be a number");
                return n.SlowBuffer(r);
            };
            u = e;
            exports_76("r", u);
            e$1 = {}, s = u.Buffer, i = s.isEncoding || function (t) {
                switch ((t = "" + t) && t.toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                    case "raw":
                        return !0;
                    default:
                        return !1;
                }
            };
            exports_76("s", e$1);
            e$1.StringDecoder = a, a.prototype.write = function (t) {
                if (0 === t.length)
                    return "";
                var e, s;
                if (this.lastNeed) {
                    if (void 0 === (e = this.fillLast(t)))
                        return "";
                    s = this.lastNeed, this.lastNeed = 0;
                }
                else
                    s = 0;
                return s < t.length ? e ? e + this.text(t, s) : this.text(t, s) : e || "";
            }, a.prototype.end = function (t) {
                var e = t && t.length ? this.write(t) : "";
                return this.lastNeed ? e + "" : e;
            }, a.prototype.text = function (t, e) {
                var s = function (t, e, s) {
                    var i = e.length - 1;
                    if (i < s)
                        return 0;
                    var a = r(e[i]);
                    if (a >= 0)
                        return a > 0 && (t.lastNeed = a - 1), a;
                    if (--i < s || -2 === a)
                        return 0;
                    if ((a = r(e[i])) >= 0)
                        return a > 0 && (t.lastNeed = a - 2), a;
                    if (--i < s || -2 === a)
                        return 0;
                    if ((a = r(e[i])) >= 0)
                        return a > 0 && (2 === a ? a = 0 : t.lastNeed = a - 3), a;
                    return 0;
                }(this, t, e);
                if (!this.lastNeed)
                    return t.toString("utf8", e);
                this.lastTotal = s;
                var i = t.length - (s - this.lastNeed);
                return t.copy(this.lastChar, 0, i), t.toString("utf8", e, i);
            }, a.prototype.fillLast = function (t) {
                if (this.lastNeed <= t.length)
                    return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
                t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length;
            };
        }
    };
});
System.register("https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/events", [], function (exports_77, context_77) {
    "use strict";
    var e, t, n, r, i, s, y, EventEmitter, defaultMaxListeners, init, listenerCount;
    var __moduleName = context_77 && context_77.id;
    function o() { o.init.call(this); }
    function u(e) { if ("function" != typeof e)
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e); }
    function f(e) { return void 0 === e._maxListeners ? o.defaultMaxListeners : e._maxListeners; }
    function v(e, t, n, r) { var i, o, s, v; if (u(n), void 0 === (o = e._events) ? (o = e._events = Object.create(null), e._eventsCount = 0) : (void 0 !== o.newListener && (e.emit("newListener", t, n.listener ? n.listener : n), o = e._events), s = o[t]), void 0 === s)
        s = o[t] = n, ++e._eventsCount;
    else if ("function" == typeof s ? s = o[t] = r ? [n, s] : [s, n] : r ? s.unshift(n) : s.push(n), (i = f(e)) > 0 && s.length > i && !s.warned) {
        s.warned = !0;
        var a = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        a.name = "MaxListenersExceededWarning", a.emitter = e, a.type = t, a.count = s.length, v = a, console && console.warn && console.warn(v);
    } return e; }
    function a() { if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments); }
    function l(e, t, n) { var r = { fired: !1, wrapFn: void 0, target: e, type: t, listener: n }, i = a.bind(r); return i.listener = n, r.wrapFn = i, i; }
    function h(e, t, n) { var r = e._events; if (void 0 === r)
        return []; var i = r[t]; return void 0 === i ? [] : "function" == typeof i ? n ? [i.listener || i] : [i] : n ? function (e) { for (var t = new Array(e.length), n = 0; n < t.length; ++n)
        t[n] = e[n].listener || e[n]; return t; }(i) : c(i, i.length); }
    function p(e) { var t = this._events; if (void 0 !== t) {
        var n = t[e];
        if ("function" == typeof n)
            return 1;
        if (void 0 !== n)
            return n.length;
    } return 0; }
    function c(e, t) { for (var n = new Array(t), r = 0; r < t; ++r)
        n[r] = e[r]; return n; }
    return {
        setters: [],
        execute: function () {
            n = "object" == typeof Reflect ? Reflect : null, r = n && "function" == typeof n.apply ? n.apply : function (e, t, n) { return Function.prototype.apply.call(e, t, n); };
            t = n && "function" == typeof n.ownKeys ? n.ownKeys : Object.getOwnPropertySymbols ? function (e) { return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e)); } : function (e) { return Object.getOwnPropertyNames(e); };
            i = Number.isNaN || function (e) { return e != e; };
            e = o, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
            s = 10;
            Object.defineProperty(o, "defaultMaxListeners", { enumerable: !0, get: function () { return s; }, set: function (e) { if ("number" != typeof e || e < 0 || i(e))
                    throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + "."); s = e; } }), o.init = function () { void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0; }, o.prototype.setMaxListeners = function (e) { if ("number" != typeof e || e < 0 || i(e))
                throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + "."); return this._maxListeners = e, this; }, o.prototype.getMaxListeners = function () { return f(this); }, o.prototype.emit = function (e) { for (var t = [], n = 1; n < arguments.length; n++)
                t.push(arguments[n]); var i = "error" === e, o = this._events; if (void 0 !== o)
                i = i && void 0 === o.error;
            else if (!i)
                return !1; if (i) {
                var s;
                if (t.length > 0 && (s = t[0]), s instanceof Error)
                    throw s;
                var u = new Error("Unhandled error." + (s ? " (" + s.message + ")" : ""));
                throw u.context = s, u;
            } var f = o[e]; if (void 0 === f)
                return !1; if ("function" == typeof f)
                r(f, this, t);
            else {
                var v = f.length, a = c(f, v);
                for (n = 0; n < v; ++n)
                    r(a[n], this, t);
            } return !0; }, o.prototype.addListener = function (e, t) { return v(this, e, t, !1); }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function (e, t) { return v(this, e, t, !0); }, o.prototype.once = function (e, t) { return u(t), this.on(e, l(this, e, t)), this; }, o.prototype.prependOnceListener = function (e, t) { return u(t), this.prependListener(e, l(this, e, t)), this; }, o.prototype.removeListener = function (e, t) { var n, r, i, o, s; if (u(t), void 0 === (r = this._events))
                return this; if (void 0 === (n = r[e]))
                return this; if (n === t || n.listener === t)
                0 == --this._eventsCount ? this._events = Object.create(null) : (delete r[e], r.removeListener && this.emit("removeListener", e, n.listener || t));
            else if ("function" != typeof n) {
                for (i = -1, o = n.length - 1; o >= 0; o--)
                    if (n[o] === t || n[o].listener === t) {
                        s = n[o].listener, i = o;
                        break;
                    }
                if (i < 0)
                    return this;
                0 === i ? n.shift() : !function (e, t) { for (; t + 1 < e.length; t++)
                    e[t] = e[t + 1]; e.pop(); }(n, i), 1 === n.length && (r[e] = n[0]), void 0 !== r.removeListener && this.emit("removeListener", e, s || t);
            } return this; }, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function (e) { var t, n, r; if (void 0 === (n = this._events))
                return this; if (void 0 === n.removeListener)
                return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== n[e] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete n[e]), this; if (0 === arguments.length) {
                var i, o = Object.keys(n);
                for (r = 0; r < o.length; ++r)
                    "removeListener" !== (i = o[r]) && this.removeAllListeners(i);
                return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
            } if ("function" == typeof (t = n[e]))
                this.removeListener(e, t);
            else if (void 0 !== t)
                for (r = t.length - 1; r >= 0; r--)
                    this.removeListener(e, t[r]); return this; }, o.prototype.listeners = function (e) { return h(this, e, !0); }, o.prototype.rawListeners = function (e) { return h(this, e, !1); }, o.listenerCount = function (e, t) { return "function" == typeof e.listenerCount ? e.listenerCount(t) : p.call(e, t); }, o.prototype.listenerCount = p, o.prototype.eventNames = function () { return this._eventsCount > 0 ? t(this._events) : []; };
            y = e;
            EventEmitter = y.EventEmitter;
            exports_77("EventEmitter", EventEmitter);
            defaultMaxListeners = y.defaultMaxListeners;
            exports_77("defaultMaxListeners", defaultMaxListeners);
            init = y.init;
            exports_77("init", init);
            listenerCount = y.listenerCount;
            exports_77("listenerCount", listenerCount);
            exports_77("default", y);
        }
    };
});
System.register("https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/chunk-cffba9d4", ["https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/chunk-dac557ba", "https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/chunk-0c2d1322", "https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/buffer", "https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/util", "https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/chunk-6e68c801", "https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/events"], function (exports_78, context_78) {
    "use strict";
    var chunk_dac557ba_js_2, chunk_0c2d1322_js_2, buffer_js_2, util_js_1, chunk_6e68c801_js_1, events_js_1, e, e$1, t, r$1, r$2, t$1, c, b, p, g, y, m, S, R, k, M, j, O, P, x, L, D, C, A, q, W, U, H, F, V, G, Y, z, J, Q, Z, $, t$2, r$3, n$1, b$1, p$1, g$1, y$1, w$1, S$1, R$1, k$1, E$1, M$1, O$1, T$1, x$1, P$1, D$1, L$1, C$1, A$1, I$1, N$1, U$1, H$1, F$1, V$1, Y$1, K$1, z$1, Q$1, X$1, t$4, t$5, n$2, i, a, o, s, f$2, h$2, p$2, o$1, e$3, s$1, t$6, o$2, e$4, f$3, v$2;
    var __moduleName = context_78 && context_78.id;
    function n(e, n, r) {
        r || (r = Error);
        class o extends r {
            constructor(e, t, r) {
                super(function (e, t, r) {
                    return "string" == typeof n ? n : n(e, t, r);
                }(e, t, r));
            }
        }
        o.prototype.name = r.name, o.prototype.code = e, t[e] = o;
    }
    function r(e, t) {
        if (Array.isArray(e)) {
            const n = e.length;
            return e = e.map(e => String(e)), n > 2 ? `one of ${t} ${e.slice(0, n - 1).join(", ")}, or ` + e[n - 1] : 2 === n ? `one of ${t} ${e[0]} or ${e[1]}` : `of ${t} ${e[0]}`;
        }
        return `of ${t} ${String(e)}`;
    }
    function e$2(e) {
        try {
            if (!r$2.localStorage)
                return !1;
        }
        catch (r) {
            return !1;
        }
        var t = r$2.localStorage[e];
        return null != t && "true" === String(t).toLowerCase();
    }
    function u(e, t) {
        var n = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var r = Object.getOwnPropertySymbols(e);
            t && (r = r.filter(function (t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable;
            })), n.push.apply(n, r);
        }
        return n;
    }
    function f(e, t, n) {
        return t in e ? Object.defineProperty(e, t, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = n, e;
    }
    function h(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
        }
    }
    function w(e, t) {
        _(e, t), v(e);
    }
    function v(e) {
        e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
    }
    function _(e, t) {
        e.emit("error", t);
    }
    function E() { }
    function T(e, t, n) {
        return t in e ? Object.defineProperty(e, t, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = n, e;
    }
    function B(e, t) {
        return {
            value: e,
            done: t
        };
    }
    function I(e) {
        var t = e[x];
        if (null !== t) {
            var n = e[W].read();
            null !== n && (e[A] = null, e[x] = null, e[L] = null, t(B(n, !1)));
        }
    }
    function N(e) {
        O.nextTick(I, e);
    }
    function K() {
        if (G)
            return V;
        G = !0;
        var d, u = chunk_0c2d1322_js_2.h;
        V = C, C.ReadableState = D;
        events_js_1.default.EventEmitter;
        var f = function (e, t) {
            return e.listeners(t).length;
        }, h = e, c = buffer_js_2.default.Buffer, b = Y.Uint8Array || function () { };
        var p, y = util_js_1.default;
        p = y && y.debuglog ? y.debuglog("stream") : function () { };
        var w, v, _, S = g, k = m, E = R.getHighWaterMark, M = e$1.codes, j = M.ERR_INVALID_ARG_TYPE, O = M.ERR_STREAM_PUSH_AFTER_EOF, T = M.ERR_METHOD_NOT_IMPLEMENTED, P = M.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
        chunk_dac557ba_js_2.t(C, h);
        var x = k.errorOrDestroy, L = ["error", "close", "destroy", "pause", "resume"];
        function D(e, t, n) {
            d = d || ee(), e = e || {}, "boolean" != typeof n && (n = t instanceof d), this.objectMode = !!e.objectMode, n && (this.objectMode = this.objectMode || !!e.readableObjectMode), this.highWaterMark = E(this, e, "readableHighWaterMark", n), this.buffer = new S(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = !1 !== e.emitClose, this.autoDestroy = !!e.autoDestroy, this.destroyed = !1, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, e.encoding && (w || (w = chunk_6e68c801_js_1.s.StringDecoder), this.decoder = new w(e.encoding), this.encoding = e.encoding);
        }
        function C(e) {
            if (d = d || ee(), !(this instanceof C))
                return new C(e);
            var t = this instanceof d;
            this._readableState = new D(e, this, t), this.readable = !0, e && ("function" == typeof e.read && (this._read = e.read), "function" == typeof e.destroy && (this._destroy = e.destroy)), h.call(this);
        }
        function A(e, t, n, r, i) {
            p("readableAddChunk", t);
            var a, o = e._readableState;
            if (null === t)
                o.reading = !1, function (e, t) {
                    if (p("onEofChunk"), t.ended)
                        return;
                    if (t.decoder) {
                        var n = t.decoder.end();
                        n && n.length && (t.buffer.push(n), t.length += t.objectMode ? 1 : n.length);
                    }
                    t.ended = !0, t.sync ? B(e) : (t.needReadable = !1, t.emittedReadable || (t.emittedReadable = !0, I(e)));
                }(e, o);
            else if (i || (a = function (e, t) {
                var n;
                r = t, c.isBuffer(r) || r instanceof b || "string" == typeof t || void 0 === t || e.objectMode || (n = new j("chunk", ["string", "Buffer", "Uint8Array"], t));
                var r;
                return n;
            }(o, t)), a)
                x(e, a);
            else if (o.objectMode || t && t.length > 0) {
                if ("string" == typeof t || o.objectMode || Object.getPrototypeOf(t) === c.prototype || (t = function (e) {
                    return c.from(e);
                }(t)), r)
                    o.endEmitted ? x(e, new P()) : q(e, o, t, !0);
                else if (o.ended)
                    x(e, new O());
                else {
                    if (o.destroyed)
                        return !1;
                    o.reading = !1, o.decoder && !n ? (t = o.decoder.write(t), o.objectMode || 0 !== t.length ? q(e, o, t, !1) : N(e, o)) : q(e, o, t, !1);
                }
            }
            else
                r || (o.reading = !1, N(e, o));
            return !o.ended && (o.length < o.highWaterMark || 0 === o.length);
        }
        function q(e, t, n, r) {
            t.flowing && 0 === t.length && !t.sync ? (t.awaitDrain = 0, e.emit("data", n)) : (t.length += t.objectMode ? 1 : n.length, r ? t.buffer.unshift(n) : t.buffer.push(n), t.needReadable && B(e)), N(e, t);
        }
        Object.defineProperty(C.prototype, "destroyed", {
            enumerable: !1,
            get: function () {
                return void 0 !== this._readableState && this._readableState.destroyed;
            },
            set: function (e) {
                this._readableState && (this._readableState.destroyed = e);
            }
        }), C.prototype.destroy = k.destroy, C.prototype._undestroy = k.undestroy, C.prototype._destroy = function (e, t) {
            t(e);
        }, C.prototype.push = function (e, t) {
            var n, r = this._readableState;
            return r.objectMode ? n = !0 : "string" == typeof e && ((t = t || r.defaultEncoding) !== r.encoding && (e = c.from(e, t), t = ""), n = !0), A(this, e, t, !1, n);
        }, C.prototype.unshift = function (e) {
            return A(this, e, null, !0, !1);
        }, C.prototype.isPaused = function () {
            return !1 === this._readableState.flowing;
        }, C.prototype.setEncoding = function (e) {
            w || (w = chunk_6e68c801_js_1.s.StringDecoder);
            var t = new w(e);
            this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
            for (var n = this._readableState.buffer.head, r = ""; null !== n;)
                r += t.write(n.data), n = n.next;
            return this._readableState.buffer.clear(), "" !== r && this._readableState.buffer.push(r), this._readableState.length = r.length, this;
        };
        function W(e, t) {
            return e <= 0 || 0 === t.length && t.ended ? 0 : t.objectMode ? 1 : e != e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = function (e) {
                return e >= 1073741824 ? e = 1073741824 : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
            }(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0));
        }
        function B(e) {
            var t = e._readableState;
            p("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = !1, t.emittedReadable || (p("emitReadable", t.flowing), t.emittedReadable = !0, u.nextTick(I, e));
        }
        function I(e) {
            var t = e._readableState;
            p("emitReadable_", t.destroyed, t.length, t.ended), t.destroyed || !t.length && !t.ended || (e.emit("readable"), t.emittedReadable = !1), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, J(e);
        }
        function N(e, t) {
            t.readingMore || (t.readingMore = !0, u.nextTick(U, e, t));
        }
        function U(e, t) {
            for (; !t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && 0 === t.length);) {
                var n = t.length;
                if (p("maybeReadMore read 0"), e.read(0), n === t.length)
                    break;
            }
            t.readingMore = !1;
        }
        function H(e) {
            var t = e._readableState;
            t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = !0 : e.listenerCount("data") > 0 && e.resume();
        }
        function K(e) {
            p("readable nexttick read 0"), e.read(0);
        }
        function z(e, t) {
            p("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = !1, e.emit("resume"), J(e), t.flowing && !t.reading && e.read(0);
        }
        function J(e) {
            var t = e._readableState;
            for (p("flow", t.flowing); t.flowing && null !== e.read();)
                ;
        }
        function Q(e, t) {
            return 0 === t.length ? null : (t.objectMode ? n = t.buffer.shift() : !e || e >= t.length ? (n = t.decoder ? t.buffer.join("") : 1 === t.buffer.length ? t.buffer.first() : t.buffer.concat(t.length), t.buffer.clear()) : n = t.buffer.consume(e, t.decoder), n);
            var n;
        }
        function X(e) {
            var t = e._readableState;
            p("endReadable", t.endEmitted), t.endEmitted || (t.ended = !0, u.nextTick(Z, t, e));
        }
        function Z(e, t) {
            if (p("endReadableNT", e.endEmitted, e.length), !e.endEmitted && 0 === e.length && (e.endEmitted = !0, t.readable = !1, t.emit("end"), e.autoDestroy)) {
                var n = t._writableState;
                (!n || n.autoDestroy && n.finished) && t.destroy();
            }
        }
        function $(e, t) {
            for (var n = 0, r = e.length; n < r; n++)
                if (e[n] === t)
                    return n;
            return -1;
        }
        return C.prototype.read = function (e) {
            p("read", e), e = parseInt(e, 10);
            var t = this._readableState, n = e;
            if (0 !== e && (t.emittedReadable = !1), 0 === e && t.needReadable && ((0 !== t.highWaterMark ? t.length >= t.highWaterMark : t.length > 0) || t.ended))
                return p("read: emitReadable", t.length, t.ended), 0 === t.length && t.ended ? X(this) : B(this), null;
            if (0 === (e = W(e, t)) && t.ended)
                return 0 === t.length && X(this), null;
            var r, i = t.needReadable;
            return p("need readable", i), (0 === t.length || t.length - e < t.highWaterMark) && p("length less than watermark", i = !0), t.ended || t.reading ? p("reading or ended", i = !1) : i && (p("do read"), t.reading = !0, t.sync = !0, 0 === t.length && (t.needReadable = !0), this._read(t.highWaterMark), t.sync = !1, t.reading || (e = W(n, t))), null === (r = e > 0 ? Q(e, t) : null) ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), 0 === t.length && (t.ended || (t.needReadable = !0), n !== e && t.ended && X(this)), null !== r && this.emit("data", r), r;
        }, C.prototype._read = function (e) {
            x(this, new T("_read()"));
        }, C.prototype.pipe = function (e, t) {
            var n = this, r = this._readableState;
            switch (r.pipesCount) {
                case 0:
                    r.pipes = e;
                    break;
                case 1:
                    r.pipes = [r.pipes, e];
                    break;
                default:
                    r.pipes.push(e);
            }
            r.pipesCount += 1, p("pipe count=%d opts=%j", r.pipesCount, t);
            var i = (!t || !1 !== t.end) && e !== u.stdout && e !== u.stderr ? o : g;
            function a(t, i) {
                p("onunpipe"), t === n && i && !1 === i.hasUnpiped && (i.hasUnpiped = !0, p("cleanup"), e.removeListener("close", c), e.removeListener("finish", b), e.removeListener("drain", s), e.removeListener("error", h), e.removeListener("unpipe", a), n.removeListener("end", o), n.removeListener("end", g), n.removeListener("data", d), l = !0, !r.awaitDrain || e._writableState && !e._writableState.needDrain || s());
            }
            function o() {
                p("onend"), e.end();
            }
            r.endEmitted ? u.nextTick(i) : n.once("end", i), e.on("unpipe", a);
            var s = function (e) {
                return function () {
                    var t = e._readableState;
                    p("pipeOnDrain", t.awaitDrain), t.awaitDrain && t.awaitDrain--, 0 === t.awaitDrain && f(e, "data") && (t.flowing = !0, J(e));
                };
            }(n);
            e.on("drain", s);
            var l = !1;
            function d(t) {
                p("ondata");
                var i = e.write(t);
                p("dest.write", i), !1 === i && ((1 === r.pipesCount && r.pipes === e || r.pipesCount > 1 && -1 !== $(r.pipes, e)) && !l && (p("false write response, pause", r.awaitDrain), r.awaitDrain++), n.pause());
            }
            function h(t) {
                p("onerror", t), g(), e.removeListener("error", h), 0 === f(e, "error") && x(e, t);
            }
            function c() {
                e.removeListener("finish", b), g();
            }
            function b() {
                p("onfinish"), e.removeListener("close", c), g();
            }
            function g() {
                p("unpipe"), n.unpipe(e);
            }
            return n.on("data", d), function (e, t, n) {
                if ("function" == typeof e.prependListener)
                    return e.prependListener(t, n);
                e._events && e._events[t] ? Array.isArray(e._events[t]) ? e._events[t].unshift(n) : e._events[t] = [n, e._events[t]] : e.on(t, n);
            }(e, "error", h), e.once("close", c), e.once("finish", b), e.emit("pipe", n), r.flowing || (p("pipe resume"), n.resume()), e;
        }, C.prototype.unpipe = function (e) {
            var t = this._readableState, n = {
                hasUnpiped: !1
            };
            if (0 === t.pipesCount)
                return this;
            if (1 === t.pipesCount)
                return e && e !== t.pipes || (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, n)), this;
            if (!e) {
                var r = t.pipes, i = t.pipesCount;
                t.pipes = null, t.pipesCount = 0, t.flowing = !1;
                for (var a = 0; a < i; a++)
                    r[a].emit("unpipe", this, {
                        hasUnpiped: !1
                    });
                return this;
            }
            var o = $(t.pipes, e);
            return -1 === o || (t.pipes.splice(o, 1), t.pipesCount -= 1, 1 === t.pipesCount && (t.pipes = t.pipes[0]), e.emit("unpipe", this, n)), this;
        }, C.prototype.on = function (e, t) {
            var n = h.prototype.on.call(this, e, t), r = this._readableState;
            return "data" === e ? (r.readableListening = this.listenerCount("readable") > 0, !1 !== r.flowing && this.resume()) : "readable" === e && (r.endEmitted || r.readableListening || (r.readableListening = r.needReadable = !0, r.flowing = !1, r.emittedReadable = !1, p("on readable", r.length, r.reading), r.length ? B(this) : r.reading || u.nextTick(K, this))), n;
        }, C.prototype.addListener = C.prototype.on, C.prototype.removeListener = function (e, t) {
            var n = h.prototype.removeListener.call(this, e, t);
            return "readable" === e && u.nextTick(H, this), n;
        }, C.prototype.removeAllListeners = function (e) {
            var t = h.prototype.removeAllListeners.apply(this, arguments);
            return "readable" !== e && void 0 !== e || u.nextTick(H, this), t;
        }, C.prototype.resume = function () {
            var e = this._readableState;
            return e.flowing || (p("resume"), e.flowing = !e.readableListening, function (e, t) {
                t.resumeScheduled || (t.resumeScheduled = !0, u.nextTick(z, e, t));
            }(this, e)), e.paused = !1, this;
        }, C.prototype.pause = function () {
            return p("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (p("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
        }, C.prototype.wrap = function (e) {
            var t = this, n = this._readableState, r = !1;
            for (var i in e.on("end", function () {
                if (p("wrapped end"), n.decoder && !n.ended) {
                    var e = n.decoder.end();
                    e && e.length && t.push(e);
                }
                t.push(null);
            }), e.on("data", function (i) {
                (p("wrapped data"), n.decoder && (i = n.decoder.write(i)), n.objectMode && null == i) || (n.objectMode || i && i.length) && (t.push(i) || (r = !0, e.pause()));
            }), e)
                void 0 === this[i] && "function" == typeof e[i] && (this[i] = function (t) {
                    return function () {
                        return e[t].apply(e, arguments);
                    };
                }(i));
            for (var a = 0; a < L.length; a++)
                e.on(L[a], this.emit.bind(this, L[a]));
            return this._read = function (t) {
                p("wrapped _read", t), r && (r = !1, e.resume());
            }, this;
        }, "function" == typeof Symbol && (C.prototype[Symbol.asyncIterator] = function () {
            return void 0 === v && (v = F), v(this);
        }), Object.defineProperty(C.prototype, "readableHighWaterMark", {
            enumerable: !1,
            get: function () {
                return this._readableState.highWaterMark;
            }
        }), Object.defineProperty(C.prototype, "readableBuffer", {
            enumerable: !1,
            get: function () {
                return this._readableState && this._readableState.buffer;
            }
        }), Object.defineProperty(C.prototype, "readableFlowing", {
            enumerable: !1,
            get: function () {
                return this._readableState.flowing;
            },
            set: function (e) {
                this._readableState && (this._readableState.flowing = e);
            }
        }), C._fromList = Q, Object.defineProperty(C.prototype, "readableLength", {
            enumerable: !1,
            get: function () {
                return this._readableState.length;
            }
        }), "function" == typeof Symbol && (C.from = function (e, t) {
            return void 0 === _ && (_ = r$1), _(C, e, t);
        }), V;
    }
    function X() {
        if (J)
            return z;
        J = !0;
        var e$2, r = chunk_0c2d1322_js_2.h;
        function s(e) {
            var t = this;
            this.next = null, this.entry = null, this.finish = function () {
                !function (e, t, n) {
                    var r = e.entry;
                    e.entry = null;
                    for (; r;) {
                        var i = r.callback;
                        t.pendingcb--, i(n), r = r.next;
                    }
                    t.corkedRequestsFree.next = e;
                }(t, e);
            };
        }
        z = P, P.WritableState = T;
        var l = {
            deprecate: t$1
        }, u = e, f = buffer_js_2.default.Buffer, h = Q.Uint8Array || function () { };
        var c, b = m, p = R.getHighWaterMark, g = e$1.codes, y = g.ERR_INVALID_ARG_TYPE, w = g.ERR_METHOD_NOT_IMPLEMENTED, v = g.ERR_MULTIPLE_CALLBACK, _ = g.ERR_STREAM_CANNOT_PIPE, S = g.ERR_STREAM_DESTROYED, k = g.ERR_STREAM_NULL_VALUES, E = g.ERR_STREAM_WRITE_AFTER_END, M = g.ERR_UNKNOWN_ENCODING, j = b.errorOrDestroy;
        function O() { }
        function T(t, n, i) {
            e$2 = e$2 || ee(), t = t || {}, "boolean" != typeof i && (i = n instanceof e$2), this.objectMode = !!t.objectMode, i && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = p(this, t, "writableHighWaterMark", i), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
            var a = !1 === t.decodeStrings;
            this.decodeStrings = !a, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function (e) {
                !function (e, t) {
                    var n = e._writableState, i = n.sync, a = n.writecb;
                    if ("function" != typeof a)
                        throw new v();
                    if (function (e) {
                        e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
                    }(n), t)
                        !function (e, t, n, i, a) {
                            --t.pendingcb, n ? (r.nextTick(a, i), r.nextTick(q, e, t), e._writableState.errorEmitted = !0, j(e, i)) : (a(i), e._writableState.errorEmitted = !0, j(e, i), q(e, t));
                        }(e, n, i, t, a);
                    else {
                        var o = C(n) || e.destroyed;
                        o || n.corked || n.bufferProcessing || !n.bufferedRequest || D(e, n), i ? r.nextTick(L, e, n, o, a) : L(e, n, o, a);
                    }
                }(n, e);
            }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !1 !== t.emitClose, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new s(this);
        }
        function P(t) {
            var n = this instanceof (e$2 = e$2 || ee());
            if (!n && !c.call(P, this))
                return new P(t);
            this._writableState = new T(t, this, n), this.writable = !0, t && ("function" == typeof t.write && (this._write = t.write), "function" == typeof t.writev && (this._writev = t.writev), "function" == typeof t.destroy && (this._destroy = t.destroy), "function" == typeof t.final && (this._final = t.final)), u.call(this);
        }
        function x(e, t, n, r, i, a, o) {
            t.writelen = r, t.writecb = o, t.writing = !0, t.sync = !0, t.destroyed ? t.onwrite(new S("write")) : n ? e._writev(i, t.onwrite) : e._write(i, a, t.onwrite), t.sync = !1;
        }
        function L(e, t, n, r) {
            n || !function (e, t) {
                0 === t.length && t.needDrain && (t.needDrain = !1, e.emit("drain"));
            }(e, t), t.pendingcb--, r(), q(e, t);
        }
        function D(e, t) {
            t.bufferProcessing = !0;
            var n = t.bufferedRequest;
            if (e._writev && n && n.next) {
                var r = t.bufferedRequestCount, i = new Array(r), a = t.corkedRequestsFree;
                a.entry = n;
                for (var o = 0, l = !0; n;)
                    i[o] = n, n.isBuf || (l = !1), n = n.next, o += 1;
                i.allBuffers = l, x(e, t, !0, t.length, i, "", a.finish), t.pendingcb++, t.lastBufferedRequest = null, a.next ? (t.corkedRequestsFree = a.next, a.next = null) : t.corkedRequestsFree = new s(t), t.bufferedRequestCount = 0;
            }
            else {
                for (; n;) {
                    var d = n.chunk, u = n.encoding, f = n.callback;
                    if (x(e, t, !1, t.objectMode ? 1 : d.length, d, u, f), n = n.next, t.bufferedRequestCount--, t.writing)
                        break;
                }
                null === n && (t.lastBufferedRequest = null);
            }
            t.bufferedRequest = n, t.bufferProcessing = !1;
        }
        function C(e) {
            return e.ending && 0 === e.length && null === e.bufferedRequest && !e.finished && !e.writing;
        }
        function A(e, t) {
            e._final(function (n) {
                t.pendingcb--, n && j(e, n), t.prefinished = !0, e.emit("prefinish"), q(e, t);
            });
        }
        function q(e, t) {
            var n = C(t);
            if (n && (!function (e, t) {
                t.prefinished || t.finalCalled || ("function" != typeof e._final || t.destroyed ? (t.prefinished = !0, e.emit("prefinish")) : (t.pendingcb++, t.finalCalled = !0, r.nextTick(A, e, t)));
            }(e, t), 0 === t.pendingcb && (t.finished = !0, e.emit("finish"), t.autoDestroy))) {
                var i = e._readableState;
                (!i || i.autoDestroy && i.endEmitted) && e.destroy();
            }
            return n;
        }
        return chunk_dac557ba_js_2.t(P, u), T.prototype.getBuffer = function () {
            for (var e = this.bufferedRequest, t = []; e;)
                t.push(e), e = e.next;
            return t;
        }, function () {
            try {
                Object.defineProperty(T.prototype, "buffer", {
                    get: l.deprecate(function () {
                        return this.getBuffer();
                    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
                });
            }
            catch (e) { }
        }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (c = Function.prototype[Symbol.hasInstance], Object.defineProperty(P, Symbol.hasInstance, {
            value: function (e) {
                return !!c.call(this, e) || this === P && e && e._writableState instanceof T;
            }
        })) : c = function (e) {
            return e instanceof this;
        }, P.prototype.pipe = function () {
            j(this, new _());
        }, P.prototype.write = function (e, t, n) {
            var i, a = this._writableState, o = !1, s = !a.objectMode && (i = e, f.isBuffer(i) || i instanceof h);
            return s && !f.isBuffer(e) && (e = function (e) {
                return f.from(e);
            }(e)), "function" == typeof t && (n = t, t = null), s ? t = "buffer" : t || (t = a.defaultEncoding), "function" != typeof n && (n = O), a.ending ? function (e, t) {
                var n = new E();
                j(e, n), r.nextTick(t, n);
            }(this, n) : (s || function (e, t, n, i) {
                var a;
                return null === n ? a = new k() : "string" == typeof n || t.objectMode || (a = new y("chunk", ["string", "Buffer"], n)), !a || (j(e, a), r.nextTick(i, a), !1);
            }(this, a, e, n)) && (a.pendingcb++, o = function (e, t, n, r, i, a) {
                if (!n) {
                    var o = function (e, t, n) {
                        e.objectMode || !1 === e.decodeStrings || "string" != typeof t || (t = f.from(t, n));
                        return t;
                    }(t, r, i);
                    r !== o && (n = !0, i = "buffer", r = o);
                }
                var s = t.objectMode ? 1 : r.length;
                t.length += s;
                var l = t.length < t.highWaterMark;
                l || (t.needDrain = !0);
                if (t.writing || t.corked) {
                    var d = t.lastBufferedRequest;
                    t.lastBufferedRequest = {
                        chunk: r,
                        encoding: i,
                        isBuf: n,
                        callback: a,
                        next: null
                    }, d ? d.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;
                }
                else
                    x(e, t, !1, s, r, i, a);
                return l;
            }(this, a, s, e, t, n)), o;
        }, P.prototype.cork = function () {
            this._writableState.corked++;
        }, P.prototype.uncork = function () {
            var e = this._writableState;
            e.corked && (e.corked--, e.writing || e.corked || e.bufferProcessing || !e.bufferedRequest || D(this, e));
        }, P.prototype.setDefaultEncoding = function (e) {
            if ("string" == typeof e && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1))
                throw new M(e);
            return this._writableState.defaultEncoding = e, this;
        }, Object.defineProperty(P.prototype, "writableBuffer", {
            enumerable: !1,
            get: function () {
                return this._writableState && this._writableState.getBuffer();
            }
        }), Object.defineProperty(P.prototype, "writableHighWaterMark", {
            enumerable: !1,
            get: function () {
                return this._writableState.highWaterMark;
            }
        }), P.prototype._write = function (e, t, n) {
            n(new w("_write()"));
        }, P.prototype._writev = null, P.prototype.end = function (e, t, n) {
            var i = this._writableState;
            return "function" == typeof e ? (n = e, e = null, t = null) : "function" == typeof t && (n = t, t = null), null != e && this.write(e, t), i.corked && (i.corked = 1, this.uncork()), i.ending || function (e, t, n) {
                t.ending = !0, q(e, t), n && (t.finished ? r.nextTick(n) : e.once("finish", n));
                t.ended = !0, e.writable = !1;
            }(this, i, n), this;
        }, Object.defineProperty(P.prototype, "writableLength", {
            enumerable: !1,
            get: function () {
                return this._writableState.length;
            }
        }), Object.defineProperty(P.prototype, "destroyed", {
            enumerable: !1,
            get: function () {
                return void 0 !== this._writableState && this._writableState.destroyed;
            },
            set: function (e) {
                this._writableState && (this._writableState.destroyed = e);
            }
        }), P.prototype.destroy = b.destroy, P.prototype._undestroy = b.undestroy, P.prototype._destroy = function (e, t) {
            t(e);
        }, z;
    }
    function ee() {
        if ($)
            return Z;
        $ = !0;
        var e = chunk_0c2d1322_js_2.h, t = Object.keys || function (e) {
            var t = [];
            for (var n in e)
                t.push(n);
            return t;
        };
        Z = d;
        var n = K(), r = X();
        chunk_dac557ba_js_2.t(d, n);
        for (var a = t(r.prototype), s = 0; s < a.length; s++) {
            var l = a[s];
            d.prototype[l] || (d.prototype[l] = r.prototype[l]);
        }
        function d(e) {
            if (!(this instanceof d))
                return new d(e);
            n.call(this, e), r.call(this, e), this.allowHalfOpen = !0, e && (!1 === e.readable && (this.readable = !1), !1 === e.writable && (this.writable = !1), !1 === e.allowHalfOpen && (this.allowHalfOpen = !1, this.once("end", u)));
        }
        function u() {
            this._writableState.ended || e.nextTick(f, this);
        }
        function f(e) {
            e.end();
        }
        return Object.defineProperty(d.prototype, "writableHighWaterMark", {
            enumerable: !1,
            get: function () {
                return this._writableState.highWaterMark;
            }
        }), Object.defineProperty(d.prototype, "writableBuffer", {
            enumerable: !1,
            get: function () {
                return this._writableState && this._writableState.getBuffer();
            }
        }), Object.defineProperty(d.prototype, "writableLength", {
            enumerable: !1,
            get: function () {
                return this._writableState.length;
            }
        }), Object.defineProperty(d.prototype, "destroyed", {
            enumerable: !1,
            get: function () {
                return void 0 !== this._readableState && void 0 !== this._writableState && this._readableState.destroyed && this._writableState.destroyed;
            },
            set: function (e) {
                void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e, this._writableState.destroyed = e);
            }
        }), Z;
    }
    function t$3() { }
    function f$1(e, t) {
        var n = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var r = Object.getOwnPropertySymbols(e);
            t && (r = r.filter(function (t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable;
            })), n.push.apply(n, r);
        }
        return n;
    }
    function h$1(e, t, n) {
        return t in e ? Object.defineProperty(e, t, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = n, e;
    }
    function c$1(e, t) {
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
        }
    }
    function _$1(e, t) {
        m$1(e, t), v$1(e);
    }
    function v$1(e) {
        e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
    }
    function m$1(e, t) {
        e.emit("error", t);
    }
    function j$1(e, t, n) {
        return t in e ? Object.defineProperty(e, t, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = n, e;
    }
    function W$1(e, t) {
        return {
            value: e,
            done: t
        };
    }
    function B$1(e) {
        var t = e[T$1];
        if (null !== t) {
            var n = e[A$1].read();
            null !== n && (e[L$1] = null, e[T$1] = null, e[x$1] = null, t(W$1(n, !1)));
        }
    }
    function q$1(e) {
        M$1.nextTick(B$1, e);
    }
    function G$1() {
        if (F$1)
            return H$1;
        F$1 = !0;
        var l, u = chunk_0c2d1322_js_2.h;
        H$1 = C, C.ReadableState = L;
        events_js_1.default.EventEmitter;
        var f = function (e, t) {
            return e.listeners(t).length;
        }, h = e, c = buffer_js_2.default.Buffer, b = V$1.Uint8Array || function () { };
        var p, g = util_js_1.default;
        p = g && g.debuglog ? g.debuglog("stream") : function () { };
        var w, _, v, m = y$1, R = S$1, k = E$1.getHighWaterMark, M = e$1.codes, j = M.ERR_INVALID_ARG_TYPE, O = M.ERR_STREAM_PUSH_AFTER_EOF, T = M.ERR_METHOD_NOT_IMPLEMENTED, x = M.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
        chunk_dac557ba_js_2.t(C, h);
        var P = R.errorOrDestroy, D = ["error", "close", "destroy", "pause", "resume"];
        function L(e, t, n) {
            l = l || Z$1(), e = e || {}, "boolean" != typeof n && (n = t instanceof l), this.objectMode = !!e.objectMode, n && (this.objectMode = this.objectMode || !!e.readableObjectMode), this.highWaterMark = k(this, e, "readableHighWaterMark", n), this.buffer = new m(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = !1 !== e.emitClose, this.autoDestroy = !!e.autoDestroy, this.destroyed = !1, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, e.encoding && (w || (w = chunk_6e68c801_js_1.s.StringDecoder), this.decoder = new w(e.encoding), this.encoding = e.encoding);
        }
        function C(e) {
            if (l = l || Z$1(), !(this instanceof C))
                return new C(e);
            var t = this instanceof l;
            this._readableState = new L(e, this, t), this.readable = !0, e && ("function" == typeof e.read && (this._read = e.read), "function" == typeof e.destroy && (this._destroy = e.destroy)), h.call(this);
        }
        function A(e, t, n, r, i) {
            p("readableAddChunk", t);
            var a, o = e._readableState;
            if (null === t)
                o.reading = !1, function (e, t) {
                    if (p("onEofChunk"), t.ended)
                        return;
                    if (t.decoder) {
                        var n = t.decoder.end();
                        n && n.length && (t.buffer.push(n), t.length += t.objectMode ? 1 : n.length);
                    }
                    t.ended = !0, t.sync ? q(e) : (t.needReadable = !1, t.emittedReadable || (t.emittedReadable = !0, I(e)));
                }(e, o);
            else if (i || (a = function (e, t) {
                var n;
                r = t, c.isBuffer(r) || r instanceof b || "string" == typeof t || void 0 === t || e.objectMode || (n = new j("chunk", ["string", "Buffer", "Uint8Array"], t));
                var r;
                return n;
            }(o, t)), a)
                P(e, a);
            else if (o.objectMode || t && t.length > 0) {
                if ("string" == typeof t || o.objectMode || Object.getPrototypeOf(t) === c.prototype || (t = function (e) {
                    return c.from(e);
                }(t)), r)
                    o.endEmitted ? P(e, new x()) : W(e, o, t, !0);
                else if (o.ended)
                    P(e, new O());
                else {
                    if (o.destroyed)
                        return !1;
                    o.reading = !1, o.decoder && !n ? (t = o.decoder.write(t), o.objectMode || 0 !== t.length ? W(e, o, t, !1) : N(e, o)) : W(e, o, t, !1);
                }
            }
            else
                r || (o.reading = !1, N(e, o));
            return !o.ended && (o.length < o.highWaterMark || 0 === o.length);
        }
        function W(e, t, n, r) {
            t.flowing && 0 === t.length && !t.sync ? (t.awaitDrain = 0, e.emit("data", n)) : (t.length += t.objectMode ? 1 : n.length, r ? t.buffer.unshift(n) : t.buffer.push(n), t.needReadable && q(e)), N(e, t);
        }
        Object.defineProperty(C.prototype, "destroyed", {
            enumerable: !1,
            get: function () {
                return void 0 !== this._readableState && this._readableState.destroyed;
            },
            set: function (e) {
                this._readableState && (this._readableState.destroyed = e);
            }
        }), C.prototype.destroy = R.destroy, C.prototype._undestroy = R.undestroy, C.prototype._destroy = function (e, t) {
            t(e);
        }, C.prototype.push = function (e, t) {
            var n, r = this._readableState;
            return r.objectMode ? n = !0 : "string" == typeof e && ((t = t || r.defaultEncoding) !== r.encoding && (e = c.from(e, t), t = ""), n = !0), A(this, e, t, !1, n);
        }, C.prototype.unshift = function (e) {
            return A(this, e, null, !0, !1);
        }, C.prototype.isPaused = function () {
            return !1 === this._readableState.flowing;
        }, C.prototype.setEncoding = function (e) {
            w || (w = chunk_6e68c801_js_1.s.StringDecoder);
            var t = new w(e);
            this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
            for (var n = this._readableState.buffer.head, r = ""; null !== n;)
                r += t.write(n.data), n = n.next;
            return this._readableState.buffer.clear(), "" !== r && this._readableState.buffer.push(r), this._readableState.length = r.length, this;
        };
        function B(e, t) {
            return e <= 0 || 0 === t.length && t.ended ? 0 : t.objectMode ? 1 : e != e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = function (e) {
                return e >= 1073741824 ? e = 1073741824 : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
            }(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0));
        }
        function q(e) {
            var t = e._readableState;
            p("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = !1, t.emittedReadable || (p("emitReadable", t.flowing), t.emittedReadable = !0, u.nextTick(I, e));
        }
        function I(e) {
            var t = e._readableState;
            p("emitReadable_", t.destroyed, t.length, t.ended), t.destroyed || !t.length && !t.ended || (e.emit("readable"), t.emittedReadable = !1), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, J(e);
        }
        function N(e, t) {
            t.readingMore || (t.readingMore = !0, u.nextTick(G, e, t));
        }
        function G(e, t) {
            for (; !t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && 0 === t.length);) {
                var n = t.length;
                if (p("maybeReadMore read 0"), e.read(0), n === t.length)
                    break;
            }
            t.readingMore = !1;
        }
        function Y(e) {
            var t = e._readableState;
            t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = !0 : e.listenerCount("data") > 0 && e.resume();
        }
        function K(e) {
            p("readable nexttick read 0"), e.read(0);
        }
        function z(e, t) {
            p("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = !1, e.emit("resume"), J(e), t.flowing && !t.reading && e.read(0);
        }
        function J(e) {
            var t = e._readableState;
            for (p("flow", t.flowing); t.flowing && null !== e.read();)
                ;
        }
        function Q(e, t) {
            return 0 === t.length ? null : (t.objectMode ? n = t.buffer.shift() : !e || e >= t.length ? (n = t.decoder ? t.buffer.join("") : 1 === t.buffer.length ? t.buffer.first() : t.buffer.concat(t.length), t.buffer.clear()) : n = t.buffer.consume(e, t.decoder), n);
            var n;
        }
        function X(e) {
            var t = e._readableState;
            p("endReadable", t.endEmitted), t.endEmitted || (t.ended = !0, u.nextTick($, t, e));
        }
        function $(e, t) {
            if (p("endReadableNT", e.endEmitted, e.length), !e.endEmitted && 0 === e.length && (e.endEmitted = !0, t.readable = !1, t.emit("end"), e.autoDestroy)) {
                var n = t._writableState;
                (!n || n.autoDestroy && n.finished) && t.destroy();
            }
        }
        function ee(e, t) {
            for (var n = 0, r = e.length; n < r; n++)
                if (e[n] === t)
                    return n;
            return -1;
        }
        return C.prototype.read = function (e) {
            p("read", e), e = parseInt(e, 10);
            var t = this._readableState, n = e;
            if (0 !== e && (t.emittedReadable = !1), 0 === e && t.needReadable && ((0 !== t.highWaterMark ? t.length >= t.highWaterMark : t.length > 0) || t.ended))
                return p("read: emitReadable", t.length, t.ended), 0 === t.length && t.ended ? X(this) : q(this), null;
            if (0 === (e = B(e, t)) && t.ended)
                return 0 === t.length && X(this), null;
            var r, i = t.needReadable;
            return p("need readable", i), (0 === t.length || t.length - e < t.highWaterMark) && p("length less than watermark", i = !0), t.ended || t.reading ? p("reading or ended", i = !1) : i && (p("do read"), t.reading = !0, t.sync = !0, 0 === t.length && (t.needReadable = !0), this._read(t.highWaterMark), t.sync = !1, t.reading || (e = B(n, t))), null === (r = e > 0 ? Q(e, t) : null) ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), 0 === t.length && (t.ended || (t.needReadable = !0), n !== e && t.ended && X(this)), null !== r && this.emit("data", r), r;
        }, C.prototype._read = function (e) {
            P(this, new T("_read()"));
        }, C.prototype.pipe = function (e, t) {
            var n = this, r = this._readableState;
            switch (r.pipesCount) {
                case 0:
                    r.pipes = e;
                    break;
                case 1:
                    r.pipes = [r.pipes, e];
                    break;
                default:
                    r.pipes.push(e);
            }
            r.pipesCount += 1, p("pipe count=%d opts=%j", r.pipesCount, t);
            var i = (!t || !1 !== t.end) && e !== u.stdout && e !== u.stderr ? o : g;
            function a(t, i) {
                p("onunpipe"), t === n && i && !1 === i.hasUnpiped && (i.hasUnpiped = !0, p("cleanup"), e.removeListener("close", c), e.removeListener("finish", b), e.removeListener("drain", s), e.removeListener("error", h), e.removeListener("unpipe", a), n.removeListener("end", o), n.removeListener("end", g), n.removeListener("data", d), l = !0, !r.awaitDrain || e._writableState && !e._writableState.needDrain || s());
            }
            function o() {
                p("onend"), e.end();
            }
            r.endEmitted ? u.nextTick(i) : n.once("end", i), e.on("unpipe", a);
            var s = function (e) {
                return function () {
                    var t = e._readableState;
                    p("pipeOnDrain", t.awaitDrain), t.awaitDrain && t.awaitDrain--, 0 === t.awaitDrain && f(e, "data") && (t.flowing = !0, J(e));
                };
            }(n);
            e.on("drain", s);
            var l = !1;
            function d(t) {
                p("ondata");
                var i = e.write(t);
                p("dest.write", i), !1 === i && ((1 === r.pipesCount && r.pipes === e || r.pipesCount > 1 && -1 !== ee(r.pipes, e)) && !l && (p("false write response, pause", r.awaitDrain), r.awaitDrain++), n.pause());
            }
            function h(t) {
                p("onerror", t), g(), e.removeListener("error", h), 0 === f(e, "error") && P(e, t);
            }
            function c() {
                e.removeListener("finish", b), g();
            }
            function b() {
                p("onfinish"), e.removeListener("close", c), g();
            }
            function g() {
                p("unpipe"), n.unpipe(e);
            }
            return n.on("data", d), function (e, t, n) {
                if ("function" == typeof e.prependListener)
                    return e.prependListener(t, n);
                e._events && e._events[t] ? Array.isArray(e._events[t]) ? e._events[t].unshift(n) : e._events[t] = [n, e._events[t]] : e.on(t, n);
            }(e, "error", h), e.once("close", c), e.once("finish", b), e.emit("pipe", n), r.flowing || (p("pipe resume"), n.resume()), e;
        }, C.prototype.unpipe = function (e) {
            var t = this._readableState, n = {
                hasUnpiped: !1
            };
            if (0 === t.pipesCount)
                return this;
            if (1 === t.pipesCount)
                return e && e !== t.pipes || (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, n)), this;
            if (!e) {
                var r = t.pipes, i = t.pipesCount;
                t.pipes = null, t.pipesCount = 0, t.flowing = !1;
                for (var a = 0; a < i; a++)
                    r[a].emit("unpipe", this, {
                        hasUnpiped: !1
                    });
                return this;
            }
            var o = ee(t.pipes, e);
            return -1 === o || (t.pipes.splice(o, 1), t.pipesCount -= 1, 1 === t.pipesCount && (t.pipes = t.pipes[0]), e.emit("unpipe", this, n)), this;
        }, C.prototype.on = function (e, t) {
            var n = h.prototype.on.call(this, e, t), r = this._readableState;
            return "data" === e ? (r.readableListening = this.listenerCount("readable") > 0, !1 !== r.flowing && this.resume()) : "readable" === e && (r.endEmitted || r.readableListening || (r.readableListening = r.needReadable = !0, r.flowing = !1, r.emittedReadable = !1, p("on readable", r.length, r.reading), r.length ? q(this) : r.reading || u.nextTick(K, this))), n;
        }, C.prototype.addListener = C.prototype.on, C.prototype.removeListener = function (e, t) {
            var n = h.prototype.removeListener.call(this, e, t);
            return "readable" === e && u.nextTick(Y, this), n;
        }, C.prototype.removeAllListeners = function (e) {
            var t = h.prototype.removeAllListeners.apply(this, arguments);
            return "readable" !== e && void 0 !== e || u.nextTick(Y, this), t;
        }, C.prototype.resume = function () {
            var e = this._readableState;
            return e.flowing || (p("resume"), e.flowing = !e.readableListening, function (e, t) {
                t.resumeScheduled || (t.resumeScheduled = !0, u.nextTick(z, e, t));
            }(this, e)), e.paused = !1, this;
        }, C.prototype.pause = function () {
            return p("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (p("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
        }, C.prototype.wrap = function (e) {
            var t = this, n = this._readableState, r = !1;
            for (var i in e.on("end", function () {
                if (p("wrapped end"), n.decoder && !n.ended) {
                    var e = n.decoder.end();
                    e && e.length && t.push(e);
                }
                t.push(null);
            }), e.on("data", function (i) {
                (p("wrapped data"), n.decoder && (i = n.decoder.write(i)), n.objectMode && null == i) || (n.objectMode || i && i.length) && (t.push(i) || (r = !0, e.pause()));
            }), e)
                void 0 === this[i] && "function" == typeof e[i] && (this[i] = function (t) {
                    return function () {
                        return e[t].apply(e, arguments);
                    };
                }(i));
            for (var a = 0; a < D.length; a++)
                e.on(D[a], this.emit.bind(this, D[a]));
            return this._read = function (t) {
                p("wrapped _read", t), r && (r = !1, e.resume());
            }, this;
        }, "function" == typeof Symbol && (C.prototype[Symbol.asyncIterator] = function () {
            return void 0 === _ && (_ = U$1), _(this);
        }), Object.defineProperty(C.prototype, "readableHighWaterMark", {
            enumerable: !1,
            get: function () {
                return this._readableState.highWaterMark;
            }
        }), Object.defineProperty(C.prototype, "readableBuffer", {
            enumerable: !1,
            get: function () {
                return this._readableState && this._readableState.buffer;
            }
        }), Object.defineProperty(C.prototype, "readableFlowing", {
            enumerable: !1,
            get: function () {
                return this._readableState.flowing;
            },
            set: function (e) {
                this._readableState && (this._readableState.flowing = e);
            }
        }), C._fromList = Q, Object.defineProperty(C.prototype, "readableLength", {
            enumerable: !1,
            get: function () {
                return this._readableState.length;
            }
        }), "function" == typeof Symbol && (C.from = function (e, t) {
            return void 0 === v && (v = r$1), v(C, e, t);
        }), H$1;
    }
    function J$1() {
        if (K$1)
            return Y$1;
        K$1 = !0;
        var e$2, r = chunk_0c2d1322_js_2.h;
        function s(e) {
            var t = this;
            this.next = null, this.entry = null, this.finish = function () {
                !function (e, t, n) {
                    var r = e.entry;
                    e.entry = null;
                    for (; r;) {
                        var i = r.callback;
                        t.pendingcb--, i(n), r = r.next;
                    }
                    t.corkedRequestsFree.next = e;
                }(t, e);
            };
        }
        Y$1 = x, x.WritableState = T;
        var l = {
            deprecate: t$1
        }, d = e, f = buffer_js_2.default.Buffer, h = z$1.Uint8Array || function () { };
        var c, b = S$1, p = E$1.getHighWaterMark, g = e$1.codes, y = g.ERR_INVALID_ARG_TYPE, w = g.ERR_METHOD_NOT_IMPLEMENTED, _ = g.ERR_MULTIPLE_CALLBACK, v = g.ERR_STREAM_CANNOT_PIPE, m = g.ERR_STREAM_DESTROYED, R = g.ERR_STREAM_NULL_VALUES, k = g.ERR_STREAM_WRITE_AFTER_END, M = g.ERR_UNKNOWN_ENCODING, j = b.errorOrDestroy;
        function O() { }
        function T(t, n, i) {
            e$2 = e$2 || Z$1(), t = t || {}, "boolean" != typeof i && (i = n instanceof e$2), this.objectMode = !!t.objectMode, i && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = p(this, t, "writableHighWaterMark", i), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
            var a = !1 === t.decodeStrings;
            this.decodeStrings = !a, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function (e) {
                !function (e, t) {
                    var n = e._writableState, i = n.sync, a = n.writecb;
                    if ("function" != typeof a)
                        throw new _();
                    if (function (e) {
                        e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
                    }(n), t)
                        !function (e, t, n, i, a) {
                            --t.pendingcb, n ? (r.nextTick(a, i), r.nextTick(W, e, t), e._writableState.errorEmitted = !0, j(e, i)) : (a(i), e._writableState.errorEmitted = !0, j(e, i), W(e, t));
                        }(e, n, i, t, a);
                    else {
                        var o = C(n) || e.destroyed;
                        o || n.corked || n.bufferProcessing || !n.bufferedRequest || L(e, n), i ? r.nextTick(D, e, n, o, a) : D(e, n, o, a);
                    }
                }(n, e);
            }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !1 !== t.emitClose, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new s(this);
        }
        function x(t) {
            var n = this instanceof (e$2 = e$2 || Z$1());
            if (!n && !c.call(x, this))
                return new x(t);
            this._writableState = new T(t, this, n), this.writable = !0, t && ("function" == typeof t.write && (this._write = t.write), "function" == typeof t.writev && (this._writev = t.writev), "function" == typeof t.destroy && (this._destroy = t.destroy), "function" == typeof t.final && (this._final = t.final)), d.call(this);
        }
        function P(e, t, n, r, i, a, o) {
            t.writelen = r, t.writecb = o, t.writing = !0, t.sync = !0, t.destroyed ? t.onwrite(new m("write")) : n ? e._writev(i, t.onwrite) : e._write(i, a, t.onwrite), t.sync = !1;
        }
        function D(e, t, n, r) {
            n || !function (e, t) {
                0 === t.length && t.needDrain && (t.needDrain = !1, e.emit("drain"));
            }(e, t), t.pendingcb--, r(), W(e, t);
        }
        function L(e, t) {
            t.bufferProcessing = !0;
            var n = t.bufferedRequest;
            if (e._writev && n && n.next) {
                var r = t.bufferedRequestCount, i = new Array(r), a = t.corkedRequestsFree;
                a.entry = n;
                for (var o = 0, l = !0; n;)
                    i[o] = n, n.isBuf || (l = !1), n = n.next, o += 1;
                i.allBuffers = l, P(e, t, !0, t.length, i, "", a.finish), t.pendingcb++, t.lastBufferedRequest = null, a.next ? (t.corkedRequestsFree = a.next, a.next = null) : t.corkedRequestsFree = new s(t), t.bufferedRequestCount = 0;
            }
            else {
                for (; n;) {
                    var d = n.chunk, u = n.encoding, f = n.callback;
                    if (P(e, t, !1, t.objectMode ? 1 : d.length, d, u, f), n = n.next, t.bufferedRequestCount--, t.writing)
                        break;
                }
                null === n && (t.lastBufferedRequest = null);
            }
            t.bufferedRequest = n, t.bufferProcessing = !1;
        }
        function C(e) {
            return e.ending && 0 === e.length && null === e.bufferedRequest && !e.finished && !e.writing;
        }
        function A(e, t) {
            e._final(function (n) {
                t.pendingcb--, n && j(e, n), t.prefinished = !0, e.emit("prefinish"), W(e, t);
            });
        }
        function W(e, t) {
            var n = C(t);
            if (n && (!function (e, t) {
                t.prefinished || t.finalCalled || ("function" != typeof e._final || t.destroyed ? (t.prefinished = !0, e.emit("prefinish")) : (t.pendingcb++, t.finalCalled = !0, r.nextTick(A, e, t)));
            }(e, t), 0 === t.pendingcb && (t.finished = !0, e.emit("finish"), t.autoDestroy))) {
                var i = e._readableState;
                (!i || i.autoDestroy && i.endEmitted) && e.destroy();
            }
            return n;
        }
        return chunk_dac557ba_js_2.t(x, d), T.prototype.getBuffer = function () {
            for (var e = this.bufferedRequest, t = []; e;)
                t.push(e), e = e.next;
            return t;
        }, function () {
            try {
                Object.defineProperty(T.prototype, "buffer", {
                    get: l.deprecate(function () {
                        return this.getBuffer();
                    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
                });
            }
            catch (e) { }
        }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (c = Function.prototype[Symbol.hasInstance], Object.defineProperty(x, Symbol.hasInstance, {
            value: function (e) {
                return !!c.call(this, e) || this === x && e && e._writableState instanceof T;
            }
        })) : c = function (e) {
            return e instanceof this;
        }, x.prototype.pipe = function () {
            j(this, new v());
        }, x.prototype.write = function (e, t, n) {
            var i, a = this._writableState, o = !1, s = !a.objectMode && (i = e, f.isBuffer(i) || i instanceof h);
            return s && !f.isBuffer(e) && (e = function (e) {
                return f.from(e);
            }(e)), "function" == typeof t && (n = t, t = null), s ? t = "buffer" : t || (t = a.defaultEncoding), "function" != typeof n && (n = O), a.ending ? function (e, t) {
                var n = new k();
                j(e, n), r.nextTick(t, n);
            }(this, n) : (s || function (e, t, n, i) {
                var a;
                return null === n ? a = new R() : "string" == typeof n || t.objectMode || (a = new y("chunk", ["string", "Buffer"], n)), !a || (j(e, a), r.nextTick(i, a), !1);
            }(this, a, e, n)) && (a.pendingcb++, o = function (e, t, n, r, i, a) {
                if (!n) {
                    var o = function (e, t, n) {
                        e.objectMode || !1 === e.decodeStrings || "string" != typeof t || (t = f.from(t, n));
                        return t;
                    }(t, r, i);
                    r !== o && (n = !0, i = "buffer", r = o);
                }
                var s = t.objectMode ? 1 : r.length;
                t.length += s;
                var l = t.length < t.highWaterMark;
                l || (t.needDrain = !0);
                if (t.writing || t.corked) {
                    var d = t.lastBufferedRequest;
                    t.lastBufferedRequest = {
                        chunk: r,
                        encoding: i,
                        isBuf: n,
                        callback: a,
                        next: null
                    }, d ? d.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;
                }
                else
                    P(e, t, !1, s, r, i, a);
                return l;
            }(this, a, s, e, t, n)), o;
        }, x.prototype.cork = function () {
            this._writableState.corked++;
        }, x.prototype.uncork = function () {
            var e = this._writableState;
            e.corked && (e.corked--, e.writing || e.corked || e.bufferProcessing || !e.bufferedRequest || L(this, e));
        }, x.prototype.setDefaultEncoding = function (e) {
            if ("string" == typeof e && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1))
                throw new M(e);
            return this._writableState.defaultEncoding = e, this;
        }, Object.defineProperty(x.prototype, "writableBuffer", {
            enumerable: !1,
            get: function () {
                return this._writableState && this._writableState.getBuffer();
            }
        }), Object.defineProperty(x.prototype, "writableHighWaterMark", {
            enumerable: !1,
            get: function () {
                return this._writableState.highWaterMark;
            }
        }), x.prototype._write = function (e, t, n) {
            n(new w("_write()"));
        }, x.prototype._writev = null, x.prototype.end = function (e, t, n) {
            var i = this._writableState;
            return "function" == typeof e ? (n = e, e = null, t = null) : "function" == typeof t && (n = t, t = null), null != e && this.write(e, t), i.corked && (i.corked = 1, this.uncork()), i.ending || function (e, t, n) {
                t.ending = !0, W(e, t), n && (t.finished ? r.nextTick(n) : e.once("finish", n));
                t.ended = !0, e.writable = !1;
            }(this, i, n), this;
        }, Object.defineProperty(x.prototype, "writableLength", {
            enumerable: !1,
            get: function () {
                return this._writableState.length;
            }
        }), Object.defineProperty(x.prototype, "destroyed", {
            enumerable: !1,
            get: function () {
                return void 0 !== this._writableState && this._writableState.destroyed;
            },
            set: function (e) {
                this._writableState && (this._writableState.destroyed = e);
            }
        }), x.prototype.destroy = b.destroy, x.prototype._undestroy = b.undestroy, x.prototype._destroy = function (e, t) {
            t(e);
        }, Y$1;
    }
    function Z$1() {
        if (X$1)
            return Q$1;
        X$1 = !0;
        var e = chunk_0c2d1322_js_2.h, t = Object.keys || function (e) {
            var t = [];
            for (var n in e)
                t.push(n);
            return t;
        };
        Q$1 = d;
        var n = G$1(), r = J$1();
        chunk_dac557ba_js_2.t(d, n);
        for (var a = t(r.prototype), s = 0; s < a.length; s++) {
            var l = a[s];
            d.prototype[l] || (d.prototype[l] = r.prototype[l]);
        }
        function d(e) {
            if (!(this instanceof d))
                return new d(e);
            n.call(this, e), r.call(this, e), this.allowHalfOpen = !0, e && (!1 === e.readable && (this.readable = !1), !1 === e.writable && (this.writable = !1), !1 === e.allowHalfOpen && (this.allowHalfOpen = !1, this.once("end", u)));
        }
        function u() {
            this._writableState.ended || e.nextTick(f, this);
        }
        function f(e) {
            e.end();
        }
        return Object.defineProperty(d.prototype, "writableHighWaterMark", {
            enumerable: !1,
            get: function () {
                return this._writableState.highWaterMark;
            }
        }), Object.defineProperty(d.prototype, "writableBuffer", {
            enumerable: !1,
            get: function () {
                return this._writableState && this._writableState.getBuffer();
            }
        }), Object.defineProperty(d.prototype, "writableLength", {
            enumerable: !1,
            get: function () {
                return this._writableState.length;
            }
        }), Object.defineProperty(d.prototype, "destroyed", {
            enumerable: !1,
            get: function () {
                return void 0 !== this._readableState && void 0 !== this._writableState && this._readableState.destroyed && this._writableState.destroyed;
            },
            set: function (e) {
                void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e, this._writableState.destroyed = e);
            }
        }), Q$1;
    }
    function l(t, r) {
        var e = this._transformState;
        e.transforming = !1;
        var n = e.writecb;
        if (null === n)
            return this.emit("error", new o());
        e.writechunk = null, e.writecb = null, null != r && this.push(r), n(t);
        var i = this._readableState;
        i.reading = !1, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
    }
    function u$1(t) {
        if (!(this instanceof u$1))
            return new u$1(t);
        h$2.call(this, t), this._transformState = {
            afterTransform: l.bind(this),
            needTransform: !1,
            transforming: !1,
            writecb: null,
            writechunk: null,
            writeencoding: null
        }, this._readableState.needReadable = !0, this._readableState.sync = !1, t && ("function" == typeof t.transform && (this._transform = t.transform), "function" == typeof t.flush && (this._flush = t.flush)), this.on("prefinish", m$2);
    }
    function m$2() {
        var t = this;
        "function" != typeof this._flush || this._readableState.destroyed ? _$2(this, null, null) : this._flush(function (r, e) {
            _$2(t, r, e);
        });
    }
    function _$2(t, r, e) {
        if (r)
            return t.emit("error", r);
        if (null != e && t.push(e), t._writableState.length)
            throw new f$2();
        if (t._transformState.transforming)
            throw new s();
        return t.push(null);
    }
    function i$1(r) {
        if (!(this instanceof i$1))
            return new i$1(r);
        e$3.call(this, r);
    }
    function i$2(r) {
        if (r)
            throw r;
    }
    function u$2(r, o, e, i) {
        i = function (r) {
            var n = !1;
            return function () {
                n || (n = !0, r.apply(void 0, arguments));
            };
        }(i);
        var u = !1;
        r.on("close", function () {
            u = !0;
        }), void 0 === t$6 && (t$6 = n$1), t$6(r, {
            readable: o,
            writable: e
        }, function (r) {
            if (r)
                return i(r);
            u = !0, i();
        });
        var a = !1;
        return function (n) {
            if (!u && !a)
                return a = !0, function (r) {
                    return r.setHeader && "function" == typeof r.abort;
                }(r) ? r.abort() : "function" == typeof r.destroy ? r.destroy() : (i(n || new f$3("pipe")), void 0);
        };
    }
    function a$1(r) {
        r();
    }
    function c$2(r, n) {
        return r.pipe(n);
    }
    function p$3(r) {
        return r.length ? "function" != typeof r[r.length - 1] ? i$2 : r.pop() : i$2;
    }
    return {
        setters: [
            function (chunk_dac557ba_js_2_1) {
                chunk_dac557ba_js_2 = chunk_dac557ba_js_2_1;
            },
            function (chunk_0c2d1322_js_2_1) {
                chunk_0c2d1322_js_2 = chunk_0c2d1322_js_2_1;
            },
            function (buffer_js_2_1) {
                buffer_js_2 = buffer_js_2_1;
            },
            function (util_js_1_1) {
                util_js_1 = util_js_1_1;
            },
            function (chunk_6e68c801_js_1_1) {
                chunk_6e68c801_js_1 = chunk_6e68c801_js_1_1;
            },
            function (events_js_1_1) {
                events_js_1 = events_js_1_1;
            }
        ],
        execute: function () {
            e = events_js_1.default.EventEmitter;
            e$1 = {};
            t = {};
            n("ERR_INVALID_OPT_VALUE", function (e, t) {
                return 'The value "' + t + '" is invalid for option "' + e + '"';
            }, TypeError), n("ERR_INVALID_ARG_TYPE", function (e, t, n) {
                let o;
                var E;
                let u;
                if ("string" == typeof t && (E = "not ", t.substr(0, E.length) === E) ? (o = "must not be", t = t.replace(/^not /, "")) : o = "must be", function (e, t, n) {
                    return (void 0 === n || n > e.length) && (n = e.length), e.substring(n - t.length, n) === t;
                }(e, " argument"))
                    u = `The ${e} ${o} ${r(t, "type")}`;
                else {
                    u = `The "${e}" ${function (e, t, n) {
                        return "number" != typeof n && (n = 0), !(n + t.length > e.length) && -1 !== e.indexOf(t, n);
                    }(e, ".") ? "property" : "argument"} ${o} ${r(t, "type")}`;
                }
                return u += `. Received type ${typeof n}`, u;
            }, TypeError), n("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), n("ERR_METHOD_NOT_IMPLEMENTED", function (e) {
                return "The " + e + " method is not implemented";
            }), n("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), n("ERR_STREAM_DESTROYED", function (e) {
                return "Cannot call " + e + " after a stream was destroyed";
            }), n("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), n("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), n("ERR_STREAM_WRITE_AFTER_END", "write after end"), n("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), n("ERR_UNKNOWN_ENCODING", function (e) {
                return "Unknown encoding: " + e;
            }, TypeError), n("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), e$1.codes = t;
            r$1 = function () {
                throw new Error("Readable.from is not available in the browser");
            };
            r$2 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;
            t$1 = function (t, n) {
                if (e$2("noDeprecation"))
                    return t;
                var o = !1;
                return function () {
                    if (!o) {
                        if (e$2("throwDeprecation"))
                            throw new Error(n);
                        e$2("traceDeprecation") ? console.trace(n) : console.warn(n), o = !0;
                    }
                    return t.apply(this || r$2, arguments);
                };
            };
            c = buffer_js_2.default.Buffer, b = util_js_1.default.inspect, p = b && b.custom || "inspect";
            g = function () {
                function e() {
                    !function (e, t) {
                        if (!(e instanceof t))
                            throw new TypeError("Cannot call a class as a function");
                    }(this, e), this.head = null, this.tail = null, this.length = 0;
                }
                var t, n;
                return t = e, (n = [{
                        key: "push",
                        value: function (e) {
                            var t = {
                                data: e,
                                next: null
                            };
                            this.length > 0 ? this.tail.next = t : this.head = t, this.tail = t, ++this.length;
                        }
                    }, {
                        key: "unshift",
                        value: function (e) {
                            var t = {
                                data: e,
                                next: this.head
                            };
                            0 === this.length && (this.tail = t), this.head = t, ++this.length;
                        }
                    }, {
                        key: "shift",
                        value: function () {
                            if (0 !== this.length) {
                                var e = this.head.data;
                                return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e;
                            }
                        }
                    }, {
                        key: "clear",
                        value: function () {
                            this.head = this.tail = null, this.length = 0;
                        }
                    }, {
                        key: "join",
                        value: function (e) {
                            if (0 === this.length)
                                return "";
                            for (var t = this.head, n = "" + t.data; t = t.next;)
                                n += e + t.data;
                            return n;
                        }
                    }, {
                        key: "concat",
                        value: function (e) {
                            if (0 === this.length)
                                return c.alloc(0);
                            for (var t, n, r, i = c.allocUnsafe(e >>> 0), a = this.head, o = 0; a;)
                                t = a.data, n = i, r = o, void c.prototype.copy.call(t, n, r), o += a.data.length, a = a.next;
                            return i;
                        }
                    }, {
                        key: "consume",
                        value: function (e, t) {
                            var n;
                            return e < this.head.data.length ? (n = this.head.data.slice(0, e), this.head.data = this.head.data.slice(e)) : n = e === this.head.data.length ? this.shift() : t ? this._getString(e) : this._getBuffer(e), n;
                        }
                    }, {
                        key: "first",
                        value: function () {
                            return this.head.data;
                        }
                    }, {
                        key: "_getString",
                        value: function (e) {
                            var t = this.head, n = 1, r = t.data;
                            for (e -= r.length; t = t.next;) {
                                var i = t.data, a = e > i.length ? i.length : e;
                                if (a === i.length ? r += i : r += i.slice(0, e), 0 == (e -= a)) {
                                    a === i.length ? (++n, t.next ? this.head = t.next : this.head = this.tail = null) : (this.head = t, t.data = i.slice(a));
                                    break;
                                }
                                ++n;
                            }
                            return this.length -= n, r;
                        }
                    }, {
                        key: "_getBuffer",
                        value: function (e) {
                            var t = c.allocUnsafe(e), n = this.head, r = 1;
                            for (n.data.copy(t), e -= n.data.length; n = n.next;) {
                                var i = n.data, a = e > i.length ? i.length : e;
                                if (i.copy(t, t.length - e, 0, a), 0 == (e -= a)) {
                                    a === i.length ? (++r, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = i.slice(a));
                                    break;
                                }
                                ++r;
                            }
                            return this.length -= r, t;
                        }
                    }, {
                        key: p,
                        value: function (e, t) {
                            return b(this, function (e) {
                                for (var t = 1; t < arguments.length; t++) {
                                    var n = null != arguments[t] ? arguments[t] : {};
                                    t % 2 ? u(Object(n), !0).forEach(function (t) {
                                        f(e, t, n[t]);
                                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : u(Object(n)).forEach(function (t) {
                                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));
                                    });
                                }
                                return e;
                            }({}, t, {
                                depth: 0,
                                customInspect: !1
                            }));
                        }
                    }]) && h(t.prototype, n), e;
            }(), y = chunk_0c2d1322_js_2.h;
            m = {
                destroy: function (e, t) {
                    var n = this, r = this._readableState && this._readableState.destroyed, i = this._writableState && this._writableState.destroyed;
                    return r || i ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, y.nextTick(_, this, e)) : y.nextTick(_, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function (e) {
                        !t && e ? n._writableState ? n._writableState.errorEmitted ? y.nextTick(v, n) : (n._writableState.errorEmitted = !0, y.nextTick(w, n, e)) : y.nextTick(w, n, e) : t ? (y.nextTick(v, n), t(e)) : y.nextTick(v, n);
                    }), this);
                },
                undestroy: function () {
                    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
                },
                errorOrDestroy: function (e, t) {
                    var n = e._readableState, r = e._writableState;
                    n && n.autoDestroy || r && r.autoDestroy ? e.destroy(t) : e.emit("error", t);
                }
            }, S = e$1.codes.ERR_INVALID_OPT_VALUE;
            R = {
                getHighWaterMark: function (e, t, n, r) {
                    var i = function (e, t, n) {
                        return null != e.highWaterMark ? e.highWaterMark : t ? e[n] : null;
                    }(t, r, n);
                    if (null != i) {
                        if (!isFinite(i) || Math.floor(i) !== i || i < 0)
                            throw new S(r ? n : "highWaterMark", i);
                        return Math.floor(i);
                    }
                    return e.objectMode ? 16 : 16384;
                }
            }, k = e$1.codes.ERR_STREAM_PREMATURE_CLOSE;
            j = function e(t, n, r) {
                if ("function" == typeof n)
                    return e(t, null, n);
                n || (n = {}), r = function (e) {
                    var t = !1;
                    return function () {
                        if (!t) {
                            t = !0;
                            for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++)
                                r[i] = arguments[i];
                            e.apply(this, r);
                        }
                    };
                }(r || E);
                var i = n.readable || !1 !== n.readable && t.readable, a = n.writable || !1 !== n.writable && t.writable, o = function () {
                    t.writable || l();
                }, s = t._writableState && t._writableState.finished, l = function () {
                    a = !1, s = !0, i || r.call(t);
                }, d = t._readableState && t._readableState.endEmitted, u = function () {
                    i = !1, d = !0, a || r.call(t);
                }, f = function (e) {
                    r.call(t, e);
                }, h = function () {
                    var e;
                    return i && !d ? (t._readableState && t._readableState.ended || (e = new k()), r.call(t, e)) : a && !s ? (t._writableState && t._writableState.ended || (e = new k()), r.call(t, e)) : void 0;
                }, c = function () {
                    t.req.on("finish", l);
                };
                return !function (e) {
                    return e.setHeader && "function" == typeof e.abort;
                }(t) ? a && !t._writableState && (t.on("end", o), t.on("close", o)) : (t.on("complete", l), t.on("abort", h), t.req ? c() : t.on("request", c)), t.on("end", u), t.on("finish", l), !1 !== n.error && t.on("error", f), t.on("close", h), function () {
                    t.removeListener("complete", l), t.removeListener("abort", h), t.removeListener("request", c), t.req && t.req.removeListener("finish", l), t.removeListener("end", o), t.removeListener("close", o), t.removeListener("finish", l), t.removeListener("end", u), t.removeListener("error", f), t.removeListener("close", h);
                };
            }, O = chunk_0c2d1322_js_2.h;
            P = j, x = Symbol("lastResolve"), L = Symbol("lastReject"), D = Symbol("error"), C = Symbol("ended"), A = Symbol("lastPromise"), q = Symbol("handlePromise"), W = Symbol("stream");
            U = Object.getPrototypeOf(function () { }), H = Object.setPrototypeOf((T(M = {
                get stream() {
                    return this[W];
                },
                next: function () {
                    var e = this, t = this[D];
                    if (null !== t)
                        return Promise.reject(t);
                    if (this[C])
                        return Promise.resolve(B(void 0, !0));
                    if (this[W].destroyed)
                        return new Promise(function (t, n) {
                            O.nextTick(function () {
                                e[D] ? n(e[D]) : t(B(void 0, !0));
                            });
                        });
                    var n, r = this[A];
                    if (r)
                        n = new Promise(function (e, t) {
                            return function (n, r) {
                                e.then(function () {
                                    if (t[C])
                                        return n(B(void 0, !0)), void 0;
                                    t[q](n, r);
                                }, r);
                            };
                        }(r, this));
                    else {
                        var i = this[W].read();
                        if (null !== i)
                            return Promise.resolve(B(i, !1));
                        n = new Promise(this[q]);
                    }
                    return this[A] = n, n;
                }
            }, Symbol.asyncIterator, function () {
                return this;
            }), T(M, "return", function () {
                var e = this;
                return new Promise(function (t, n) {
                    e[W].destroy(null, function (e) {
                        if (e)
                            return n(e), void 0;
                        t(B(void 0, !0));
                    });
                });
            }), M), U), F = function (e) {
                var t, n = Object.create(H, (T(t = {}, W, {
                    value: e,
                    writable: !0
                }), T(t, x, {
                    value: null,
                    writable: !0
                }), T(t, L, {
                    value: null,
                    writable: !0
                }), T(t, D, {
                    value: null,
                    writable: !0
                }), T(t, C, {
                    value: e._readableState.endEmitted,
                    writable: !0
                }), T(t, q, {
                    value: function (e, t) {
                        var r = n[W].read();
                        r ? (n[A] = null, n[x] = null, n[L] = null, e(B(r, !1))) : (n[x] = e, n[L] = t);
                    },
                    writable: !0
                }), t));
                return n[A] = null, P(e, function (e) {
                    if (e && "ERR_STREAM_PREMATURE_CLOSE" !== e.code) {
                        var t = n[L];
                        return null !== t && (n[A] = null, n[x] = null, n[L] = null, t(e)), n[D] = e, void 0;
                    }
                    var r = n[x];
                    null !== r && (n[A] = null, n[x] = null, n[L] = null, r(B(void 0, !0))), n[C] = !0;
                }), e.on("readable", N.bind(null, n)), n;
            }, V = {}, G = !1, Y = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;
            z = {}, J = !1, Q = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;
            Z = {}, $ = !1;
            t$2 = K();
            exports_78("o", t$2);
            r$3 = e$1.codes.ERR_STREAM_PREMATURE_CLOSE;
            n$1 = function e(n, o, a) {
                if ("function" == typeof o)
                    return e(n, null, o);
                o || (o = {}), a = function (e) {
                    var r = !1;
                    return function () {
                        if (!r) {
                            r = !0;
                            for (var t = arguments.length, n = new Array(t), o = 0; o < t; o++)
                                n[o] = arguments[o];
                            e.apply(this, n);
                        }
                    };
                }(a || t$3);
                var i = o.readable || !1 !== o.readable && n.readable, l = o.writable || !1 !== o.writable && n.writable, c = function () {
                    n.writable || s();
                }, f = n._writableState && n._writableState.finished, s = function () {
                    l = !1, f = !0, i || a.call(n);
                }, u = n._readableState && n._readableState.endEmitted, d = function () {
                    i = !1, u = !0, l || a.call(n);
                }, b = function (e) {
                    a.call(n, e);
                }, v = function () {
                    var e;
                    return i && !u ? (n._readableState && n._readableState.ended || (e = new r$3()), a.call(n, e)) : l && !f ? (n._writableState && n._writableState.ended || (e = new r$3()), a.call(n, e)) : void 0;
                }, m = function () {
                    n.req.on("finish", s);
                };
                return !function (e) {
                    return e.setHeader && "function" == typeof e.abort;
                }(n) ? l && !n._writableState && (n.on("end", c), n.on("close", c)) : (n.on("complete", s), n.on("abort", v), n.req ? m() : n.on("request", m)), n.on("end", d), n.on("finish", s), !1 !== o.error && n.on("error", b), n.on("close", v), function () {
                    n.removeListener("complete", s), n.removeListener("abort", v), n.removeListener("request", m), n.req && n.req.removeListener("finish", s), n.removeListener("end", c), n.removeListener("close", c), n.removeListener("finish", s), n.removeListener("end", d), n.removeListener("error", b), n.removeListener("close", v);
                };
            };
            exports_78("r", n$1);
            b$1 = buffer_js_2.default.Buffer, p$1 = util_js_1.default.inspect, g$1 = p$1 && p$1.custom || "inspect";
            y$1 = function () {
                function e() {
                    !function (e, t) {
                        if (!(e instanceof t))
                            throw new TypeError("Cannot call a class as a function");
                    }(this, e), this.head = null, this.tail = null, this.length = 0;
                }
                var t, n;
                return t = e, (n = [{
                        key: "push",
                        value: function (e) {
                            var t = {
                                data: e,
                                next: null
                            };
                            this.length > 0 ? this.tail.next = t : this.head = t, this.tail = t, ++this.length;
                        }
                    }, {
                        key: "unshift",
                        value: function (e) {
                            var t = {
                                data: e,
                                next: this.head
                            };
                            0 === this.length && (this.tail = t), this.head = t, ++this.length;
                        }
                    }, {
                        key: "shift",
                        value: function () {
                            if (0 !== this.length) {
                                var e = this.head.data;
                                return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e;
                            }
                        }
                    }, {
                        key: "clear",
                        value: function () {
                            this.head = this.tail = null, this.length = 0;
                        }
                    }, {
                        key: "join",
                        value: function (e) {
                            if (0 === this.length)
                                return "";
                            for (var t = this.head, n = "" + t.data; t = t.next;)
                                n += e + t.data;
                            return n;
                        }
                    }, {
                        key: "concat",
                        value: function (e) {
                            if (0 === this.length)
                                return b$1.alloc(0);
                            for (var t, n, r, i = b$1.allocUnsafe(e >>> 0), a = this.head, o = 0; a;)
                                t = a.data, n = i, r = o, void b$1.prototype.copy.call(t, n, r), o += a.data.length, a = a.next;
                            return i;
                        }
                    }, {
                        key: "consume",
                        value: function (e, t) {
                            var n;
                            return e < this.head.data.length ? (n = this.head.data.slice(0, e), this.head.data = this.head.data.slice(e)) : n = e === this.head.data.length ? this.shift() : t ? this._getString(e) : this._getBuffer(e), n;
                        }
                    }, {
                        key: "first",
                        value: function () {
                            return this.head.data;
                        }
                    }, {
                        key: "_getString",
                        value: function (e) {
                            var t = this.head, n = 1, r = t.data;
                            for (e -= r.length; t = t.next;) {
                                var i = t.data, a = e > i.length ? i.length : e;
                                if (a === i.length ? r += i : r += i.slice(0, e), 0 == (e -= a)) {
                                    a === i.length ? (++n, t.next ? this.head = t.next : this.head = this.tail = null) : (this.head = t, t.data = i.slice(a));
                                    break;
                                }
                                ++n;
                            }
                            return this.length -= n, r;
                        }
                    }, {
                        key: "_getBuffer",
                        value: function (e) {
                            var t = b$1.allocUnsafe(e), n = this.head, r = 1;
                            for (n.data.copy(t), e -= n.data.length; n = n.next;) {
                                var i = n.data, a = e > i.length ? i.length : e;
                                if (i.copy(t, t.length - e, 0, a), 0 == (e -= a)) {
                                    a === i.length ? (++r, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = i.slice(a));
                                    break;
                                }
                                ++r;
                            }
                            return this.length -= r, t;
                        }
                    }, {
                        key: g$1,
                        value: function (e, t) {
                            return p$1(this, function (e) {
                                for (var t = 1; t < arguments.length; t++) {
                                    var n = null != arguments[t] ? arguments[t] : {};
                                    t % 2 ? f$1(Object(n), !0).forEach(function (t) {
                                        h$1(e, t, n[t]);
                                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : f$1(Object(n)).forEach(function (t) {
                                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));
                                    });
                                }
                                return e;
                            }({}, t, {
                                depth: 0,
                                customInspect: !1
                            }));
                        }
                    }]) && c$1(t.prototype, n), e;
            }(), w$1 = chunk_0c2d1322_js_2.h;
            S$1 = {
                destroy: function (e, t) {
                    var n = this, r = this._readableState && this._readableState.destroyed, i = this._writableState && this._writableState.destroyed;
                    return r || i ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, w$1.nextTick(m$1, this, e)) : w$1.nextTick(m$1, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function (e) {
                        !t && e ? n._writableState ? n._writableState.errorEmitted ? w$1.nextTick(v$1, n) : (n._writableState.errorEmitted = !0, w$1.nextTick(_$1, n, e)) : w$1.nextTick(_$1, n, e) : t ? (w$1.nextTick(v$1, n), t(e)) : w$1.nextTick(v$1, n);
                    }), this);
                },
                undestroy: function () {
                    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
                },
                errorOrDestroy: function (e, t) {
                    var n = e._readableState, r = e._writableState;
                    n && n.autoDestroy || r && r.autoDestroy ? e.destroy(t) : e.emit("error", t);
                }
            }, R$1 = e$1.codes.ERR_INVALID_OPT_VALUE;
            E$1 = {
                getHighWaterMark: function (e, t, n, r) {
                    var i = function (e, t, n) {
                        return null != e.highWaterMark ? e.highWaterMark : t ? e[n] : null;
                    }(t, r, n);
                    if (null != i) {
                        if (!isFinite(i) || Math.floor(i) !== i || i < 0)
                            throw new R$1(r ? n : "highWaterMark", i);
                        return Math.floor(i);
                    }
                    return e.objectMode ? 16 : 16384;
                }
            }, M$1 = chunk_0c2d1322_js_2.h;
            O$1 = n$1, T$1 = Symbol("lastResolve"), x$1 = Symbol("lastReject"), P$1 = Symbol("error"), D$1 = Symbol("ended"), L$1 = Symbol("lastPromise"), C$1 = Symbol("handlePromise"), A$1 = Symbol("stream");
            I$1 = Object.getPrototypeOf(function () { }), N$1 = Object.setPrototypeOf((j$1(k$1 = {
                get stream() {
                    return this[A$1];
                },
                next: function () {
                    var e = this, t = this[P$1];
                    if (null !== t)
                        return Promise.reject(t);
                    if (this[D$1])
                        return Promise.resolve(W$1(void 0, !0));
                    if (this[A$1].destroyed)
                        return new Promise(function (t, n) {
                            M$1.nextTick(function () {
                                e[P$1] ? n(e[P$1]) : t(W$1(void 0, !0));
                            });
                        });
                    var n, r = this[L$1];
                    if (r)
                        n = new Promise(function (e, t) {
                            return function (n, r) {
                                e.then(function () {
                                    if (t[D$1])
                                        return n(W$1(void 0, !0)), void 0;
                                    t[C$1](n, r);
                                }, r);
                            };
                        }(r, this));
                    else {
                        var i = this[A$1].read();
                        if (null !== i)
                            return Promise.resolve(W$1(i, !1));
                        n = new Promise(this[C$1]);
                    }
                    return this[L$1] = n, n;
                }
            }, Symbol.asyncIterator, function () {
                return this;
            }), j$1(k$1, "return", function () {
                var e = this;
                return new Promise(function (t, n) {
                    e[A$1].destroy(null, function (e) {
                        if (e)
                            return n(e), void 0;
                        t(W$1(void 0, !0));
                    });
                });
            }), k$1), I$1), U$1 = function (e) {
                var t, n = Object.create(N$1, (j$1(t = {}, A$1, {
                    value: e,
                    writable: !0
                }), j$1(t, T$1, {
                    value: null,
                    writable: !0
                }), j$1(t, x$1, {
                    value: null,
                    writable: !0
                }), j$1(t, P$1, {
                    value: null,
                    writable: !0
                }), j$1(t, D$1, {
                    value: e._readableState.endEmitted,
                    writable: !0
                }), j$1(t, C$1, {
                    value: function (e, t) {
                        var r = n[A$1].read();
                        r ? (n[L$1] = null, n[T$1] = null, n[x$1] = null, e(W$1(r, !1))) : (n[T$1] = e, n[x$1] = t);
                    },
                    writable: !0
                }), t));
                return n[L$1] = null, O$1(e, function (e) {
                    if (e && "ERR_STREAM_PREMATURE_CLOSE" !== e.code) {
                        var t = n[x$1];
                        return null !== t && (n[L$1] = null, n[T$1] = null, n[x$1] = null, t(e)), n[P$1] = e, void 0;
                    }
                    var r = n[T$1];
                    null !== r && (n[L$1] = null, n[T$1] = null, n[x$1] = null, r(W$1(void 0, !0))), n[D$1] = !0;
                }), e.on("readable", q$1.bind(null, n)), n;
            }, H$1 = {}, F$1 = !1, V$1 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;
            Y$1 = {}, K$1 = !1, z$1 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;
            Q$1 = {}, X$1 = !1;
            t$4 = J$1();
            exports_78("s", t$4);
            t$5 = ee();
            exports_78("e", t$5);
            n$2 = u$1;
            i = e$1.codes, a = i.ERR_METHOD_NOT_IMPLEMENTED, o = i.ERR_MULTIPLE_CALLBACK, s = i.ERR_TRANSFORM_ALREADY_TRANSFORMING, f$2 = i.ERR_TRANSFORM_WITH_LENGTH_0, h$2 = t$5;
            chunk_dac557ba_js_2.t(u$1, h$2), u$1.prototype.push = function (t, r) {
                return this._transformState.needTransform = !1, h$2.prototype.push.call(this, t, r);
            }, u$1.prototype._transform = function (t, r, e) {
                e(new a("_transform()"));
            }, u$1.prototype._write = function (t, r, e) {
                var n = this._transformState;
                if (n.writecb = e, n.writechunk = t, n.writeencoding = r, !n.transforming) {
                    var i = this._readableState;
                    (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
                }
            }, u$1.prototype._read = function (t) {
                var r = this._transformState;
                null === r.writechunk || r.transforming ? r.needTransform = !0 : (r.transforming = !0, this._transform(r.writechunk, r.writeencoding, r.afterTransform));
            }, u$1.prototype._destroy = function (t, r) {
                h$2.prototype._destroy.call(this, t, function (t) {
                    r(t);
                });
            };
            p$2 = n$2;
            exports_78("t", p$2);
            o$1 = i$1;
            e$3 = p$2;
            chunk_dac557ba_js_2.t(i$1, e$3), i$1.prototype._transform = function (r, t, o) {
                o(null, r);
            };
            s$1 = o$1;
            exports_78("i", s$1);
            o$2 = e$1.codes, e$4 = o$2.ERR_MISSING_ARGS, f$3 = o$2.ERR_STREAM_DESTROYED;
            v$2 = function () {
                for (var r = arguments.length, n = new Array(r), t = 0; t < r; t++)
                    n[t] = arguments[t];
                var o, f = p$3(n);
                if (Array.isArray(n[0]) && (n = n[0]), n.length < 2)
                    throw new e$4("streams");
                var i = n.map(function (r, t) {
                    var e = t < n.length - 1;
                    return u$2(r, e, t > 0, function (r) {
                        o || (o = r), r && i.forEach(a$1), e || (i.forEach(a$1), f(o));
                    });
                });
                return n.reduce(c$2);
            };
            exports_78("m", v$2);
        }
    };
});
System.register("https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/stream", ["https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/chunk-dac557ba", "https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/chunk-0c2d1322", "https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/buffer", "https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/util", "https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/chunk-6e68c801", "https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/events", "https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/chunk-cffba9d4"], function (exports_79, context_79) {
    "use strict";
    var chunk_dac557ba_js_3, events_js_2, chunk_cffba9d4_js_1, l, d, f, b, Readable, Writable, Duplex, Transform, PassThrough, finished, pipeline, Stream;
    var __moduleName = context_79 && context_79.id;
    function p() {
        f.call(this || d);
    }
    return {
        setters: [
            function (chunk_dac557ba_js_3_1) {
                chunk_dac557ba_js_3 = chunk_dac557ba_js_3_1;
            },
            function (_3) {
            },
            function (_4) {
            },
            function (_5) {
            },
            function (_6) {
            },
            function (events_js_2_1) {
                events_js_2 = events_js_2_1;
            },
            function (chunk_cffba9d4_js_1_1) {
                chunk_cffba9d4_js_1 = chunk_cffba9d4_js_1_1;
            }
        ],
        execute: function () {
            d = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;
            l = p;
            f = events_js_2.default.EventEmitter;
            chunk_dac557ba_js_3.t(p, f), p.Readable = chunk_cffba9d4_js_1.o, p.Writable = chunk_cffba9d4_js_1.s, p.Duplex = chunk_cffba9d4_js_1.e, p.Transform = chunk_cffba9d4_js_1.t, p.PassThrough = chunk_cffba9d4_js_1.i, p.finished = chunk_cffba9d4_js_1.r, p.pipeline = chunk_cffba9d4_js_1.m, p.Stream = p, p.prototype.pipe = function (e, r) {
                var t = this || d;
                function o(r) {
                    e.writable && !1 === e.write(r) && t.pause && t.pause();
                }
                function i() {
                    t.readable && t.resume && t.resume();
                }
                t.on("data", o), e.on("drain", i), e._isStdio || r && !1 === r.end || (t.on("end", a), t.on("close", s));
                var n = !1;
                function a() {
                    n || (n = !0, e.end());
                }
                function s() {
                    n || (n = !0, "function" == typeof e.destroy && e.destroy());
                }
                function m(e) {
                    if (l(), 0 === f.listenerCount(this || d, "error"))
                        throw e;
                }
                function l() {
                    t.removeListener("data", o), e.removeListener("drain", i), t.removeListener("end", a), t.removeListener("close", s), t.removeListener("error", m), e.removeListener("error", m), t.removeListener("end", l), t.removeListener("close", l), e.removeListener("close", l);
                }
                return t.on("error", m), e.on("error", m), t.on("end", l), t.on("close", l), e.on("close", l), e.emit("pipe", t), e;
            };
            b = l;
            Readable = b.Readable;
            exports_79("Readable", Readable);
            Writable = b.Writable;
            exports_79("Writable", Writable);
            Duplex = b.Duplex;
            exports_79("Duplex", Duplex);
            Transform = b.Transform;
            exports_79("Transform", Transform);
            PassThrough = b.PassThrough;
            exports_79("PassThrough", PassThrough);
            finished = b.finished;
            exports_79("finished", finished);
            pipeline = b.pipeline;
            exports_79("pipeline", pipeline);
            Stream = b.Stream;
            exports_79("Stream", Stream);
            exports_79("default", b);
        }
    };
});
System.register("https://dev.jspm.io/npm:@jspm/core@1/nodelibs/stream", ["https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/stream", "https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/chunk-dac557ba", "https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/chunk-0c2d1322", "https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/buffer", "https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/util", "https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/chunk-6e68c801", "https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/events", "https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/chunk-cffba9d4"], function (exports_80, context_80) {
    "use strict";
    var __moduleName = context_80 && context_80.id;
    var exportedNames_2 = {
        "default": true
    };
    function exportStar_4(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default" && !exportedNames_2.hasOwnProperty(n)) exports[n] = m[n];
        }
        exports_80(exports);
    }
    return {
        setters: [
            function (stream_js_1_1) {
                exportStar_4(stream_js_1_1);
                exports_80({
                    "default": stream_js_1_1["default"]
                });
            },
            function (_7) {
            },
            function (_8) {
            },
            function (_9) {
            },
            function (_10) {
            },
            function (_11) {
            },
            function (_12) {
            },
            function (_13) {
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://dev.jspm.io/npm:lodash._reinterpolate@3.0.0/index.dew", [], function (exports_81, context_81) {
    "use strict";
    var exports, _dewExec;
    var __moduleName = context_81 && context_81.id;
    function dew() {
        if (_dewExec)
            return exports;
        _dewExec = true;
        /**
         * lodash 3.0.0 (Custom Build) <https://lodash.com/>
         * Build: `lodash modern modularize exports="npm" -o ./`
         * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
         * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
         * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
         * Available under MIT license <https://lodash.com/license>
         */
        /** Used to match template delimiters. */
        var reInterpolate = /<%=([\s\S]+?)%>/g;
        exports = reInterpolate;
        return exports;
    }
    exports_81("dew", dew);
    return {
        setters: [],
        execute: function () {
            exports = {}, _dewExec = false;
        }
    };
});
System.register("https://dev.jspm.io/npm:lodash._reinterpolate@3?dew", ["https://dev.jspm.io/npm:lodash._reinterpolate@3.0.0/index.dew"], function (exports_82, context_82) {
    "use strict";
    var __moduleName = context_82 && context_82.id;
    return {
        setters: [
            function (index_dew_js_1_1) {
                exports_82({
                    "dew": index_dew_js_1_1["dew"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://dev.jspm.io/npm:lodash.templatesettings@4.2.0/index.dew", ["https://dev.jspm.io/npm:lodash._reinterpolate@3?dew"], function (exports_83, context_83) {
    "use strict";
    var npm_lodash__reinterpolate_3_dew_1, exports, _dewExec, _global;
    var __moduleName = context_83 && context_83.id;
    function dew() {
        if (_dewExec)
            return exports;
        _dewExec = true;
        /**
         * Lodash (Custom Build) <https://lodash.com/>
         * Build: `lodash modularize exports="npm" -o ./`
         * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
         * Released under MIT license <https://lodash.com/license>
         * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
         * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
         */
        var reInterpolate = npm_lodash__reinterpolate_3_dew_1.dew();
        /** Used as references for various `Number` constants. */
        var INFINITY = 1 / 0;
        /** `Object#toString` result references. */
        var nullTag = '[object Null]', symbolTag = '[object Symbol]', undefinedTag = '[object Undefined]';
        /** Used to match HTML entities and HTML characters. */
        var reUnescapedHtml = /[&<>"']/g, reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        /** Used to match template delimiters. */
        var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g;
        /** Used to map characters to HTML entities. */
        var htmlEscapes = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;'
        };
        /** Detect free variable `global` from Node.js. */
        var freeGlobal = typeof _global == 'object' && _global && _global.Object === Object && _global;
        /** Detect free variable `self`. */
        var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
        /** Used as a reference to the global object. */
        var root = freeGlobal || freeSelf || Function('return this')();
        /**
         * A specialized version of `_.map` for arrays without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function arrayMap(array, iteratee) {
            var index = -1, length = array == null ? 0 : array.length, result = Array(length);
            while (++index < length) {
                result[index] = iteratee(array[index], index, array);
            }
            return result;
        }
        /**
         * The base implementation of `_.propertyOf` without support for deep paths.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Function} Returns the new accessor function.
         */
        function basePropertyOf(object) {
            return function (key) {
                return object == null ? undefined : object[key];
            };
        }
        /**
         * Used by `_.escape` to convert characters to HTML entities.
         *
         * @private
         * @param {string} chr The matched character to escape.
         * @returns {string} Returns the escaped character.
         */
        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        /** Used for built-in method references. */
        var objectProto = Object.prototype;
        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;
        /**
         * Used to resolve the
         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
         * of values.
         */
        var nativeObjectToString = objectProto.toString;
        /** Built-in value references. */
        var Symbol = root.Symbol, symToStringTag = Symbol ? Symbol.toStringTag : undefined;
        /** Used to convert symbols to primitives and strings. */
        var symbolProto = Symbol ? Symbol.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
        /**
         * By default, the template delimiters used by lodash are like those in
         * embedded Ruby (ERB) as well as ES2015 template strings. Change the
         * following template settings to use alternative delimiters.
         *
         * @static
         * @memberOf _
         * @type {Object}
         */
        var templateSettings = {
            /**
             * Used to detect `data` property values to be HTML-escaped.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            'escape': reEscape,
            /**
             * Used to detect code to be evaluated.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            'evaluate': reEvaluate,
            /**
             * Used to detect `data` property values to inject.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            'interpolate': reInterpolate,
            /**
             * Used to reference the data object in the template text.
             *
             * @memberOf _.templateSettings
             * @type {string}
             */
            'variable': '',
            /**
             * Used to import variables into the compiled template.
             *
             * @memberOf _.templateSettings
             * @type {Object}
             */
            'imports': {
                /**
                 * A reference to the `lodash` function.
                 *
                 * @memberOf _.templateSettings.imports
                 * @type {Function}
                 */
                '_': {
                    'escape': escape
                }
            }
        };
        /**
         * The base implementation of `getTag` without fallbacks for buggy environments.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the `toStringTag`.
         */
        function baseGetTag(value) {
            if (value == null) {
                return value === undefined ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
        }
        /**
         * The base implementation of `_.toString` which doesn't convert nullish
         * values to empty strings.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {string} Returns the string.
         */
        function baseToString(value) {
            // Exit early for strings to avoid a performance hit in some environments.
            if (typeof value == 'string') {
                return value;
            }
            if (isArray(value)) {
                // Recursively convert values (susceptible to call stack limits).
                return arrayMap(value, baseToString) + '';
            }
            if (isSymbol(value)) {
                return symbolToString ? symbolToString.call(value) : '';
            }
            var result = value + '';
            return result == '0' && 1 / value == -INFINITY ? '-0' : result;
        }
        /**
         * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the raw `toStringTag`.
         */
        function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
                value[symToStringTag] = undefined;
                var unmasked = true;
            }
            catch (e) { }
            var result = nativeObjectToString.call(value);
            if (unmasked) {
                if (isOwn) {
                    value[symToStringTag] = tag;
                }
                else {
                    delete value[symToStringTag];
                }
            }
            return result;
        }
        /**
         * Converts `value` to a string using `Object.prototype.toString`.
         *
         * @private
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         */
        function objectToString(value) {
            return nativeObjectToString.call(value);
        }
        /**
         * Checks if `value` is classified as an `Array` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array, else `false`.
         * @example
         *
         * _.isArray([1, 2, 3]);
         * // => true
         *
         * _.isArray(document.body.children);
         * // => false
         *
         * _.isArray('abc');
         * // => false
         *
         * _.isArray(_.noop);
         * // => false
         */
        var isArray = Array.isArray;
        /**
         * Checks if `value` is object-like. A value is object-like if it's not `null`
         * and has a `typeof` result of "object".
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
         * @example
         *
         * _.isObjectLike({});
         * // => true
         *
         * _.isObjectLike([1, 2, 3]);
         * // => true
         *
         * _.isObjectLike(_.noop);
         * // => false
         *
         * _.isObjectLike(null);
         * // => false
         */
        function isObjectLike(value) {
            return value != null && typeof value == 'object';
        }
        /**
         * Checks if `value` is classified as a `Symbol` primitive or object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
         * @example
         *
         * _.isSymbol(Symbol.iterator);
         * // => true
         *
         * _.isSymbol('abc');
         * // => false
         */
        function isSymbol(value) {
            return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        /**
         * Converts `value` to a string. An empty string is returned for `null`
         * and `undefined` values. The sign of `-0` is preserved.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.toString(null);
         * // => ''
         *
         * _.toString(-0);
         * // => '-0'
         *
         * _.toString([1, 2, 3]);
         * // => '1,2,3'
         */
        function toString(value) {
            return value == null ? '' : baseToString(value);
        }
        /**
         * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
         * corresponding HTML entities.
         *
         * **Note:** No other characters are escaped. To escape additional
         * characters use a third-party library like [_he_](https://mths.be/he).
         *
         * Though the ">" character is escaped for symmetry, characters like
         * ">" and "/" don't need escaping in HTML and have no special meaning
         * unless they're part of a tag or unquoted attribute value. See
         * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
         * (under "semi-related fun fact") for more details.
         *
         * When working with HTML you should always
         * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
         * XSS vectors.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to escape.
         * @returns {string} Returns the escaped string.
         * @example
         *
         * _.escape('fred, barney, & pebbles');
         * // => 'fred, barney, &amp; pebbles'
         */
        function escape(string) {
            string = toString(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        exports = templateSettings;
        return exports;
    }
    exports_83("dew", dew);
    return {
        setters: [
            function (npm_lodash__reinterpolate_3_dew_1_1) {
                npm_lodash__reinterpolate_3_dew_1 = npm_lodash__reinterpolate_3_dew_1_1;
            }
        ],
        execute: function () {
            exports = {}, _dewExec = false;
            _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
        }
    };
});
System.register("https://dev.jspm.io/npm:lodash.templatesettings@4?dew", ["https://dev.jspm.io/npm:lodash.templatesettings@4.2.0/index.dew", "https://dev.jspm.io/npm:lodash._reinterpolate@3?dew"], function (exports_84, context_84) {
    "use strict";
    var __moduleName = context_84 && context_84.id;
    return {
        setters: [
            function (index_dew_js_2_1) {
                exports_84({
                    "dew": index_dew_js_2_1["dew"]
                });
            },
            function (_14) {
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://dev.jspm.io/npm:lodash.template@4.5.0/index.dew", ["https://dev.jspm.io/npm:lodash._reinterpolate@3?dew", "https://dev.jspm.io/npm:lodash.templatesettings@4?dew"], function (exports_85, context_85) {
    "use strict";
    var npm_lodash__reinterpolate_3_dew_2, npm_lodash_templatesettings_4_dew_1, exports, _dewExec, module, _global;
    var __moduleName = context_85 && context_85.id;
    function dew() {
        if (_dewExec)
            return module.exports;
        _dewExec = true;
        /**
         * Lodash (Custom Build) <https://lodash.com/>
         * Build: `lodash modularize exports="npm" -o ./`
         * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
         * Released under MIT license <https://lodash.com/license>
         * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
         * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
         */
        var reInterpolate = npm_lodash__reinterpolate_3_dew_2.dew(), templateSettings = npm_lodash_templatesettings_4_dew_1.dew();
        /** Used to detect hot functions by number of calls within a span of milliseconds. */
        var HOT_COUNT = 800, HOT_SPAN = 16;
        /** Used as references for various `Number` constants. */
        var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991;
        /** `Object#toString` result references. */
        var argsTag = '[object Arguments]', arrayTag = '[object Array]', asyncTag = '[object AsyncFunction]', boolTag = '[object Boolean]', dateTag = '[object Date]', domExcTag = '[object DOMException]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', nullTag = '[object Null]', objectTag = '[object Object]', proxyTag = '[object Proxy]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', undefinedTag = '[object Undefined]', weakMapTag = '[object WeakMap]';
        var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
        /** Used to match empty string literals in compiled template source. */
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        /**
         * Used to match `RegExp`
         * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
         */
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
        /**
         * Used to match
         * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
         */
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        /** Used to detect host constructors (Safari). */
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        /** Used to detect unsigned integer values. */
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        /** Used to ensure capturing order of template delimiters. */
        var reNoMatch = /($^)/;
        /** Used to match unescaped characters in compiled string literals. */
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        /** Used to identify `toStringTag` values of typed arrays. */
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        /** Used to escape characters for inclusion in compiled string literals. */
        var stringEscapes = {
            '\\': '\\',
            "'": "'",
            '\n': 'n',
            '\r': 'r',
            '\u2028': 'u2028',
            '\u2029': 'u2029'
        };
        /** Detect free variable `global` from Node.js. */
        var freeGlobal = typeof _global == 'object' && _global && _global.Object === Object && _global;
        /** Detect free variable `self`. */
        var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
        /** Used as a reference to the global object. */
        var root = freeGlobal || freeSelf || Function('return this')();
        /** Detect free variable `exports`. */
        var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
        /** Detect free variable `module`. */
        var freeModule = freeExports && true && module && !module.nodeType && module;
        /** Detect the popular CommonJS extension `module.exports`. */
        var moduleExports = freeModule && freeModule.exports === freeExports;
        /** Detect free variable `process` from Node.js. */
        var freeProcess = moduleExports && freeGlobal.process;
        /** Used to access faster Node.js helpers. */
        var nodeUtil = function () {
            try {
                // Use `util.types` for Node.js 10+.
                var types = freeModule && freeModule.require && freeModule.require('util').types;
                if (types) {
                    return types;
                } // Legacy `process.binding('util')` for Node.js < 10.
                return freeProcess && freeProcess.binding && freeProcess.binding('util');
            }
            catch (e) { }
        }();
        /* Node.js helper references. */
        var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        /**
         * A faster alternative to `Function#apply`, this function invokes `func`
         * with the `this` binding of `thisArg` and the arguments of `args`.
         *
         * @private
         * @param {Function} func The function to invoke.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {Array} args The arguments to invoke `func` with.
         * @returns {*} Returns the result of `func`.
         */
        function apply(func, thisArg, args) {
            switch (args.length) {
                case 0:
                    return func.call(thisArg);
                case 1:
                    return func.call(thisArg, args[0]);
                case 2:
                    return func.call(thisArg, args[0], args[1]);
                case 3:
                    return func.call(thisArg, args[0], args[1], args[2]);
            }
            return func.apply(thisArg, args);
        }
        /**
         * A specialized version of `_.map` for arrays without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function arrayMap(array, iteratee) {
            var index = -1, length = array == null ? 0 : array.length, result = Array(length);
            while (++index < length) {
                result[index] = iteratee(array[index], index, array);
            }
            return result;
        }
        /**
         * The base implementation of `_.times` without support for iteratee shorthands
         * or max array length checks.
         *
         * @private
         * @param {number} n The number of times to invoke `iteratee`.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the array of results.
         */
        function baseTimes(n, iteratee) {
            var index = -1, result = Array(n);
            while (++index < n) {
                result[index] = iteratee(index);
            }
            return result;
        }
        /**
         * The base implementation of `_.unary` without support for storing metadata.
         *
         * @private
         * @param {Function} func The function to cap arguments for.
         * @returns {Function} Returns the new capped function.
         */
        function baseUnary(func) {
            return function (value) {
                return func(value);
            };
        }
        /**
         * The base implementation of `_.values` and `_.valuesIn` which creates an
         * array of `object` property values corresponding to the property names
         * of `props`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} props The property names to get values for.
         * @returns {Object} Returns the array of property values.
         */
        function baseValues(object, props) {
            return arrayMap(props, function (key) {
                return object[key];
            });
        }
        /**
         * Used by `_.template` to escape characters for inclusion in compiled string literals.
         *
         * @private
         * @param {string} chr The matched character to escape.
         * @returns {string} Returns the escaped character.
         */
        function escapeStringChar(chr) {
            return '\\' + stringEscapes[chr];
        }
        /**
         * Gets the value at `key` of `object`.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {string} key The key of the property to get.
         * @returns {*} Returns the property value.
         */
        function getValue(object, key) {
            return object == null ? undefined : object[key];
        }
        /**
         * Creates a unary function that invokes `func` with its argument transformed.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {Function} transform The argument transform.
         * @returns {Function} Returns the new function.
         */
        function overArg(func, transform) {
            return function (arg) {
                return func(transform(arg));
            };
        }
        /** Used for built-in method references. */
        var funcProto = Function.prototype, objectProto = Object.prototype;
        /** Used to detect overreaching core-js shims. */
        var coreJsData = root['__core-js_shared__'];
        /** Used to resolve the decompiled source of functions. */
        var funcToString = funcProto.toString;
        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;
        /** Used to detect methods masquerading as native. */
        var maskSrcKey = function () {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
            return uid ? 'Symbol(src)_1.' + uid : '';
        }();
        /**
         * Used to resolve the
         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
         * of values.
         */
        var nativeObjectToString = objectProto.toString;
        /** Used to infer the `Object` constructor. */
        var objectCtorString = funcToString.call(Object);
        /** Used to detect if a method is native. */
        var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
        /** Built-in value references. */
        var Buffer = moduleExports ? root.Buffer : undefined, Symbol = root.Symbol, getPrototype = overArg(Object.getPrototypeOf, Object), propertyIsEnumerable = objectProto.propertyIsEnumerable, symToStringTag = Symbol ? Symbol.toStringTag : undefined;
        var defineProperty = function () {
            try {
                var func = getNative(Object, 'defineProperty');
                func({}, '', {});
                return func;
            }
            catch (e) { }
        }();
        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined, nativeKeys = overArg(Object.keys, Object), nativeMax = Math.max, nativeNow = Date.now;
        /** Used to convert symbols to primitives and strings. */
        var symbolProto = Symbol ? Symbol.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
        /**
         * Creates an array of the enumerable property names of the array-like `value`.
         *
         * @private
         * @param {*} value The value to query.
         * @param {boolean} inherited Specify returning inherited property names.
         * @returns {Array} Returns the array of property names.
         */
        function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
            for (var key in value) {
                if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
                key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
                    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
                    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
                    isIndex(key, length)))) {
                    result.push(key);
                }
            }
            return result;
        }
        /**
         * Assigns `value` to `key` of `object` if the existing value is not equivalent
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
                baseAssignValue(object, key, value);
            }
        }
        /**
         * The base implementation of `assignValue` and `assignMergeValue` without
         * value checks.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function baseAssignValue(object, key, value) {
            if (key == '__proto__' && defineProperty) {
                defineProperty(object, key, {
                    'configurable': true,
                    'enumerable': true,
                    'value': value,
                    'writable': true
                });
            }
            else {
                object[key] = value;
            }
        }
        /**
         * The base implementation of `getTag` without fallbacks for buggy environments.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the `toStringTag`.
         */
        function baseGetTag(value) {
            if (value == null) {
                return value === undefined ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
        }
        /**
         * The base implementation of `_.isArguments`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
         */
        function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        /**
         * The base implementation of `_.isNative` without bad shim checks.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a native function,
         *  else `false`.
         */
        function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
                return false;
            }
            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
        }
        /**
         * The base implementation of `_.isTypedArray` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
         */
        function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        /**
         * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function baseKeys(object) {
            if (!isPrototype(object)) {
                return nativeKeys(object);
            }
            var result = [];
            for (var key in Object(object)) {
                if (hasOwnProperty.call(object, key) && key != 'constructor') {
                    result.push(key);
                }
            }
            return result;
        }
        /**
         * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function baseKeysIn(object) {
            if (!isObject(object)) {
                return nativeKeysIn(object);
            }
            var isProto = isPrototype(object), result = [];
            for (var key in object) {
                if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                    result.push(key);
                }
            }
            return result;
        }
        /**
         * The base implementation of `_.rest` which doesn't validate or coerce arguments.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @returns {Function} Returns the new function.
         */
        function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + '');
        }
        /**
         * The base implementation of `setToString` without support for hot loop shorting.
         *
         * @private
         * @param {Function} func The function to modify.
         * @param {Function} string The `toString` result.
         * @returns {Function} Returns `func`.
         */
        var baseSetToString = !defineProperty ? identity : function (func, string) {
            return defineProperty(func, 'toString', {
                'configurable': true,
                'enumerable': false,
                'value': constant(string),
                'writable': true
            });
        };
        /**
         * The base implementation of `_.toString` which doesn't convert nullish
         * values to empty strings.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {string} Returns the string.
         */
        function baseToString(value) {
            // Exit early for strings to avoid a performance hit in some environments.
            if (typeof value == 'string') {
                return value;
            }
            if (isArray(value)) {
                // Recursively convert values (susceptible to call stack limits).
                return arrayMap(value, baseToString) + '';
            }
            if (isSymbol(value)) {
                return symbolToString ? symbolToString.call(value) : '';
            }
            var result = value + '';
            return result == '0' && 1 / value == -INFINITY ? '-0' : result;
        }
        /**
         * Copies properties of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy properties from.
         * @param {Array} props The property identifiers to copy.
         * @param {Object} [object={}] The object to copy properties to.
         * @param {Function} [customizer] The function to customize copied values.
         * @returns {Object} Returns `object`.
         */
        function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index = -1, length = props.length;
            while (++index < length) {
                var key = props[index];
                var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
                if (newValue === undefined) {
                    newValue = source[key];
                }
                if (isNew) {
                    baseAssignValue(object, key, newValue);
                }
                else {
                    assignValue(object, key, newValue);
                }
            }
            return object;
        }
        /**
         * Creates a function like `_.assign`.
         *
         * @private
         * @param {Function} assigner The function to assign values.
         * @returns {Function} Returns the new assigner function.
         */
        function createAssigner(assigner) {
            return baseRest(function (object, sources) {
                var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;
                customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;
                if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                    customizer = length < 3 ? undefined : customizer;
                    length = 1;
                }
                object = Object(object);
                while (++index < length) {
                    var source = sources[index];
                    if (source) {
                        assigner(object, source, index, customizer);
                    }
                }
                return object;
            });
        }
        /**
         * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
         * of source objects to the destination object for all destination properties
         * that resolve to `undefined`.
         *
         * @private
         * @param {*} objValue The destination value.
         * @param {*} srcValue The source value.
         * @param {string} key The key of the property to assign.
         * @param {Object} object The parent object of `objValue`.
         * @returns {*} Returns the value to assign.
         */
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                return srcValue;
            }
            return objValue;
        }
        /**
         * Gets the native function at `key` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the method to get.
         * @returns {*} Returns the function if it's native, else `undefined`.
         */
        function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined;
        }
        /**
         * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the raw `toStringTag`.
         */
        function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
                value[symToStringTag] = undefined;
                var unmasked = true;
            }
            catch (e) { }
            var result = nativeObjectToString.call(value);
            if (unmasked) {
                if (isOwn) {
                    value[symToStringTag] = tag;
                }
                else {
                    delete value[symToStringTag];
                }
            }
            return result;
        }
        /**
         * Checks if `value` is a valid array-like index.
         *
         * @private
         * @param {*} value The value to check.
         * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
         * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
         */
        function isIndex(value, length) {
            var type = typeof value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
        }
        /**
         * Checks if the given arguments are from an iteratee call.
         *
         * @private
         * @param {*} value The potential iteratee value argument.
         * @param {*} index The potential iteratee index or key argument.
         * @param {*} object The potential iteratee object argument.
         * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
         *  else `false`.
         */
        function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
                return false;
            }
            var type = typeof index;
            if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
                return eq(object[index], value);
            }
            return false;
        }
        /**
         * Checks if `func` has its source masked.
         *
         * @private
         * @param {Function} func The function to check.
         * @returns {boolean} Returns `true` if `func` is masked, else `false`.
         */
        function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
        }
        /**
         * Checks if `value` is likely a prototype object.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
         */
        function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
            return value === proto;
        }
        /**
         * This function is like
         * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
         * except that it includes inherited enumerable properties.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function nativeKeysIn(object) {
            var result = [];
            if (object != null) {
                for (var key in Object(object)) {
                    result.push(key);
                }
            }
            return result;
        }
        /**
         * Converts `value` to a string using `Object.prototype.toString`.
         *
         * @private
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         */
        function objectToString(value) {
            return nativeObjectToString.call(value);
        }
        /**
         * A specialized version of `baseRest` which transforms the rest array.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @param {Function} transform The rest array transform.
         * @returns {Function} Returns the new function.
         */
        function overRest(func, start, transform) {
            start = nativeMax(start === undefined ? func.length - 1 : start, 0);
            return function () {
                var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
                while (++index < length) {
                    array[index] = args[start + index];
                }
                index = -1;
                var otherArgs = Array(start + 1);
                while (++index < start) {
                    otherArgs[index] = args[index];
                }
                otherArgs[start] = transform(array);
                return apply(func, this || _global, otherArgs);
            };
        }
        /**
         * Sets the `toString` method of `func` to return `string`.
         *
         * @private
         * @param {Function} func The function to modify.
         * @param {Function} string The `toString` result.
         * @returns {Function} Returns `func`.
         */
        var setToString = shortOut(baseSetToString);
        /**
         * Creates a function that'll short out and invoke `identity` instead
         * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
         * milliseconds.
         *
         * @private
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new shortable function.
         */
        function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function () {
                var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
                lastCalled = stamp;
                if (remaining > 0) {
                    if (++count >= HOT_COUNT) {
                        return arguments[0];
                    }
                }
                else {
                    count = 0;
                }
                return func.apply(undefined, arguments);
            };
        }
        /**
         * Converts `func` to its source code.
         *
         * @private
         * @param {Function} func The function to convert.
         * @returns {string} Returns the source code.
         */
        function toSource(func) {
            if (func != null) {
                try {
                    return funcToString.call(func);
                }
                catch (e) { }
                try {
                    return func + '';
                }
                catch (e) { }
            }
            return '';
        }
        /**
         * Performs a
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * comparison between two values to determine if they are equivalent.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'a': 1 };
         * var other = { 'a': 1 };
         *
         * _.eq(object, object);
         * // => true
         *
         * _.eq(object, other);
         * // => false
         *
         * _.eq('a', 'a');
         * // => true
         *
         * _.eq('a', Object('a'));
         * // => false
         *
         * _.eq(NaN, NaN);
         * // => true
         */
        function eq(value, other) {
            return value === other || value !== value && other !== other;
        }
        /**
         * Checks if `value` is likely an `arguments` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
         *  else `false`.
         * @example
         *
         * _.isArguments(function() { return arguments; }());
         * // => true
         *
         * _.isArguments([1, 2, 3]);
         * // => false
         */
        var isArguments = baseIsArguments(function () {
            return arguments;
        }()) ? baseIsArguments : function (value) {
            return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
        };
        /**
         * Checks if `value` is classified as an `Array` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array, else `false`.
         * @example
         *
         * _.isArray([1, 2, 3]);
         * // => true
         *
         * _.isArray(document.body.children);
         * // => false
         *
         * _.isArray('abc');
         * // => false
         *
         * _.isArray(_.noop);
         * // => false
         */
        var isArray = Array.isArray;
        /**
         * Checks if `value` is array-like. A value is considered array-like if it's
         * not a function and has a `value.length` that's an integer greater than or
         * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
         * @example
         *
         * _.isArrayLike([1, 2, 3]);
         * // => true
         *
         * _.isArrayLike(document.body.children);
         * // => true
         *
         * _.isArrayLike('abc');
         * // => true
         *
         * _.isArrayLike(_.noop);
         * // => false
         */
        function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value);
        }
        /**
         * Checks if `value` is a buffer.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
         * @example
         *
         * _.isBuffer(new Buffer(2));
         * // => true
         *
         * _.isBuffer(new Uint8Array(2));
         * // => false
         */
        var isBuffer = nativeIsBuffer || stubFalse;
        /**
         * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
         * `SyntaxError`, `TypeError`, or `URIError` object.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
         * @example
         *
         * _.isError(new Error);
         * // => true
         *
         * _.isError(Error);
         * // => false
         */
        function isError(value) {
            if (!isObjectLike(value)) {
                return false;
            }
            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value);
        }
        /**
         * Checks if `value` is classified as a `Function` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a function, else `false`.
         * @example
         *
         * _.isFunction(_);
         * // => true
         *
         * _.isFunction(/abc/);
         * // => false
         */
        function isFunction(value) {
            if (!isObject(value)) {
                return false;
            } // The use of `Object#toString` avoids issues with the `typeof` operator
            // in Safari 9 which returns 'object' for typed arrays and other constructors.
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        /**
         * Checks if `value` is a valid array-like length.
         *
         * **Note:** This method is loosely based on
         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
         * @example
         *
         * _.isLength(3);
         * // => true
         *
         * _.isLength(Number.MIN_VALUE);
         * // => false
         *
         * _.isLength(Infinity);
         * // => false
         *
         * _.isLength('3');
         * // => false
         */
        function isLength(value) {
            return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        /**
         * Checks if `value` is the
         * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
         * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an object, else `false`.
         * @example
         *
         * _.isObject({});
         * // => true
         *
         * _.isObject([1, 2, 3]);
         * // => true
         *
         * _.isObject(_.noop);
         * // => true
         *
         * _.isObject(null);
         * // => false
         */
        function isObject(value) {
            var type = typeof value;
            return value != null && (type == 'object' || type == 'function');
        }
        /**
         * Checks if `value` is object-like. A value is object-like if it's not `null`
         * and has a `typeof` result of "object".
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
         * @example
         *
         * _.isObjectLike({});
         * // => true
         *
         * _.isObjectLike([1, 2, 3]);
         * // => true
         *
         * _.isObjectLike(_.noop);
         * // => false
         *
         * _.isObjectLike(null);
         * // => false
         */
        function isObjectLike(value) {
            return value != null && typeof value == 'object';
        }
        /**
         * Checks if `value` is a plain object, that is, an object created by the
         * `Object` constructor or one with a `[[Prototype]]` of `null`.
         *
         * @static
         * @memberOf _
         * @since 0.8.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * _.isPlainObject(new Foo);
         * // => false
         *
         * _.isPlainObject([1, 2, 3]);
         * // => false
         *
         * _.isPlainObject({ 'x': 0, 'y': 0 });
         * // => true
         *
         * _.isPlainObject(Object.create(null));
         * // => true
         */
        function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
                return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
                return true;
            }
            var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
            return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        /**
         * Checks if `value` is classified as a `Symbol` primitive or object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
         * @example
         *
         * _.isSymbol(Symbol.iterator);
         * // => true
         *
         * _.isSymbol('abc');
         * // => false
         */
        function isSymbol(value) {
            return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        /**
         * Checks if `value` is classified as a typed array.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
         * @example
         *
         * _.isTypedArray(new Uint8Array);
         * // => true
         *
         * _.isTypedArray([]);
         * // => false
         */
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        /**
         * Converts `value` to a string. An empty string is returned for `null`
         * and `undefined` values. The sign of `-0` is preserved.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.toString(null);
         * // => ''
         *
         * _.toString(-0);
         * // => '-0'
         *
         * _.toString([1, 2, 3]);
         * // => '1,2,3'
         */
        function toString(value) {
            return value == null ? '' : baseToString(value);
        }
        /**
         * This method is like `_.assignIn` except that it accepts `customizer`
         * which is invoked to produce the assigned values. If `customizer` returns
         * `undefined`, assignment is handled by the method instead. The `customizer`
         * is invoked with five arguments: (objValue, srcValue, key, object, source).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @alias extendWith
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} sources The source objects.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @see _.assignWith
         * @example
         *
         * function customizer(objValue, srcValue) {
         *   return _.isUndefined(objValue) ? srcValue : objValue;
         * }
         *
         * var defaults = _.partialRight(_.assignInWith, customizer);
         *
         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
         * // => { 'a': 1, 'b': 2 }
         */
        var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
        });
        /**
         * Creates an array of the own enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects. See the
         * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
         * for more details.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keys(new Foo);
         * // => ['a', 'b'] (iteration order is not guaranteed)
         *
         * _.keys('hi');
         * // => ['0', '1']
         */
        function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        /**
         * Creates an array of the own and inherited enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keysIn(new Foo);
         * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
         */
        function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        /**
         * Creates a compiled template function that can interpolate data properties
         * in "interpolate" delimiters, HTML-escape interpolated data properties in
         * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
         * properties may be accessed as free variables in the template. If a setting
         * object is given, it takes precedence over `_.templateSettings` values.
         *
         * **Note:** In the development build `_.template` utilizes
         * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
         * for easier debugging.
         *
         * For more information on precompiling templates see
         * [lodash's custom builds documentation](https://lodash.com/custom-builds).
         *
         * For more information on Chrome extension sandboxes see
         * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category String
         * @param {string} [string=''] The template string.
         * @param {Object} [options={}] The options object.
         * @param {RegExp} [options.escape=_.templateSettings.escape]
         *  The HTML "escape" delimiter.
         * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
         *  The "evaluate" delimiter.
         * @param {Object} [options.imports=_.templateSettings.imports]
         *  An object to import into the template as free variables.
         * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
         *  The "interpolate" delimiter.
         * @param {string} [options.sourceURL='templateSources[n]']
         *  The sourceURL of the compiled template.
         * @param {string} [options.variable='obj']
         *  The data object variable name.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Function} Returns the compiled template function.
         * @example
         *
         * // Use the "interpolate" delimiter to create a compiled template.
         * var compiled = _.template('hello <%= user %>!');
         * compiled({ 'user': 'fred' });
         * // => 'hello fred!'
         *
         * // Use the HTML "escape" delimiter to escape data property values.
         * var compiled = _.template('<b><%- value %></b>');
         * compiled({ 'value': '<script>' });
         * // => '<b>&lt;script&gt;</b>'
         *
         * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
         * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
         * compiled({ 'users': ['fred', 'barney'] });
         * // => '<li>fred</li><li>barney</li>'
         *
         * // Use the internal `print` function in "evaluate" delimiters.
         * var compiled = _.template('<% print("hello " + user); %>!');
         * compiled({ 'user': 'barney' });
         * // => 'hello barney!'
         *
         * // Use the ES template literal delimiter as an "interpolate" delimiter.
         * // Disable support by replacing the "interpolate" delimiter.
         * var compiled = _.template('hello ${ user }!');
         * compiled({ 'user': 'pebbles' });
         * // => 'hello pebbles!'
         *
         * // Use backslashes to treat delimiters as plain text.
         * var compiled = _.template('<%= "\\<%- value %\\>" %>');
         * compiled({ 'value': 'ignored' });
         * // => '<%- value %>'
         *
         * // Use the `imports` option to import `jQuery` as `jq`.
         * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
         * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
         * compiled({ 'users': ['fred', 'barney'] });
         * // => '<li>fred</li><li>barney</li>'
         *
         * // Use the `sourceURL` option to specify a custom sourceURL for the template.
         * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
         * compiled(data);
         * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
         *
         * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
         * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
         * compiled.source;
         * // => function(data) {
         * //   var __t, __p = '';
         * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
         * //   return __p;
         * // }
         *
         * // Use custom template delimiters.
         * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
         * var compiled = _.template('hello {{ user }}!');
         * compiled({ 'user': 'mustache' });
         * // => 'hello mustache!'
         *
         * // Use the `source` property to inline compiled templates for meaningful
         * // line numbers in error messages and stack traces.
         * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
         *   var JST = {\
         *     "main": ' + _.template(mainText).source + '\
         *   };\
         * ');
         */
        function template(string, options, guard) {
            // Based on John Resig's `tmpl` implementation
            // (http://ejohn.org/blog/javascript-micro-templating/)
            // and Laura Doktorova's doT.js (https://github.com/olado/doT).
            var settings = templateSettings.imports._.templateSettings || templateSettings;
            if (guard && isIterateeCall(string, options, guard)) {
                options = undefined;
            }
            string = toString(string);
            options = assignInWith({}, options, settings, customDefaultsAssignIn);
            var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '"; // Compile the regexp to match each delimiter.
            var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g'); // Use a sourceURL for easier debugging.
            // The sourceURL gets injected into the source that's eval-ed, so be careful
            // with lookup (in case of e.g. prototype pollution), and strip newlines if any.
            // A newline wouldn't be a valid sourceURL anyway, and it'd enable code injection.
            var sourceURL = hasOwnProperty.call(options, 'sourceURL') ? '//# sourceURL=' + (options.sourceURL + '').replace(/[\r\n]/g, ' ') + '\n' : '';
            string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                interpolateValue || (interpolateValue = esTemplateValue); // Escape characters that can't be included in string literals.
                source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar); // Replace delimiters with snippets.
                if (escapeValue) {
                    isEscaping = true;
                    source += "' +\n__e(" + escapeValue + ") +\n'";
                }
                if (evaluateValue) {
                    isEvaluating = true;
                    source += "';\n" + evaluateValue + ";\n__p += '";
                }
                if (interpolateValue) {
                    source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                }
                index = offset + match.length; // The JS engine embedded in Adobe products needs `match` returned in
                // order to produce the correct `offset` value.
                return match;
            });
            source += "';\n"; // If `variable` is not specified wrap a with-statement around the generated
            // code to add the data object to the top of the scope chain.
            // Like with sourceURL, we take care to not check the option's prototype,
            // as this configuration is a code injection vector.
            var variable = hasOwnProperty.call(options, 'variable') && options.variable;
            if (!variable) {
                source = 'with (obj) {\n' + source + '\n}\n';
            } // Cleanup code by stripping empty strings.
            source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;'); // Frame code as the function body.
            source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
            var result = attempt(function () {
                return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
            }); // Provide the compiled function's source by its `toString` method or
            // the `source` property as a convenience for inlining compiled templates.
            result.source = source;
            if (isError(result)) {
                throw result;
            }
            return result;
        }
        /**
         * Attempts to invoke `func`, returning either the result or the caught error
         * object. Any additional arguments are provided to `func` when it's invoked.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Util
         * @param {Function} func The function to attempt.
         * @param {...*} [args] The arguments to invoke `func` with.
         * @returns {*} Returns the `func` result or error object.
         * @example
         *
         * // Avoid throwing errors for invalid selectors.
         * var elements = _.attempt(function(selector) {
         *   return document.querySelectorAll(selector);
         * }, '>_>');
         *
         * if (_.isError(elements)) {
         *   elements = [];
         * }
         */
        var attempt = baseRest(function (func, args) {
            try {
                return apply(func, undefined, args);
            }
            catch (e) {
                return isError(e) ? e : new Error(e);
            }
        });
        /**
         * Creates a function that returns `value`.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Util
         * @param {*} value The value to return from the new function.
         * @returns {Function} Returns the new constant function.
         * @example
         *
         * var objects = _.times(2, _.constant({ 'a': 1 }));
         *
         * console.log(objects);
         * // => [{ 'a': 1 }, { 'a': 1 }]
         *
         * console.log(objects[0] === objects[1]);
         * // => true
         */
        function constant(value) {
            return function () {
                return value;
            };
        }
        /**
         * This method returns the first argument it receives.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {*} value Any value.
         * @returns {*} Returns `value`.
         * @example
         *
         * var object = { 'a': 1 };
         *
         * console.log(_.identity(object) === object);
         * // => true
         */
        function identity(value) {
            return value;
        }
        /**
         * This method returns `false`.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {boolean} Returns `false`.
         * @example
         *
         * _.times(2, _.stubFalse);
         * // => [false, false]
         */
        function stubFalse() {
            return false;
        }
        module.exports = template;
        return module.exports;
    }
    exports_85("dew", dew);
    return {
        setters: [
            function (npm_lodash__reinterpolate_3_dew_2_1) {
                npm_lodash__reinterpolate_3_dew_2 = npm_lodash__reinterpolate_3_dew_2_1;
            },
            function (npm_lodash_templatesettings_4_dew_1_1) {
                npm_lodash_templatesettings_4_dew_1 = npm_lodash_templatesettings_4_dew_1_1;
            }
        ],
        execute: function () {
            exports = {}, _dewExec = false;
            module = {
                exports: exports
            };
            _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
        }
    };
});
System.register("https://dev.jspm.io/npm:lodash.template@4?dew", ["https://dev.jspm.io/npm:lodash.template@4.5.0/index.dew", "https://dev.jspm.io/npm:lodash._reinterpolate@3?dew", "https://dev.jspm.io/npm:lodash.templatesettings@4?dew"], function (exports_86, context_86) {
    "use strict";
    var __moduleName = context_86 && context_86.id;
    return {
        setters: [
            function (index_dew_js_3_1) {
                exports_86({
                    "dew": index_dew_js_3_1["dew"]
                });
            },
            function (_15) {
            },
            function (_16) {
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/path", ["https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/chunk-0c2d1322"], function (exports_87, context_87) {
    "use strict";
    var chunk_0c2d1322_js_3, r, i, l, _makeLong, basename, delimiter, dirname, extname, format, isAbsolute, join, normalize, parse, posix, relative, resolve, sep, win32;
    var __moduleName = context_87 && context_87.id;
    function t(e) {
        if ("string" != typeof e)
            throw new TypeError("Path must be a string. Received " + JSON.stringify(e));
    }
    function n(e, r) {
        for (var t, n = "", i = 0, l = -1, o = 0, a = 0; a <= e.length; ++a) {
            if (a < e.length)
                t = e.charCodeAt(a);
            else {
                if (47 === t)
                    break;
                t = 47;
            }
            if (47 === t) {
                if (l === a - 1 || 1 === o)
                    ;
                else if (l !== a - 1 && 2 === o) {
                    if (n.length < 2 || 2 !== i || 46 !== n.charCodeAt(n.length - 1) || 46 !== n.charCodeAt(n.length - 2))
                        if (n.length > 2) {
                            var h = n.lastIndexOf("/");
                            if (h !== n.length - 1) {
                                -1 === h ? (n = "", i = 0) : i = (n = n.slice(0, h)).length - 1 - n.lastIndexOf("/"), l = a, o = 0;
                                continue;
                            }
                        }
                        else if (2 === n.length || 1 === n.length) {
                            n = "", i = 0, l = a, o = 0;
                            continue;
                        }
                    r && (n.length > 0 ? n += "/.." : n = "..", i = 2);
                }
                else
                    n.length > 0 ? n += "/" + e.slice(l + 1, a) : n = e.slice(l + 1, a), i = a - l - 1;
                l = a, o = 0;
            }
            else
                46 === t && -1 !== o ? ++o : o = -1;
        }
        return n;
    }
    return {
        setters: [
            function (chunk_0c2d1322_js_3_1) {
                chunk_0c2d1322_js_3 = chunk_0c2d1322_js_3_1;
            }
        ],
        execute: function () {
            r = chunk_0c2d1322_js_3.h;
            i = {
                resolve: function () {
                    for (var e, i = "", l = !1, o = arguments.length - 1; o >= -1 && !l; o--) {
                        var a;
                        o >= 0 ? a = arguments[o] : (void 0 === e && (e = r.cwd()), a = e), t(a), 0 !== a.length && (i = a + "/" + i, l = 47 === a.charCodeAt(0));
                    }
                    return i = n(i, !l), l ? i.length > 0 ? "/" + i : "/" : i.length > 0 ? i : ".";
                },
                normalize: function (e) {
                    if (t(e), 0 === e.length)
                        return ".";
                    var r = 47 === e.charCodeAt(0), i = 47 === e.charCodeAt(e.length - 1);
                    return 0 !== (e = n(e, !r)).length || r || (e = "."), e.length > 0 && i && (e += "/"), r ? "/" + e : e;
                },
                isAbsolute: function (e) {
                    return t(e), e.length > 0 && 47 === e.charCodeAt(0);
                },
                join: function () {
                    if (0 === arguments.length)
                        return ".";
                    for (var e, r = 0; r < arguments.length; ++r) {
                        var n = arguments[r];
                        t(n), n.length > 0 && (void 0 === e ? e = n : e += "/" + n);
                    }
                    return void 0 === e ? "." : i.normalize(e);
                },
                relative: function (e, r) {
                    if (t(e), t(r), e === r)
                        return "";
                    if ((e = i.resolve(e)) === (r = i.resolve(r)))
                        return "";
                    for (var n = 1; n < e.length && 47 === e.charCodeAt(n); ++n)
                        ;
                    for (var l = e.length, o = l - n, a = 1; a < r.length && 47 === r.charCodeAt(a); ++a)
                        ;
                    for (var h = r.length - a, f = o < h ? o : h, c = -1, s = 0; s <= f; ++s) {
                        if (s === f) {
                            if (h > f) {
                                if (47 === r.charCodeAt(a + s))
                                    return r.slice(a + s + 1);
                                if (0 === s)
                                    return r.slice(a + s);
                            }
                            else
                                o > f && (47 === e.charCodeAt(n + s) ? c = s : 0 === s && (c = 0));
                            break;
                        }
                        var g = e.charCodeAt(n + s);
                        if (g !== r.charCodeAt(a + s))
                            break;
                        47 === g && (c = s);
                    }
                    var u = "";
                    for (s = n + c + 1; s <= l; ++s)
                        s !== l && 47 !== e.charCodeAt(s) || (0 === u.length ? u += ".." : u += "/..");
                    return u.length > 0 ? u + r.slice(a + c) : (a += c, 47 === r.charCodeAt(a) && ++a, r.slice(a));
                },
                _makeLong: function (e) {
                    return e;
                },
                dirname: function (e) {
                    if (t(e), 0 === e.length)
                        return ".";
                    for (var r = e.charCodeAt(0), n = 47 === r, i = -1, l = !0, o = e.length - 1; o >= 1; --o)
                        if (47 === (r = e.charCodeAt(o))) {
                            if (!l) {
                                i = o;
                                break;
                            }
                        }
                        else
                            l = !1;
                    return -1 === i ? n ? "/" : "." : n && 1 === i ? "//" : e.slice(0, i);
                },
                basename: function (e, r) {
                    if (void 0 !== r && "string" != typeof r)
                        throw new TypeError('"ext" argument must be a string');
                    t(e);
                    var n, i = 0, l = -1, o = !0;
                    if (void 0 !== r && r.length > 0 && r.length <= e.length) {
                        if (r.length === e.length && r === e)
                            return "";
                        var a = r.length - 1, h = -1;
                        for (n = e.length - 1; n >= 0; --n) {
                            var f = e.charCodeAt(n);
                            if (47 === f) {
                                if (!o) {
                                    i = n + 1;
                                    break;
                                }
                            }
                            else
                                -1 === h && (o = !1, h = n + 1), a >= 0 && (f === r.charCodeAt(a) ? -1 == --a && (l = n) : (a = -1, l = h));
                        }
                        return i === l ? l = h : -1 === l && (l = e.length), e.slice(i, l);
                    }
                    for (n = e.length - 1; n >= 0; --n)
                        if (47 === e.charCodeAt(n)) {
                            if (!o) {
                                i = n + 1;
                                break;
                            }
                        }
                        else
                            -1 === l && (o = !1, l = n + 1);
                    return -1 === l ? "" : e.slice(i, l);
                },
                extname: function (e) {
                    t(e);
                    for (var r = -1, n = 0, i = -1, l = !0, o = 0, a = e.length - 1; a >= 0; --a) {
                        var h = e.charCodeAt(a);
                        if (47 !== h)
                            -1 === i && (l = !1, i = a + 1), 46 === h ? -1 === r ? r = a : 1 !== o && (o = 1) : -1 !== r && (o = -1);
                        else if (!l) {
                            n = a + 1;
                            break;
                        }
                    }
                    return -1 === r || -1 === i || 0 === o || 1 === o && r === i - 1 && r === n + 1 ? "" : e.slice(r, i);
                },
                format: function (e) {
                    if (null === e || "object" != typeof e)
                        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e);
                    return function (e, r) {
                        var t = r.dir || r.root, n = r.base || (r.name || "") + (r.ext || "");
                        return t ? t === r.root ? t + n : t + e + n : n;
                    }("/", e);
                },
                parse: function (e) {
                    t(e);
                    var r = {
                        root: "",
                        dir: "",
                        base: "",
                        ext: "",
                        name: ""
                    };
                    if (0 === e.length)
                        return r;
                    var n, i = e.charCodeAt(0), l = 47 === i;
                    l ? (r.root = "/", n = 1) : n = 0;
                    for (var o = -1, a = 0, h = -1, f = !0, c = e.length - 1, s = 0; c >= n; --c)
                        if (47 !== (i = e.charCodeAt(c)))
                            -1 === h && (f = !1, h = c + 1), 46 === i ? -1 === o ? o = c : 1 !== s && (s = 1) : -1 !== o && (s = -1);
                        else if (!f) {
                            a = c + 1;
                            break;
                        }
                    return -1 === o || -1 === h || 0 === s || 1 === s && o === h - 1 && o === a + 1 ? -1 !== h && (r.base = r.name = 0 === a && l ? e.slice(1, h) : e.slice(a, h)) : (0 === a && l ? (r.name = e.slice(1, o), r.base = e.slice(1, h)) : (r.name = e.slice(a, o), r.base = e.slice(a, h)), r.ext = e.slice(o, h)), a > 0 ? r.dir = e.slice(0, a - 1) : l && (r.dir = "/"), r;
                },
                sep: "/",
                delimiter: ":",
                win32: null,
                posix: null
            };
            i.posix = i;
            l = i;
            _makeLong = l._makeLong;
            exports_87("_makeLong", _makeLong);
            basename = l.basename;
            exports_87("basename", basename);
            delimiter = l.delimiter;
            exports_87("delimiter", delimiter);
            dirname = l.dirname;
            exports_87("dirname", dirname);
            extname = l.extname;
            exports_87("extname", extname);
            format = l.format;
            exports_87("format", format);
            isAbsolute = l.isAbsolute;
            exports_87("isAbsolute", isAbsolute);
            join = l.join;
            exports_87("join", join);
            normalize = l.normalize;
            exports_87("normalize", normalize);
            parse = l.parse;
            exports_87("parse", parse);
            posix = l.posix;
            exports_87("posix", posix);
            relative = l.relative;
            exports_87("relative", relative);
            resolve = l.resolve;
            exports_87("resolve", resolve);
            sep = l.sep;
            exports_87("sep", sep);
            win32 = l.win32;
            exports_87("win32", win32);
            exports_87("default", l);
        }
    };
});
System.register("https://dev.jspm.io/npm:@jspm/core@1/nodelibs/path", ["https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/path", "https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/chunk-0c2d1322"], function (exports_88, context_88) {
    "use strict";
    var __moduleName = context_88 && context_88.id;
    var exportedNames_3 = {
        "default": true
    };
    function exportStar_5(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default" && !exportedNames_3.hasOwnProperty(n)) exports[n] = m[n];
        }
        exports_88(exports);
    }
    return {
        setters: [
            function (path_js_1_1) {
                exportStar_5(path_js_1_1);
                exports_88({
                    "default": path_js_1_1["default"]
                });
            },
            function (_17) {
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://dev.jspm.io/npm:serialize-javascript@2.1.2/index.dew", [], function (exports_89, context_89) {
    "use strict";
    var exports, _dewExec;
    var __moduleName = context_89 && context_89.id;
    function dew() {
        if (_dewExec)
            return exports;
        _dewExec = true;
        // Generate an internal UID to make the regexp pattern harder to guess.
        var UID = Math.floor(Math.random() * 0x10000000000).toString(16);
        var PLACE_HOLDER_REGEXP = new RegExp('"@__(F|R|D|M|S|U)-' + UID + '-(\\d+)__@"', 'g');
        var IS_NATIVE_CODE_REGEXP = /\{\s*\[native code\]\s*\}/g;
        var IS_PURE_FUNCTION = /function.*?\(/;
        var IS_ARROW_FUNCTION = /.*?=>.*?/;
        var UNSAFE_CHARS_REGEXP = /[<>\/\u2028\u2029]/g;
        var RESERVED_SYMBOLS = ['*', 'async']; // Mapping of unsafe HTML and invalid JavaScript line terminator chars to their
        // Unicode char counterparts which are safe to use in JavaScript strings.
        var ESCAPED_CHARS = {
            '<': '\\u003C',
            '>': '\\u003E',
            '/': '\\u002F',
            '\u2028': '\\u2028',
            '\u2029': '\\u2029'
        };
        function escapeUnsafeChars(unsafeChar) {
            return ESCAPED_CHARS[unsafeChar];
        }
        function deleteFunctions(obj) {
            var functionKeys = [];
            for (var key in obj) {
                if (typeof obj[key] === "function") {
                    functionKeys.push(key);
                }
            }
            for (var i = 0; i < functionKeys.length; i++) {
                delete obj[functionKeys[i]];
            }
        }
        exports = function serialize(obj, options) {
            options || (options = {}); // Backwards-compatibility for `space` as the second argument.
            if (typeof options === 'number' || typeof options === 'string') {
                options = {
                    space: options
                };
            }
            var functions = [];
            var regexps = [];
            var dates = [];
            var maps = [];
            var sets = [];
            var undefs = []; // Returns placeholders for functions and regexps (identified by index)
            // which are later replaced by their string representation.
            function replacer(key, value) {
                // For nested function
                if (options.ignoreFunction) {
                    deleteFunctions(value);
                }
                if (!value && value !== undefined) {
                    return value;
                } // If the value is an object w/ a toJSON method, toJSON is called before
                // the replacer runs, so we use this[key] to get the non-toJSONed value.
                var origValue = this[key];
                var type = typeof origValue;
                if (type === 'object') {
                    if (origValue instanceof RegExp) {
                        return '@__R-' + UID + '-' + (regexps.push(origValue) - 1) + '__@';
                    }
                    if (origValue instanceof Date) {
                        return '@__D-' + UID + '-' + (dates.push(origValue) - 1) + '__@';
                    }
                    if (origValue instanceof Map) {
                        return '@__M-' + UID + '-' + (maps.push(origValue) - 1) + '__@';
                    }
                    if (origValue instanceof Set) {
                        return '@__S-' + UID + '-' + (sets.push(origValue) - 1) + '__@';
                    }
                }
                if (type === 'function') {
                    return '@__F-' + UID + '-' + (functions.push(origValue) - 1) + '__@';
                }
                if (type === 'undefined') {
                    return '@__U-' + UID + '-' + (undefs.push(origValue) - 1) + '__@';
                }
                return value;
            }
            function serializeFunc(fn) {
                var serializedFn = fn.toString();
                if (IS_NATIVE_CODE_REGEXP.test(serializedFn)) {
                    throw new TypeError('Serializing native function: ' + fn.name);
                } // pure functions, example: {key: function() {}}
                if (IS_PURE_FUNCTION.test(serializedFn)) {
                    return serializedFn;
                } // arrow functions, example: arg1 => arg1+5
                if (IS_ARROW_FUNCTION.test(serializedFn)) {
                    return serializedFn;
                }
                var argsStartsAt = serializedFn.indexOf('(');
                var def = serializedFn.substr(0, argsStartsAt).trim().split(' ').filter(function (val) {
                    return val.length > 0;
                });
                var nonReservedSymbols = def.filter(function (val) {
                    return RESERVED_SYMBOLS.indexOf(val) === -1;
                }); // enhanced literal objects, example: {key() {}}
                if (nonReservedSymbols.length > 0) {
                    return (def.indexOf('async') > -1 ? 'async ' : '') + 'function' + (def.join('').indexOf('*') > -1 ? '*' : '') + serializedFn.substr(argsStartsAt);
                } // arrow functions
                return serializedFn;
            } // Check if the parameter is function
            if (options.ignoreFunction && typeof obj === "function") {
                obj = undefined;
            } // Protects against `JSON.stringify()` returning `undefined`, by serializing
            // to the literal string: "undefined".
            if (obj === undefined) {
                return String(obj);
            }
            var str; // Creates a JSON string representation of the value.
            // NOTE: Node 0.12 goes into slow mode with extra JSON.stringify() args.
            if (options.isJSON && !options.space) {
                str = JSON.stringify(obj);
            }
            else {
                str = JSON.stringify(obj, options.isJSON ? null : replacer, options.space);
            } // Protects against `JSON.stringify()` returning `undefined`, by serializing
            // to the literal string: "undefined".
            if (typeof str !== 'string') {
                return String(str);
            } // Replace unsafe HTML and invalid JavaScript line terminator chars with
            // their safe Unicode char counterpart. This _must_ happen before the
            // regexps and functions are serialized and added back to the string.
            if (options.unsafe !== true) {
                str = str.replace(UNSAFE_CHARS_REGEXP, escapeUnsafeChars);
            }
            if (functions.length === 0 && regexps.length === 0 && dates.length === 0 && maps.length === 0 && sets.length === 0 && undefs.length === 0) {
                return str;
            } // Replaces all occurrences of function, regexp, date, map and set placeholders in the
            // JSON string with their string representations. If the original value can
            // not be found, then `undefined` is used.
            return str.replace(PLACE_HOLDER_REGEXP, function (match, type, valueIndex) {
                if (type === 'D') {
                    return "new Date(\"" + dates[valueIndex].toISOString() + "\")";
                }
                if (type === 'R') {
                    return "new RegExp(" + serialize(regexps[valueIndex].source) + ", \"" + regexps[valueIndex].flags + "\")";
                }
                if (type === 'M') {
                    return "new Map(" + serialize(Array.from(maps[valueIndex].entries()), options) + ")";
                }
                if (type === 'S') {
                    return "new Set(" + serialize(Array.from(sets[valueIndex].values()), options) + ")";
                }
                if (type === 'U') {
                    return 'undefined';
                }
                var fn = functions[valueIndex];
                return serializeFunc(fn);
            });
        };
        return exports;
    }
    exports_89("dew", dew);
    return {
        setters: [],
        execute: function () {
            exports = {}, _dewExec = false;
        }
    };
});
System.register("https://dev.jspm.io/npm:serialize-javascript@2?dew", ["https://dev.jspm.io/npm:serialize-javascript@2.1.2/index.dew"], function (exports_90, context_90) {
    "use strict";
    var __moduleName = context_90 && context_90.id;
    return {
        setters: [
            function (index_dew_js_4_1) {
                exports_90({
                    "dew": index_dew_js_4_1["dew"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/vm", [], function (exports_91, context_91) {
    "use strict";
    var _global, exports, indexOf, Object_keys, forEach, defineProp, globals, Script, Script$1, createContext, createScript, isContext, runInContext, runInNewContext, runInThisContext;
    var __moduleName = context_91 && context_91.id;
    function Context() { }
    return {
        setters: [],
        execute: function () {
            _global = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global, exports = {}, indexOf = function (e, t) { if (e.indexOf)
                return e.indexOf(t); for (var n = 0; n < e.length; n++)
                if (e[n] === t)
                    return n; return -1; }, Object_keys = function (e) { if (Object.keys)
                return Object.keys(e); var t = []; for (var n in e)
                t.push(n); return t; }, forEach = function (e, t) { if (e.forEach)
                return e.forEach(t); for (var n = 0; n < e.length; n++)
                t(e[n], n, e); }, defineProp = function () { try {
                return Object.defineProperty({}, "_", {}), function (e, t, n) { Object.defineProperty(e, t, { writable: !0, enumerable: !1, configurable: !0, value: n }); };
            }
            catch (e) {
                return function (e, t, n) { e[t] = n; };
            } }(), globals = ["Array", "Boolean", "Date", "Error", "EvalError", "Function", "Infinity", "JSON", "Math", "NaN", "Number", "Object", "RangeError", "ReferenceError", "RegExp", "String", "SyntaxError", "TypeError", "URIError", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "undefined", "unescape"];
            Context.prototype = {};
            Script = exports.Script = function (e) { if (!((this || _global) instanceof Script))
                return new Script(e); (this || _global).code = e; };
            Script.prototype.runInContext = function (e) { if (!(e instanceof Context))
                throw new TypeError("needs a 'context' argument."); var t = document.createElement("iframe"); t.style || (t.style = {}), t.style.display = "none", document.body.appendChild(t); var n = t.contentWindow, r = n.eval, o = n.execScript; !r && o && (o.call(n, "null"), r = n.eval), forEach(Object_keys(e), (function (t) { n[t] = e[t]; })), forEach(globals, (function (t) { e[t] && (n[t] = e[t]); })); var c = Object_keys(n), i = r.call(n, (this || _global).code); return forEach(Object_keys(n), (function (t) { (t in e || -1 === indexOf(c, t)) && (e[t] = n[t]); })), forEach(globals, (function (t) { t in e || defineProp(e, t, n[t]); })), document.body.removeChild(t), i; }, Script.prototype.runInThisContext = function () { return eval((this || _global).code); }, Script.prototype.runInNewContext = function (e) { var t = Script.createContext(e), n = this.runInContext(t); return e && forEach(Object_keys(t), (function (n) { e[n] = t[n]; })), n; }, forEach(Object_keys(Script.prototype), (function (e) { exports[e] = Script[e] = function (t) { var n = Script(t); return n[e].apply(n, [].slice.call(arguments, 1)); }; })), exports.isContext = function (e) { return e instanceof Context; }, exports.createScript = function (e) { return exports.Script(e); }, exports.createContext = Script.createContext = function (e) { var t = new Context; return "object" == typeof e && forEach(Object_keys(e), (function (n) { t[n] = e[n]; })), t; };
            Script$1 = exports.Script;
            exports_91("Script", Script$1);
            createContext = exports.createContext;
            exports_91("createContext", createContext);
            createScript = exports.createScript;
            exports_91("createScript", createScript);
            isContext = exports.isContext;
            exports_91("isContext", isContext);
            runInContext = exports.runInContext;
            exports_91("runInContext", runInContext);
            runInNewContext = exports.runInNewContext;
            exports_91("runInNewContext", runInNewContext);
            runInThisContext = exports.runInThisContext;
            exports_91("runInThisContext", runInThisContext);
            exports_91("default", exports);
        }
    };
});
System.register("https://dev.jspm.io/npm:@jspm/core@1/nodelibs/vm", ["https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/vm"], function (exports_92, context_92) {
    "use strict";
    var __moduleName = context_92 && context_92.id;
    var exportedNames_4 = {
        "default": true
    };
    function exportStar_6(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default" && !exportedNames_4.hasOwnProperty(n)) exports[n] = m[n];
        }
        exports_92(exports);
    }
    return {
        setters: [
            function (vm_js_1_1) {
                exportStar_6(vm_js_1_1);
                exports_92({
                    "default": vm_js_1_1["default"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/fs", [], function (exports_93, context_93) {
    "use strict";
    var promises, fs, F_OK, R_OK, W_OK, X_OK, constants;
    var __moduleName = context_93 && context_93.id;
    function unimplemented() { throw new Error("Node.js fs module is not supported by jspm core" + ("undefined" != typeof Deno ? ". Deno support here is tracking in https://github.com/jspm/jspm-core/issues/4, +1's are appreciated!" : " in the browser")); }
    exports_93("Dir", unimplemented);
    exports_93("Dirent", unimplemented);
    exports_93("FileReadStream", unimplemented);
    exports_93("FileWriteStream", unimplemented);
    exports_93("ReadStream", unimplemented);
    exports_93("Stats", unimplemented);
    exports_93("WriteStream", unimplemented);
    exports_93("_toUnixTimestamp", unimplemented);
    exports_93("access", unimplemented);
    exports_93("accessSync", unimplemented);
    exports_93("appendFile", unimplemented);
    exports_93("appendFileSync", unimplemented);
    exports_93("chmod", unimplemented);
    exports_93("chmodSync", unimplemented);
    exports_93("chown", unimplemented);
    exports_93("chownSync", unimplemented);
    exports_93("close", unimplemented);
    exports_93("closeSync", unimplemented);
    exports_93("copyFile", unimplemented);
    exports_93("copyFileSync", unimplemented);
    exports_93("createReadStream", unimplemented);
    exports_93("createWriteStream", unimplemented);
    exports_93("exists", unimplemented);
    exports_93("existsSync", unimplemented);
    exports_93("fchmod", unimplemented);
    exports_93("fchmodSync", unimplemented);
    exports_93("fchown", unimplemented);
    exports_93("fchownSync", unimplemented);
    exports_93("fdatasync", unimplemented);
    exports_93("fdatasyncSync", unimplemented);
    exports_93("fstat", unimplemented);
    exports_93("fstatSync", unimplemented);
    exports_93("fsync", unimplemented);
    exports_93("fsyncSync", unimplemented);
    exports_93("ftruncate", unimplemented);
    exports_93("ftruncateSync", unimplemented);
    exports_93("futimes", unimplemented);
    exports_93("futimesSync", unimplemented);
    exports_93("lchmod", unimplemented);
    exports_93("lchmodSync", unimplemented);
    exports_93("lchown", unimplemented);
    exports_93("lchownSync", unimplemented);
    exports_93("link", unimplemented);
    exports_93("linkSync", unimplemented);
    exports_93("lstat", unimplemented);
    exports_93("lstatSync", unimplemented);
    exports_93("mkdir", unimplemented);
    exports_93("mkdirSync", unimplemented);
    exports_93("mkdtemp", unimplemented);
    exports_93("mkdtempSync", unimplemented);
    exports_93("open", unimplemented);
    exports_93("openSync", unimplemented);
    exports_93("opendir", unimplemented);
    exports_93("opendirSync", unimplemented);
    exports_93("read", unimplemented);
    exports_93("readFile", unimplemented);
    exports_93("readFileSync", unimplemented);
    exports_93("readSync", unimplemented);
    exports_93("readdir", unimplemented);
    exports_93("readdirSync", unimplemented);
    exports_93("readlink", unimplemented);
    exports_93("readlinkSync", unimplemented);
    exports_93("realpath", unimplemented);
    exports_93("realpathSync", unimplemented);
    exports_93("rename", unimplemented);
    exports_93("renameSync", unimplemented);
    exports_93("rmdir", unimplemented);
    exports_93("rmdirSync", unimplemented);
    exports_93("stat", unimplemented);
    exports_93("statSync", unimplemented);
    exports_93("symlink", unimplemented);
    exports_93("symlinkSync", unimplemented);
    exports_93("truncate", unimplemented);
    exports_93("truncateSync", unimplemented);
    exports_93("unlink", unimplemented);
    exports_93("unlinkSync", unimplemented);
    exports_93("unwatchFile", unimplemented);
    exports_93("utimes", unimplemented);
    exports_93("utimesSync", unimplemented);
    exports_93("watch", unimplemented);
    exports_93("watchFile", unimplemented);
    exports_93("write", unimplemented);
    exports_93("writeFile", unimplemented);
    exports_93("writeFileSync", unimplemented);
    exports_93("writeSync", unimplemented);
    exports_93("writev", unimplemented);
    exports_93("writevSync", unimplemented);
    return {
        setters: [],
        execute: function () {
            promises = { access: unimplemented, copyFile: unimplemented, open: unimplemented, opendir: unimplemented, rename: unimplemented, truncate: unimplemented, rmdir: unimplemented, mkdir: unimplemented, readdir: unimplemented, readlink: unimplemented, symlink: unimplemented, lstat: unimplemented, stat: unimplemented, link: unimplemented, unlink: unimplemented, chmod: unimplemented, lchmod: unimplemented, lchown: unimplemented, chown: unimplemented, utimes: unimplemented, realpath: unimplemented, mkdtemp: unimplemented, writeFile: unimplemented, appendFile: unimplemented, readFile: unimplemented };
            exports_93("promises", promises);
            fs = { appendFile: unimplemented, appendFileSync: unimplemented, access: unimplemented, accessSync: unimplemented, chown: unimplemented, chownSync: unimplemented, chmod: unimplemented, chmodSync: unimplemented, close: unimplemented, closeSync: unimplemented, copyFile: unimplemented, copyFileSync: unimplemented, createReadStream: unimplemented, createWriteStream: unimplemented, exists: unimplemented, existsSync: unimplemented, fchown: unimplemented, fchownSync: unimplemented, fchmod: unimplemented, fchmodSync: unimplemented, fdatasync: unimplemented, fdatasyncSync: unimplemented, fstat: unimplemented, fstatSync: unimplemented, fsync: unimplemented, fsyncSync: unimplemented, ftruncate: unimplemented, ftruncateSync: unimplemented, futimes: unimplemented, futimesSync: unimplemented, lchown: unimplemented, lchownSync: unimplemented, lchmod: unimplemented, lchmodSync: unimplemented, link: unimplemented, linkSync: unimplemented, lstat: unimplemented, lstatSync: unimplemented, mkdir: unimplemented, mkdirSync: unimplemented, mkdtemp: unimplemented, mkdtempSync: unimplemented, open: unimplemented, openSync: unimplemented, opendir: unimplemented, opendirSync: unimplemented, readdir: unimplemented, readdirSync: unimplemented, read: unimplemented, readSync: unimplemented, readFile: unimplemented, readFileSync: unimplemented, readlink: unimplemented, readlinkSync: unimplemented, realpath: unimplemented, realpathSync: unimplemented, rename: unimplemented, renameSync: unimplemented, rmdir: unimplemented, rmdirSync: unimplemented, stat: unimplemented, statSync: unimplemented, symlink: unimplemented, symlinkSync: unimplemented, truncate: unimplemented, truncateSync: unimplemented, unwatchFile: unimplemented, unlink: unimplemented, unlinkSync: unimplemented, utimes: unimplemented, utimesSync: unimplemented, watch: unimplemented, watchFile: unimplemented, writeFile: unimplemented, writeFileSync: unimplemented, write: unimplemented, writeSync: unimplemented, writev: unimplemented, writevSync: unimplemented, Dir: unimplemented, Dirent: unimplemented, Stats: unimplemented, ReadStream: unimplemented, WriteStream: unimplemented, FileReadStream: unimplemented, FileWriteStream: unimplemented, _toUnixTimestamp: unimplemented, F_OK: null, R_OK: null, W_OK: null, X_OK: null, constants: null, promises: promises };
            F_OK = null, R_OK = null, W_OK = null, X_OK = null, constants = null;
            exports_93("F_OK", F_OK);
            exports_93("R_OK", R_OK);
            exports_93("W_OK", W_OK);
            exports_93("X_OK", X_OK);
            exports_93("constants", constants);
            exports_93("default", fs);
        }
    };
});
System.register("https://dev.jspm.io/npm:@jspm/core@1/nodelibs/fs", ["https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/fs"], function (exports_94, context_94) {
    "use strict";
    var __moduleName = context_94 && context_94.id;
    var exportedNames_5 = {
        "default": true
    };
    function exportStar_7(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default" && !exportedNames_5.hasOwnProperty(n)) exports[n] = m[n];
        }
        exports_94(exports);
    }
    return {
        setters: [
            function (fs_js_1_1) {
                exportStar_7(fs_js_1_1);
                exports_94({
                    "default": fs_js_1_1["default"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://dev.jspm.io/npm:resolve@1.17.0/lib/caller.dew", [], function (exports_95, context_95) {
    "use strict";
    var exports, _dewExec;
    var __moduleName = context_95 && context_95.id;
    function dew() {
        if (_dewExec)
            return exports;
        _dewExec = true;
        exports = function () {
            // see https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
            var origPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = function (_, stack) {
                return stack;
            };
            var stack = new Error().stack;
            Error.prepareStackTrace = origPrepareStackTrace;
            return stack[2].getFileName();
        };
        return exports;
    }
    exports_95("dew", dew);
    return {
        setters: [],
        execute: function () {
            exports = {}, _dewExec = false;
        }
    };
});
System.register("https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/process", ["https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/chunk-0c2d1322"], function (exports_96, context_96) {
    "use strict";
    var __moduleName = context_96 && context_96.id;
    return {
        setters: [
            function (chunk_0c2d1322_js_4_1) {
                exports_96({
                    "addListener": chunk_0c2d1322_js_4_1["a"],
                    "argv": chunk_0c2d1322_js_4_1["b"],
                    "binding": chunk_0c2d1322_js_4_1["c"],
                    "browser": chunk_0c2d1322_js_4_1["d"],
                    "chdir": chunk_0c2d1322_js_4_1["e"],
                    "cwd": chunk_0c2d1322_js_4_1["f"],
                    "default": chunk_0c2d1322_js_4_1["h"],
                    "emit": chunk_0c2d1322_js_4_1["g"],
                    "env": chunk_0c2d1322_js_4_1["i"],
                    "listeners": chunk_0c2d1322_js_4_1["l"],
                    "nextTick": chunk_0c2d1322_js_4_1["n"],
                    "off": chunk_0c2d1322_js_4_1["o"],
                    "on": chunk_0c2d1322_js_4_1["j"],
                    "once": chunk_0c2d1322_js_4_1["k"],
                    "prependListener": chunk_0c2d1322_js_4_1["p"],
                    "prependOnceListener": chunk_0c2d1322_js_4_1["m"],
                    "removeAllListeners": chunk_0c2d1322_js_4_1["r"],
                    "removeListener": chunk_0c2d1322_js_4_1["q"],
                    "title": chunk_0c2d1322_js_4_1["t"],
                    "umask": chunk_0c2d1322_js_4_1["u"],
                    "version": chunk_0c2d1322_js_4_1["v"],
                    "versions": chunk_0c2d1322_js_4_1["s"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://dev.jspm.io/npm:@jspm/core@1/nodelibs/process", ["https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/process", "https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/chunk-0c2d1322"], function (exports_97, context_97) {
    "use strict";
    var __moduleName = context_97 && context_97.id;
    var exportedNames_6 = {
        "default": true
    };
    function exportStar_8(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default" && !exportedNames_6.hasOwnProperty(n)) exports[n] = m[n];
        }
        exports_97(exports);
    }
    return {
        setters: [
            function (process_js_1_1) {
                exportStar_8(process_js_1_1);
                exports_97({
                    "default": process_js_1_1["default"]
                });
            },
            function (_18) {
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://dev.jspm.io/npm:path-parse@1.0.6/index.dew", ["https://dev.jspm.io/npm:@jspm/core@1/nodelibs/process"], function (exports_98, context_98) {
    "use strict";
    var process_js_2, exports, _dewExec;
    var __moduleName = context_98 && context_98.id;
    function dew() {
        if (_dewExec)
            return exports;
        _dewExec = true;
        var process = process_js_2.default;
        var isWindows = process.platform === 'win32'; // Regex to split a windows path into three parts: [*, device, slash,
        // tail] windows-only
        var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/; // Regex to split the tail part of the above into [*, dir, basename, ext]
        var splitTailRe = /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;
        var win32 = {}; // Function to split a filename into [root, dir, basename, ext]
        function win32SplitPath(filename) {
            // Separate device+slash from tail
            var result = splitDeviceRe.exec(filename), device = (result[1] || '') + (result[2] || ''), tail = result[3] || ''; // Split the tail into dir, basename and extension
            var result2 = splitTailRe.exec(tail), dir = result2[1], basename = result2[2], ext = result2[3];
            return [device, dir, basename, ext];
        }
        win32.parse = function (pathString) {
            if (typeof pathString !== 'string') {
                throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
            }
            var allParts = win32SplitPath(pathString);
            if (!allParts || allParts.length !== 4) {
                throw new TypeError("Invalid path '" + pathString + "'");
            }
            return {
                root: allParts[0],
                dir: allParts[0] + allParts[1].slice(0, -1),
                base: allParts[2],
                ext: allParts[3],
                name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
            };
        }; // Split a filename into [root, dir, basename, ext], unix version
        // 'root' is just a slash, or nothing.
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        var posix = {};
        function posixSplitPath(filename) {
            return splitPathRe.exec(filename).slice(1);
        }
        posix.parse = function (pathString) {
            if (typeof pathString !== 'string') {
                throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
            }
            var allParts = posixSplitPath(pathString);
            if (!allParts || allParts.length !== 4) {
                throw new TypeError("Invalid path '" + pathString + "'");
            }
            allParts[1] = allParts[1] || '';
            allParts[2] = allParts[2] || '';
            allParts[3] = allParts[3] || '';
            return {
                root: allParts[0],
                dir: allParts[0] + allParts[1].slice(0, -1),
                base: allParts[2],
                ext: allParts[3],
                name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
            };
        };
        if (isWindows)
            exports = win32.parse;
        else
            /* posix */
            exports = posix.parse;
        exports.posix = posix.parse;
        exports.win32 = win32.parse;
        return exports;
    }
    exports_98("dew", dew);
    return {
        setters: [
            function (process_js_2_1) {
                process_js_2 = process_js_2_1;
            }
        ],
        execute: function () {
            exports = {}, _dewExec = false;
        }
    };
});
System.register("https://dev.jspm.io/npm:path-parse@1?dew", ["https://dev.jspm.io/npm:path-parse@1.0.6/index.dew", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/process"], function (exports_99, context_99) {
    "use strict";
    var __moduleName = context_99 && context_99.id;
    return {
        setters: [
            function (index_dew_js_5_1) {
                exports_99({
                    "dew": index_dew_js_5_1["dew"]
                });
            },
            function (_19) {
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://dev.jspm.io/npm:resolve@1.17.0/lib/node-modules-paths.dew", ["https://dev.jspm.io/npm:@jspm/core@1/nodelibs/path", "https://dev.jspm.io/npm:path-parse@1?dew"], function (exports_100, context_100) {
    "use strict";
    var path_js_2, npm_path_parse_1_dew_1, exports, _dewExec;
    var __moduleName = context_100 && context_100.id;
    function dew() {
        if (_dewExec)
            return exports;
        _dewExec = true;
        var path = path_js_2.default;
        var parse = path.parse || npm_path_parse_1_dew_1.dew();
        var getNodeModulesDirs = function getNodeModulesDirs(absoluteStart, modules) {
            var prefix = '/';
            if (/^([A-Za-z]:)/.test(absoluteStart)) {
                prefix = '';
            }
            else if (/^\\\\/.test(absoluteStart)) {
                prefix = '\\\\';
            }
            var paths = [absoluteStart];
            var parsed = parse(absoluteStart);
            while (parsed.dir !== paths[paths.length - 1]) {
                paths.push(parsed.dir);
                parsed = parse(parsed.dir);
            }
            return paths.reduce(function (dirs, aPath) {
                return dirs.concat(modules.map(function (moduleDir) {
                    return path.resolve(prefix, aPath, moduleDir);
                }));
            }, []);
        };
        exports = function nodeModulesPaths(start, opts, request) {
            var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ['node_modules'];
            if (opts && typeof opts.paths === 'function') {
                return opts.paths(request, start, function () {
                    return getNodeModulesDirs(start, modules);
                }, opts);
            }
            var dirs = getNodeModulesDirs(start, modules);
            return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
        };
        return exports;
    }
    exports_100("dew", dew);
    return {
        setters: [
            function (path_js_2_1) {
                path_js_2 = path_js_2_1;
            },
            function (npm_path_parse_1_dew_1_1) {
                npm_path_parse_1_dew_1 = npm_path_parse_1_dew_1_1;
            }
        ],
        execute: function () {
            exports = {}, _dewExec = false;
        }
    };
});
System.register("https://dev.jspm.io/npm:resolve@1.17.0/lib/normalize-options.dew", [], function (exports_101, context_101) {
    "use strict";
    var exports, _dewExec;
    var __moduleName = context_101 && context_101.id;
    function dew() {
        if (_dewExec)
            return exports;
        _dewExec = true;
        exports = function (x, opts) {
            /**
             * This file is purposefully a passthrough. It's expected that third-party
             * environments will override it at runtime in order to inject special logic
             * into `resolve` (by manipulating the options). One such example is the PnP
             * code path in Yarn.
             */
            return opts || {};
        };
        return exports;
    }
    exports_101("dew", dew);
    return {
        setters: [],
        execute: function () {
            exports = {}, _dewExec = false;
        }
    };
});
System.register("https://dev.jspm.io/npm:resolve@1.17.0/lib/core.json.dew", [], function (exports_102, context_102) {
    "use strict";
    var exports;
    var __moduleName = context_102 && context_102.id;
    function dew() { return exports; }
    exports_102("dew", dew);
    return {
        setters: [],
        execute: function () {
            exports = {
                "assert": true,
                "async_hooks": ">= 8",
                "buffer_ieee754": "< 0.9.7",
                "buffer": true,
                "child_process": true,
                "cluster": true,
                "console": true,
                "constants": true,
                "crypto": true,
                "_debug_agent": ">= 1 && < 8",
                "_debugger": "< 8",
                "dgram": true,
                "dns": true,
                "domain": true,
                "events": true,
                "freelist": "< 6",
                "fs": true,
                "fs/promises": [">= 10 && < 10.1", ">= 14"],
                "_http_agent": ">= 0.11.1",
                "_http_client": ">= 0.11.1",
                "_http_common": ">= 0.11.1",
                "_http_incoming": ">= 0.11.1",
                "_http_outgoing": ">= 0.11.1",
                "_http_server": ">= 0.11.1",
                "http": true,
                "http2": ">= 8.8",
                "https": true,
                "inspector": ">= 8.0.0",
                "_linklist": "< 8",
                "module": true,
                "net": true,
                "node-inspect/lib/_inspect": ">= 7.6.0 && < 12",
                "node-inspect/lib/internal/inspect_client": ">= 7.6.0 && < 12",
                "node-inspect/lib/internal/inspect_repl": ">= 7.6.0 && < 12",
                "os": true,
                "path": true,
                "perf_hooks": ">= 8.5",
                "process": ">= 1",
                "punycode": true,
                "querystring": true,
                "readline": true,
                "repl": true,
                "smalloc": ">= 0.11.5 && < 3",
                "_stream_duplex": ">= 0.9.4",
                "_stream_transform": ">= 0.9.4",
                "_stream_wrap": ">= 1.4.1",
                "_stream_passthrough": ">= 0.9.4",
                "_stream_readable": ">= 0.9.4",
                "_stream_writable": ">= 0.9.4",
                "stream": true,
                "string_decoder": true,
                "sys": true,
                "timers": true,
                "_tls_common": ">= 0.11.13",
                "_tls_legacy": ">= 0.11.3 && < 10",
                "_tls_wrap": ">= 0.11.3",
                "tls": true,
                "trace_events": ">= 10",
                "tty": true,
                "url": true,
                "util": true,
                "v8/tools/arguments": ">= 10 && < 12",
                "v8/tools/codemap": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
                "v8/tools/consarray": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
                "v8/tools/csvparser": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
                "v8/tools/logreader": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
                "v8/tools/profile_view": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
                "v8/tools/splaytree": [">= 4.4.0 && < 5", ">= 5.2.0 && < 12"],
                "v8": ">= 1",
                "vm": true,
                "wasi": ">= 13.4 && < 13.5",
                "worker_threads": ">= 11.7",
                "zlib": true
            };
        }
    };
});
System.register("https://dev.jspm.io/npm:resolve@1.17.0/lib/core.dew", ["https://dev.jspm.io/npm:resolve@1.17.0/lib/core.json.dew", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/process"], function (exports_103, context_103) {
    "use strict";
    var core_json_dew_js_1, process_js_3, exports, _dewExec;
    var __moduleName = context_103 && context_103.id;
    function dew() {
        if (_dewExec)
            return exports;
        _dewExec = true;
        var process = process_js_3.default;
        var current = process.versions && process.versions.node && process.versions.node.split('.') || [];
        function specifierIncluded(specifier) {
            var parts = specifier.split(' ');
            var op = parts.length > 1 ? parts[0] : '=';
            var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split('.');
            for (var i = 0; i < 3; ++i) {
                var cur = Number(current[i] || 0);
                var ver = Number(versionParts[i] || 0);
                if (cur === ver) {
                    continue; // eslint-disable-line no-restricted-syntax, no-continue
                }
                if (op === '<') {
                    return cur < ver;
                }
                else if (op === '>=') {
                    return cur >= ver;
                }
                else {
                    return false;
                }
            }
            return op === '>=';
        }
        function matchesRange(range) {
            var specifiers = range.split(/ ?&& ?/);
            if (specifiers.length === 0) {
                return false;
            }
            for (var i = 0; i < specifiers.length; ++i) {
                if (!specifierIncluded(specifiers[i])) {
                    return false;
                }
            }
            return true;
        }
        function versionIncluded(specifierValue) {
            if (typeof specifierValue === 'boolean') {
                return specifierValue;
            }
            if (specifierValue && typeof specifierValue === 'object') {
                for (var i = 0; i < specifierValue.length; ++i) {
                    if (matchesRange(specifierValue[i])) {
                        return true;
                    }
                }
                return false;
            }
            return matchesRange(specifierValue);
        }
        var data = core_json_dew_js_1.dew();
        var core = {};
        for (var mod in data) {
            // eslint-disable-line no-restricted-syntax
            if (Object.prototype.hasOwnProperty.call(data, mod)) {
                core[mod] = versionIncluded(data[mod]);
            }
        }
        exports = core;
        return exports;
    }
    exports_103("dew", dew);
    return {
        setters: [
            function (core_json_dew_js_1_1) {
                core_json_dew_js_1 = core_json_dew_js_1_1;
            },
            function (process_js_3_1) {
                process_js_3 = process_js_3_1;
            }
        ],
        execute: function () {
            exports = {}, _dewExec = false;
        }
    };
});
System.register("https://dev.jspm.io/npm:resolve@1.17.0/lib/is-core.dew", ["https://dev.jspm.io/npm:resolve@1.17.0/lib/core.dew"], function (exports_104, context_104) {
    "use strict";
    var core_dew_js_1, exports, _dewExec;
    var __moduleName = context_104 && context_104.id;
    function dew() {
        if (_dewExec)
            return exports;
        _dewExec = true;
        var core = core_dew_js_1.dew();
        exports = function isCore(x) {
            return Object.prototype.hasOwnProperty.call(core, x);
        };
        return exports;
    }
    exports_104("dew", dew);
    return {
        setters: [
            function (core_dew_js_1_1) {
                core_dew_js_1 = core_dew_js_1_1;
            }
        ],
        execute: function () {
            exports = {}, _dewExec = false;
        }
    };
});
System.register("https://dev.jspm.io/npm:resolve@1.17.0/lib/async.dew", ["https://dev.jspm.io/npm:@jspm/core@1/nodelibs/fs", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/path", "https://dev.jspm.io/npm:resolve@1.17.0/lib/caller.dew", "https://dev.jspm.io/npm:resolve@1.17.0/lib/node-modules-paths.dew", "https://dev.jspm.io/npm:resolve@1.17.0/lib/normalize-options.dew", "https://dev.jspm.io/npm:resolve@1.17.0/lib/is-core.dew", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/process"], function (exports_105, context_105) {
    "use strict";
    var fs_js_2, path_js_3, caller_dew_js_1, node_modules_paths_dew_js_1, normalize_options_dew_js_1, is_core_dew_js_1, process_js_4, exports, _dewExec;
    var __moduleName = context_105 && context_105.id;
    function dew() {
        if (_dewExec)
            return exports;
        _dewExec = true;
        var process = process_js_4.default;
        var fs = fs_js_2.default;
        var path = path_js_3.default;
        var caller = caller_dew_js_1.dew();
        var nodeModulesPaths = node_modules_paths_dew_js_1.dew();
        var normalizeOptions = normalize_options_dew_js_1.dew();
        var isCore = is_core_dew_js_1.dew();
        var realpathFS = fs.realpath && typeof fs.realpath.native === 'function' ? fs.realpath.native : fs.realpath;
        var defaultIsFile = function isFile(file, cb) {
            fs.stat(file, function (err, stat) {
                if (!err) {
                    return cb(null, stat.isFile() || stat.isFIFO());
                }
                if (err.code === 'ENOENT' || err.code === 'ENOTDIR')
                    return cb(null, false);
                return cb(err);
            });
        };
        var defaultIsDir = function isDirectory(dir, cb) {
            fs.stat(dir, function (err, stat) {
                if (!err) {
                    return cb(null, stat.isDirectory());
                }
                if (err.code === 'ENOENT' || err.code === 'ENOTDIR')
                    return cb(null, false);
                return cb(err);
            });
        };
        var defaultRealpath = function realpath(x, cb) {
            realpathFS(x, function (realpathErr, realPath) {
                if (realpathErr && realpathErr.code !== 'ENOENT')
                    cb(realpathErr);
                else
                    cb(null, realpathErr ? x : realPath);
            });
        };
        var maybeRealpath = function maybeRealpath(realpath, x, opts, cb) {
            if (opts && opts.preserveSymlinks === false) {
                realpath(x, cb);
            }
            else {
                cb(null, x);
            }
        };
        var getPackageCandidates = function getPackageCandidates(x, start, opts) {
            var dirs = nodeModulesPaths(start, opts, x);
            for (var i = 0; i < dirs.length; i++) {
                dirs[i] = path.join(dirs[i], x);
            }
            return dirs;
        };
        exports = function resolve(x, options, callback) {
            var cb = callback;
            var opts = options;
            if (typeof options === 'function') {
                cb = opts;
                opts = {};
            }
            if (typeof x !== 'string') {
                var err = new TypeError('Path must be a string.');
                return process.nextTick(function () {
                    cb(err);
                });
            }
            opts = normalizeOptions(x, opts);
            var isFile = opts.isFile || defaultIsFile;
            var isDirectory = opts.isDirectory || defaultIsDir;
            var readFile = opts.readFile || fs.readFile;
            var realpath = opts.realpath || defaultRealpath;
            var packageIterator = opts.packageIterator;
            var extensions = opts.extensions || ['.js'];
            var basedir = opts.basedir || path.dirname(caller());
            var parent = opts.filename || basedir;
            opts.paths = opts.paths || []; // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
            var absoluteStart = path.resolve(basedir);
            maybeRealpath(realpath, absoluteStart, opts, function (err, realStart) {
                if (err)
                    cb(err);
                else
                    init(realStart);
            });
            var res;
            function init(basedir) {
                if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
                    res = path.resolve(basedir, x);
                    if (x === '.' || x === '..' || x.slice(-1) === '/')
                        res += '/';
                    if (/\/$/.test(x) && res === basedir) {
                        loadAsDirectory(res, opts.package, onfile);
                    }
                    else
                        loadAsFile(res, opts.package, onfile);
                }
                else if (isCore(x)) {
                    return cb(null, x);
                }
                else
                    loadNodeModules(x, basedir, function (err, n, pkg) {
                        if (err)
                            cb(err);
                        else if (n) {
                            return maybeRealpath(realpath, n, opts, function (err, realN) {
                                if (err) {
                                    cb(err);
                                }
                                else {
                                    cb(null, realN, pkg);
                                }
                            });
                        }
                        else {
                            var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                            moduleError.code = 'MODULE_NOT_FOUND';
                            cb(moduleError);
                        }
                    });
            }
            function onfile(err, m, pkg) {
                if (err)
                    cb(err);
                else if (m)
                    cb(null, m, pkg);
                else
                    loadAsDirectory(res, function (err, d, pkg) {
                        if (err)
                            cb(err);
                        else if (d) {
                            maybeRealpath(realpath, d, opts, function (err, realD) {
                                if (err) {
                                    cb(err);
                                }
                                else {
                                    cb(null, realD, pkg);
                                }
                            });
                        }
                        else {
                            var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
                            moduleError.code = 'MODULE_NOT_FOUND';
                            cb(moduleError);
                        }
                    });
            }
            function loadAsFile(x, thePackage, callback) {
                var loadAsFilePackage = thePackage;
                var cb = callback;
                if (typeof loadAsFilePackage === 'function') {
                    cb = loadAsFilePackage;
                    loadAsFilePackage = undefined;
                }
                var exts = [''].concat(extensions);
                load(exts, x, loadAsFilePackage);
                function load(exts, x, loadPackage) {
                    if (exts.length === 0)
                        return cb(null, undefined, loadPackage);
                    var file = x + exts[0];
                    var pkg = loadPackage;
                    if (pkg)
                        onpkg(null, pkg);
                    else
                        loadpkg(path.dirname(file), onpkg);
                    function onpkg(err, pkg_, dir) {
                        pkg = pkg_;
                        if (err)
                            return cb(err);
                        if (dir && pkg && opts.pathFilter) {
                            var rfile = path.relative(dir, file);
                            var rel = rfile.slice(0, rfile.length - exts[0].length);
                            var r = opts.pathFilter(pkg, x, rel);
                            if (r)
                                return load([''].concat(extensions.slice()), path.resolve(dir, r), pkg);
                        }
                        isFile(file, onex);
                    }
                    function onex(err, ex) {
                        if (err)
                            return cb(err);
                        if (ex)
                            return cb(null, file, pkg);
                        load(exts.slice(1), x, pkg);
                    }
                }
            }
            function loadpkg(dir, cb) {
                if (dir === '' || dir === '/')
                    return cb(null);
                if (process.platform === 'win32' && /^\w:[/\\]*$/.test(dir)) {
                    return cb(null);
                }
                if (/[/\\]node_modules[/\\]*$/.test(dir))
                    return cb(null);
                maybeRealpath(realpath, dir, opts, function (unwrapErr, pkgdir) {
                    if (unwrapErr)
                        return loadpkg(path.dirname(dir), cb);
                    var pkgfile = path.join(pkgdir, 'package.json');
                    isFile(pkgfile, function (err, ex) {
                        // on err, ex is false
                        if (!ex)
                            return loadpkg(path.dirname(dir), cb);
                        readFile(pkgfile, function (err, body) {
                            if (err)
                                cb(err);
                            try {
                                var pkg = JSON.parse(body);
                            }
                            catch (jsonErr) { }
                            if (pkg && opts.packageFilter) {
                                pkg = opts.packageFilter(pkg, pkgfile);
                            }
                            cb(null, pkg, dir);
                        });
                    });
                });
            }
            function loadAsDirectory(x, loadAsDirectoryPackage, callback) {
                var cb = callback;
                var fpkg = loadAsDirectoryPackage;
                if (typeof fpkg === 'function') {
                    cb = fpkg;
                    fpkg = opts.package;
                }
                maybeRealpath(realpath, x, opts, function (unwrapErr, pkgdir) {
                    if (unwrapErr)
                        return cb(unwrapErr);
                    var pkgfile = path.join(pkgdir, 'package.json');
                    isFile(pkgfile, function (err, ex) {
                        if (err)
                            return cb(err);
                        if (!ex)
                            return loadAsFile(path.join(x, 'index'), fpkg, cb);
                        readFile(pkgfile, function (err, body) {
                            if (err)
                                return cb(err);
                            try {
                                var pkg = JSON.parse(body);
                            }
                            catch (jsonErr) { }
                            if (pkg && opts.packageFilter) {
                                pkg = opts.packageFilter(pkg, pkgfile);
                            }
                            if (pkg && pkg.main) {
                                if (typeof pkg.main !== 'string') {
                                    var mainError = new TypeError('package ' + pkg.name + ' `main` must be a string');
                                    mainError.code = 'INVALID_PACKAGE_MAIN';
                                    return cb(mainError);
                                }
                                if (pkg.main === '.' || pkg.main === './') {
                                    pkg.main = 'index';
                                }
                                loadAsFile(path.resolve(x, pkg.main), pkg, function (err, m, pkg) {
                                    if (err)
                                        return cb(err);
                                    if (m)
                                        return cb(null, m, pkg);
                                    if (!pkg)
                                        return loadAsFile(path.join(x, 'index'), pkg, cb);
                                    var dir = path.resolve(x, pkg.main);
                                    loadAsDirectory(dir, pkg, function (err, n, pkg) {
                                        if (err)
                                            return cb(err);
                                        if (n)
                                            return cb(null, n, pkg);
                                        loadAsFile(path.join(x, 'index'), pkg, cb);
                                    });
                                });
                                return;
                            }
                            loadAsFile(path.join(x, '/index'), pkg, cb);
                        });
                    });
                });
            }
            function processDirs(cb, dirs) {
                if (dirs.length === 0)
                    return cb(null, undefined);
                var dir = dirs[0];
                isDirectory(path.dirname(dir), isdir);
                function isdir(err, isdir) {
                    if (err)
                        return cb(err);
                    if (!isdir)
                        return processDirs(cb, dirs.slice(1));
                    loadAsFile(dir, opts.package, onfile);
                }
                function onfile(err, m, pkg) {
                    if (err)
                        return cb(err);
                    if (m)
                        return cb(null, m, pkg);
                    loadAsDirectory(dir, opts.package, ondir);
                }
                function ondir(err, n, pkg) {
                    if (err)
                        return cb(err);
                    if (n)
                        return cb(null, n, pkg);
                    processDirs(cb, dirs.slice(1));
                }
            }
            function loadNodeModules(x, start, cb) {
                var thunk = function () {
                    return getPackageCandidates(x, start, opts);
                };
                processDirs(cb, packageIterator ? packageIterator(x, start, thunk, opts) : thunk());
            }
        };
        return exports;
    }
    exports_105("dew", dew);
    return {
        setters: [
            function (fs_js_2_1) {
                fs_js_2 = fs_js_2_1;
            },
            function (path_js_3_1) {
                path_js_3 = path_js_3_1;
            },
            function (caller_dew_js_1_1) {
                caller_dew_js_1 = caller_dew_js_1_1;
            },
            function (node_modules_paths_dew_js_1_1) {
                node_modules_paths_dew_js_1 = node_modules_paths_dew_js_1_1;
            },
            function (normalize_options_dew_js_1_1) {
                normalize_options_dew_js_1 = normalize_options_dew_js_1_1;
            },
            function (is_core_dew_js_1_1) {
                is_core_dew_js_1 = is_core_dew_js_1_1;
            },
            function (process_js_4_1) {
                process_js_4 = process_js_4_1;
            }
        ],
        execute: function () {
            exports = {}, _dewExec = false;
        }
    };
});
System.register("https://dev.jspm.io/npm:resolve@1.17.0/lib/sync.dew", ["https://dev.jspm.io/npm:resolve@1.17.0/lib/is-core.dew", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/fs", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/path", "https://dev.jspm.io/npm:resolve@1.17.0/lib/caller.dew", "https://dev.jspm.io/npm:resolve@1.17.0/lib/node-modules-paths.dew", "https://dev.jspm.io/npm:resolve@1.17.0/lib/normalize-options.dew", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/process"], function (exports_106, context_106) {
    "use strict";
    var is_core_dew_js_2, fs_js_3, path_js_4, caller_dew_js_2, node_modules_paths_dew_js_2, normalize_options_dew_js_2, process_js_5, exports, _dewExec;
    var __moduleName = context_106 && context_106.id;
    function dew() {
        if (_dewExec)
            return exports;
        _dewExec = true;
        var process = process_js_5.default;
        var isCore = is_core_dew_js_2.dew();
        var fs = fs_js_3.default;
        var path = path_js_4.default;
        var caller = caller_dew_js_2.dew();
        var nodeModulesPaths = node_modules_paths_dew_js_2.dew();
        var normalizeOptions = normalize_options_dew_js_2.dew();
        var realpathFS = fs.realpathSync && typeof fs.realpathSync.native === 'function' ? fs.realpathSync.native : fs.realpathSync;
        var defaultIsFile = function isFile(file) {
            try {
                var stat = fs.statSync(file);
            }
            catch (e) {
                if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR'))
                    return false;
                throw e;
            }
            return stat.isFile() || stat.isFIFO();
        };
        var defaultIsDir = function isDirectory(dir) {
            try {
                var stat = fs.statSync(dir);
            }
            catch (e) {
                if (e && (e.code === 'ENOENT' || e.code === 'ENOTDIR'))
                    return false;
                throw e;
            }
            return stat.isDirectory();
        };
        var defaultRealpathSync = function realpathSync(x) {
            try {
                return realpathFS(x);
            }
            catch (realpathErr) {
                if (realpathErr.code !== 'ENOENT') {
                    throw realpathErr;
                }
            }
            return x;
        };
        var maybeRealpathSync = function maybeRealpathSync(realpathSync, x, opts) {
            if (opts && opts.preserveSymlinks === false) {
                return realpathSync(x);
            }
            return x;
        };
        var getPackageCandidates = function getPackageCandidates(x, start, opts) {
            var dirs = nodeModulesPaths(start, opts, x);
            for (var i = 0; i < dirs.length; i++) {
                dirs[i] = path.join(dirs[i], x);
            }
            return dirs;
        };
        exports = function resolveSync(x, options) {
            if (typeof x !== 'string') {
                throw new TypeError('Path must be a string.');
            }
            var opts = normalizeOptions(x, options);
            var isFile = opts.isFile || defaultIsFile;
            var readFileSync = opts.readFileSync || fs.readFileSync;
            var isDirectory = opts.isDirectory || defaultIsDir;
            var realpathSync = opts.realpathSync || defaultRealpathSync;
            var packageIterator = opts.packageIterator;
            var extensions = opts.extensions || ['.js'];
            var basedir = opts.basedir || path.dirname(caller());
            var parent = opts.filename || basedir;
            opts.paths = opts.paths || []; // ensure that `basedir` is an absolute path at this point, resolving against the process' current working directory
            var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);
            if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
                var res = path.resolve(absoluteStart, x);
                if (x === '.' || x === '..' || x.slice(-1) === '/')
                    res += '/';
                var m = loadAsFileSync(res) || loadAsDirectorySync(res);
                if (m)
                    return maybeRealpathSync(realpathSync, m, opts);
            }
            else if (isCore(x)) {
                return x;
            }
            else {
                var n = loadNodeModulesSync(x, absoluteStart);
                if (n)
                    return maybeRealpathSync(realpathSync, n, opts);
            }
            var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
            err.code = 'MODULE_NOT_FOUND';
            throw err;
            function loadAsFileSync(x) {
                var pkg = loadpkg(path.dirname(x));
                if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
                    var rfile = path.relative(pkg.dir, x);
                    var r = opts.pathFilter(pkg.pkg, x, rfile);
                    if (r) {
                        x = path.resolve(pkg.dir, r); // eslint-disable-line no-param-reassign
                    }
                }
                if (isFile(x)) {
                    return x;
                }
                for (var i = 0; i < extensions.length; i++) {
                    var file = x + extensions[i];
                    if (isFile(file)) {
                        return file;
                    }
                }
            }
            function loadpkg(dir) {
                if (dir === '' || dir === '/')
                    return;
                if (process.platform === 'win32' && /^\w:[/\\]*$/.test(dir)) {
                    return;
                }
                if (/[/\\]node_modules[/\\]*$/.test(dir))
                    return;
                var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), 'package.json');
                if (!isFile(pkgfile)) {
                    return loadpkg(path.dirname(dir));
                }
                var body = readFileSync(pkgfile);
                try {
                    var pkg = JSON.parse(body);
                }
                catch (jsonErr) { }
                if (pkg && opts.packageFilter) {
                    // v2 will pass pkgfile
                    pkg = opts.packageFilter(pkg, 
                    /*pkgfile,*/
                    dir); // eslint-disable-line spaced-comment
                }
                return {
                    pkg: pkg,
                    dir: dir
                };
            }
            function loadAsDirectorySync(x) {
                var pkgfile = path.join(maybeRealpathSync(realpathSync, x, opts), '/package.json');
                if (isFile(pkgfile)) {
                    try {
                        var body = readFileSync(pkgfile, 'UTF8');
                        var pkg = JSON.parse(body);
                    }
                    catch (e) { }
                    if (pkg && opts.packageFilter) {
                        // v2 will pass pkgfile
                        pkg = opts.packageFilter(pkg, 
                        /*pkgfile,*/
                        x); // eslint-disable-line spaced-comment
                    }
                    if (pkg && pkg.main) {
                        if (typeof pkg.main !== 'string') {
                            var mainError = new TypeError('package ' + pkg.name + ' `main` must be a string');
                            mainError.code = 'INVALID_PACKAGE_MAIN';
                            throw mainError;
                        }
                        if (pkg.main === '.' || pkg.main === './') {
                            pkg.main = 'index';
                        }
                        try {
                            var m = loadAsFileSync(path.resolve(x, pkg.main));
                            if (m)
                                return m;
                            var n = loadAsDirectorySync(path.resolve(x, pkg.main));
                            if (n)
                                return n;
                        }
                        catch (e) { }
                    }
                }
                return loadAsFileSync(path.join(x, '/index'));
            }
            function loadNodeModulesSync(x, start) {
                var thunk = function () {
                    return getPackageCandidates(x, start, opts);
                };
                var dirs = packageIterator ? packageIterator(x, start, thunk, opts) : thunk();
                for (var i = 0; i < dirs.length; i++) {
                    var dir = dirs[i];
                    if (isDirectory(path.dirname(dir))) {
                        var m = loadAsFileSync(dir);
                        if (m)
                            return m;
                        var n = loadAsDirectorySync(dir);
                        if (n)
                            return n;
                    }
                }
            }
        };
        return exports;
    }
    exports_106("dew", dew);
    return {
        setters: [
            function (is_core_dew_js_2_1) {
                is_core_dew_js_2 = is_core_dew_js_2_1;
            },
            function (fs_js_3_1) {
                fs_js_3 = fs_js_3_1;
            },
            function (path_js_4_1) {
                path_js_4 = path_js_4_1;
            },
            function (caller_dew_js_2_1) {
                caller_dew_js_2 = caller_dew_js_2_1;
            },
            function (node_modules_paths_dew_js_2_1) {
                node_modules_paths_dew_js_2 = node_modules_paths_dew_js_2_1;
            },
            function (normalize_options_dew_js_2_1) {
                normalize_options_dew_js_2 = normalize_options_dew_js_2_1;
            },
            function (process_js_5_1) {
                process_js_5 = process_js_5_1;
            }
        ],
        execute: function () {
            exports = {}, _dewExec = false;
        }
    };
});
System.register("https://dev.jspm.io/npm:resolve@1.17.0/index.dew", ["https://dev.jspm.io/npm:resolve@1.17.0/lib/async.dew", "https://dev.jspm.io/npm:resolve@1.17.0/lib/core.dew", "https://dev.jspm.io/npm:resolve@1.17.0/lib/is-core.dew", "https://dev.jspm.io/npm:resolve@1.17.0/lib/sync.dew"], function (exports_107, context_107) {
    "use strict";
    var async_dew_js_1, core_dew_js_2, is_core_dew_js_3, sync_dew_js_1, exports, _dewExec;
    var __moduleName = context_107 && context_107.id;
    function dew() {
        if (_dewExec)
            return exports;
        _dewExec = true;
        var async = async_dew_js_1.dew();
        async.core = core_dew_js_2.dew();
        async.isCore = is_core_dew_js_3.dew();
        async.sync = sync_dew_js_1.dew();
        exports = async;
        return exports;
    }
    exports_107("dew", dew);
    return {
        setters: [
            function (async_dew_js_1_1) {
                async_dew_js_1 = async_dew_js_1_1;
            },
            function (core_dew_js_2_1) {
                core_dew_js_2 = core_dew_js_2_1;
            },
            function (is_core_dew_js_3_1) {
                is_core_dew_js_3 = is_core_dew_js_3_1;
            },
            function (sync_dew_js_1_1) {
                sync_dew_js_1 = sync_dew_js_1_1;
            }
        ],
        execute: function () {
            exports = {}, _dewExec = false;
        }
    };
});
System.register("https://dev.jspm.io/npm:resolve@1?dew", ["https://dev.jspm.io/npm:resolve@1.17.0/index.dew", "https://dev.jspm.io/npm:resolve@1.17.0/lib/async.dew", "https://dev.jspm.io/npm:resolve@1.17.0/lib/core.dew", "https://dev.jspm.io/npm:resolve@1.17.0/lib/is-core.dew", "https://dev.jspm.io/npm:resolve@1.17.0/lib/sync.dew", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/fs", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/path", "https://dev.jspm.io/npm:resolve@1.17.0/lib/caller.dew", "https://dev.jspm.io/npm:resolve@1.17.0/lib/node-modules-paths.dew", "https://dev.jspm.io/npm:resolve@1.17.0/lib/normalize-options.dew", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/process", "https://dev.jspm.io/npm:path-parse@1?dew", "https://dev.jspm.io/npm:resolve@1.17.0/lib/core.json.dew"], function (exports_108, context_108) {
    "use strict";
    var __moduleName = context_108 && context_108.id;
    return {
        setters: [
            function (index_dew_js_6_1) {
                exports_108({
                    "dew": index_dew_js_6_1["dew"]
                });
            },
            function (_20) {
            },
            function (_21) {
            },
            function (_22) {
            },
            function (_23) {
            },
            function (_24) {
            },
            function (_25) {
            },
            function (_26) {
            },
            function (_27) {
            },
            function (_28) {
            },
            function (_29) {
            },
            function (_30) {
            },
            function (_31) {
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://dev.jspm.io/npm:@jspm/core@1/nodelibs/@empty", ["https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/@empty"], function (exports_109, context_109) {
    "use strict";
    var __moduleName = context_109 && context_109.id;
    return {
        setters: [
            function (_empty_js_2_1) {
                exports_109({
                    "default": _empty_js_2_1["default"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://dev.jspm.io/npm:source-map@0.5.6/lib/base64.dew", [], function (exports_110, context_110) {
    "use strict";
    var exports, _dewExec;
    var __moduleName = context_110 && context_110.id;
    function dew() {
        if (_dewExec)
            return exports;
        _dewExec = true;
        /* -*- Mode: js; js-indent-level: 2; -*- */
        /*
         * Copyright 2011 Mozilla Foundation and contributors
         * Licensed under the New BSD license. See LICENSE or:
         * http://opensource.org/licenses/BSD-3-Clause
         */
        var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
        /**
         * Encode an integer in the range of 0 to 63 to a single base 64 digit.
         */
        exports.encode = function (number) {
            if (0 <= number && number < intToCharMap.length) {
                return intToCharMap[number];
            }
            throw new TypeError("Must be between 0 and 63: " + number);
        };
        /**
         * Decode a single base 64 character code digit to an integer. Returns -1 on
         * failure.
         */
        exports.decode = function (charCode) {
            var bigA = 65; // 'A'
            var bigZ = 90; // 'Z'
            var littleA = 97; // 'a'
            var littleZ = 122; // 'z'
            var zero = 48; // '0'
            var nine = 57; // '9'
            var plus = 43; // '+'
            var slash = 47; // '/'
            var littleOffset = 26;
            var numberOffset = 52; // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
            if (bigA <= charCode && charCode <= bigZ) {
                return charCode - bigA;
            } // 26 - 51: abcdefghijklmnopqrstuvwxyz
            if (littleA <= charCode && charCode <= littleZ) {
                return charCode - littleA + littleOffset;
            } // 52 - 61: 0123456789
            if (zero <= charCode && charCode <= nine) {
                return charCode - zero + numberOffset;
            } // 62: +
            if (charCode == plus) {
                return 62;
            } // 63: /
            if (charCode == slash) {
                return 63;
            } // Invalid base64 digit.
            return -1;
        };
        return exports;
    }
    exports_110("dew", dew);
    return {
        setters: [],
        execute: function () {
            exports = {}, _dewExec = false;
        }
    };
});
System.register("https://dev.jspm.io/npm:source-map@0.5.6/lib/base64-vlq.dew", ["https://dev.jspm.io/npm:source-map@0.5.6/lib/base64.dew"], function (exports_111, context_111) {
    "use strict";
    var base64_dew_js_1, exports, _dewExec;
    var __moduleName = context_111 && context_111.id;
    function dew() {
        if (_dewExec)
            return exports;
        _dewExec = true;
        /* -*- Mode: js; js-indent-level: 2; -*- */
        /*
         * Copyright 2011 Mozilla Foundation and contributors
         * Licensed under the New BSD license. See LICENSE or:
         * http://opensource.org/licenses/BSD-3-Clause
         *
         * Based on the Base 64 VLQ implementation in Closure Compiler:
         * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
         *
         * Copyright 2011 The Closure Compiler Authors. All rights reserved.
         * Redistribution and use in source and binary forms, with or without
         * modification, are permitted provided that the following conditions are
         * met:
         *
         *  * Redistributions of source code must retain the above copyright
         *    notice, this list of conditions and the following disclaimer.
         *  * Redistributions in binary form must reproduce the above
         *    copyright notice, this list of conditions and the following
         *    disclaimer in the documentation and/or other materials provided
         *    with the distribution.
         *  * Neither the name of Google Inc. nor the names of its
         *    contributors may be used to endorse or promote products derived
         *    from this software without specific prior written permission.
         *
         * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
         * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
         * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
         * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
         * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
         * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
         * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
         * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
         * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
         * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
         * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
         */
        var base64 = base64_dew_js_1.dew(); // A single base 64 digit can contain 6 bits of data. For the base 64 variable
        // length quantities we use in the source map spec, the first bit is the sign,
        // the next four bits are the actual value, and the 6th bit is the
        // continuation bit. The continuation bit tells us whether there are more
        // digits in this value following this digit.
        //
        //   Continuation
        //   |    Sign
        //   |    |
        //   V    V
        //   101011
        var VLQ_BASE_SHIFT = 5; // binary: 100000
        var VLQ_BASE = 1 << VLQ_BASE_SHIFT; // binary: 011111
        var VLQ_BASE_MASK = VLQ_BASE - 1; // binary: 100000
        var VLQ_CONTINUATION_BIT = VLQ_BASE;
        /**
         * Converts from a two-complement value to a value where the sign bit is
         * placed in the least significant bit.  For example, as decimals:
         *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
         *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
         */
        function toVLQSigned(aValue) {
            return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
        }
        /**
         * Converts to a two-complement value from a value where the sign bit is
         * placed in the least significant bit.  For example, as decimals:
         *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
         *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
         */
        function fromVLQSigned(aValue) {
            var isNegative = (aValue & 1) === 1;
            var shifted = aValue >> 1;
            return isNegative ? -shifted : shifted;
        }
        /**
         * Returns the base 64 VLQ encoded value.
         */
        exports.encode = function base64VLQ_encode(aValue) {
            var encoded = "";
            var digit;
            var vlq = toVLQSigned(aValue);
            do {
                digit = vlq & VLQ_BASE_MASK;
                vlq >>>= VLQ_BASE_SHIFT;
                if (vlq > 0) {
                    // There are still more digits in this value, so we must make sure the
                    // continuation bit is marked.
                    digit |= VLQ_CONTINUATION_BIT;
                }
                encoded += base64.encode(digit);
            } while (vlq > 0);
            return encoded;
        };
        /**
         * Decodes the next base 64 VLQ value from the given string and returns the
         * value and the rest of the string via the out parameter.
         */
        exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
            var strLen = aStr.length;
            var result = 0;
            var shift = 0;
            var continuation, digit;
            do {
                if (aIndex >= strLen) {
                    throw new Error("Expected more digits in base 64 VLQ value.");
                }
                digit = base64.decode(aStr.charCodeAt(aIndex++));
                if (digit === -1) {
                    throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
                }
                continuation = !!(digit & VLQ_CONTINUATION_BIT);
                digit &= VLQ_BASE_MASK;
                result = result + (digit << shift);
                shift += VLQ_BASE_SHIFT;
            } while (continuation);
            aOutParam.value = fromVLQSigned(result);
            aOutParam.rest = aIndex;
        };
        return exports;
    }
    exports_111("dew", dew);
    return {
        setters: [
            function (base64_dew_js_1_1) {
                base64_dew_js_1 = base64_dew_js_1_1;
            }
        ],
        execute: function () {
            exports = {}, _dewExec = false;
        }
    };
});
System.register("https://dev.jspm.io/npm:source-map@0.5.6/lib/util.dew", [], function (exports_112, context_112) {
    "use strict";
    var exports, _dewExec;
    var __moduleName = context_112 && context_112.id;
    function dew() {
        if (_dewExec)
            return exports;
        _dewExec = true;
        /* -*- Mode: js; js-indent-level: 2; -*- */
        /*
         * Copyright 2011 Mozilla Foundation and contributors
         * Licensed under the New BSD license. See LICENSE or:
         * http://opensource.org/licenses/BSD-3-Clause
         */
        /**
         * This is a helper function for getting values from parameter/options
         * objects.
         *
         * @param args The object we are extracting values from
         * @param name The name of the property we are getting.
         * @param defaultValue An optional value to return if the property is missing
         * from the object. If this is not specified and the property is missing, an
         * error will be thrown.
         */
        function getArg(aArgs, aName, aDefaultValue) {
            if (aName in aArgs) {
                return aArgs[aName];
            }
            else if (arguments.length === 3) {
                return aDefaultValue;
            }
            else {
                throw new Error('"' + aName + '" is a required argument.');
            }
        }
        exports.getArg = getArg;
        var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
        var dataUrlRegexp = /^data:.+\,.+$/;
        function urlParse(aUrl) {
            var match = aUrl.match(urlRegexp);
            if (!match) {
                return null;
            }
            return {
                scheme: match[1],
                auth: match[2],
                host: match[3],
                port: match[4],
                path: match[5]
            };
        }
        exports.urlParse = urlParse;
        function urlGenerate(aParsedUrl) {
            var url = '';
            if (aParsedUrl.scheme) {
                url += aParsedUrl.scheme + ':';
            }
            url += '//';
            if (aParsedUrl.auth) {
                url += aParsedUrl.auth + '@';
            }
            if (aParsedUrl.host) {
                url += aParsedUrl.host;
            }
            if (aParsedUrl.port) {
                url += ":" + aParsedUrl.port;
            }
            if (aParsedUrl.path) {
                url += aParsedUrl.path;
            }
            return url;
        }
        exports.urlGenerate = urlGenerate;
        /**
         * Normalizes a path, or the path portion of a URL:
         *
         * - Replaces consecutive slashes with one slash.
         * - Removes unnecessary '.' parts.
         * - Removes unnecessary '<dir>/..' parts.
         *
         * Based on code in the Node.js 'path' core module.
         *
         * @param aPath The path or url to normalize.
         */
        function normalize(aPath) {
            var path = aPath;
            var url = urlParse(aPath);
            if (url) {
                if (!url.path) {
                    return aPath;
                }
                path = url.path;
            }
            var isAbsolute = exports.isAbsolute(path);
            var parts = path.split(/\/+/);
            for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
                part = parts[i];
                if (part === '.') {
                    parts.splice(i, 1);
                }
                else if (part === '..') {
                    up++;
                }
                else if (up > 0) {
                    if (part === '') {
                        // The first part is blank if the path is absolute. Trying to go
                        // above the root is a no-op. Therefore we can remove all '..' parts
                        // directly after the root.
                        parts.splice(i + 1, up);
                        up = 0;
                    }
                    else {
                        parts.splice(i, 2);
                        up--;
                    }
                }
            }
            path = parts.join('/');
            if (path === '') {
                path = isAbsolute ? '/' : '.';
            }
            if (url) {
                url.path = path;
                return urlGenerate(url);
            }
            return path;
        }
        exports.normalize = normalize;
        /**
         * Joins two paths/URLs.
         *
         * @param aRoot The root path or URL.
         * @param aPath The path or URL to be joined with the root.
         *
         * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
         *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
         *   first.
         * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
         *   is updated with the result and aRoot is returned. Otherwise the result
         *   is returned.
         *   - If aPath is absolute, the result is aPath.
         *   - Otherwise the two paths are joined with a slash.
         * - Joining for example 'http://' and 'www.example.com' is also supported.
         */
        function join(aRoot, aPath) {
            if (aRoot === "") {
                aRoot = ".";
            }
            if (aPath === "") {
                aPath = ".";
            }
            var aPathUrl = urlParse(aPath);
            var aRootUrl = urlParse(aRoot);
            if (aRootUrl) {
                aRoot = aRootUrl.path || '/';
            } // `join(foo, '//www.example.org')`
            if (aPathUrl && !aPathUrl.scheme) {
                if (aRootUrl) {
                    aPathUrl.scheme = aRootUrl.scheme;
                }
                return urlGenerate(aPathUrl);
            }
            if (aPathUrl || aPath.match(dataUrlRegexp)) {
                return aPath;
            } // `join('http://', 'www.example.com')`
            if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
                aRootUrl.host = aPath;
                return urlGenerate(aRootUrl);
            }
            var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
            if (aRootUrl) {
                aRootUrl.path = joined;
                return urlGenerate(aRootUrl);
            }
            return joined;
        }
        exports.join = join;
        exports.isAbsolute = function (aPath) {
            return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
        };
        /**
         * Make a path relative to a URL or another path.
         *
         * @param aRoot The root path or URL.
         * @param aPath The path or URL to be made relative to aRoot.
         */
        function relative(aRoot, aPath) {
            if (aRoot === "") {
                aRoot = ".";
            }
            aRoot = aRoot.replace(/\/$/, ''); // It is possible for the path to be above the root. In this case, simply
            // checking whether the root is a prefix of the path won't work. Instead, we
            // need to remove components from the root one by one, until either we find
            // a prefix that fits, or we run out of components to remove.
            var level = 0;
            while (aPath.indexOf(aRoot + '/') !== 0) {
                var index = aRoot.lastIndexOf("/");
                if (index < 0) {
                    return aPath;
                } // If the only part of the root that is left is the scheme (i.e. http://,
                // file:///, etc.), one or more slashes (/), or simply nothing at all, we
                // have exhausted all components, so the path is not relative to the root.
                aRoot = aRoot.slice(0, index);
                if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
                    return aPath;
                }
                ++level;
            } // Make sure we add a "../" for each component we removed from the root.
            return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
        }
        exports.relative = relative;
        var supportsNullProto = function () {
            var obj = Object.create(null);
            return !('__proto__' in obj);
        }();
        function identity(s) {
            return s;
        }
        /**
         * Because behavior goes wacky when you set `__proto__` on objects, we
         * have to prefix all the strings in our set with an arbitrary character.
         *
         * See https://github.com/mozilla/source-map/pull/31 and
         * https://github.com/mozilla/source-map/issues/30
         *
         * @param String aStr
         */
        function toSetString(aStr) {
            if (isProtoString(aStr)) {
                return '$' + aStr;
            }
            return aStr;
        }
        exports.toSetString = supportsNullProto ? identity : toSetString;
        function fromSetString(aStr) {
            if (isProtoString(aStr)) {
                return aStr.slice(1);
            }
            return aStr;
        }
        exports.fromSetString = supportsNullProto ? identity : fromSetString;
        function isProtoString(s) {
            if (!s) {
                return false;
            }
            var length = s.length;
            if (length < 9
            /* "__proto__".length */
            ) {
                return false;
            }
            if (s.charCodeAt(length - 1) !== 95
                /* '_' */
                || s.charCodeAt(length - 2) !== 95
                /* '_' */
                || s.charCodeAt(length - 3) !== 111
                /* 'o' */
                || s.charCodeAt(length - 4) !== 116
                /* 't' */
                || s.charCodeAt(length - 5) !== 111
                /* 'o' */
                || s.charCodeAt(length - 6) !== 114
                /* 'r' */
                || s.charCodeAt(length - 7) !== 112
                /* 'p' */
                || s.charCodeAt(length - 8) !== 95
                /* '_' */
                || s.charCodeAt(length - 9) !== 95
            /* '_' */
            ) {
                return false;
            }
            for (var i = length - 10; i >= 0; i--) {
                if (s.charCodeAt(i) !== 36
                /* '$' */
                ) {
                    return false;
                }
            }
            return true;
        }
        /**
         * Comparator between two mappings where the original positions are compared.
         *
         * Optionally pass in `true` as `onlyCompareGenerated` to consider two
         * mappings with the same original source/line/column, but different generated
         * line and column the same. Useful when searching for a mapping with a
         * stubbed out mapping.
         */
        function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
            var cmp = mappingA.source - mappingB.source;
            if (cmp !== 0) {
                return cmp;
            }
            cmp = mappingA.originalLine - mappingB.originalLine;
            if (cmp !== 0) {
                return cmp;
            }
            cmp = mappingA.originalColumn - mappingB.originalColumn;
            if (cmp !== 0 || onlyCompareOriginal) {
                return cmp;
            }
            cmp = mappingA.generatedColumn - mappingB.generatedColumn;
            if (cmp !== 0) {
                return cmp;
            }
            cmp = mappingA.generatedLine - mappingB.generatedLine;
            if (cmp !== 0) {
                return cmp;
            }
            return mappingA.name - mappingB.name;
        }
        exports.compareByOriginalPositions = compareByOriginalPositions;
        /**
         * Comparator between two mappings with deflated source and name indices where
         * the generated positions are compared.
         *
         * Optionally pass in `true` as `onlyCompareGenerated` to consider two
         * mappings with the same generated line and column, but different
         * source/name/original line and column the same. Useful when searching for a
         * mapping with a stubbed out mapping.
         */
        function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
            var cmp = mappingA.generatedLine - mappingB.generatedLine;
            if (cmp !== 0) {
                return cmp;
            }
            cmp = mappingA.generatedColumn - mappingB.generatedColumn;
            if (cmp !== 0 || onlyCompareGenerated) {
                return cmp;
            }
            cmp = mappingA.source - mappingB.source;
            if (cmp !== 0) {
                return cmp;
            }
            cmp = mappingA.originalLine - mappingB.originalLine;
            if (cmp !== 0) {
                return cmp;
            }
            cmp = mappingA.originalColumn - mappingB.originalColumn;
            if (cmp !== 0) {
                return cmp;
            }
            return mappingA.name - mappingB.name;
        }
        exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
        function strcmp(aStr1, aStr2) {
            if (aStr1 === aStr2) {
                return 0;
            }
            if (aStr1 > aStr2) {
                return 1;
            }
            return -1;
        }
        /**
         * Comparator between two mappings with inflated source and name strings where
         * the generated positions are compared.
         */
        function compareByGeneratedPositionsInflated(mappingA, mappingB) {
            var cmp = mappingA.generatedLine - mappingB.generatedLine;
            if (cmp !== 0) {
                return cmp;
            }
            cmp = mappingA.generatedColumn - mappingB.generatedColumn;
            if (cmp !== 0) {
                return cmp;
            }
            cmp = strcmp(mappingA.source, mappingB.source);
            if (cmp !== 0) {
                return cmp;
            }
            cmp = mappingA.originalLine - mappingB.originalLine;
            if (cmp !== 0) {
                return cmp;
            }
            cmp = mappingA.originalColumn - mappingB.originalColumn;
            if (cmp !== 0) {
                return cmp;
            }
            return strcmp(mappingA.name, mappingB.name);
        }
        exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
        return exports;
    }
    exports_112("dew", dew);
    return {
        setters: [],
        execute: function () {
            exports = {}, _dewExec = false;
        }
    };
});
System.register("https://dev.jspm.io/npm:source-map@0.5.6/lib/array-set.dew", ["https://dev.jspm.io/npm:source-map@0.5.6/lib/util.dew"], function (exports_113, context_113) {
    "use strict";
    var util_dew_js_1, exports, _dewExec, _global;
    var __moduleName = context_113 && context_113.id;
    function dew() {
        if (_dewExec)
            return exports;
        _dewExec = true;
        /* -*- Mode: js; js-indent-level: 2; -*- */
        /*
         * Copyright 2011 Mozilla Foundation and contributors
         * Licensed under the New BSD license. See LICENSE or:
         * http://opensource.org/licenses/BSD-3-Clause
         */
        var util = util_dew_js_1.dew();
        var has = Object.prototype.hasOwnProperty;
        /**
         * A data structure which is a combination of an array and a set. Adding a new
         * member is O(1), testing for membership is O(1), and finding the index of an
         * element is O(1). Removing elements from the set is not supported. Only
         * strings are supported for membership.
         */
        function ArraySet() {
            (this || _global)._array = [];
            (this || _global)._set = Object.create(null);
        }
        /**
         * Static method for creating ArraySet instances from an existing array.
         */
        ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
            var set = new ArraySet();
            for (var i = 0, len = aArray.length; i < len; i++) {
                set.add(aArray[i], aAllowDuplicates);
            }
            return set;
        };
        /**
         * Return how many unique items are in this ArraySet. If duplicates have been
         * added, than those do not count towards the size.
         *
         * @returns Number
         */
        ArraySet.prototype.size = function ArraySet_size() {
            return Object.getOwnPropertyNames((this || _global)._set).length;
        };
        /**
         * Add the given string to this set.
         *
         * @param String aStr
         */
        ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
            var sStr = util.toSetString(aStr);
            var isDuplicate = has.call((this || _global)._set, sStr);
            var idx = (this || _global)._array.length;
            if (!isDuplicate || aAllowDuplicates) {
                (this || _global)._array.push(aStr);
            }
            if (!isDuplicate) {
                (this || _global)._set[sStr] = idx;
            }
        };
        /**
         * Is the given string a member of this set?
         *
         * @param String aStr
         */
        ArraySet.prototype.has = function ArraySet_has(aStr) {
            var sStr = util.toSetString(aStr);
            return has.call((this || _global)._set, sStr);
        };
        /**
         * What is the index of the given string in the array?
         *
         * @param String aStr
         */
        ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
            var sStr = util.toSetString(aStr);
            if (has.call((this || _global)._set, sStr)) {
                return (this || _global)._set[sStr];
            }
            throw new Error('"' + aStr + '" is not in the set.');
        };
        /**
         * What is the element at the given index?
         *
         * @param Number aIdx
         */
        ArraySet.prototype.at = function ArraySet_at(aIdx) {
            if (aIdx >= 0 && aIdx < (this || _global)._array.length) {
                return (this || _global)._array[aIdx];
            }
            throw new Error('No element indexed by ' + aIdx);
        };
        /**
         * Returns the array representation of this set (which has the proper indices
         * indicated by indexOf). Note that this is a copy of the internal array used
         * for storing the members so that no one can mess with internal state.
         */
        ArraySet.prototype.toArray = function ArraySet_toArray() {
            return (this || _global)._array.slice();
        };
        exports.ArraySet = ArraySet;
        return exports;
    }
    exports_113("dew", dew);
    return {
        setters: [
            function (util_dew_js_1_1) {
                util_dew_js_1 = util_dew_js_1_1;
            }
        ],
        execute: function () {
            exports = {}, _dewExec = false;
            _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
        }
    };
});
System.register("https://dev.jspm.io/npm:source-map@0.5.6/lib/mapping-list.dew", ["https://dev.jspm.io/npm:source-map@0.5.6/lib/util.dew"], function (exports_114, context_114) {
    "use strict";
    var util_dew_js_2, exports, _dewExec, _global;
    var __moduleName = context_114 && context_114.id;
    function dew() {
        if (_dewExec)
            return exports;
        _dewExec = true;
        /* -*- Mode: js; js-indent-level: 2; -*- */
        /*
         * Copyright 2014 Mozilla Foundation and contributors
         * Licensed under the New BSD license. See LICENSE or:
         * http://opensource.org/licenses/BSD-3-Clause
         */
        var util = util_dew_js_2.dew();
        /**
         * Determine whether mappingB is after mappingA with respect to generated
         * position.
         */
        function generatedPositionAfter(mappingA, mappingB) {
            // Optimized for most common case
            var lineA = mappingA.generatedLine;
            var lineB = mappingB.generatedLine;
            var columnA = mappingA.generatedColumn;
            var columnB = mappingB.generatedColumn;
            return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
        }
        /**
         * A data structure to provide a sorted view of accumulated mappings in a
         * performance conscious manner. It trades a neglibable overhead in general
         * case for a large speedup in case of mappings being added in order.
         */
        function MappingList() {
            (this || _global)._array = [];
            (this || _global)._sorted = true; // Serves as infimum
            (this || _global)._last = {
                generatedLine: -1,
                generatedColumn: 0
            };
        }
        /**
         * Iterate through internal items. This method takes the same arguments that
         * `Array.prototype.forEach` takes.
         *
         * NOTE: The order of the mappings is NOT guaranteed.
         */
        MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
            (this || _global)._array.forEach(aCallback, aThisArg);
        };
        /**
         * Add the given source mapping.
         *
         * @param Object aMapping
         */
        MappingList.prototype.add = function MappingList_add(aMapping) {
            if (generatedPositionAfter((this || _global)._last, aMapping)) {
                (this || _global)._last = aMapping;
                (this || _global)._array.push(aMapping);
            }
            else {
                (this || _global)._sorted = false;
                (this || _global)._array.push(aMapping);
            }
        };
        /**
         * Returns the flat, sorted array of mappings. The mappings are sorted by
         * generated position.
         *
         * WARNING: This method returns internal data without copying, for
         * performance. The return value must NOT be mutated, and should be treated as
         * an immutable borrow. If you want to take ownership, you must make your own
         * copy.
         */
        MappingList.prototype.toArray = function MappingList_toArray() {
            if (!(this || _global)._sorted) {
                (this || _global)._array.sort(util.compareByGeneratedPositionsInflated);
                (this || _global)._sorted = true;
            }
            return (this || _global)._array;
        };
        exports.MappingList = MappingList;
        return exports;
    }
    exports_114("dew", dew);
    return {
        setters: [
            function (util_dew_js_2_1) {
                util_dew_js_2 = util_dew_js_2_1;
            }
        ],
        execute: function () {
            exports = {}, _dewExec = false;
            _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
        }
    };
});
System.register("https://dev.jspm.io/npm:source-map@0.5.6/lib/source-map-generator.dew", ["https://dev.jspm.io/npm:source-map@0.5.6/lib/base64-vlq.dew", "https://dev.jspm.io/npm:source-map@0.5.6/lib/util.dew", "https://dev.jspm.io/npm:source-map@0.5.6/lib/array-set.dew", "https://dev.jspm.io/npm:source-map@0.5.6/lib/mapping-list.dew"], function (exports_115, context_115) {
    "use strict";
    var base64_vlq_dew_js_1, util_dew_js_3, array_set_dew_js_1, mapping_list_dew_js_1, exports, _dewExec, _global;
    var __moduleName = context_115 && context_115.id;
    function dew() {
        if (_dewExec)
            return exports;
        _dewExec = true;
        /* -*- Mode: js; js-indent-level: 2; -*- */
        /*
         * Copyright 2011 Mozilla Foundation and contributors
         * Licensed under the New BSD license. See LICENSE or:
         * http://opensource.org/licenses/BSD-3-Clause
         */
        var base64VLQ = base64_vlq_dew_js_1.dew();
        var util = util_dew_js_3.dew();
        var ArraySet = array_set_dew_js_1.dew().ArraySet;
        var MappingList = mapping_list_dew_js_1.dew().MappingList;
        /**
         * An instance of the SourceMapGenerator represents a source map which is
         * being built incrementally. You may pass an object with the following
         * properties:
         *
         *   - file: The filename of the generated source.
         *   - sourceRoot: A root for all relative URLs in this source map.
         */
        function SourceMapGenerator(aArgs) {
            if (!aArgs) {
                aArgs = {};
            }
            (this || _global)._file = util.getArg(aArgs, 'file', null);
            (this || _global)._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
            (this || _global)._skipValidation = util.getArg(aArgs, 'skipValidation', false);
            (this || _global)._sources = new ArraySet();
            (this || _global)._names = new ArraySet();
            (this || _global)._mappings = new MappingList();
            (this || _global)._sourcesContents = null;
        }
        SourceMapGenerator.prototype._version = 3;
        /**
         * Creates a new SourceMapGenerator based on a SourceMapConsumer
         *
         * @param aSourceMapConsumer The SourceMap.
         */
        SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
            var sourceRoot = aSourceMapConsumer.sourceRoot;
            var generator = new SourceMapGenerator({
                file: aSourceMapConsumer.file,
                sourceRoot: sourceRoot
            });
            aSourceMapConsumer.eachMapping(function (mapping) {
                var newMapping = {
                    generated: {
                        line: mapping.generatedLine,
                        column: mapping.generatedColumn
                    }
                };
                if (mapping.source != null) {
                    newMapping.source = mapping.source;
                    if (sourceRoot != null) {
                        newMapping.source = util.relative(sourceRoot, newMapping.source);
                    }
                    newMapping.original = {
                        line: mapping.originalLine,
                        column: mapping.originalColumn
                    };
                    if (mapping.name != null) {
                        newMapping.name = mapping.name;
                    }
                }
                generator.addMapping(newMapping);
            });
            aSourceMapConsumer.sources.forEach(function (sourceFile) {
                var content = aSourceMapConsumer.sourceContentFor(sourceFile);
                if (content != null) {
                    generator.setSourceContent(sourceFile, content);
                }
            });
            return generator;
        };
        /**
         * Add a single mapping from original source line and column to the generated
         * source's line and column for this source map being created. The mapping
         * object should have the following properties:
         *
         *   - generated: An object with the generated line and column positions.
         *   - original: An object with the original line and column positions.
         *   - source: The original source file (relative to the sourceRoot).
         *   - name: An optional original token name for this mapping.
         */
        SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
            var generated = util.getArg(aArgs, 'generated');
            var original = util.getArg(aArgs, 'original', null);
            var source = util.getArg(aArgs, 'source', null);
            var name = util.getArg(aArgs, 'name', null);
            if (!(this || _global)._skipValidation) {
                this._validateMapping(generated, original, source, name);
            }
            if (source != null) {
                source = String(source);
                if (!(this || _global)._sources.has(source)) {
                    (this || _global)._sources.add(source);
                }
            }
            if (name != null) {
                name = String(name);
                if (!(this || _global)._names.has(name)) {
                    (this || _global)._names.add(name);
                }
            }
            (this || _global)._mappings.add({
                generatedLine: generated.line,
                generatedColumn: generated.column,
                originalLine: original != null && original.line,
                originalColumn: original != null && original.column,
                source: source,
                name: name
            });
        };
        /**
         * Set the source content for a source file.
         */
        SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
            var source = aSourceFile;
            if ((this || _global)._sourceRoot != null) {
                source = util.relative((this || _global)._sourceRoot, source);
            }
            if (aSourceContent != null) {
                // Add the source content to the _sourcesContents map.
                // Create a new _sourcesContents map if the property is null.
                if (!(this || _global)._sourcesContents) {
                    (this || _global)._sourcesContents = Object.create(null);
                }
                (this || _global)._sourcesContents[util.toSetString(source)] = aSourceContent;
            }
            else if ((this || _global)._sourcesContents) {
                // Remove the source file from the _sourcesContents map.
                // If the _sourcesContents map is empty, set the property to null.
                delete (this || _global)._sourcesContents[util.toSetString(source)];
                if (Object.keys((this || _global)._sourcesContents).length === 0) {
                    (this || _global)._sourcesContents = null;
                }
            }
        };
        /**
         * Applies the mappings of a sub-source-map for a specific source file to the
         * source map being generated. Each mapping to the supplied source file is
         * rewritten using the supplied source map. Note: The resolution for the
         * resulting mappings is the minimium of this map and the supplied map.
         *
         * @param aSourceMapConsumer The source map to be applied.
         * @param aSourceFile Optional. The filename of the source file.
         *        If omitted, SourceMapConsumer's file property will be used.
         * @param aSourceMapPath Optional. The dirname of the path to the source map
         *        to be applied. If relative, it is relative to the SourceMapConsumer.
         *        This parameter is needed when the two source maps aren't in the same
         *        directory, and the source map to be applied contains relative source
         *        paths. If so, those relative source paths need to be rewritten
         *        relative to the SourceMapGenerator.
         */
        SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
            var sourceFile = aSourceFile; // If aSourceFile is omitted, we will use the file property of the SourceMap
            if (aSourceFile == null) {
                if (aSourceMapConsumer.file == null) {
                    throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
                }
                sourceFile = aSourceMapConsumer.file;
            }
            var sourceRoot = (this || _global)._sourceRoot; // Make "sourceFile" relative if an absolute Url is passed.
            if (sourceRoot != null) {
                sourceFile = util.relative(sourceRoot, sourceFile);
            } // Applying the SourceMap can add and remove items from the sources and
            // the names array.
            var newSources = new ArraySet();
            var newNames = new ArraySet(); // Find mappings for the "sourceFile"
            (this || _global)._mappings.unsortedForEach(function (mapping) {
                if (mapping.source === sourceFile && mapping.originalLine != null) {
                    // Check if it can be mapped by the source map, then update the mapping.
                    var original = aSourceMapConsumer.originalPositionFor({
                        line: mapping.originalLine,
                        column: mapping.originalColumn
                    });
                    if (original.source != null) {
                        // Copy mapping
                        mapping.source = original.source;
                        if (aSourceMapPath != null) {
                            mapping.source = util.join(aSourceMapPath, mapping.source);
                        }
                        if (sourceRoot != null) {
                            mapping.source = util.relative(sourceRoot, mapping.source);
                        }
                        mapping.originalLine = original.line;
                        mapping.originalColumn = original.column;
                        if (original.name != null) {
                            mapping.name = original.name;
                        }
                    }
                }
                var source = mapping.source;
                if (source != null && !newSources.has(source)) {
                    newSources.add(source);
                }
                var name = mapping.name;
                if (name != null && !newNames.has(name)) {
                    newNames.add(name);
                }
            }, this || _global);
            (this || _global)._sources = newSources;
            (this || _global)._names = newNames; // Copy sourcesContents of applied map.
            aSourceMapConsumer.sources.forEach(function (sourceFile) {
                var content = aSourceMapConsumer.sourceContentFor(sourceFile);
                if (content != null) {
                    if (aSourceMapPath != null) {
                        sourceFile = util.join(aSourceMapPath, sourceFile);
                    }
                    if (sourceRoot != null) {
                        sourceFile = util.relative(sourceRoot, sourceFile);
                    }
                    this.setSourceContent(sourceFile, content);
                }
            }, this || _global);
        };
        /**
         * A mapping can have one of the three levels of data:
         *
         *   1. Just the generated position.
         *   2. The Generated position, original position, and original source.
         *   3. Generated and original position, original source, as well as a name
         *      token.
         *
         * To maintain consistency, we validate that any new mapping being added falls
         * in to one of these categories.
         */
        SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
            if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
                // Case 1.
                return;
            }
            else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
                // Cases 2 and 3.
                return;
            }
            else {
                throw new Error('Invalid mapping: ' + JSON.stringify({
                    generated: aGenerated,
                    source: aSource,
                    original: aOriginal,
                    name: aName
                }));
            }
        };
        /**
         * Serialize the accumulated mappings in to the stream of base 64 VLQs
         * specified by the source map format.
         */
        SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
            var previousGeneratedColumn = 0;
            var previousGeneratedLine = 1;
            var previousOriginalColumn = 0;
            var previousOriginalLine = 0;
            var previousName = 0;
            var previousSource = 0;
            var result = '';
            var next;
            var mapping;
            var nameIdx;
            var sourceIdx;
            var mappings = (this || _global)._mappings.toArray();
            for (var i = 0, len = mappings.length; i < len; i++) {
                mapping = mappings[i];
                next = '';
                if (mapping.generatedLine !== previousGeneratedLine) {
                    previousGeneratedColumn = 0;
                    while (mapping.generatedLine !== previousGeneratedLine) {
                        next += ';';
                        previousGeneratedLine++;
                    }
                }
                else {
                    if (i > 0) {
                        if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
                            continue;
                        }
                        next += ',';
                    }
                }
                next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
                previousGeneratedColumn = mapping.generatedColumn;
                if (mapping.source != null) {
                    sourceIdx = (this || _global)._sources.indexOf(mapping.source);
                    next += base64VLQ.encode(sourceIdx - previousSource);
                    previousSource = sourceIdx; // lines are stored 0-based in SourceMap spec version 3
                    next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
                    previousOriginalLine = mapping.originalLine - 1;
                    next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
                    previousOriginalColumn = mapping.originalColumn;
                    if (mapping.name != null) {
                        nameIdx = (this || _global)._names.indexOf(mapping.name);
                        next += base64VLQ.encode(nameIdx - previousName);
                        previousName = nameIdx;
                    }
                }
                result += next;
            }
            return result;
        };
        SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
            return aSources.map(function (source) {
                if (!(this || _global)._sourcesContents) {
                    return null;
                }
                if (aSourceRoot != null) {
                    source = util.relative(aSourceRoot, source);
                }
                var key = util.toSetString(source);
                return Object.prototype.hasOwnProperty.call((this || _global)._sourcesContents, key) ? (this || _global)._sourcesContents[key] : null;
            }, this || _global);
        };
        /**
         * Externalize the source map.
         */
        SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
            var map = {
                version: (this || _global)._version,
                sources: (this || _global)._sources.toArray(),
                names: (this || _global)._names.toArray(),
                mappings: this._serializeMappings()
            };
            if ((this || _global)._file != null) {
                map.file = (this || _global)._file;
            }
            if ((this || _global)._sourceRoot != null) {
                map.sourceRoot = (this || _global)._sourceRoot;
            }
            if ((this || _global)._sourcesContents) {
                map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
            }
            return map;
        };
        /**
         * Render the source map being generated to a string.
         */
        SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
            return JSON.stringify(this.toJSON());
        };
        exports.SourceMapGenerator = SourceMapGenerator;
        return exports;
    }
    exports_115("dew", dew);
    return {
        setters: [
            function (base64_vlq_dew_js_1_1) {
                base64_vlq_dew_js_1 = base64_vlq_dew_js_1_1;
            },
            function (util_dew_js_3_1) {
                util_dew_js_3 = util_dew_js_3_1;
            },
            function (array_set_dew_js_1_1) {
                array_set_dew_js_1 = array_set_dew_js_1_1;
            },
            function (mapping_list_dew_js_1_1) {
                mapping_list_dew_js_1 = mapping_list_dew_js_1_1;
            }
        ],
        execute: function () {
            exports = {}, _dewExec = false;
            _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
        }
    };
});
System.register("https://dev.jspm.io/npm:source-map@0.5.6/lib/binary-search.dew", [], function (exports_116, context_116) {
    "use strict";
    var exports, _dewExec;
    var __moduleName = context_116 && context_116.id;
    function dew() {
        if (_dewExec)
            return exports;
        _dewExec = true;
        /* -*- Mode: js; js-indent-level: 2; -*- */
        /*
         * Copyright 2011 Mozilla Foundation and contributors
         * Licensed under the New BSD license. See LICENSE or:
         * http://opensource.org/licenses/BSD-3-Clause
         */
        exports.GREATEST_LOWER_BOUND = 1;
        exports.LEAST_UPPER_BOUND = 2;
        /**
         * Recursive implementation of binary search.
         *
         * @param aLow Indices here and lower do not contain the needle.
         * @param aHigh Indices here and higher do not contain the needle.
         * @param aNeedle The element being searched for.
         * @param aHaystack The non-empty array being searched.
         * @param aCompare Function which takes two elements and returns -1, 0, or 1.
         * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
         *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
         *     closest element that is smaller than or greater than the one we are
         *     searching for, respectively, if the exact element cannot be found.
         */
        function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
            // This function terminates when one of the following is true:
            //
            //   1. We find the exact element we are looking for.
            //
            //   2. We did not find the exact element, but we can return the index of
            //      the next-closest element.
            //
            //   3. We did not find the exact element, and there is no next-closest
            //      element than the one we are searching for, so we return -1.
            var mid = Math.floor((aHigh - aLow) / 2) + aLow;
            var cmp = aCompare(aNeedle, aHaystack[mid], true);
            if (cmp === 0) {
                // Found the element we are looking for.
                return mid;
            }
            else if (cmp > 0) {
                // Our needle is greater than aHaystack[mid].
                if (aHigh - mid > 1) {
                    // The element is in the upper half.
                    return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
                } // The exact needle element was not found in this haystack. Determine if
                // we are in termination case (3) or (2) and return the appropriate thing.
                if (aBias == exports.LEAST_UPPER_BOUND) {
                    return aHigh < aHaystack.length ? aHigh : -1;
                }
                else {
                    return mid;
                }
            }
            else {
                // Our needle is less than aHaystack[mid].
                if (mid - aLow > 1) {
                    // The element is in the lower half.
                    return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
                } // we are in termination case (3) or (2) and return the appropriate thing.
                if (aBias == exports.LEAST_UPPER_BOUND) {
                    return mid;
                }
                else {
                    return aLow < 0 ? -1 : aLow;
                }
            }
        }
        /**
         * This is an implementation of binary search which will always try and return
         * the index of the closest element if there is no exact hit. This is because
         * mappings between original and generated line/col pairs are single points,
         * and there is an implicit region between each of them, so a miss just means
         * that you aren't on the very start of a region.
         *
         * @param aNeedle The element you are looking for.
         * @param aHaystack The array that is being searched.
         * @param aCompare A function which takes the needle and an element in the
         *     array and returns -1, 0, or 1 depending on whether the needle is less
         *     than, equal to, or greater than the element, respectively.
         * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
         *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
         *     closest element that is smaller than or greater than the one we are
         *     searching for, respectively, if the exact element cannot be found.
         *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
         */
        exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
            if (aHaystack.length === 0) {
                return -1;
            }
            var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
            if (index < 0) {
                return -1;
            } // We have found either the exact element, or the next-closest element than
            // the one we are searching for. However, there may be more than one such
            // element. Make sure we always return the smallest of these.
            while (index - 1 >= 0) {
                if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
                    break;
                }
                --index;
            }
            return index;
        };
        return exports;
    }
    exports_116("dew", dew);
    return {
        setters: [],
        execute: function () {
            exports = {}, _dewExec = false;
        }
    };
});
System.register("https://dev.jspm.io/npm:source-map@0.5.6/lib/quick-sort.dew", [], function (exports_117, context_117) {
    "use strict";
    var exports, _dewExec;
    var __moduleName = context_117 && context_117.id;
    function dew() {
        if (_dewExec)
            return exports;
        _dewExec = true;
        /* -*- Mode: js; js-indent-level: 2; -*- */
        /*
         * Copyright 2011 Mozilla Foundation and contributors
         * Licensed under the New BSD license. See LICENSE or:
         * http://opensource.org/licenses/BSD-3-Clause
         */
        // It turns out that some (most?) JavaScript engines don't self-host
        // `Array.prototype.sort`. This makes sense because C++ will likely remain
        // faster than JS when doing raw CPU-intensive sorting. However, when using a
        // custom comparator function, calling back and forth between the VM's C++ and
        // JIT'd JS is rather slow *and* loses JIT type information, resulting in
        // worse generated code for the comparator function than would be optimal. In
        // fact, when sorting with a comparator, these costs outweigh the benefits of
        // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
        // a ~3500ms mean speed-up in `bench/bench.html`.
        /**
         * Swap the elements indexed by `x` and `y` in the array `ary`.
         *
         * @param {Array} ary
         *        The array.
         * @param {Number} x
         *        The index of the first item.
         * @param {Number} y
         *        The index of the second item.
         */
        function swap(ary, x, y) {
            var temp = ary[x];
            ary[x] = ary[y];
            ary[y] = temp;
        }
        /**
         * Returns a random integer within the range `low .. high` inclusive.
         *
         * @param {Number} low
         *        The lower bound on the range.
         * @param {Number} high
         *        The upper bound on the range.
         */
        function randomIntInRange(low, high) {
            return Math.round(low + Math.random() * (high - low));
        }
        /**
         * The Quick Sort algorithm.
         *
         * @param {Array} ary
         *        An array to sort.
         * @param {function} comparator
         *        Function to use to compare two items.
         * @param {Number} p
         *        Start index of the array
         * @param {Number} r
         *        End index of the array
         */
        function doQuickSort(ary, comparator, p, r) {
            // If our lower bound is less than our upper bound, we (1) partition the
            // array into two pieces and (2) recurse on each half. If it is not, this is
            // the empty array and our base case.
            if (p < r) {
                // (1) Partitioning.
                //
                // The partitioning chooses a pivot between `p` and `r` and moves all
                // elements that are less than or equal to the pivot to the before it, and
                // all the elements that are greater than it after it. The effect is that
                // once partition is done, the pivot is in the exact place it will be when
                // the array is put in sorted order, and it will not need to be moved
                // again. This runs in O(n) time.
                // Always choose a random pivot so that an input array which is reverse
                // sorted does not cause O(n^2) running time.
                var pivotIndex = randomIntInRange(p, r);
                var i = p - 1;
                swap(ary, pivotIndex, r);
                var pivot = ary[r]; // Immediately after `j` is incremented in this loop, the following hold
                // true:
                //
                //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
                //
                //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
                for (var j = p; j < r; j++) {
                    if (comparator(ary[j], pivot) <= 0) {
                        i += 1;
                        swap(ary, i, j);
                    }
                }
                swap(ary, i + 1, j);
                var q = i + 1; // (2) Recurse on each half.
                doQuickSort(ary, comparator, p, q - 1);
                doQuickSort(ary, comparator, q + 1, r);
            }
        }
        /**
         * Sort the given array in-place with the given comparator function.
         *
         * @param {Array} ary
         *        An array to sort.
         * @param {function} comparator
         *        Function to use to compare two items.
         */
        exports.quickSort = function (ary, comparator) {
            doQuickSort(ary, comparator, 0, ary.length - 1);
        };
        return exports;
    }
    exports_117("dew", dew);
    return {
        setters: [],
        execute: function () {
            exports = {}, _dewExec = false;
        }
    };
});
System.register("https://dev.jspm.io/npm:source-map@0.5.6/lib/source-map-consumer.dew", ["https://dev.jspm.io/npm:source-map@0.5.6/lib/util.dew", "https://dev.jspm.io/npm:source-map@0.5.6/lib/binary-search.dew", "https://dev.jspm.io/npm:source-map@0.5.6/lib/array-set.dew", "https://dev.jspm.io/npm:source-map@0.5.6/lib/base64-vlq.dew", "https://dev.jspm.io/npm:source-map@0.5.6/lib/quick-sort.dew"], function (exports_118, context_118) {
    "use strict";
    var util_dew_js_4, binary_search_dew_js_1, array_set_dew_js_2, base64_vlq_dew_js_2, quick_sort_dew_js_1, exports, _dewExec, _global;
    var __moduleName = context_118 && context_118.id;
    function dew() {
        if (_dewExec)
            return exports;
        _dewExec = true;
        /* -*- Mode: js; js-indent-level: 2; -*- */
        /*
         * Copyright 2011 Mozilla Foundation and contributors
         * Licensed under the New BSD license. See LICENSE or:
         * http://opensource.org/licenses/BSD-3-Clause
         */
        var util = util_dew_js_4.dew();
        var binarySearch = binary_search_dew_js_1.dew();
        var ArraySet = array_set_dew_js_2.dew().ArraySet;
        var base64VLQ = base64_vlq_dew_js_2.dew();
        var quickSort = quick_sort_dew_js_1.dew().quickSort;
        function SourceMapConsumer(aSourceMap) {
            var sourceMap = aSourceMap;
            if (typeof aSourceMap === 'string') {
                sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
            }
            return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap) : new BasicSourceMapConsumer(sourceMap);
        }
        SourceMapConsumer.fromSourceMap = function (aSourceMap) {
            return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
        };
        /**
         * The version of the source mapping spec that we are consuming.
         */
        SourceMapConsumer.prototype._version = 3; // `__generatedMappings` and `__originalMappings` are arrays that hold the
        // parsed mapping coordinates from the source map's "mappings" attribute. They
        // are lazily instantiated, accessed via the `_generatedMappings` and
        // `_originalMappings` getters respectively, and we only parse the mappings
        // and create these arrays once queried for a source location. We jump through
        // these hoops because there can be many thousands of mappings, and parsing
        // them is expensive, so we only want to do it if we must.
        //
        // Each object in the arrays is of the form:
        //
        //     {
        //       generatedLine: The line number in the generated code,
        //       generatedColumn: The column number in the generated code,
        //       source: The path to the original source file that generated this
        //               chunk of code,
        //       originalLine: The line number in the original source that
        //                     corresponds to this chunk of generated code,
        //       originalColumn: The column number in the original source that
        //                       corresponds to this chunk of generated code,
        //       name: The name of the original symbol which generated this chunk of
        //             code.
        //     }
        //
        // All properties except for `generatedLine` and `generatedColumn` can be
        // `null`.
        //
        // `_generatedMappings` is ordered by the generated positions.
        //
        // `_originalMappings` is ordered by the original positions.
        SourceMapConsumer.prototype.__generatedMappings = null;
        Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
            get: function () {
                if (!(this || _global).__generatedMappings) {
                    this._parseMappings((this || _global)._mappings, (this || _global).sourceRoot);
                }
                return (this || _global).__generatedMappings;
            }
        });
        SourceMapConsumer.prototype.__originalMappings = null;
        Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
            get: function () {
                if (!(this || _global).__originalMappings) {
                    this._parseMappings((this || _global)._mappings, (this || _global).sourceRoot);
                }
                return (this || _global).__originalMappings;
            }
        });
        SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
            var c = aStr.charAt(index);
            return c === ";" || c === ",";
        };
        /**
         * Parse the mappings in a string in to a data structure which we can easily
         * query (the ordered arrays in the `this.__generatedMappings` and
         * `this.__originalMappings` properties).
         */
        SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
            throw new Error("Subclasses must implement _parseMappings");
        };
        SourceMapConsumer.GENERATED_ORDER = 1;
        SourceMapConsumer.ORIGINAL_ORDER = 2;
        SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
        SourceMapConsumer.LEAST_UPPER_BOUND = 2;
        /**
         * Iterate over each mapping between an original source/line/column and a
         * generated line/column in this source map.
         *
         * @param Function aCallback
         *        The function that is called with each mapping.
         * @param Object aContext
         *        Optional. If specified, this object will be the value of `this` every
         *        time that `aCallback` is called.
         * @param aOrder
         *        Either `SourceMapConsumer.GENERATED_ORDER` or
         *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
         *        iterate over the mappings sorted by the generated file's line/column
         *        order or the original's source/line/column order, respectively. Defaults to
         *        `SourceMapConsumer.GENERATED_ORDER`.
         */
        SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
            var context = aContext || null;
            var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
            var mappings;
            switch (order) {
                case SourceMapConsumer.GENERATED_ORDER:
                    mappings = (this || _global)._generatedMappings;
                    break;
                case SourceMapConsumer.ORIGINAL_ORDER:
                    mappings = (this || _global)._originalMappings;
                    break;
                default:
                    throw new Error("Unknown order of iteration.");
            }
            var sourceRoot = (this || _global).sourceRoot;
            mappings.map(function (mapping) {
                var source = mapping.source === null ? null : (this || _global)._sources.at(mapping.source);
                if (source != null && sourceRoot != null) {
                    source = util.join(sourceRoot, source);
                }
                return {
                    source: source,
                    generatedLine: mapping.generatedLine,
                    generatedColumn: mapping.generatedColumn,
                    originalLine: mapping.originalLine,
                    originalColumn: mapping.originalColumn,
                    name: mapping.name === null ? null : (this || _global)._names.at(mapping.name)
                };
            }, this || _global).forEach(aCallback, context);
        };
        /**
         * Returns all generated line and column information for the original source,
         * line, and column provided. If no column is provided, returns all mappings
         * corresponding to a either the line we are searching for or the next
         * closest line that has any mappings. Otherwise, returns all mappings
         * corresponding to the given line and either the column we are searching for
         * or the next closest column that has any offsets.
         *
         * The only argument is an object with the following properties:
         *
         *   - source: The filename of the original source.
         *   - line: The line number in the original source.
         *   - column: Optional. the column number in the original source.
         *
         * and an array of objects is returned, each with the following properties:
         *
         *   - line: The line number in the generated source, or null.
         *   - column: The column number in the generated source, or null.
         */
        SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
            var line = util.getArg(aArgs, 'line'); // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
            // returns the index of the closest mapping less than the needle. By
            // setting needle.originalColumn to 0, we thus find the last mapping for
            // the given line, provided such a mapping exists.
            var needle = {
                source: util.getArg(aArgs, 'source'),
                originalLine: line,
                originalColumn: util.getArg(aArgs, 'column', 0)
            };
            if ((this || _global).sourceRoot != null) {
                needle.source = util.relative((this || _global).sourceRoot, needle.source);
            }
            if (!(this || _global)._sources.has(needle.source)) {
                return [];
            }
            needle.source = (this || _global)._sources.indexOf(needle.source);
            var mappings = [];
            var index = this._findMapping(needle, (this || _global)._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
            if (index >= 0) {
                var mapping = (this || _global)._originalMappings[index];
                if (aArgs.column === undefined) {
                    var originalLine = mapping.originalLine; // Iterate until either we run out of mappings, or we run into
                    // a mapping for a different line than the one we found. Since
                    // mappings are sorted, this is guaranteed to find all mappings for
                    // the line we found.
                    while (mapping && mapping.originalLine === originalLine) {
                        mappings.push({
                            line: util.getArg(mapping, 'generatedLine', null),
                            column: util.getArg(mapping, 'generatedColumn', null),
                            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
                        });
                        mapping = (this || _global)._originalMappings[++index];
                    }
                }
                else {
                    var originalColumn = mapping.originalColumn; // Iterate until either we run out of mappings, or we run into
                    // a mapping for a different line than the one we were searching for.
                    // Since mappings are sorted, this is guaranteed to find all mappings for
                    // the line we are searching for.
                    while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
                        mappings.push({
                            line: util.getArg(mapping, 'generatedLine', null),
                            column: util.getArg(mapping, 'generatedColumn', null),
                            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
                        });
                        mapping = (this || _global)._originalMappings[++index];
                    }
                }
            }
            return mappings;
        };
        exports.SourceMapConsumer = SourceMapConsumer;
        /**
         * A BasicSourceMapConsumer instance represents a parsed source map which we can
         * query for information about the original file positions by giving it a file
         * position in the generated source.
         *
         * The only parameter is the raw source map (either as a JSON string, or
         * already parsed to an object). According to the spec, source maps have the
         * following attributes:
         *
         *   - version: Which version of the source map spec this map is following.
         *   - sources: An array of URLs to the original source files.
         *   - names: An array of identifiers which can be referrenced by individual mappings.
         *   - sourceRoot: Optional. The URL root from which all sources are relative.
         *   - sourcesContent: Optional. An array of contents of the original source files.
         *   - mappings: A string of base64 VLQs which contain the actual mappings.
         *   - file: Optional. The generated file this source map is associated with.
         *
         * Here is an example source map, taken from the source map spec[0]:
         *
         *     {
         *       version : 3,
         *       file: "out.js",
         *       sourceRoot : "",
         *       sources: ["foo.js", "bar.js"],
         *       names: ["src", "maps", "are", "fun"],
         *       mappings: "AA,AB;;ABCDE;"
         *     }
         *
         * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
         */
        function BasicSourceMapConsumer(aSourceMap) {
            var sourceMap = aSourceMap;
            if (typeof aSourceMap === 'string') {
                sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
            }
            var version = util.getArg(sourceMap, 'version');
            var sources = util.getArg(sourceMap, 'sources'); // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
            // requires the array) to play nice here.
            var names = util.getArg(sourceMap, 'names', []);
            var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
            var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
            var mappings = util.getArg(sourceMap, 'mappings');
            var file = util.getArg(sourceMap, 'file', null); // Once again, Sass deviates from the spec and supplies the version as a
            // string rather than a number, so we use loose equality checking here.
            if (version != (this || _global)._version) {
                throw new Error('Unsupported version: ' + version);
            }
            sources = sources.map(String) // Some source maps produce relative source paths like "./foo.js" instead of
                // "foo.js".  Normalize these first so that future comparisons will succeed.
                // See bugzil.la/1090768.
                .map(util.normalize) // Always ensure that absolute sources are internally stored relative to
                // the source root, if the source root is absolute. Not doing this would
                // be particularly problematic when the source root is a prefix of the
                // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
                .map(function (source) {
                return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
            }); // Pass `true` below to allow duplicate names and sources. While source maps
            // are intended to be compressed and deduplicated, the TypeScript compiler
            // sometimes generates source maps with duplicates in them. See Github issue
            // #72 and bugzil.la/889492.
            (this || _global)._names = ArraySet.fromArray(names.map(String), true);
            (this || _global)._sources = ArraySet.fromArray(sources, true);
            (this || _global).sourceRoot = sourceRoot;
            (this || _global).sourcesContent = sourcesContent;
            (this || _global)._mappings = mappings;
            (this || _global).file = file;
        }
        BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
        BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
        /**
         * Create a BasicSourceMapConsumer from a SourceMapGenerator.
         *
         * @param SourceMapGenerator aSourceMap
         *        The source map that will be consumed.
         * @returns BasicSourceMapConsumer
         */
        BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {
            var smc = Object.create(BasicSourceMapConsumer.prototype);
            var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
            var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
            smc.sourceRoot = aSourceMap._sourceRoot;
            smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
            smc.file = aSourceMap._file; // Because we are modifying the entries (by converting string sources and
            // names to indices into the sources and names ArraySets), we have to make
            // a copy of the entry or else bad things happen. Shared mutable state
            // strikes again! See github issue #191.
            var generatedMappings = aSourceMap._mappings.toArray().slice();
            var destGeneratedMappings = smc.__generatedMappings = [];
            var destOriginalMappings = smc.__originalMappings = [];
            for (var i = 0, length = generatedMappings.length; i < length; i++) {
                var srcMapping = generatedMappings[i];
                var destMapping = new Mapping();
                destMapping.generatedLine = srcMapping.generatedLine;
                destMapping.generatedColumn = srcMapping.generatedColumn;
                if (srcMapping.source) {
                    destMapping.source = sources.indexOf(srcMapping.source);
                    destMapping.originalLine = srcMapping.originalLine;
                    destMapping.originalColumn = srcMapping.originalColumn;
                    if (srcMapping.name) {
                        destMapping.name = names.indexOf(srcMapping.name);
                    }
                    destOriginalMappings.push(destMapping);
                }
                destGeneratedMappings.push(destMapping);
            }
            quickSort(smc.__originalMappings, util.compareByOriginalPositions);
            return smc;
        };
        /**
         * The version of the source mapping spec that we are consuming.
         */
        BasicSourceMapConsumer.prototype._version = 3;
        /**
         * The list of original sources.
         */
        Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
            get: function () {
                return (this || _global)._sources.toArray().map(function (s) {
                    return (this || _global).sourceRoot != null ? util.join((this || _global).sourceRoot, s) : s;
                }, this || _global);
            }
        });
        /**
         * Provide the JIT with a nice shape / hidden class.
         */
        function Mapping() {
            (this || _global).generatedLine = 0;
            (this || _global).generatedColumn = 0;
            (this || _global).source = null;
            (this || _global).originalLine = null;
            (this || _global).originalColumn = null;
            (this || _global).name = null;
        }
        /**
         * Parse the mappings in a string in to a data structure which we can easily
         * query (the ordered arrays in the `this.__generatedMappings` and
         * `this.__originalMappings` properties).
         */
        BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
            var generatedLine = 1;
            var previousGeneratedColumn = 0;
            var previousOriginalLine = 0;
            var previousOriginalColumn = 0;
            var previousSource = 0;
            var previousName = 0;
            var length = aStr.length;
            var index = 0;
            var cachedSegments = {};
            var temp = {};
            var originalMappings = [];
            var generatedMappings = [];
            var mapping, str, segment, end, value;
            while (index < length) {
                if (aStr.charAt(index) === ';') {
                    generatedLine++;
                    index++;
                    previousGeneratedColumn = 0;
                }
                else if (aStr.charAt(index) === ',') {
                    index++;
                }
                else {
                    mapping = new Mapping();
                    mapping.generatedLine = generatedLine; // Because each offset is encoded relative to the previous one,
                    // many segments often have the same encoding. We can exploit this
                    // fact by caching the parsed variable length fields of each segment,
                    // allowing us to avoid a second parse if we encounter the same
                    // segment again.
                    for (end = index; end < length; end++) {
                        if (this._charIsMappingSeparator(aStr, end)) {
                            break;
                        }
                    }
                    str = aStr.slice(index, end);
                    segment = cachedSegments[str];
                    if (segment) {
                        index += str.length;
                    }
                    else {
                        segment = [];
                        while (index < end) {
                            base64VLQ.decode(aStr, index, temp);
                            value = temp.value;
                            index = temp.rest;
                            segment.push(value);
                        }
                        if (segment.length === 2) {
                            throw new Error('Found a source, but no line and column');
                        }
                        if (segment.length === 3) {
                            throw new Error('Found a source and line, but no column');
                        }
                        cachedSegments[str] = segment;
                    } // Generated column.
                    mapping.generatedColumn = previousGeneratedColumn + segment[0];
                    previousGeneratedColumn = mapping.generatedColumn;
                    if (segment.length > 1) {
                        // Original source.
                        mapping.source = previousSource + segment[1];
                        previousSource += segment[1]; // Original line.
                        mapping.originalLine = previousOriginalLine + segment[2];
                        previousOriginalLine = mapping.originalLine; // Lines are stored 0-based
                        mapping.originalLine += 1; // Original column.
                        mapping.originalColumn = previousOriginalColumn + segment[3];
                        previousOriginalColumn = mapping.originalColumn;
                        if (segment.length > 4) {
                            // Original name.
                            mapping.name = previousName + segment[4];
                            previousName += segment[4];
                        }
                    }
                    generatedMappings.push(mapping);
                    if (typeof mapping.originalLine === 'number') {
                        originalMappings.push(mapping);
                    }
                }
            }
            quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
            (this || _global).__generatedMappings = generatedMappings;
            quickSort(originalMappings, util.compareByOriginalPositions);
            (this || _global).__originalMappings = originalMappings;
        };
        /**
         * Find the mapping that best matches the hypothetical "needle" mapping that
         * we are searching for in the given "haystack" of mappings.
         */
        BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
            // To return the position we are searching for, we must first find the
            // mapping for the given position and then return the opposite position it
            // points to. Because the mappings are sorted, we can use binary search to
            // find the best mapping.
            if (aNeedle[aLineName] <= 0) {
                throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
            }
            if (aNeedle[aColumnName] < 0) {
                throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
            }
            return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
        };
        /**
         * Compute the last column for each generated mapping. The last column is
         * inclusive.
         */
        BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
            for (var index = 0; index < (this || _global)._generatedMappings.length; ++index) {
                var mapping = (this || _global)._generatedMappings[index]; // Mappings do not contain a field for the last generated columnt. We
                // can come up with an optimistic estimate, however, by assuming that
                // mappings are contiguous (i.e. given two consecutive mappings, the
                // first mapping ends where the second one starts).
                if (index + 1 < (this || _global)._generatedMappings.length) {
                    var nextMapping = (this || _global)._generatedMappings[index + 1];
                    if (mapping.generatedLine === nextMapping.generatedLine) {
                        mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
                        continue;
                    }
                } // The last mapping for each line spans the entire line.
                mapping.lastGeneratedColumn = Infinity;
            }
        };
        /**
         * Returns the original source, line, and column information for the generated
         * source's line and column positions provided. The only argument is an object
         * with the following properties:
         *
         *   - line: The line number in the generated source.
         *   - column: The column number in the generated source.
         *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
         *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
         *     closest element that is smaller than or greater than the one we are
         *     searching for, respectively, if the exact element cannot be found.
         *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
         *
         * and an object is returned with the following properties:
         *
         *   - source: The original source file, or null.
         *   - line: The line number in the original source, or null.
         *   - column: The column number in the original source, or null.
         *   - name: The original identifier, or null.
         */
        BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
            var needle = {
                generatedLine: util.getArg(aArgs, 'line'),
                generatedColumn: util.getArg(aArgs, 'column')
            };
            var index = this._findMapping(needle, (this || _global)._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
            if (index >= 0) {
                var mapping = (this || _global)._generatedMappings[index];
                if (mapping.generatedLine === needle.generatedLine) {
                    var source = util.getArg(mapping, 'source', null);
                    if (source !== null) {
                        source = (this || _global)._sources.at(source);
                        if ((this || _global).sourceRoot != null) {
                            source = util.join((this || _global).sourceRoot, source);
                        }
                    }
                    var name = util.getArg(mapping, 'name', null);
                    if (name !== null) {
                        name = (this || _global)._names.at(name);
                    }
                    return {
                        source: source,
                        line: util.getArg(mapping, 'originalLine', null),
                        column: util.getArg(mapping, 'originalColumn', null),
                        name: name
                    };
                }
            }
            return {
                source: null,
                line: null,
                column: null,
                name: null
            };
        };
        /**
         * Return true if we have the source content for every source in the source
         * map, false otherwise.
         */
        BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
            if (!(this || _global).sourcesContent) {
                return false;
            }
            return (this || _global).sourcesContent.length >= (this || _global)._sources.size() && !(this || _global).sourcesContent.some(function (sc) {
                return sc == null;
            });
        };
        /**
         * Returns the original source content. The only argument is the url of the
         * original source file. Returns null if no original source content is
         * available.
         */
        BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
            if (!(this || _global).sourcesContent) {
                return null;
            }
            if ((this || _global).sourceRoot != null) {
                aSource = util.relative((this || _global).sourceRoot, aSource);
            }
            if ((this || _global)._sources.has(aSource)) {
                return (this || _global).sourcesContent[(this || _global)._sources.indexOf(aSource)];
            }
            var url;
            if ((this || _global).sourceRoot != null && (url = util.urlParse((this || _global).sourceRoot))) {
                // XXX: file:// URIs and absolute paths lead to unexpected behavior for
                // many users. We can help them out when they expect file:// URIs to
                // behave like it would if they were running a local HTTP server. See
                // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
                var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
                if (url.scheme == "file" && (this || _global)._sources.has(fileUriAbsPath)) {
                    return (this || _global).sourcesContent[(this || _global)._sources.indexOf(fileUriAbsPath)];
                }
                if ((!url.path || url.path == "/") && (this || _global)._sources.has("/" + aSource)) {
                    return (this || _global).sourcesContent[(this || _global)._sources.indexOf("/" + aSource)];
                }
            } // This function is used recursively from
            // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
            // don't want to throw if we can't find the source - we just want to
            // return null, so we provide a flag to exit gracefully.
            if (nullOnMissing) {
                return null;
            }
            else {
                throw new Error('"' + aSource + '" is not in the SourceMap.');
            }
        };
        /**
         * Returns the generated line and column information for the original source,
         * line, and column positions provided. The only argument is an object with
         * the following properties:
         *
         *   - source: The filename of the original source.
         *   - line: The line number in the original source.
         *   - column: The column number in the original source.
         *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
         *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
         *     closest element that is smaller than or greater than the one we are
         *     searching for, respectively, if the exact element cannot be found.
         *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
         *
         * and an object is returned with the following properties:
         *
         *   - line: The line number in the generated source, or null.
         *   - column: The column number in the generated source, or null.
         */
        BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
            var source = util.getArg(aArgs, 'source');
            if ((this || _global).sourceRoot != null) {
                source = util.relative((this || _global).sourceRoot, source);
            }
            if (!(this || _global)._sources.has(source)) {
                return {
                    line: null,
                    column: null,
                    lastColumn: null
                };
            }
            source = (this || _global)._sources.indexOf(source);
            var needle = {
                source: source,
                originalLine: util.getArg(aArgs, 'line'),
                originalColumn: util.getArg(aArgs, 'column')
            };
            var index = this._findMapping(needle, (this || _global)._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));
            if (index >= 0) {
                var mapping = (this || _global)._originalMappings[index];
                if (mapping.source === needle.source) {
                    return {
                        line: util.getArg(mapping, 'generatedLine', null),
                        column: util.getArg(mapping, 'generatedColumn', null),
                        lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
                    };
                }
            }
            return {
                line: null,
                column: null,
                lastColumn: null
            };
        };
        exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
        /**
         * An IndexedSourceMapConsumer instance represents a parsed source map which
         * we can query for information. It differs from BasicSourceMapConsumer in
         * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
         * input.
         *
         * The only parameter is a raw source map (either as a JSON string, or already
         * parsed to an object). According to the spec for indexed source maps, they
         * have the following attributes:
         *
         *   - version: Which version of the source map spec this map is following.
         *   - file: Optional. The generated file this source map is associated with.
         *   - sections: A list of section definitions.
         *
         * Each value under the "sections" field has two fields:
         *   - offset: The offset into the original specified at which this section
         *       begins to apply, defined as an object with a "line" and "column"
         *       field.
         *   - map: A source map definition. This source map could also be indexed,
         *       but doesn't have to be.
         *
         * Instead of the "map" field, it's also possible to have a "url" field
         * specifying a URL to retrieve a source map from, but that's currently
         * unsupported.
         *
         * Here's an example source map, taken from the source map spec[0], but
         * modified to omit a section which uses the "url" field.
         *
         *  {
         *    version : 3,
         *    file: "app.js",
         *    sections: [{
         *      offset: {line:100, column:10},
         *      map: {
         *        version : 3,
         *        file: "section.js",
         *        sources: ["foo.js", "bar.js"],
         *        names: ["src", "maps", "are", "fun"],
         *        mappings: "AAAA,E;;ABCDE;"
         *      }
         *    }],
         *  }
         *
         * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
         */
        function IndexedSourceMapConsumer(aSourceMap) {
            var sourceMap = aSourceMap;
            if (typeof aSourceMap === 'string') {
                sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
            }
            var version = util.getArg(sourceMap, 'version');
            var sections = util.getArg(sourceMap, 'sections');
            if (version != (this || _global)._version) {
                throw new Error('Unsupported version: ' + version);
            }
            (this || _global)._sources = new ArraySet();
            (this || _global)._names = new ArraySet();
            var lastOffset = {
                line: -1,
                column: 0
            };
            (this || _global)._sections = sections.map(function (s) {
                if (s.url) {
                    // The url field will require support for asynchronicity.
                    // See https://github.com/mozilla/source-map/issues/16
                    throw new Error('Support for url field in sections not implemented.');
                }
                var offset = util.getArg(s, 'offset');
                var offsetLine = util.getArg(offset, 'line');
                var offsetColumn = util.getArg(offset, 'column');
                if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
                    throw new Error('Section offsets must be ordered and non-overlapping.');
                }
                lastOffset = offset;
                return {
                    generatedOffset: {
                        // The offset fields are 0-based, but we use 1-based indices when
                        // encoding/decoding from VLQ.
                        generatedLine: offsetLine + 1,
                        generatedColumn: offsetColumn + 1
                    },
                    consumer: new SourceMapConsumer(util.getArg(s, 'map'))
                };
            });
        }
        IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
        IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
        /**
         * The version of the source mapping spec that we are consuming.
         */
        IndexedSourceMapConsumer.prototype._version = 3;
        /**
         * The list of original sources.
         */
        Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
            get: function () {
                var sources = [];
                for (var i = 0; i < (this || _global)._sections.length; i++) {
                    for (var j = 0; j < (this || _global)._sections[i].consumer.sources.length; j++) {
                        sources.push((this || _global)._sections[i].consumer.sources[j]);
                    }
                }
                return sources;
            }
        });
        /**
         * Returns the original source, line, and column information for the generated
         * source's line and column positions provided. The only argument is an object
         * with the following properties:
         *
         *   - line: The line number in the generated source.
         *   - column: The column number in the generated source.
         *
         * and an object is returned with the following properties:
         *
         *   - source: The original source file, or null.
         *   - line: The line number in the original source, or null.
         *   - column: The column number in the original source, or null.
         *   - name: The original identifier, or null.
         */
        IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
            var needle = {
                generatedLine: util.getArg(aArgs, 'line'),
                generatedColumn: util.getArg(aArgs, 'column')
            }; // Find the section containing the generated position we're trying to map
            // to an original position.
            var sectionIndex = binarySearch.search(needle, (this || _global)._sections, function (needle, section) {
                var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
                if (cmp) {
                    return cmp;
                }
                return needle.generatedColumn - section.generatedOffset.generatedColumn;
            });
            var section = (this || _global)._sections[sectionIndex];
            if (!section) {
                return {
                    source: null,
                    line: null,
                    column: null,
                    name: null
                };
            }
            return section.consumer.originalPositionFor({
                line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
                column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
                bias: aArgs.bias
            });
        };
        /**
         * Return true if we have the source content for every source in the source
         * map, false otherwise.
         */
        IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
            return (this || _global)._sections.every(function (s) {
                return s.consumer.hasContentsOfAllSources();
            });
        };
        /**
         * Returns the original source content. The only argument is the url of the
         * original source file. Returns null if no original source content is
         * available.
         */
        IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
            for (var i = 0; i < (this || _global)._sections.length; i++) {
                var section = (this || _global)._sections[i];
                var content = section.consumer.sourceContentFor(aSource, true);
                if (content) {
                    return content;
                }
            }
            if (nullOnMissing) {
                return null;
            }
            else {
                throw new Error('"' + aSource + '" is not in the SourceMap.');
            }
        };
        /**
         * Returns the generated line and column information for the original source,
         * line, and column positions provided. The only argument is an object with
         * the following properties:
         *
         *   - source: The filename of the original source.
         *   - line: The line number in the original source.
         *   - column: The column number in the original source.
         *
         * and an object is returned with the following properties:
         *
         *   - line: The line number in the generated source, or null.
         *   - column: The column number in the generated source, or null.
         */
        IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
            for (var i = 0; i < (this || _global)._sections.length; i++) {
                var section = (this || _global)._sections[i]; // Only consider this section if the requested source is in the list of
                // sources of the consumer.
                if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
                    continue;
                }
                var generatedPosition = section.consumer.generatedPositionFor(aArgs);
                if (generatedPosition) {
                    var ret = {
                        line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
                        column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
                    };
                    return ret;
                }
            }
            return {
                line: null,
                column: null
            };
        };
        /**
         * Parse the mappings in a string in to a data structure which we can easily
         * query (the ordered arrays in the `this.__generatedMappings` and
         * `this.__originalMappings` properties).
         */
        IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
            (this || _global).__generatedMappings = [];
            (this || _global).__originalMappings = [];
            for (var i = 0; i < (this || _global)._sections.length; i++) {
                var section = (this || _global)._sections[i];
                var sectionMappings = section.consumer._generatedMappings;
                for (var j = 0; j < sectionMappings.length; j++) {
                    var mapping = sectionMappings[j];
                    var source = section.consumer._sources.at(mapping.source);
                    if (section.consumer.sourceRoot !== null) {
                        source = util.join(section.consumer.sourceRoot, source);
                    }
                    (this || _global)._sources.add(source);
                    source = (this || _global)._sources.indexOf(source);
                    var name = section.consumer._names.at(mapping.name);
                    (this || _global)._names.add(name);
                    name = (this || _global)._names.indexOf(name); // The mappings coming from the consumer for the section have
                    // generated positions relative to the start of the section, so we
                    // need to offset them to be relative to the start of the concatenated
                    // generated file.
                    var adjustedMapping = {
                        source: source,
                        generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
                        generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
                        originalLine: mapping.originalLine,
                        originalColumn: mapping.originalColumn,
                        name: name
                    };
                    (this || _global).__generatedMappings.push(adjustedMapping);
                    if (typeof adjustedMapping.originalLine === 'number') {
                        (this || _global).__originalMappings.push(adjustedMapping);
                    }
                }
            }
            quickSort((this || _global).__generatedMappings, util.compareByGeneratedPositionsDeflated);
            quickSort((this || _global).__originalMappings, util.compareByOriginalPositions);
        };
        exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
        return exports;
    }
    exports_118("dew", dew);
    return {
        setters: [
            function (util_dew_js_4_1) {
                util_dew_js_4 = util_dew_js_4_1;
            },
            function (binary_search_dew_js_1_1) {
                binary_search_dew_js_1 = binary_search_dew_js_1_1;
            },
            function (array_set_dew_js_2_1) {
                array_set_dew_js_2 = array_set_dew_js_2_1;
            },
            function (base64_vlq_dew_js_2_1) {
                base64_vlq_dew_js_2 = base64_vlq_dew_js_2_1;
            },
            function (quick_sort_dew_js_1_1) {
                quick_sort_dew_js_1 = quick_sort_dew_js_1_1;
            }
        ],
        execute: function () {
            exports = {}, _dewExec = false;
            _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
        }
    };
});
System.register("https://dev.jspm.io/npm:source-map@0.5.6/lib/source-node.dew", ["https://dev.jspm.io/npm:source-map@0.5.6/lib/source-map-generator.dew", "https://dev.jspm.io/npm:source-map@0.5.6/lib/util.dew"], function (exports_119, context_119) {
    "use strict";
    var source_map_generator_dew_js_1, util_dew_js_5, exports, _dewExec, _global;
    var __moduleName = context_119 && context_119.id;
    function dew() {
        if (_dewExec)
            return exports;
        _dewExec = true;
        /* -*- Mode: js; js-indent-level: 2; -*- */
        /*
         * Copyright 2011 Mozilla Foundation and contributors
         * Licensed under the New BSD license. See LICENSE or:
         * http://opensource.org/licenses/BSD-3-Clause
         */
        var SourceMapGenerator = source_map_generator_dew_js_1.dew().SourceMapGenerator;
        var util = util_dew_js_5.dew(); // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
        // operating systems these days (capturing the result).
        var REGEX_NEWLINE = /(\r?\n)/; // Newline character code for charCodeAt() comparisons
        var NEWLINE_CODE = 10; // Private symbol for identifying `SourceNode`s when multiple versions of
        // the source-map library are loaded. This MUST NOT CHANGE across
        // versions!
        var isSourceNode = "$$$isSourceNode$$$";
        /**
         * SourceNodes provide a way to abstract over interpolating/concatenating
         * snippets of generated JavaScript source code while maintaining the line and
         * column information associated with the original source code.
         *
         * @param aLine The original line number.
         * @param aColumn The original column number.
         * @param aSource The original source's filename.
         * @param aChunks Optional. An array of strings which are snippets of
         *        generated JS, or other SourceNodes.
         * @param aName The original identifier.
         */
        function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
            (this || _global).children = [];
            (this || _global).sourceContents = {};
            (this || _global).line = aLine == null ? null : aLine;
            (this || _global).column = aColumn == null ? null : aColumn;
            (this || _global).source = aSource == null ? null : aSource;
            (this || _global).name = aName == null ? null : aName;
            (this || _global)[isSourceNode] = true;
            if (aChunks != null)
                this.add(aChunks);
        }
        /**
         * Creates a SourceNode from generated code and a SourceMapConsumer.
         *
         * @param aGeneratedCode The generated code
         * @param aSourceMapConsumer The SourceMap for the generated code
         * @param aRelativePath Optional. The path that relative sources in the
         *        SourceMapConsumer should be relative to.
         */
        SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
            // The SourceNode we want to fill with the generated code
            // and the SourceMap
            var node = new SourceNode(); // All even indices of this array are one line of the generated code,
            // while all odd indices are the newlines between two adjacent lines
            // (since `REGEX_NEWLINE` captures its match).
            // Processed fragments are removed from this array, by calling `shiftNextLine`.
            var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
            var shiftNextLine = function () {
                var lineContents = remainingLines.shift(); // The last line of a file might not have a newline.
                var newLine = remainingLines.shift() || "";
                return lineContents + newLine;
            }; // We need to remember the position of "remainingLines"
            var lastGeneratedLine = 1, lastGeneratedColumn = 0; // The generate SourceNodes we need a code range.
            // To extract it current and last mapping is used.
            // Here we store the last mapping.
            var lastMapping = null;
            aSourceMapConsumer.eachMapping(function (mapping) {
                if (lastMapping !== null) {
                    // We add the code from "lastMapping" to "mapping":
                    // First check if there is a new line in between.
                    if (lastGeneratedLine < mapping.generatedLine) {
                        // Associate first line with "lastMapping"
                        addMappingWithCode(lastMapping, shiftNextLine());
                        lastGeneratedLine++;
                        lastGeneratedColumn = 0; // The remaining code is added without mapping
                    }
                    else {
                        // There is no new line in between.
                        // Associate the code between "lastGeneratedColumn" and
                        // "mapping.generatedColumn" with "lastMapping"
                        var nextLine = remainingLines[0];
                        var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
                        remainingLines[0] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
                        lastGeneratedColumn = mapping.generatedColumn;
                        addMappingWithCode(lastMapping, code); // No more remaining code, continue
                        lastMapping = mapping;
                        return;
                    }
                } // We add the generated code until the first mapping
                // to the SourceNode without any mapping.
                // Each line is added as separate string.
                while (lastGeneratedLine < mapping.generatedLine) {
                    node.add(shiftNextLine());
                    lastGeneratedLine++;
                }
                if (lastGeneratedColumn < mapping.generatedColumn) {
                    var nextLine = remainingLines[0];
                    node.add(nextLine.substr(0, mapping.generatedColumn));
                    remainingLines[0] = nextLine.substr(mapping.generatedColumn);
                    lastGeneratedColumn = mapping.generatedColumn;
                }
                lastMapping = mapping;
            }, this || _global); // We have processed all mappings.
            if (remainingLines.length > 0) {
                if (lastMapping) {
                    // Associate the remaining code in the current line with "lastMapping"
                    addMappingWithCode(lastMapping, shiftNextLine());
                } // and add the remaining lines without any mapping
                node.add(remainingLines.join(""));
            } // Copy sourcesContent into SourceNode
            aSourceMapConsumer.sources.forEach(function (sourceFile) {
                var content = aSourceMapConsumer.sourceContentFor(sourceFile);
                if (content != null) {
                    if (aRelativePath != null) {
                        sourceFile = util.join(aRelativePath, sourceFile);
                    }
                    node.setSourceContent(sourceFile, content);
                }
            });
            return node;
            function addMappingWithCode(mapping, code) {
                if (mapping === null || mapping.source === undefined) {
                    node.add(code);
                }
                else {
                    var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
                    node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
                }
            }
        };
        /**
         * Add a chunk of generated JS to this source node.
         *
         * @param aChunk A string snippet of generated JS code, another instance of
         *        SourceNode, or an array where each member is one of those things.
         */
        SourceNode.prototype.add = function SourceNode_add(aChunk) {
            if (Array.isArray(aChunk)) {
                aChunk.forEach(function (chunk) {
                    this.add(chunk);
                }, this || _global);
            }
            else if (aChunk[isSourceNode] || typeof aChunk === "string") {
                if (aChunk) {
                    (this || _global).children.push(aChunk);
                }
            }
            else {
                throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
            }
            return this || _global;
        };
        /**
         * Add a chunk of generated JS to the beginning of this source node.
         *
         * @param aChunk A string snippet of generated JS code, another instance of
         *        SourceNode, or an array where each member is one of those things.
         */
        SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
            if (Array.isArray(aChunk)) {
                for (var i = aChunk.length - 1; i >= 0; i--) {
                    this.prepend(aChunk[i]);
                }
            }
            else if (aChunk[isSourceNode] || typeof aChunk === "string") {
                (this || _global).children.unshift(aChunk);
            }
            else {
                throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
            }
            return this || _global;
        };
        /**
         * Walk over the tree of JS snippets in this node and its children. The
         * walking function is called once for each snippet of JS and is passed that
         * snippet and the its original associated source's line/column location.
         *
         * @param aFn The traversal function.
         */
        SourceNode.prototype.walk = function SourceNode_walk(aFn) {
            var chunk;
            for (var i = 0, len = (this || _global).children.length; i < len; i++) {
                chunk = (this || _global).children[i];
                if (chunk[isSourceNode]) {
                    chunk.walk(aFn);
                }
                else {
                    if (chunk !== '') {
                        aFn(chunk, {
                            source: (this || _global).source,
                            line: (this || _global).line,
                            column: (this || _global).column,
                            name: (this || _global).name
                        });
                    }
                }
            }
        };
        /**
         * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
         * each of `this.children`.
         *
         * @param aSep The separator.
         */
        SourceNode.prototype.join = function SourceNode_join(aSep) {
            var newChildren;
            var i;
            var len = (this || _global).children.length;
            if (len > 0) {
                newChildren = [];
                for (i = 0; i < len - 1; i++) {
                    newChildren.push((this || _global).children[i]);
                    newChildren.push(aSep);
                }
                newChildren.push((this || _global).children[i]);
                (this || _global).children = newChildren;
            }
            return this || _global;
        };
        /**
         * Call String.prototype.replace on the very right-most source snippet. Useful
         * for trimming whitespace from the end of a source node, etc.
         *
         * @param aPattern The pattern to replace.
         * @param aReplacement The thing to replace the pattern with.
         */
        SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
            var lastChild = (this || _global).children[(this || _global).children.length - 1];
            if (lastChild[isSourceNode]) {
                lastChild.replaceRight(aPattern, aReplacement);
            }
            else if (typeof lastChild === 'string') {
                (this || _global).children[(this || _global).children.length - 1] = lastChild.replace(aPattern, aReplacement);
            }
            else {
                (this || _global).children.push(''.replace(aPattern, aReplacement));
            }
            return this || _global;
        };
        /**
         * Set the source content for a source file. This will be added to the SourceMapGenerator
         * in the sourcesContent field.
         *
         * @param aSourceFile The filename of the source file
         * @param aSourceContent The content of the source file
         */
        SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
            (this || _global).sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
        };
        /**
         * Walk over the tree of SourceNodes. The walking function is called for each
         * source file content and is passed the filename and source content.
         *
         * @param aFn The traversal function.
         */
        SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
            for (var i = 0, len = (this || _global).children.length; i < len; i++) {
                if ((this || _global).children[i][isSourceNode]) {
                    (this || _global).children[i].walkSourceContents(aFn);
                }
            }
            var sources = Object.keys((this || _global).sourceContents);
            for (var i = 0, len = sources.length; i < len; i++) {
                aFn(util.fromSetString(sources[i]), (this || _global).sourceContents[sources[i]]);
            }
        };
        /**
         * Return the string representation of this source node. Walks over the tree
         * and concatenates all the various snippets together to one string.
         */
        SourceNode.prototype.toString = function SourceNode_toString() {
            var str = "";
            this.walk(function (chunk) {
                str += chunk;
            });
            return str;
        };
        /**
         * Returns the string representation of this source node along with a source
         * map.
         */
        SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
            var generated = {
                code: "",
                line: 1,
                column: 0
            };
            var map = new SourceMapGenerator(aArgs);
            var sourceMappingActive = false;
            var lastOriginalSource = null;
            var lastOriginalLine = null;
            var lastOriginalColumn = null;
            var lastOriginalName = null;
            this.walk(function (chunk, original) {
                generated.code += chunk;
                if (original.source !== null && original.line !== null && original.column !== null) {
                    if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
                        map.addMapping({
                            source: original.source,
                            original: {
                                line: original.line,
                                column: original.column
                            },
                            generated: {
                                line: generated.line,
                                column: generated.column
                            },
                            name: original.name
                        });
                    }
                    lastOriginalSource = original.source;
                    lastOriginalLine = original.line;
                    lastOriginalColumn = original.column;
                    lastOriginalName = original.name;
                    sourceMappingActive = true;
                }
                else if (sourceMappingActive) {
                    map.addMapping({
                        generated: {
                            line: generated.line,
                            column: generated.column
                        }
                    });
                    lastOriginalSource = null;
                    sourceMappingActive = false;
                }
                for (var idx = 0, length = chunk.length; idx < length; idx++) {
                    if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
                        generated.line++;
                        generated.column = 0; // Mappings end at eol
                        if (idx + 1 === length) {
                            lastOriginalSource = null;
                            sourceMappingActive = false;
                        }
                        else if (sourceMappingActive) {
                            map.addMapping({
                                source: original.source,
                                original: {
                                    line: original.line,
                                    column: original.column
                                },
                                generated: {
                                    line: generated.line,
                                    column: generated.column
                                },
                                name: original.name
                            });
                        }
                    }
                    else {
                        generated.column++;
                    }
                }
            });
            this.walkSourceContents(function (sourceFile, sourceContent) {
                map.setSourceContent(sourceFile, sourceContent);
            });
            return {
                code: generated.code,
                map: map
            };
        };
        exports.SourceNode = SourceNode;
        return exports;
    }
    exports_119("dew", dew);
    return {
        setters: [
            function (source_map_generator_dew_js_1_1) {
                source_map_generator_dew_js_1 = source_map_generator_dew_js_1_1;
            },
            function (util_dew_js_5_1) {
                util_dew_js_5 = util_dew_js_5_1;
            }
        ],
        execute: function () {
            exports = {}, _dewExec = false;
            _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
        }
    };
});
System.register("https://dev.jspm.io/npm:source-map@0.5.6/source-map.dew", ["https://dev.jspm.io/npm:source-map@0.5.6/lib/source-map-generator.dew", "https://dev.jspm.io/npm:source-map@0.5.6/lib/source-map-consumer.dew", "https://dev.jspm.io/npm:source-map@0.5.6/lib/source-node.dew"], function (exports_120, context_120) {
    "use strict";
    var source_map_generator_dew_js_2, source_map_consumer_dew_js_1, source_node_dew_js_1, exports, _dewExec;
    var __moduleName = context_120 && context_120.id;
    function dew() {
        if (_dewExec)
            return exports;
        _dewExec = true;
        /*
         * Copyright 2009-2011 Mozilla Foundation and contributors
         * Licensed under the New BSD license. See LICENSE.txt or:
         * http://opensource.org/licenses/BSD-3-Clause
         */
        exports.SourceMapGenerator = source_map_generator_dew_js_2.dew().SourceMapGenerator;
        exports.SourceMapConsumer = source_map_consumer_dew_js_1.dew().SourceMapConsumer;
        exports.SourceNode = source_node_dew_js_1.dew().SourceNode;
        return exports;
    }
    exports_120("dew", dew);
    return {
        setters: [
            function (source_map_generator_dew_js_2_1) {
                source_map_generator_dew_js_2 = source_map_generator_dew_js_2_1;
            },
            function (source_map_consumer_dew_js_1_1) {
                source_map_consumer_dew_js_1 = source_map_consumer_dew_js_1_1;
            },
            function (source_node_dew_js_1_1) {
                source_node_dew_js_1 = source_node_dew_js_1_1;
            }
        ],
        execute: function () {
            exports = {}, _dewExec = false;
        }
    };
});
System.register("https://dev.jspm.io/npm:source-map@0.5.6?dew", ["https://dev.jspm.io/npm:source-map@0.5.6/source-map.dew", "https://dev.jspm.io/npm:source-map@0.5.6/lib/source-map-generator.dew", "https://dev.jspm.io/npm:source-map@0.5.6/lib/source-map-consumer.dew", "https://dev.jspm.io/npm:source-map@0.5.6/lib/source-node.dew", "https://dev.jspm.io/npm:source-map@0.5.6/lib/base64-vlq.dew", "https://dev.jspm.io/npm:source-map@0.5.6/lib/util.dew", "https://dev.jspm.io/npm:source-map@0.5.6/lib/array-set.dew", "https://dev.jspm.io/npm:source-map@0.5.6/lib/mapping-list.dew", "https://dev.jspm.io/npm:source-map@0.5.6/lib/base64.dew", "https://dev.jspm.io/npm:source-map@0.5.6/lib/binary-search.dew", "https://dev.jspm.io/npm:source-map@0.5.6/lib/quick-sort.dew"], function (exports_121, context_121) {
    "use strict";
    var __moduleName = context_121 && context_121.id;
    return {
        setters: [
            function (source_map_dew_js_1_1) {
                exports_121({
                    "dew": source_map_dew_js_1_1["dew"]
                });
            },
            function (_32) {
            },
            function (_33) {
            },
            function (_34) {
            },
            function (_35) {
            },
            function (_36) {
            },
            function (_37) {
            },
            function (_38) {
            },
            function (_39) {
            },
            function (_40) {
            },
            function (_41) {
            }
        ],
        execute: function () {
        }
    };
});
System.register("https://dev.jspm.io/npm:@jspm/core@1/nodelibs/buffer", ["https://dev.jspm.io/npm:@jspm/core@1.1.1/nodelibs/buffer"], function (exports_122, context_122) {
    "use strict";
    var __moduleName = context_122 && context_122.id;
    var exportedNames_7 = {
        "default": true
    };
    function exportStar_9(m) {
        var exports = {};
        for (var n in m) {
            if (n !== "default" && !exportedNames_7.hasOwnProperty(n)) exports[n] = m[n];
        }
        exports_122(exports);
    }
    return {
        setters: [
            function (buffer_js_3_1) {
                exportStar_9(buffer_js_3_1);
                exports_122({
                    "default": buffer_js_3_1["default"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("file:///Users/norbert/Documents/workspace/deno/deno-ssr/vue-server-render/build.dev.dew", ["https://dev.jspm.io/npm:he@1?dew", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/stream", "https://dev.jspm.io/npm:lodash.template@4?dew", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/path", "https://dev.jspm.io/npm:serialize-javascript@2?dew", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/vm", "https://dev.jspm.io/npm:resolve@1?dew", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/@empty", "https://dev.jspm.io/npm:source-map@0.5.6?dew", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/process", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/buffer"], function (exports_123, context_123) {
    "use strict";
    var npm_he_1_dew_1, stream_js_2, npm_lodash_template_4_dew_1, path_js_5, npm_serialize_javascript_2_dew_1, vm_js_2, npm_resolve_1_dew_1, _empty_js_3, npm_source_map_0_5_6_dew_1, process_js_6, buffer_js_4, exports, _dewExec, _global;
    var __moduleName = context_123 && context_123.id;
    function dew() {
        if (_dewExec)
            return exports;
        _dewExec = true;
        function _nullRequire(id) {
            var e = new Error("Cannot find module '" + id + "'");
            e.code = "MODULE_NOT_FOUND";
            throw e;
        }
        var Buffer = buffer_js_4.default.Buffer;
        var process = process_js_6.default;
        Object.defineProperty(exports, "__esModule", {
            value: true,
        });
        function _interopDefault(ex) {
            return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
        }
        var he = _interopDefault(npm_he_1_dew_1.dew());
        /*  */
        var emptyObject = Object.freeze({}); // These helpers produce better VM code in JS engines due to their
        // explicitness and function inlining.
        function isUndef(v) {
            return v === undefined || v === null;
        }
        function isDef(v) {
            return v !== undefined && v !== null;
        }
        function isTrue(v) {
            return v === true;
        }
        function isFalse(v) {
            return v === false;
        }
        /**
         * Check if value is primitive.
         */
        function isPrimitive(value) {
            return typeof value === "string" || typeof value === "number" || // $flow-disable-line
                typeof value === "symbol" || typeof value === "boolean";
        }
        /**
         * Quick object check - this is primarily used to tell
         * Objects from primitive values when we know the value
         * is a JSON-compliant type.
         */
        function isObject(obj) {
            return obj !== null && typeof obj === "object";
        }
        /**
         * Get the raw type string of a value, e.g., [object Object].
         */
        var _toString = Object.prototype.toString;
        function toRawType(value) {
            return _toString.call(value).slice(8, -1);
        }
        /**
         * Strict object type check. Only returns true
         * for plain JavaScript objects.
         */
        function isPlainObject(obj) {
            return _toString.call(obj) === "[object Object]";
        }
        /**
         * Check if val is a valid array index.
         */
        function isValidArrayIndex(val) {
            var n = parseFloat(String(val));
            return n >= 0 && Math.floor(n) === n && isFinite(val);
        }
        function isPromise(val) {
            return isDef(val) && typeof val.then === "function" &&
                typeof val.catch === "function";
        }
        /**
         * Convert a value to a string that is actually rendered.
         */
        function toString(val) {
            return val == null
                ? ""
                : Array.isArray(val) || isPlainObject(val) && val.toString === _toString
                    ? JSON.stringify(val, null, 2)
                    : String(val);
        }
        /**
         * Convert an input value to a number for persistence.
         * If the conversion fails, return original string.
         */
        function toNumber(val) {
            var n = parseFloat(val);
            return isNaN(n) ? val : n;
        }
        /**
         * Make a map and return a function for checking if a key
         * is in that map.
         */
        function makeMap(str, expectsLowerCase) {
            var map = Object.create(null);
            var list = str.split(",");
            for (var i = 0; i < list.length; i++) {
                map[list[i]] = true;
            }
            return expectsLowerCase
                ? function (val) {
                    return map[val.toLowerCase()];
                }
                : function (val) {
                    return map[val];
                };
        }
        /**
         * Check if a tag is a built-in tag.
         */
        var isBuiltInTag = makeMap("slot,component", true);
        /**
         * Check if an attribute is a reserved attribute.
         */
        var isReservedAttribute = makeMap("key,ref,slot,slot-scope,is");
        /**
         * Remove an item from an array.
         */
        function remove(arr, item) {
            if (arr.length) {
                var index = arr.indexOf(item);
                if (index > -1) {
                    return arr.splice(index, 1);
                }
            }
        }
        /**
         * Check whether an object has the property.
         */
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        function hasOwn(obj, key) {
            return hasOwnProperty.call(obj, key);
        }
        /**
         * Create a cached version of a pure function.
         */
        function cached(fn) {
            var cache = Object.create(null);
            return function cachedFn(str) {
                var hit = cache[str];
                return hit || (cache[str] = fn(str));
            };
        }
        /**
         * Camelize a hyphen-delimited string.
         */
        var camelizeRE = /-(\w)/g;
        var camelize = cached(function (str) {
            return str.replace(camelizeRE, function (_, c) {
                return c ? c.toUpperCase() : "";
            });
        });
        /**
         * Capitalize a string.
         */
        var capitalize = cached(function (str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        });
        /**
         * Hyphenate a camelCase string.
         */
        var hyphenateRE = /\B([A-Z])/g;
        var hyphenate = cached(function (str) {
            return str.replace(hyphenateRE, "-$1").toLowerCase();
        });
        /**
         * Simple bind polyfill for environments that do not support it,
         * e.g., PhantomJS 1.x. Technically, we don't need this anymore
         * since native bind is now performant enough in most browsers.
         * But removing it would mean breaking code that was able to run in
         * PhantomJS 1.x, so this must be kept for backward compatibility.
         */
        /* istanbul ignore next */
        function polyfillBind(fn, ctx) {
            function boundFn(a) {
                var l = arguments.length;
                return l
                    ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a)
                    : fn.call(ctx);
            }
            boundFn._length = fn.length;
            return boundFn;
        }
        function nativeBind(fn, ctx) {
            return fn.bind(ctx);
        }
        var bind = Function.prototype.bind ? nativeBind : polyfillBind;
        /**
         * Mix properties into target object.
         */
        function extend(to, _from) {
            for (var key in _from) {
                to[key] = _from[key];
            }
            return to;
        }
        /**
         * Merge an Array of Objects into a single Object.
         */
        function toObject(arr) {
            var res = {};
            for (var i = 0; i < arr.length; i++) {
                if (arr[i]) {
                    extend(res, arr[i]);
                }
            }
            return res;
        }
        /* eslint-disable no-unused-vars */
        /**
         * Perform no operation.
         * Stubbing args to make Flow happy without leaving useless transpiled code
         * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
         */
        function noop(a, b, c) { }
        /**
         * Always return false.
         */
        var no = function (a, b, c) {
            return false;
        };
        /* eslint-enable no-unused-vars */
        /**
         * Return the same value.
         */
        var identity = function (_) {
            return _;
        };
        /**
         * Generate a string containing static keys from compiler modules.
         */
        function genStaticKeys(modules) {
            return modules.reduce(function (keys, m) {
                return keys.concat(m.staticKeys || []);
            }, []).join(",");
        }
        /**
         * Check if two values are loosely equal - that is,
         * if they are plain objects, do they have the same shape?
         */
        function looseEqual(a, b) {
            if (a === b) {
                return true;
            }
            var isObjectA = isObject(a);
            var isObjectB = isObject(b);
            if (isObjectA && isObjectB) {
                try {
                    var isArrayA = Array.isArray(a);
                    var isArrayB = Array.isArray(b);
                    if (isArrayA && isArrayB) {
                        return a.length === b.length && a.every(function (e, i) {
                            return looseEqual(e, b[i]);
                        });
                    }
                    else if (a instanceof Date && b instanceof Date) {
                        return a.getTime() === b.getTime();
                    }
                    else if (!isArrayA && !isArrayB) {
                        var keysA = Object.keys(a);
                        var keysB = Object.keys(b);
                        return keysA.length === keysB.length && keysA.every(function (key) {
                            return looseEqual(a[key], b[key]);
                        });
                    }
                    else {
                        /* istanbul ignore next */
                        return false;
                    }
                }
                catch (e) {
                    /* istanbul ignore next */
                    return false;
                }
            }
            else if (!isObjectA && !isObjectB) {
                return String(a) === String(b);
            }
            else {
                return false;
            }
        }
        /**
         * Return the first index at which a loosely equal value can be
         * found in the array (if value is a plain object, the array must
         * contain an object of the same shape), or -1 if it is not present.
         */
        function looseIndexOf(arr, val) {
            for (var i = 0; i < arr.length; i++) {
                if (looseEqual(arr[i], val)) {
                    return i;
                }
            }
            return -1;
        }
        /**
         * Ensure a function is called only once.
         */
        function once(fn) {
            var called = false;
            return function () {
                if (!called) {
                    called = true;
                    fn.apply(this, arguments);
                }
            };
        }
        /*  */
        var isAttr = makeMap("accept,accept-charset,accesskey,action,align,alt,async,autocomplete," +
            "autofocus,autoplay,autosave,bgcolor,border,buffered,challenge,charset," +
            "checked,cite,class,code,codebase,color,cols,colspan,content,http-equiv," +
            "name,contenteditable,contextmenu,controls,coords,data,datetime,default," +
            "defer,dir,dirname,disabled,download,draggable,dropzone,enctype,method,for," +
            "form,formaction,headers,height,hidden,high,href,hreflang,http-equiv," +
            "icon,id,ismap,itemprop,keytype,kind,label,lang,language,list,loop,low," +
            "manifest,max,maxlength,media,method,GET,POST,min,multiple,email,file," +
            "muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster," +
            "preload,radiogroup,readonly,rel,required,reversed,rows,rowspan,sandbox," +
            "scope,scoped,seamless,selected,shape,size,type,text,password,sizes,span," +
            "spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex," +
            "target,title,type,usemap,value,width,wrap");
        var unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/; // eslint-disable-line no-control-regex
        var isSSRUnsafeAttr = function (name) {
            return unsafeAttrCharRE.test(name);
        };
        /* istanbul ignore next */
        var isRenderableAttr = function (name) {
            return isAttr(name) || name.indexOf("data-") === 0 ||
                name.indexOf("aria-") === 0;
        };
        var propsToAttrMap = {
            acceptCharset: "accept-charset",
            className: "class",
            htmlFor: "for",
            httpEquiv: "http-equiv",
        };
        var ESC = {
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "&": "&amp;",
        };
        function escape(s) {
            return s.replace(/[<>"&]/g, escapeChar);
        }
        function escapeChar(a) {
            return ESC[a] || a;
        }
        var noUnitNumericStyleProps = {
            "animation-iteration-count": true,
            "border-image-outset": true,
            "border-image-slice": true,
            "border-image-width": true,
            "box-flex": true,
            "box-flex-group": true,
            "box-ordinal-group": true,
            "column-count": true,
            "columns": true,
            "flex": true,
            "flex-grow": true,
            "flex-positive": true,
            "flex-shrink": true,
            "flex-negative": true,
            "flex-order": true,
            "grid-row": true,
            "grid-row-end": true,
            "grid-row-span": true,
            "grid-row-start": true,
            "grid-column": true,
            "grid-column-end": true,
            "grid-column-span": true,
            "grid-column-start": true,
            "font-weight": true,
            "line-clamp": true,
            "line-height": true,
            "opacity": true,
            "order": true,
            "orphans": true,
            "tab-size": true,
            "widows": true,
            "z-index": true,
            "zoom": true,
            // SVG
            "fill-opacity": true,
            "flood-opacity": true,
            "stop-opacity": true,
            "stroke-dasharray": true,
            "stroke-dashoffset": true,
            "stroke-miterlimit": true,
            "stroke-opacity": true,
            "stroke-width": true,
        };
        /*  */
        // these are reserved for web because they are directly compiled away
        // during template compilation
        var isReservedAttr = makeMap("style,class"); // attributes that should be using props for binding
        var acceptValue = makeMap("input,textarea,option,select,progress");
        var mustUseProp = function (tag, type, attr) {
            return attr === "value" && acceptValue(tag) && type !== "button" ||
                attr === "selected" && tag === "option" ||
                attr === "checked" && tag === "input" ||
                attr === "muted" && tag === "video";
        };
        var isEnumeratedAttr = makeMap("contenteditable,draggable,spellcheck");
        var isValidContentEditableValue = makeMap("events,caret,typing,plaintext-only");
        var convertEnumeratedValue = function (key, value) {
            return isFalsyAttrValue(value) || value === "false"
                ? "false" // allow arbitrary string value for contenteditable
                : key === "contenteditable" && isValidContentEditableValue(value)
                    ? value
                    : "true";
        };
        var isBooleanAttr = makeMap("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare," +
            "default,defaultchecked,defaultmuted,defaultselected,defer,disabled," +
            "enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple," +
            "muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly," +
            "required,reversed,scoped,seamless,selected,sortable,translate," +
            "truespeed,typemustmatch,visible");
        var isFalsyAttrValue = function (val) {
            return val == null || val === false;
        };
        /*  */
        function renderAttrs(node) {
            var attrs = node.data.attrs;
            var res = "";
            var opts = node.parent && node.parent.componentOptions;
            if (isUndef(opts) || opts.Ctor.options.inheritAttrs !== false) {
                var parent = node.parent;
                while (isDef(parent)) {
                    if (isDef(parent.data) && isDef(parent.data.attrs)) {
                        attrs = extend(extend({}, attrs), parent.data.attrs);
                    }
                    parent = parent.parent;
                }
            }
            if (isUndef(attrs)) {
                return res;
            }
            for (var key in attrs) {
                if (isSSRUnsafeAttr(key)) {
                    continue;
                }
                if (key === "style") {
                    // leave it to the style module
                    continue;
                }
                res += renderAttr(key, attrs[key]);
            }
            return res;
        }
        function renderAttr(key, value) {
            if (isBooleanAttr(key)) {
                if (!isFalsyAttrValue(value)) {
                    return " " + key + '="' + key + '"';
                }
            }
            else if (isEnumeratedAttr(key)) {
                return " " + key + '="' + escape(convertEnumeratedValue(key, value)) +
                    '"';
            }
            else if (!isFalsyAttrValue(value)) {
                return " " + key + '="' + escape(String(value)) + '"';
            }
            return "";
        }
        /*  */
        var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
            this.tag = tag;
            this.data = data;
            this.children = children;
            this.text = text;
            this.elm = elm;
            this.ns = undefined;
            this.context = context;
            this.fnContext = undefined;
            this.fnOptions = undefined;
            this.fnScopeId = undefined;
            this.key = data && data.key;
            this.componentOptions = componentOptions;
            this.componentInstance = undefined;
            this.parent = undefined;
            this.raw = false;
            this.isStatic = false;
            this.isRootInsert = true;
            this.isComment = false;
            this.isCloned = false;
            this.isOnce = false;
            this.asyncFactory = asyncFactory;
            this.asyncMeta = undefined;
            this.isAsyncPlaceholder = false;
        };
        var prototypeAccessors = {
            child: {
                configurable: true,
            },
        }; // DEPRECATED: alias for componentInstance for backwards compat.
        /* istanbul ignore next */
        prototypeAccessors.child.get = function () {
            return this.componentInstance;
        };
        Object.defineProperties(VNode.prototype, prototypeAccessors);
        var createEmptyVNode = function (text) {
            if (text === void 0)
                text = "";
            var node = new VNode();
            node.text = text;
            node.isComment = true;
            return node;
        };
        function createTextVNode(val) {
            return new VNode(undefined, undefined, undefined, String(val));
        } // optimized shallow clone
        // used for static nodes and slot nodes because they may be reused across
        // multiple renders, cloning them avoids errors when DOM manipulations rely
        // on their elm reference.
        function cloneVNode(vnode) {
            var cloned = new VNode(vnode.tag, vnode.data, // #7975
            // clone children array to avoid mutating original in case of cloning
            // a child.
            vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
            cloned.ns = vnode.ns;
            cloned.isStatic = vnode.isStatic;
            cloned.key = vnode.key;
            cloned.isComment = vnode.isComment;
            cloned.fnContext = vnode.fnContext;
            cloned.fnOptions = vnode.fnOptions;
            cloned.fnScopeId = vnode.fnScopeId;
            cloned.asyncMeta = vnode.asyncMeta;
            cloned.isCloned = true;
            return cloned;
        }
        /*  */
        function renderDOMProps(node) {
            var props = node.data.domProps;
            var res = "";
            var parent = node.parent;
            while (isDef(parent)) {
                if (parent.data && parent.data.domProps) {
                    props = extend(extend({}, props), parent.data.domProps);
                }
                parent = parent.parent;
            }
            if (isUndef(props)) {
                return res;
            }
            var attrs = node.data.attrs;
            for (var key in props) {
                if (key === "innerHTML") {
                    setText(node, props[key], true);
                }
                else if (key === "textContent") {
                    setText(node, props[key], false);
                }
                else if (key === "value" && node.tag === "textarea") {
                    setText(node, props[key], false);
                }
                else {
                    // $flow-disable-line (WTF?)
                    var attr = propsToAttrMap[key] || key.toLowerCase();
                    if (isRenderableAttr(attr) && // avoid rendering double-bound props/attrs twice
                        !(isDef(attrs) && isDef(attrs[attr]))) {
                        res += renderAttr(attr, props[key]);
                    }
                }
            }
            return res;
        }
        function setText(node, text, raw) {
            var child = new VNode(undefined, undefined, undefined, text);
            child.raw = raw;
            node.children = [child];
        }
        /*  */
        /**
         * unicode letters used for parsing html tags, component names and property paths.
         * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
         * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
         */
        var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
        /**
         * Define a property.
         */
        function def(obj, key, val, enumerable) {
            Object.defineProperty(obj, key, {
                value: val,
                enumerable: !!enumerable,
                writable: true,
                configurable: true,
            });
        }
        /*  */
        // can we use __proto__?
        var hasProto = "__proto__" in {}; // Browser environment sniffing
        var inBrowser = typeof window !== "undefined";
        var inWeex = typeof WXEnvironment !== "undefined" && !!WXEnvironment.platform;
        var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
        var UA = inBrowser && "userAgent";
        var isIE = UA && /msie|trident/.test(UA);
        var isIE9 = UA && UA.indexOf("msie 9.0") > 0;
        var isEdge = UA && UA.indexOf("edge/") > 0;
        var isAndroid = UA && UA.indexOf("android") > 0 || weexPlatform === "android";
        var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === "ios";
        var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
        var isPhantomJS = UA && /phantomjs/.test(UA);
        var isFF = UA && UA.match(/firefox\/(\d+)/); // Firefox has a "watch" function on Object.prototype...
        var nativeWatch = {}.watch;
        if (inBrowser) {
            try {
                var opts = {};
                Object.defineProperty(opts, "passive", {
                    get: function get() { },
                }); // https://github.com/facebook/flow/issues/285
                window.addEventListener("test-passive", null, opts);
            }
            catch (e) { }
        } // this needs to be lazy-evaled because vue may be required before
        // vue-server-renderer can set VUE_ENV
        var _isServer;
        var isServerRendering = function () {
            if (_isServer === undefined) {
                /* istanbul ignore if */
                if (!inBrowser && !inWeex && typeof _global !== "undefined") {
                    // detect presence of vue-server-renderer and avoid
                    // Webpack shimming the process
                    _isServer = _global["process"] &&
                        _global["process"].env.VUE_ENV === "server";
                }
                else {
                    _isServer = false;
                }
            }
            return _isServer;
        }; // detect devtools
        var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
        /* istanbul ignore next */
        function isNative(Ctor) {
            return typeof Ctor === "function" && /native code/.test(Ctor.toString());
        }
        var hasSymbol = typeof Symbol !== "undefined" && isNative(Symbol) &&
            typeof Reflect !== "undefined" && isNative(Reflect.ownKeys);
        var _Set;
        /* istanbul ignore if */
        // $flow-disable-line
        if (typeof Set !== "undefined" && isNative(Set)) {
            // use native Set when available.
            _Set = Set;
        }
        else {
            // a non-standard Set polyfill that only works with primitive keys.
            _Set =
                /*@__PURE__*/
                function () {
                    function Set() {
                        this.set = Object.create(null);
                    }
                    Set.prototype.has = function has(key) {
                        return this.set[key] === true;
                    };
                    Set.prototype.add = function add(key) {
                        this.set[key] = true;
                    };
                    Set.prototype.clear = function clear() {
                        this.set = Object.create(null);
                    };
                    return Set;
                }();
        }
        var SSR_ATTR = "data-server-rendered";
        var ASSET_TYPES = ["component", "directive", "filter"];
        var LIFECYCLE_HOOKS = [
            "beforeCreate",
            "created",
            "beforeMount",
            "mounted",
            "beforeUpdate",
            "updated",
            "beforeDestroy",
            "destroyed",
            "activated",
            "deactivated",
            "errorCaptured",
            "serverPrefetch",
        ];
        /*  */
        var config = {
            /**
             * Option merge strategies (used in core/util/options)
             */
            // $flow-disable-line
            optionMergeStrategies: Object.create(null),
            /**
             * Whether to suppress warnings.
             */
            silent: false,
            /**
             * Show production mode tip message on boot?
             */
            productionTip: "development" !== "production",
            /**
             * Whether to enable devtools
             */
            devtools: "development" !== "production",
            /**
             * Whether to record perf
             */
            performance: false,
            /**
             * Error handler for watcher errors
             */
            errorHandler: null,
            /**
             * Warn handler for watcher warns
             */
            warnHandler: null,
            /**
             * Ignore certain custom elements
             */
            ignoredElements: [],
            /**
             * Custom user key aliases for v-on
             */
            // $flow-disable-line
            keyCodes: Object.create(null),
            /**
             * Check if a tag is reserved so that it cannot be registered as a
             * component. This is platform-dependent and may be overwritten.
             */
            isReservedTag: no,
            /**
             * Check if an attribute is reserved so that it cannot be used as a component
             * prop. This is platform-dependent and may be overwritten.
             */
            isReservedAttr: no,
            /**
             * Check if a tag is an unknown element.
             * Platform-dependent.
             */
            isUnknownElement: no,
            /**
             * Get the namespace of an element
             */
            getTagNamespace: noop,
            /**
             * Parse the real tag name for the specific platform.
             */
            parsePlatformTagName: identity,
            /**
             * Check if an attribute must be bound using property, e.g. value
             * Platform-dependent.
             */
            mustUseProp: no,
            /**
             * Perform updates asynchronously. Intended to be used by Vue Test Utils
             * This will significantly reduce performance if set to false.
             */
            async: true,
            /**
             * Exposed for legacy reasons
             */
            _lifecycleHooks: LIFECYCLE_HOOKS,
        };
        /*  */
        var warn = noop;
        var tip = noop;
        var generateComponentTrace = noop; // work around flow check
        var formatComponentName = noop;
        {
            var hasConsole = typeof console !== "undefined";
            var classifyRE = /(?:^|[-_])(\w)/g;
            var classify = function (str) {
                return str.replace(classifyRE, function (c) {
                    return c.toUpperCase();
                }).replace(/[-_]/g, "");
            };
            warn = function (msg, vm) {
                var trace = vm ? generateComponentTrace(vm) : "";
                if (hasConsole && !config.silent) {
                    console.error("[Vue warn]: " + msg + trace);
                }
            };
            tip = function (msg, vm) {
                if (hasConsole && !config.silent) {
                    console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ""));
                }
            };
            formatComponentName = function (vm, includeFile) {
                if (vm.$root === vm) {
                    return "<Root>";
                }
                var options = typeof vm === "function" && vm.cid != null
                    ? vm.options
                    : vm._isVue
                        ? vm.$options || vm.constructor.options
                        : vm;
                var name = options.name || options._componentTag;
                var file = options.__file;
                if (!name && file) {
                    var match = file.match(/([^/\\]+)\.vue$/);
                    name = match && match[1];
                }
                return (name ? "<" + classify(name) + ">" : "<Anonymous>") +
                    (file && includeFile !== false ? " at " + file : "");
            };
            var repeat = function (str, n) {
                var res = "";
                while (n) {
                    if (n % 2 === 1) {
                        res += str;
                    }
                    if (n > 1) {
                        str += str;
                    }
                    n >>= 1;
                }
                return res;
            };
            generateComponentTrace = function (vm) {
                if (vm._isVue && vm.$parent) {
                    var tree = [];
                    var currentRecursiveSequence = 0;
                    while (vm) {
                        if (tree.length > 0) {
                            var last = tree[tree.length - 1];
                            if (last.constructor === vm.constructor) {
                                currentRecursiveSequence++;
                                vm = vm.$parent;
                                continue;
                            }
                            else if (currentRecursiveSequence > 0) {
                                tree[tree.length - 1] = [last, currentRecursiveSequence];
                                currentRecursiveSequence = 0;
                            }
                        }
                        tree.push(vm);
                        vm = vm.$parent;
                    }
                    return "\n\nfound in\n\n" + tree.map(function (vm, i) {
                        return "" + (i === 0 ? "---> " : repeat(" ", 5 + i * 2)) +
                            (Array.isArray(vm)
                                ? formatComponentName(vm[0]) + "... (" + vm[1] +
                                    " recursive calls)"
                                : formatComponentName(vm));
                    }).join("\n");
                }
                else {
                    return "\n\n(found in " + formatComponentName(vm) + ")";
                }
            };
        }
        /*  */
        var uid = 0;
        /**
         * A dep is an observable that can have multiple
         * directives subscribing to it.
         */
        var Dep = function Dep() {
            this.id = uid++;
            this.subs = [];
        };
        Dep.prototype.addSub = function addSub(sub) {
            this.subs.push(sub);
        };
        Dep.prototype.removeSub = function removeSub(sub) {
            remove(this.subs, sub);
        };
        Dep.prototype.depend = function depend() {
            if (Dep.target) {
                Dep.target.addDep(this);
            }
        };
        Dep.prototype.notify = function notify() {
            // stabilize the subscriber list first
            var subs = this.subs.slice();
            for (var i = 0, l = subs.length; i < l; i++) {
                subs[i].update();
            }
        }; // The current target watcher being evaluated.
        // This is globally unique because only one watcher
        // can be evaluated at a time.
        Dep.target = null;
        var targetStack = [];
        function pushTarget(target) {
            targetStack.push(target);
            Dep.target = target;
        }
        function popTarget() {
            targetStack.pop();
            Dep.target = targetStack[targetStack.length - 1];
        }
        /*
         * not type checking this file because flow doesn't play well with
         * dynamically accessing methods on Array prototype
         */
        var arrayProto = Array.prototype;
        var arrayMethods = Object.create(arrayProto);
        var methodsToPatch = [
            "push",
            "pop",
            "shift",
            "unshift",
            "splice",
            "sort",
            "reverse",
        ];
        /**
         * Intercept mutating methods and emit events
         */
        methodsToPatch.forEach(function (method) {
            // cache original method
            var original = arrayProto[method];
            def(arrayMethods, method, function mutator() {
                var args = [], len = arguments.length;
                while (len--)
                    args[len] = arguments[len];
                var result = original.apply(this, args);
                var ob = this.__ob__;
                var inserted;
                switch (method) {
                    case "push":
                    case "unshift":
                        inserted = args;
                        break;
                    case "splice":
                        inserted = args.slice(2);
                        break;
                }
                if (inserted) {
                    ob.observeArray(inserted);
                } // notify change
                ob.dep.notify();
                return result;
            });
        });
        /*  */
        var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
        /**
         * In some cases we may want to disable observation inside a component's
         * update computation.
         */
        var shouldObserve = true;
        function toggleObserving(value) {
            shouldObserve = value;
        }
        /**
         * Observer class that is attached to each observed
         * object. Once attached, the observer converts the target
         * object's property keys into getter/setters that
         * collect dependencies and dispatch updates.
         */
        var Observer = function Observer(value) {
            this.value = value;
            this.dep = new Dep();
            this.vmCount = 0;
            def(value, "__ob__", this);
            if (Array.isArray(value)) {
                if (hasProto) {
                    protoAugment(value, arrayMethods);
                }
                else {
                    copyAugment(value, arrayMethods, arrayKeys);
                }
                this.observeArray(value);
            }
            else {
                this.walk(value);
            }
        };
        /**
         * Walk through all properties and convert them into
         * getter/setters. This method should only be called when
         * value type is Object.
         */
        Observer.prototype.walk = function walk(obj) {
            var keys = Object.keys(obj);
            for (var i = 0; i < keys.length; i++) {
                defineReactive$$1(obj, keys[i]);
            }
        };
        /**
         * Observe a list of Array items.
         */
        Observer.prototype.observeArray = function observeArray(items) {
            for (var i = 0, l = items.length; i < l; i++) {
                observe(items[i]);
            }
        }; // helpers
        /**
         * Augment a target Object or Array by intercepting
         * the prototype chain using __proto__
         */
        function protoAugment(target, src) {
            /* eslint-disable no-proto */
            target.__proto__ = src;
            /* eslint-enable no-proto */
        }
        /**
         * Augment a target Object or Array by defining
         * hidden properties.
         */
        /* istanbul ignore next */
        function copyAugment(target, src, keys) {
            for (var i = 0, l = keys.length; i < l; i++) {
                var key = keys[i];
                def(target, key, src[key]);
            }
        }
        /**
         * Attempt to create an observer instance for a value,
         * returns the new observer if successfully observed,
         * or the existing observer if the value already has one.
         */
        function observe(value, asRootData) {
            if (!isObject(value) || value instanceof VNode) {
                return;
            }
            var ob;
            if (hasOwn(value, "__ob__") && value.__ob__ instanceof Observer) {
                ob = value.__ob__;
            }
            else if (shouldObserve && !isServerRendering() &&
                (Array.isArray(value) || isPlainObject(value)) &&
                Object.isExtensible(value) && !value._isVue) {
                ob = new Observer(value);
            }
            if (asRootData && ob) {
                ob.vmCount++;
            }
            return ob;
        }
        /**
         * Define a reactive property on an Object.
         */
        function defineReactive$$1(obj, key, val, customSetter, shallow) {
            var dep = new Dep();
            var property = Object.getOwnPropertyDescriptor(obj, key);
            if (property && property.configurable === false) {
                return;
            } // cater for pre-defined getter/setters
            var getter = property && property.get;
            var setter = property && property.set;
            if ((!getter || setter) && arguments.length === 2) {
                val = obj[key];
            }
            var childOb = !shallow && observe(val);
            Object.defineProperty(obj, key, {
                enumerable: true,
                configurable: true,
                get: function reactiveGetter() {
                    var value = getter ? getter.call(obj) : val;
                    if (Dep.target) {
                        dep.depend();
                        if (childOb) {
                            childOb.dep.depend();
                            if (Array.isArray(value)) {
                                dependArray(value);
                            }
                        }
                    }
                    return value;
                },
                set: function reactiveSetter(newVal) {
                    var value = getter ? getter.call(obj) : val;
                    /* eslint-disable no-self-compare */
                    if (newVal === value || newVal !== newVal && value !== value) {
                        return;
                    }
                    /* eslint-enable no-self-compare */
                    if (customSetter) {
                        customSetter();
                    } // #7981: for accessor properties without setter
                    if (getter && !setter) {
                        return;
                    }
                    if (setter) {
                        setter.call(obj, newVal);
                    }
                    else {
                        val = newVal;
                    }
                    childOb = !shallow && observe(newVal);
                    dep.notify();
                },
            });
        }
        /**
         * Set a property on an object. Adds the new property and
         * triggers change notification if the property doesn't
         * already exist.
         */
        function set(target, key, val) {
            if (isUndef(target) || isPrimitive(target)) {
                warn("Cannot set reactive property on undefined, null, or primitive value: " +
                    target);
            }
            if (Array.isArray(target) && isValidArrayIndex(key)) {
                target.length = Math.max(target.length, key);
                target.splice(key, 1, val);
                return val;
            }
            if (key in target && !(key in Object.prototype)) {
                target[key] = val;
                return val;
            }
            var ob = target.__ob__;
            if (target._isVue || ob && ob.vmCount) {
                warn("Avoid adding reactive properties to a Vue instance or its root $data " +
                    "at runtime - declare it upfront in the data option.");
                return val;
            }
            if (!ob) {
                target[key] = val;
                return val;
            }
            defineReactive$$1(ob.value, key, val);
            ob.dep.notify();
            return val;
        }
        /**
         * Collect dependencies on array elements when the array is touched, since
         * we cannot intercept array element access like property getters.
         */
        function dependArray(value) {
            for (var e = void 0, i = 0, l = value.length; i < l; i++) {
                e = value[i];
                e && e.__ob__ && e.__ob__.dep.depend();
                if (Array.isArray(e)) {
                    dependArray(e);
                }
            }
        }
        /*  */
        /**
         * Option overwriting strategies are functions that handle
         * how to merge a parent option value and a child option
         * value into the final value.
         */
        var strats = config.optionMergeStrategies;
        /**
         * Options with restrictions
         */
        {
            strats.el = strats.propsData = function (parent, child, vm, key) {
                if (!vm) {
                    warn('option "' + key + '" can only be used during instance ' +
                        "creation with the `new` keyword.");
                }
                return defaultStrat(parent, child);
            };
        }
        /**
         * Helper that recursively merges two data objects together.
         */
        function mergeData(to, from) {
            if (!from) {
                return to;
            }
            var key, toVal, fromVal;
            var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);
            for (var i = 0; i < keys.length; i++) {
                key = keys[i]; // in case the object is already observed...
                if (key === "__ob__") {
                    continue;
                }
                toVal = to[key];
                fromVal = from[key];
                if (!hasOwn(to, key)) {
                    set(to, key, fromVal);
                }
                else if (toVal !== fromVal && isPlainObject(toVal) && isPlainObject(fromVal)) {
                    mergeData(toVal, fromVal);
                }
            }
            return to;
        }
        /**
         * Data
         */
        function mergeDataOrFn(parentVal, childVal, vm) {
            if (!vm) {
                // in a Vue.extend merge, both should be functions
                if (!childVal) {
                    return parentVal;
                }
                if (!parentVal) {
                    return childVal;
                } // when parentVal & childVal are both present,
                // we need to return a function that returns the
                // merged result of both functions... no need to
                // check if parentVal is a function here because
                // it has to be a function to pass previous merges.
                return function mergedDataFn() {
                    return mergeData(typeof childVal === "function" ? childVal.call(this, this) : childVal, typeof parentVal === "function"
                        ? parentVal.call(this, this)
                        : parentVal);
                };
            }
            else {
                return function mergedInstanceDataFn() {
                    // instance merge
                    var instanceData = typeof childVal === "function"
                        ? childVal.call(vm, vm)
                        : childVal;
                    var defaultData = typeof parentVal === "function"
                        ? parentVal.call(vm, vm)
                        : parentVal;
                    if (instanceData) {
                        return mergeData(instanceData, defaultData);
                    }
                    else {
                        return defaultData;
                    }
                };
            }
        }
        strats.data = function (parentVal, childVal, vm) {
            if (!vm) {
                if (childVal && typeof childVal !== "function") {
                    warn('The "data" option should be a function ' +
                        "that returns a per-instance value in component " + "definitions.", vm);
                    return parentVal;
                }
                return mergeDataOrFn(parentVal, childVal);
            }
            return mergeDataOrFn(parentVal, childVal, vm);
        };
        /**
         * Hooks and props are merged as arrays.
         */
        function mergeHook(parentVal, childVal) {
            var res = childVal
                ? parentVal
                    ? parentVal.concat(childVal)
                    : Array.isArray(childVal)
                        ? childVal
                        : [childVal]
                : parentVal;
            return res ? dedupeHooks(res) : res;
        }
        function dedupeHooks(hooks) {
            var res = [];
            for (var i = 0; i < hooks.length; i++) {
                if (res.indexOf(hooks[i]) === -1) {
                    res.push(hooks[i]);
                }
            }
            return res;
        }
        LIFECYCLE_HOOKS.forEach(function (hook) {
            strats[hook] = mergeHook;
        });
        /**
         * Assets
         *
         * When a vm is present (instance creation), we need to do
         * a three-way merge between constructor options, instance
         * options and parent options.
         */
        function mergeAssets(parentVal, childVal, vm, key) {
            var res = Object.create(parentVal || null);
            if (childVal) {
                assertObjectType(key, childVal, vm);
                return extend(res, childVal);
            }
            else {
                return res;
            }
        }
        ASSET_TYPES.forEach(function (type) {
            strats[type + "s"] = mergeAssets;
        });
        /**
         * Watchers.
         *
         * Watchers hashes should not overwrite one
         * another, so we merge them as arrays.
         */
        strats.watch = function (parentVal, childVal, vm, key) {
            // work around Firefox's Object.prototype.watch...
            if (parentVal === nativeWatch) {
                parentVal = undefined;
            }
            if (childVal === nativeWatch) {
                childVal = undefined;
            }
            /* istanbul ignore if */
            if (!childVal) {
                return Object.create(parentVal || null);
            }
            {
                assertObjectType(key, childVal, vm);
            }
            if (!parentVal) {
                return childVal;
            }
            var ret = {};
            extend(ret, parentVal);
            for (var key$1 in childVal) {
                var parent = ret[key$1];
                var child = childVal[key$1];
                if (parent && !Array.isArray(parent)) {
                    parent = [parent];
                }
                ret[key$1] = parent
                    ? parent.concat(child)
                    : Array.isArray(child)
                        ? child
                        : [child];
            }
            return ret;
        };
        /**
         * Other object hashes.
         */
        strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
            if (childVal && "development" !== "production") {
                assertObjectType(key, childVal, vm);
            }
            if (!parentVal) {
                return childVal;
            }
            var ret = Object.create(null);
            extend(ret, parentVal);
            if (childVal) {
                extend(ret, childVal);
            }
            return ret;
        };
        strats.provide = mergeDataOrFn;
        /**
         * Default strategy.
         */
        var defaultStrat = function (parentVal, childVal) {
            return childVal === undefined ? parentVal : childVal;
        };
        /**
         * Validate component names
         */
        function checkComponents(options) {
            for (var key in options.components) {
                validateComponentName(key);
            }
        }
        function validateComponentName(name) {
            if (!new RegExp("^[a-zA-Z][\\-\\.0-9_" + unicodeRegExp.source + "]*$").test(name)) {
                warn('Invalid component name: "' + name + '". Component names ' +
                    "should conform to valid custom element name in html5 specification.");
            }
            if (isBuiltInTag(name) || config.isReservedTag(name)) {
                warn("Do not use built-in or reserved HTML elements as component " + "id: " +
                    name);
            }
        }
        /**
         * Ensure all props option syntax are normalized into the
         * Object-based format.
         */
        function normalizeProps(options, vm) {
            var props = options.props;
            if (!props) {
                return;
            }
            var res = {};
            var i, val, name;
            if (Array.isArray(props)) {
                i = props.length;
                while (i--) {
                    val = props[i];
                    if (typeof val === "string") {
                        name = camelize(val);
                        res[name] = {
                            type: null,
                        };
                    }
                    else {
                        warn("props must be strings when using array syntax.");
                    }
                }
            }
            else if (isPlainObject(props)) {
                for (var key in props) {
                    val = props[key];
                    name = camelize(key);
                    res[name] = isPlainObject(val) ? val : {
                        type: val,
                    };
                }
            }
            else {
                warn('Invalid value for option "props": expected an Array or an Object, ' +
                    "but got " + toRawType(props) + ".", vm);
            }
            options.props = res;
        }
        /**
         * Normalize all injections into Object-based format
         */
        function normalizeInject(options, vm) {
            var inject = options.inject;
            if (!inject) {
                return;
            }
            var normalized = options.inject = {};
            if (Array.isArray(inject)) {
                for (var i = 0; i < inject.length; i++) {
                    normalized[inject[i]] = {
                        from: inject[i],
                    };
                }
            }
            else if (isPlainObject(inject)) {
                for (var key in inject) {
                    var val = inject[key];
                    normalized[key] = isPlainObject(val)
                        ? extend({
                            from: key,
                        }, val)
                        : {
                            from: val,
                        };
                }
            }
            else {
                warn('Invalid value for option "inject": expected an Array or an Object, ' +
                    "but got " + toRawType(inject) + ".", vm);
            }
        }
        /**
         * Normalize raw function directives into object format.
         */
        function normalizeDirectives(options) {
            var dirs = options.directives;
            if (dirs) {
                for (var key in dirs) {
                    var def$$1 = dirs[key];
                    if (typeof def$$1 === "function") {
                        dirs[key] = {
                            bind: def$$1,
                            update: def$$1,
                        };
                    }
                }
            }
        }
        function assertObjectType(name, value, vm) {
            if (!isPlainObject(value)) {
                warn('Invalid value for option "' + name + '": expected an Object, ' +
                    "but got " + toRawType(value) + ".", vm);
            }
        }
        /**
         * Merge two option objects into a new one.
         * Core utility used in both instantiation and inheritance.
         */
        function mergeOptions(parent, child, vm) {
            {
                checkComponents(child);
            }
            if (typeof child === "function") {
                child = child.options;
            }
            normalizeProps(child, vm);
            normalizeInject(child, vm);
            normalizeDirectives(child); // Apply extends and mixins on the child options,
            // but only if it is a raw options object that isn't
            // the result of another mergeOptions call.
            // Only merged options has the _base property.
            if (!child._base) {
                if (child.extends) {
                    parent = mergeOptions(parent, child.extends, vm);
                }
                if (child.mixins) {
                    for (var i = 0, l = child.mixins.length; i < l; i++) {
                        parent = mergeOptions(parent, child.mixins[i], vm);
                    }
                }
            }
            var options = {};
            var key;
            for (key in parent) {
                mergeField(key);
            }
            for (key in child) {
                if (!hasOwn(parent, key)) {
                    mergeField(key);
                }
            }
            function mergeField(key) {
                var strat = strats[key] || defaultStrat;
                options[key] = strat(parent[key], child[key], vm, key);
            }
            return options;
        }
        /**
         * Resolve an asset.
         * This function is used because child instances need access
         * to assets defined in its ancestor chain.
         */
        function resolveAsset(options, type, id, warnMissing) {
            /* istanbul ignore if */
            if (typeof id !== "string") {
                return;
            }
            var assets = options[type]; // check local registration variations first
            if (hasOwn(assets, id)) {
                return assets[id];
            }
            var camelizedId = camelize(id);
            if (hasOwn(assets, camelizedId)) {
                return assets[camelizedId];
            }
            var PascalCaseId = capitalize(camelizedId);
            if (hasOwn(assets, PascalCaseId)) {
                return assets[PascalCaseId];
            } // fallback to prototype chain
            var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
            if (warnMissing && !res) {
                warn("Failed to resolve " + type.slice(0, -1) + ": " + id, options);
            }
            return res;
        }
        /*  */
        function validateProp(key, propOptions, propsData, vm) {
            var prop = propOptions[key];
            var absent = !hasOwn(propsData, key);
            var value = propsData[key]; // boolean casting
            var booleanIndex = getTypeIndex(Boolean, prop.type);
            if (booleanIndex > -1) {
                if (absent && !hasOwn(prop, "default")) {
                    value = false;
                }
                else if (value === "" || value === hyphenate(key)) {
                    // only cast empty string / same name to boolean if
                    // boolean has higher priority
                    var stringIndex = getTypeIndex(String, prop.type);
                    if (stringIndex < 0 || booleanIndex < stringIndex) {
                        value = true;
                    }
                }
            } // check default value
            if (value === undefined) {
                value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,
                // make sure to observe it.
                var prevShouldObserve = shouldObserve;
                toggleObserving(true);
                observe(value);
                toggleObserving(prevShouldObserve);
            }
            {
                assertProp(prop, key, value, vm, absent);
            }
            return value;
        }
        /**
         * Get the default value of a prop.
         */
        function getPropDefaultValue(vm, prop, key) {
            // no default, return undefined
            if (!hasOwn(prop, "default")) {
                return undefined;
            }
            var def = prop.default; // warn against non-factory defaults for Object & Array
            if (isObject(def)) {
                warn('Invalid default value for prop "' + key + '": ' +
                    "Props with type Object/Array must use a factory function " +
                    "to return the default value.", vm);
            } // the raw prop value was also undefined from previous render,
            // return previous default value to avoid unnecessary watcher trigger
            if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined &&
                vm._props[key] !== undefined) {
                return vm._props[key];
            } // call factory function for non-Function types
            // a value is Function if its prototype is function even across different execution context
            return typeof def === "function" && getType(prop.type) !== "Function"
                ? def.call(vm)
                : def;
        }
        /**
         * Assert whether a prop is valid.
         */
        function assertProp(prop, name, value, vm, absent) {
            if (prop.required && absent) {
                warn('Missing required prop: "' + name + '"', vm);
                return;
            }
            if (value == null && !prop.required) {
                return;
            }
            var type = prop.type;
            var valid = !type || type === true;
            var expectedTypes = [];
            if (type) {
                if (!Array.isArray(type)) {
                    type = [type];
                }
                for (var i = 0; i < type.length && !valid; i++) {
                    var assertedType = assertType(value, type[i]);
                    expectedTypes.push(assertedType.expectedType || "");
                    valid = assertedType.valid;
                }
            }
            if (!valid) {
                warn(getInvalidTypeMessage(name, value, expectedTypes), vm);
                return;
            }
            var validator = prop.validator;
            if (validator) {
                if (!validator(value)) {
                    warn('Invalid prop: custom validator check failed for prop "' + name +
                        '".', vm);
                }
            }
        }
        var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;
        function assertType(value, type) {
            var valid;
            var expectedType = getType(type);
            if (simpleCheckRE.test(expectedType)) {
                var t = typeof value;
                valid = t === expectedType.toLowerCase(); // for primitive wrapper objects
                if (!valid && t === "object") {
                    valid = value instanceof type;
                }
            }
            else if (expectedType === "Object") {
                valid = isPlainObject(value);
            }
            else if (expectedType === "Array") {
                valid = Array.isArray(value);
            }
            else {
                valid = value instanceof type;
            }
            return {
                valid: valid,
                expectedType: expectedType,
            };
        }
        /**
         * Use function string name to check built-in types,
         * because a simple equality check will fail when running
         * across different vms / iframes.
         */
        function getType(fn) {
            var match = fn && fn.toString().match(/^\s*function (\w+)/);
            return match ? match[1] : "";
        }
        function isSameType(a, b) {
            return getType(a) === getType(b);
        }
        function getTypeIndex(type, expectedTypes) {
            if (!Array.isArray(expectedTypes)) {
                return isSameType(expectedTypes, type) ? 0 : -1;
            }
            for (var i = 0, len = expectedTypes.length; i < len; i++) {
                if (isSameType(expectedTypes[i], type)) {
                    return i;
                }
            }
            return -1;
        }
        function getInvalidTypeMessage(name, value, expectedTypes) {
            var message = 'Invalid prop: type check failed for prop "' + name + '".' +
                " Expected " + expectedTypes.map(capitalize).join(", ");
            var expectedType = expectedTypes[0];
            var receivedType = toRawType(value);
            var expectedValue = styleValue(value, expectedType);
            var receivedValue = styleValue(value, receivedType); // check if we need to specify expected value
            if (expectedTypes.length === 1 && isExplicable(expectedType) &&
                !isBoolean(expectedType, receivedType)) {
                message += " with value " + expectedValue;
            }
            message += ", got " + receivedType + " "; // check if we need to specify received value
            if (isExplicable(receivedType)) {
                message += "with value " + receivedValue + ".";
            }
            return message;
        }
        function styleValue(value, type) {
            if (type === "String") {
                return '"' + value + '"';
            }
            else if (type === "Number") {
                return "" + Number(value);
            }
            else {
                return "" + value;
            }
        }
        function isExplicable(value) {
            var explicitTypes = ["string", "number", "boolean"];
            return explicitTypes.some(function (elem) {
                return value.toLowerCase() === elem;
            });
        }
        function isBoolean() {
            var args = [], len = arguments.length;
            while (len--)
                args[len] = arguments[len];
            return args.some(function (elem) {
                return elem.toLowerCase() === "boolean";
            });
        }
        /*  */
        function handleError(err, vm, info) {
            // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
            // See: https://github.com/vuejs/vuex/issues/1505
            pushTarget();
            try {
                if (vm) {
                    var cur = vm;
                    while (cur = cur.$parent) {
                        var hooks = cur.$options.errorCaptured;
                        if (hooks) {
                            for (var i = 0; i < hooks.length; i++) {
                                try {
                                    var capture = hooks[i].call(cur, err, vm, info) === false;
                                    if (capture) {
                                        return;
                                    }
                                }
                                catch (e) {
                                    globalHandleError(e, cur, "errorCaptured hook");
                                }
                            }
                        }
                    }
                }
                globalHandleError(err, vm, info);
            }
            finally {
                popTarget();
            }
        }
        function invokeWithErrorHandling(handler, context, args, vm, info) {
            var res;
            try {
                res = args ? handler.apply(context, args) : handler.call(context);
                if (res && !res._isVue && isPromise(res) && !res._handled) {
                    res.catch(function (e) {
                        return handleError(e, vm, info + " (Promise/async)");
                    }); // issue #9511
                    // avoid catch triggering multiple times when nested calls
                    res._handled = true;
                }
            }
            catch (e) {
                handleError(e, vm, info);
            }
            return res;
        }
        function globalHandleError(err, vm, info) {
            logError(err, vm, info);
        }
        function logError(err, vm, info) {
            {
                warn("Error in " + info + ': "' + err.toString() + '"', vm);
            }
            /* istanbul ignore else */
            if ((inBrowser || inWeex) && typeof console !== "undefined") {
                console.error(err);
            }
            else {
                throw err;
            }
        }
        /*  */
        var callbacks = [];
        function flushCallbacks() {
            var copies = callbacks.slice(0);
            callbacks.length = 0;
            for (var i = 0; i < copies.length; i++) {
                copies[i]();
            }
        } // The nextTick behavior leverages the microtask queue, which can be accessed
        // via either native Promise.then or MutationObserver.
        // MutationObserver has wider support, however it is seriously bugged in
        // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
        // completely stops working after triggering a few times... so, if native
        // Promise is available, we will use it:
        /* istanbul ignore next, $flow-disable-line */
        if (typeof Promise !== "undefined" && isNative(Promise))
            ;
        else if (!isIE && typeof MutationObserver !== "undefined" &&
            (isNative(MutationObserver) || // PhantomJS and iOS 7.x
                MutationObserver.toString() === "[object MutationObserverConstructor]")) {
            // Use MutationObserver where native Promise is not available,
            // e.g. PhantomJS, iOS7, Android 4.4
            // (#6466 MutationObserver is unreliable in IE11)
            var counter = 1;
            var observer = new MutationObserver(flushCallbacks);
            var textNode = {};
            observer.observe(textNode, {
                characterData: true,
            });
        }
        else if (typeof setImmediate !== "undefined" && isNative(setImmediate))
            ;
        /*  */
        /*  */
        function genClassForVnode(vnode) {
            var data = vnode.data;
            var parentNode = vnode;
            var childNode = vnode;
            while (isDef(childNode.componentInstance)) {
                childNode = childNode.componentInstance._vnode;
                if (childNode && childNode.data) {
                    data = mergeClassData(childNode.data, data);
                }
            }
            while (isDef(parentNode = parentNode.parent)) {
                if (parentNode && parentNode.data) {
                    data = mergeClassData(data, parentNode.data);
                }
            }
            return renderClass(data.staticClass, data.class);
        }
        function mergeClassData(child, parent) {
            return {
                staticClass: concat(child.staticClass, parent.staticClass),
                class: isDef(child.class) ? [child.class, parent.class] : parent.class,
            };
        }
        function renderClass(staticClass, dynamicClass) {
            if (isDef(staticClass) || isDef(dynamicClass)) {
                return concat(staticClass, stringifyClass(dynamicClass));
            }
            /* istanbul ignore next */
            return "";
        }
        function concat(a, b) {
            return a ? b ? a + " " + b : a : b || "";
        }
        function stringifyClass(value) {
            if (Array.isArray(value)) {
                return stringifyArray(value);
            }
            if (isObject(value)) {
                return stringifyObject(value);
            }
            if (typeof value === "string") {
                return value;
            }
            /* istanbul ignore next */
            return "";
        }
        function stringifyArray(value) {
            var res = "";
            var stringified;
            for (var i = 0, l = value.length; i < l; i++) {
                if (isDef(stringified = stringifyClass(value[i])) && stringified !== "") {
                    if (res) {
                        res += " ";
                    }
                    res += stringified;
                }
            }
            return res;
        }
        function stringifyObject(value) {
            var res = "";
            for (var key in value) {
                if (value[key]) {
                    if (res) {
                        res += " ";
                    }
                    res += key;
                }
            }
            return res;
        }
        /*  */
        var isHTMLTag = makeMap("html,body,base,head,link,meta,style,title," +
            "address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section," +
            "div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul," +
            "a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby," +
            "s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video," +
            "embed,object,param,source,canvas,script,noscript,del,ins," +
            "caption,col,colgroup,table,thead,tbody,td,th,tr," +
            "button,datalist,fieldset,form,input,label,legend,meter,optgroup,option," +
            "output,progress,select,textarea," +
            "details,dialog,menu,menuitem,summary," +
            "content,element,shadow,template,blockquote,iframe,tfoot"); // this map is intentionally selective, only covering SVG elements that may
        // contain child elements.
        var isSVG = makeMap("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face," +
            "foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern," +
            "polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", true);
        var isPreTag = function (tag) {
            return tag === "pre";
        };
        var isReservedTag = function (tag) {
            return isHTMLTag(tag) || isSVG(tag);
        };
        function getTagNamespace(tag) {
            if (isSVG(tag)) {
                return "svg";
            } // basic support for MathML
            // note it doesn't support other MathML elements being component roots
            if (tag === "math") {
                return "math";
            }
        }
        var isTextInputType = makeMap("text,number,password,search,email,tel,url");
        /*  */
        /*  */
        function renderClass$1(node) {
            var classList = genClassForVnode(node);
            if (classList !== "") {
                return ' class="' + escape(classList) + '"';
            }
        }
        /*  */
        var parseStyleText = cached(function (cssText) {
            var res = {};
            var listDelimiter = /;(?![^(]*\))/g;
            var propertyDelimiter = /:(.+)/;
            cssText.split(listDelimiter).forEach(function (item) {
                if (item) {
                    var tmp = item.split(propertyDelimiter);
                    tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
                }
            });
            return res;
        }); // merge static and dynamic style data on the same vnode
        function normalizeStyleData(data) {
            var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation
            // and is always a fresh object, so it's safe to merge into it
            return data.staticStyle ? extend(data.staticStyle, style) : style;
        } // normalize possible array / string values into Object
        function normalizeStyleBinding(bindingStyle) {
            if (Array.isArray(bindingStyle)) {
                return toObject(bindingStyle);
            }
            if (typeof bindingStyle === "string") {
                return parseStyleText(bindingStyle);
            }
            return bindingStyle;
        }
        /**
         * parent component style should be after child's
         * so that parent component's style could override it
         */
        function getStyle(vnode, checkChild) {
            var res = {};
            var styleData;
            if (checkChild) {
                var childNode = vnode;
                while (childNode.componentInstance) {
                    childNode = childNode.componentInstance._vnode;
                    if (childNode && childNode.data &&
                        (styleData = normalizeStyleData(childNode.data))) {
                        extend(res, styleData);
                    }
                }
            }
            if (styleData = normalizeStyleData(vnode.data)) {
                extend(res, styleData);
            }
            var parentNode = vnode;
            while (parentNode = parentNode.parent) {
                if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
                    extend(res, styleData);
                }
            }
            return res;
        }
        /*  */
        function genStyle(style) {
            var styleText = "";
            for (var key in style) {
                var value = style[key];
                var hyphenatedKey = hyphenate(key);
                if (Array.isArray(value)) {
                    for (var i = 0, len = value.length; i < len; i++) {
                        styleText += normalizeValue(hyphenatedKey, value[i]);
                    }
                }
                else {
                    styleText += normalizeValue(hyphenatedKey, value);
                }
            }
            return styleText;
        }
        function normalizeValue(key, value) {
            if (typeof value === "string" ||
                typeof value === "number" && noUnitNumericStyleProps[key] ||
                value === 0) {
                return key + ":" + value + ";";
            }
            else {
                // invalid values
                return "";
            }
        }
        function renderStyle(vnode) {
            var styleText = genStyle(getStyle(vnode, false));
            if (styleText !== "") {
                return " style=" + JSON.stringify(escape(styleText));
            }
        }
        var modules = [renderAttrs, renderDOMProps, renderClass$1, renderStyle];
        /*  */
        function show(node, dir) {
            if (!dir.value) {
                var style = node.data.style || (node.data.style = {});
                if (Array.isArray(style)) {
                    style.push({
                        display: "none",
                    });
                }
                else {
                    style.display = "none";
                }
            }
        }
        /*  */
        // this is only applied for <select v-model> because it is the only edge case
        // that must be done at runtime instead of compile time.
        function model(node, dir) {
            if (!node.children) {
                return;
            }
            var value = dir.value;
            var isMultiple = node.data.attrs && node.data.attrs.multiple;
            for (var i = 0, l = node.children.length; i < l; i++) {
                var option = node.children[i];
                if (option.tag === "option") {
                    if (isMultiple) {
                        var selected = Array.isArray(value) &&
                            looseIndexOf(value, getValue(option)) > -1;
                        if (selected) {
                            setSelected(option);
                        }
                    }
                    else {
                        if (looseEqual(value, getValue(option))) {
                            setSelected(option);
                            return;
                        }
                    }
                }
            }
        }
        function getValue(option) {
            var data = option.data || {};
            return data.attrs && data.attrs.value ||
                data.domProps && data.domProps.value ||
                option.children && option.children[0] && option.children[0].text;
        }
        function setSelected(option) {
            var data = option.data || (option.data = {});
            var attrs = data.attrs || (data.attrs = {});
            attrs.selected = "";
        }
        var baseDirectives = {
            show: show,
            model: model,
        };
        /*  */
        var isUnaryTag = makeMap("area,base,br,col,embed,frame,hr,img,input,isindex,keygen," +
            "link,meta,param,source,track,wbr"); // Elements that you can, intentionally, leave open
        // (and which close themselves)
        var canBeLeftOpenTag = makeMap("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"); // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
        // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
        var isNonPhrasingTag = makeMap("address,article,aside,base,blockquote,body,caption,col,colgroup,dd," +
            "details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form," +
            "h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta," +
            "optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead," +
            "title,tr,track");
        /*  */
        var MAX_STACK_DEPTH = 800;
        var noop$1 = function (_) {
            return _;
        };
        var defer = typeof process !== "undefined" && process.nextTick
            ? process.nextTick
            : typeof Promise !== "undefined"
                ? function (fn) {
                    return Promise.resolve().then(fn);
                }
                : typeof setTimeout !== "undefined"
                    ? setTimeout
                    : noop$1;
        if (defer === noop$1) {
            throw new Error("Your JavaScript runtime does not support any asynchronous primitives " +
                "that are required by vue-server-renderer. Please use a polyfill for " +
                "either Promise or setTimeout.");
        }
        function createWriteFunction(write, onError) {
            var stackDepth = 0;
            var cachedWrite = function (text, next) {
                if (text && cachedWrite.caching) {
                    cachedWrite.cacheBuffer[cachedWrite.cacheBuffer.length - 1] += text;
                }
                var waitForNext = write(text, next);
                if (waitForNext !== true) {
                    if (stackDepth >= MAX_STACK_DEPTH) {
                        defer(function () {
                            try {
                                next();
                            }
                            catch (e) {
                                onError(e);
                            }
                        });
                    }
                    else {
                        stackDepth++;
                        next();
                        stackDepth--;
                    }
                }
            };
            cachedWrite.caching = false;
            cachedWrite.cacheBuffer = [];
            cachedWrite.componentBuffer = [];
            return cachedWrite;
        }
        /*  */
        /**
         * Original RenderStream implementation by Sasha Aickin (@aickin)
         * Licensed under the Apache License, Version 2.0
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Modified by Evan You (@yyx990803)
         */
        var stream = stream_js_2.default;
        var RenderStream = 
        /*@__PURE__*/
        function (superclass) {
            function RenderStream(render) {
                var this$1 = this;
                superclass.call(this);
                this.buffer = "";
                this.render = render;
                this.expectedSize = 0;
                this.write = createWriteFunction(function (text, next) {
                    var n = this$1.expectedSize;
                    this$1.buffer += text;
                    if (this$1.buffer.length >= n) {
                        this$1.next = next;
                        this$1.pushBySize(n);
                        return true; // we will decide when to call next
                    }
                    return false;
                }, function (err) {
                    this$1.emit("error", err);
                });
                this.end = function () {
                    this$1.emit("beforeEnd"); // the rendering is finished; we should push out the last of the buffer.
                    this$1.done = true;
                    this$1.push(this$1.buffer);
                };
            }
            if (superclass)
                RenderStream.__proto__ = superclass;
            RenderStream.prototype = Object.create(superclass && superclass.prototype);
            RenderStream.prototype.constructor = RenderStream;
            RenderStream.prototype.pushBySize = function pushBySize(n) {
                var bufferToPush = this.buffer.substring(0, n);
                this.buffer = this.buffer.substring(n);
                this.push(bufferToPush);
            };
            RenderStream.prototype.tryRender = function tryRender() {
                try {
                    this.render(this.write, this.end);
                }
                catch (e) {
                    this.emit("error", e);
                }
            };
            RenderStream.prototype.tryNext = function tryNext() {
                try {
                    this.next();
                }
                catch (e) {
                    this.emit("error", e);
                }
            };
            RenderStream.prototype._read = function _read(n) {
                this.expectedSize = n; // it's possible that the last chunk added bumped the buffer up to > 2 * n,
                // which means we will need to go through multiple read calls to drain it
                // down to < n.
                if (isTrue(this.done)) {
                    this.push(null);
                    return;
                }
                if (this.buffer.length >= n) {
                    this.pushBySize(n);
                    return;
                }
                if (isUndef(this.next)) {
                    // start the rendering chain.
                    this.tryRender();
                }
                else {
                    // continue with the rendering.
                    this.tryNext();
                }
            };
            return RenderStream;
        }(stream.Readable);
        /*  */
        var RenderContext = function RenderContext(options) {
            this.userContext = options.userContext;
            this.activeInstance = options.activeInstance;
            this.renderStates = [];
            this.write = options.write;
            this.done = options.done;
            this.renderNode = options.renderNode;
            this.isUnaryTag = options.isUnaryTag;
            this.modules = options.modules;
            this.directives = options.directives;
            var cache = options.cache;
            if (cache && (!cache.get || !cache.set)) {
                throw new Error("renderer cache must implement at least get & set.");
            }
            this.cache = cache;
            this.get = cache && normalizeAsync(cache, "get");
            this.has = cache && normalizeAsync(cache, "has");
            this.next = this.next.bind(this);
        };
        RenderContext.prototype.next = function next() {
            // eslint-disable-next-line
            while (true) {
                var lastState = this.renderStates[this.renderStates.length - 1];
                if (isUndef(lastState)) {
                    return this.done();
                }
                /* eslint-disable no-case-declarations */
                switch (lastState.type) {
                    case "Element":
                    case "Fragment":
                        var children = lastState.children;
                        var total = lastState.total;
                        var rendered = lastState.rendered++;
                        if (rendered < total) {
                            return this.renderNode(children[rendered], false, this);
                        }
                        else {
                            this.renderStates.pop();
                            if (lastState.type === "Element") {
                                return this.write(lastState.endTag, this.next);
                            }
                        }
                        break;
                    case "Component":
                        this.renderStates.pop();
                        this.activeInstance = lastState.prevActive;
                        break;
                    case "ComponentWithCache":
                        this.renderStates.pop();
                        var buffer = lastState.buffer;
                        var bufferIndex = lastState.bufferIndex;
                        var componentBuffer = lastState.componentBuffer;
                        var key = lastState.key;
                        var result = {
                            html: buffer[bufferIndex],
                            components: componentBuffer[bufferIndex],
                        };
                        this.cache.set(key, result);
                        if (bufferIndex === 0) {
                            // this is a top-level cached component,
                            // exit caching mode.
                            this.write.caching = false;
                        }
                        else {
                            // parent component is also being cached,
                            // merge self into parent's result
                            buffer[bufferIndex - 1] += result.html;
                            var prev = componentBuffer[bufferIndex - 1];
                            result.components.forEach(function (c) {
                                return prev.add(c);
                            });
                        }
                        buffer.length = bufferIndex;
                        componentBuffer.length = bufferIndex;
                        break;
                }
            }
        };
        function normalizeAsync(cache, method) {
            var fn = cache[method];
            if (isUndef(fn)) {
                return;
            }
            else if (fn.length > 1) {
                return function (key, cb) {
                    return fn.call(cache, key, cb);
                };
            }
            else {
                return function (key, cb) {
                    return cb(fn.call(cache, key));
                };
            }
        }
        /*  */
        var validDivisionCharRE = /[\w).+\-_$\]]/;
        function parseFilters(exp) {
            var inSingle = false;
            var inDouble = false;
            var inTemplateString = false;
            var inRegex = false;
            var curly = 0;
            var square = 0;
            var paren = 0;
            var lastFilterIndex = 0;
            var c, prev, i, expression, filters;
            for (i = 0; i < exp.length; i++) {
                prev = c;
                c = exp.charCodeAt(i);
                if (inSingle) {
                    if (c === 0x27 && prev !== 0x5C) {
                        inSingle = false;
                    }
                }
                else if (inDouble) {
                    if (c === 0x22 && prev !== 0x5C) {
                        inDouble = false;
                    }
                }
                else if (inTemplateString) {
                    if (c === 0x60 && prev !== 0x5C) {
                        inTemplateString = false;
                    }
                }
                else if (inRegex) {
                    if (c === 0x2f && prev !== 0x5C) {
                        inRegex = false;
                    }
                }
                else if (c === 0x7C && // pipe
                    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C &&
                    !curly && !square && !paren) {
                    if (expression === undefined) {
                        // first filter, end of expression
                        lastFilterIndex = i + 1;
                        expression = exp.slice(0, i).trim();
                    }
                    else {
                        pushFilter();
                    }
                }
                else {
                    switch (c) {
                        case 0x22:
                            inDouble = true;
                            break;
                        // "
                        case 0x27:
                            inSingle = true;
                            break;
                        // '
                        case 0x60:
                            inTemplateString = true;
                            break;
                        // `
                        case 0x28:
                            paren++;
                            break;
                        // (
                        case 0x29:
                            paren--;
                            break;
                        // )
                        case 0x5B:
                            square++;
                            break;
                        // [
                        case 0x5D:
                            square--;
                            break;
                        // ]
                        case 0x7B:
                            curly++;
                            break;
                        // {
                        case 0x7D:
                            curly--;
                            break;
                        // }
                    }
                    if (c === 0x2f) {
                        // /
                        var j = i - 1;
                        var p = void 0; // find first non-whitespace prev char
                        for (; j >= 0; j--) {
                            p = exp.charAt(j);
                            if (p !== " ") {
                                break;
                            }
                        }
                        if (!p || !validDivisionCharRE.test(p)) {
                            inRegex = true;
                        }
                    }
                }
            }
            if (expression === undefined) {
                expression = exp.slice(0, i).trim();
            }
            else if (lastFilterIndex !== 0) {
                pushFilter();
            }
            function pushFilter() {
                (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
                lastFilterIndex = i + 1;
            }
            if (filters) {
                for (i = 0; i < filters.length; i++) {
                    expression = wrapFilter(expression, filters[i]);
                }
            }
            return expression;
        }
        function wrapFilter(exp, filter) {
            var i = filter.indexOf("(");
            if (i < 0) {
                // _f: resolveFilter
                return '_f("' + filter + '")(' + exp + ")";
            }
            else {
                var name = filter.slice(0, i);
                var args = filter.slice(i + 1);
                return '_f("' + name + '")(' + exp + (args !== ")" ? "," + args : args);
            }
        }
        /*  */
        var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;
        var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
        var buildRegex = cached(function (delimiters) {
            var open = delimiters[0].replace(regexEscapeRE, "\\$&");
            var close = delimiters[1].replace(regexEscapeRE, "\\$&");
            return new RegExp(open + "((?:.|\\n)+?)" + close, "g");
        });
        function parseText(text, delimiters) {
            var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
            if (!tagRE.test(text)) {
                return;
            }
            var tokens = [];
            var rawTokens = [];
            var lastIndex = tagRE.lastIndex = 0;
            var match, index, tokenValue;
            while (match = tagRE.exec(text)) {
                index = match.index; // push text token
                if (index > lastIndex) {
                    rawTokens.push(tokenValue = text.slice(lastIndex, index));
                    tokens.push(JSON.stringify(tokenValue));
                } // tag token
                var exp = parseFilters(match[1].trim());
                tokens.push("_s(" + exp + ")");
                rawTokens.push({
                    "@binding": exp,
                });
                lastIndex = index + match[0].length;
            }
            if (lastIndex < text.length) {
                rawTokens.push(tokenValue = text.slice(lastIndex));
                tokens.push(JSON.stringify(tokenValue));
            }
            return {
                expression: tokens.join("+"),
                tokens: rawTokens,
            };
        }
        /*  */
        /* eslint-disable no-unused-vars */
        function baseWarn(msg, range) {
            console.error("[Vue compiler]: " + msg);
        }
        /* eslint-enable no-unused-vars */
        function pluckModuleFunction(modules, key) {
            return modules
                ? modules.map(function (m) {
                    return m[key];
                }).filter(function (_) {
                    return _;
                })
                : [];
        }
        function addProp(el, name, value, range, dynamic) {
            (el.props || (el.props = [])).push(rangeSetItem({
                name: name,
                value: value,
                dynamic: dynamic,
            }, range));
            el.plain = false;
        }
        function addAttr(el, name, value, range, dynamic) {
            var attrs = dynamic
                ? el.dynamicAttrs || (el.dynamicAttrs = [])
                : el.attrs || (el.attrs = []);
            attrs.push(rangeSetItem({
                name: name,
                value: value,
                dynamic: dynamic,
            }, range));
            el.plain = false;
        } // add a raw attr (use this in preTransforms)
        function addRawAttr(el, name, value, range) {
            el.attrsMap[name] = value;
            el.attrsList.push(rangeSetItem({
                name: name,
                value: value,
            }, range));
        }
        function addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {
            (el.directives || (el.directives = [])).push(rangeSetItem({
                name: name,
                rawName: rawName,
                value: value,
                arg: arg,
                isDynamicArg: isDynamicArg,
                modifiers: modifiers,
            }, range));
            el.plain = false;
        }
        function prependModifierMarker(symbol, name, dynamic) {
            return dynamic ? "_p(" + name + ',"' + symbol + '")' : symbol + name; // mark the event as captured
        }
        function addHandler(el, name, value, modifiers, important, warn, range, dynamic) {
            modifiers = modifiers || emptyObject; // warn prevent and passive modifier
            /* istanbul ignore if */
            if (warn && modifiers.prevent && modifiers.passive) {
                warn("passive and prevent can't be used together. " +
                    "Passive handler can't prevent default event.", range);
            } // normalize click.right and click.middle since they don't actually fire
            // this is technically browser-specific, but at least for now browsers are
            // the only target envs that have right/middle clicks.
            if (modifiers.right) {
                if (dynamic) {
                    name = "(" + name + ")==='click'?'contextmenu':(" + name + ")";
                }
                else if (name === "click") {
                    name = "contextmenu";
                    delete modifiers.right;
                }
            }
            else if (modifiers.middle) {
                if (dynamic) {
                    name = "(" + name + ")==='click'?'mouseup':(" + name + ")";
                }
                else if (name === "click") {
                    name = "mouseup";
                }
            } // check capture modifier
            if (modifiers.capture) {
                delete modifiers.capture;
                name = prependModifierMarker("!", name, dynamic);
            }
            if (modifiers.once) {
                delete modifiers.once;
                name = prependModifierMarker("~", name, dynamic);
            }
            /* istanbul ignore if */
            if (modifiers.passive) {
                delete modifiers.passive;
                name = prependModifierMarker("&", name, dynamic);
            }
            var events;
            if (modifiers.native) {
                delete modifiers.native;
                events = el.nativeEvents || (el.nativeEvents = {});
            }
            else {
                events = el.events || (el.events = {});
            }
            var newHandler = rangeSetItem({
                value: value.trim(),
                dynamic: dynamic,
            }, range);
            if (modifiers !== emptyObject) {
                newHandler.modifiers = modifiers;
            }
            var handlers = events[name];
            /* istanbul ignore if */
            if (Array.isArray(handlers)) {
                important ? handlers.unshift(newHandler) : handlers.push(newHandler);
            }
            else if (handlers) {
                events[name] = important
                    ? [newHandler, handlers]
                    : [handlers, newHandler];
            }
            else {
                events[name] = newHandler;
            }
            el.plain = false;
        }
        function getRawBindingAttr(el, name) {
            return el.rawAttrsMap[":" + name] || el.rawAttrsMap["v-bind:" + name] ||
                el.rawAttrsMap[name];
        }
        function getBindingAttr(el, name, getStatic) {
            var dynamicValue = getAndRemoveAttr(el, ":" + name) ||
                getAndRemoveAttr(el, "v-bind:" + name);
            if (dynamicValue != null) {
                return parseFilters(dynamicValue);
            }
            else if (getStatic !== false) {
                var staticValue = getAndRemoveAttr(el, name);
                if (staticValue != null) {
                    return JSON.stringify(staticValue);
                }
            }
        } // note: this only removes the attr from the Array (attrsList) so that it
        // doesn't get processed by processAttrs.
        // By default it does NOT remove it from the map (attrsMap) because the map is
        // needed during codegen.
        function getAndRemoveAttr(el, name, removeFromMap) {
            var val;
            if ((val = el.attrsMap[name]) != null) {
                var list = el.attrsList;
                for (var i = 0, l = list.length; i < l; i++) {
                    if (list[i].name === name) {
                        list.splice(i, 1);
                        break;
                    }
                }
            }
            if (removeFromMap) {
                delete el.attrsMap[name];
            }
            return val;
        }
        function getAndRemoveAttrByRegex(el, name) {
            var list = el.attrsList;
            for (var i = 0, l = list.length; i < l; i++) {
                var attr = list[i];
                if (name.test(attr.name)) {
                    list.splice(i, 1);
                    return attr;
                }
            }
        }
        function rangeSetItem(item, range) {
            if (range) {
                if (range.start != null) {
                    item.start = range.start;
                }
                if (range.end != null) {
                    item.end = range.end;
                }
            }
            return item;
        }
        /*  */
        function transformNode(el, options) {
            var warn = options.warn || baseWarn;
            var staticClass = getAndRemoveAttr(el, "class");
            if (staticClass) {
                var res = parseText(staticClass, options.delimiters);
                if (res) {
                    warn('class="' + staticClass + '": ' +
                        "Interpolation inside attributes has been removed. " +
                        "Use v-bind or the colon shorthand instead. For example, " +
                        'instead of <div class="{{ val }}">, use <div :class="val">.', el.rawAttrsMap["class"]);
                }
            }
            if (staticClass) {
                el.staticClass = JSON.stringify(staticClass);
            }
            var classBinding = getBindingAttr(el, "class", false /* getStatic */);
            if (classBinding) {
                el.classBinding = classBinding;
            }
        }
        function genData(el) {
            var data = "";
            if (el.staticClass) {
                data += "staticClass:" + el.staticClass + ",";
            }
            if (el.classBinding) {
                data += "class:" + el.classBinding + ",";
            }
            return data;
        }
        var klass = {
            staticKeys: ["staticClass"],
            transformNode: transformNode,
            genData: genData,
        };
        /*  */
        function transformNode$1(el, options) {
            var warn = options.warn || baseWarn;
            var staticStyle = getAndRemoveAttr(el, "style");
            if (staticStyle) {
                /* istanbul ignore if */
                {
                    var res = parseText(staticStyle, options.delimiters);
                    if (res) {
                        warn('style="' + staticStyle + '": ' +
                            "Interpolation inside attributes has been removed. " +
                            "Use v-bind or the colon shorthand instead. For example, " +
                            'instead of <div style="{{ val }}">, use <div :style="val">.', el.rawAttrsMap["style"]);
                    }
                }
                el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
            }
            var styleBinding = getBindingAttr(el, "style", false /* getStatic */);
            if (styleBinding) {
                el.styleBinding = styleBinding;
            }
        }
        function genData$1(el) {
            var data = "";
            if (el.staticStyle) {
                data += "staticStyle:" + el.staticStyle + ",";
            }
            if (el.styleBinding) {
                data += "style:(" + el.styleBinding + "),";
            }
            return data;
        }
        var style = {
            staticKeys: ["staticStyle"],
            transformNode: transformNode$1,
            genData: genData$1,
        };
        /**
         * Not type-checking this file because it's mostly vendor code.
         */
        // Regular Expressions for parsing tags and attributes
        var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
        var dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
        var ncname = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + unicodeRegExp.source + "]*";
        var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
        var startTagOpen = new RegExp("^<" + qnameCapture);
        var startTagClose = /^\s*(\/?)>/;
        var endTag = new RegExp("^<\\/" + qnameCapture + "[^>]*>");
        var doctype = /^<!DOCTYPE [^>]+>/i; // #7298: escape - to avoid being passed as HTML comment when inlined in page
        var comment = /^<!\--/;
        var conditionalComment = /^<!\[/; // Special Elements (can contain anything)
        var isPlainTextElement = makeMap("script,style,textarea", true);
        var reCache = {};
        var decodingMap = {
            "&lt;": "<",
            "&gt;": ">",
            "&quot;": '"',
            "&amp;": "&",
            "&#10;": "\n",
            "&#9;": "\t",
            "&#39;": "'",
        };
        var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
        var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g; // #5992
        var isIgnoreNewlineTag = makeMap("pre,textarea", true);
        var shouldIgnoreFirstNewline = function (tag, html) {
            return tag && isIgnoreNewlineTag(tag) && html[0] === "\n";
        };
        function decodeAttr(value, shouldDecodeNewlines) {
            var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
            return value.replace(re, function (match) {
                return decodingMap[match];
            });
        }
        function parseHTML(html, options) {
            var stack = [];
            var expectHTML = options.expectHTML;
            var isUnaryTag$$1 = options.isUnaryTag || no;
            var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
            var index = 0;
            var last, lastTag;
            while (html) {
                last = html; // Make sure we're not in a plaintext content element like script/style
                if (!lastTag || !isPlainTextElement(lastTag)) {
                    var textEnd = html.indexOf("<");
                    if (textEnd === 0) {
                        // Comment:
                        if (comment.test(html)) {
                            var commentEnd = html.indexOf("-->");
                            if (commentEnd >= 0) {
                                if (options.shouldKeepComment) {
                                    options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
                                }
                                advance(commentEnd + 3);
                                continue;
                            }
                        } // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
                        if (conditionalComment.test(html)) {
                            var conditionalEnd = html.indexOf("]>");
                            if (conditionalEnd >= 0) {
                                advance(conditionalEnd + 2);
                                continue;
                            }
                        } // Doctype:
                        var doctypeMatch = html.match(doctype);
                        if (doctypeMatch) {
                            advance(doctypeMatch[0].length);
                            continue;
                        } // End tag:
                        var endTagMatch = html.match(endTag);
                        if (endTagMatch) {
                            var curIndex = index;
                            advance(endTagMatch[0].length);
                            parseEndTag(endTagMatch[1], curIndex, index);
                            continue;
                        } // Start tag:
                        var startTagMatch = parseStartTag();
                        if (startTagMatch) {
                            handleStartTag(startTagMatch);
                            if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
                                advance(1);
                            }
                            continue;
                        }
                    }
                    var text = void 0, rest = void 0, next = void 0;
                    if (textEnd >= 0) {
                        rest = html.slice(textEnd);
                        while (!endTag.test(rest) && !startTagOpen.test(rest) &&
                            !comment.test(rest) && !conditionalComment.test(rest)) {
                            // < in plain text, be forgiving and treat it as text
                            next = rest.indexOf("<", 1);
                            if (next < 0) {
                                break;
                            }
                            textEnd += next;
                            rest = html.slice(textEnd);
                        }
                        text = html.substring(0, textEnd);
                    }
                    if (textEnd < 0) {
                        text = html;
                    }
                    if (text) {
                        advance(text.length);
                    }
                    if (options.chars && text) {
                        options.chars(text, index - text.length, index);
                    }
                }
                else {
                    var endTagLength = 0;
                    var stackedTag = lastTag.toLowerCase();
                    var reStackedTag = reCache[stackedTag] ||
                        (reCache[stackedTag] = new RegExp("([\\s\\S]*?)(</" + stackedTag + "[^>]*>)", "i"));
                    var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
                        endTagLength = endTag.length;
                        if (!isPlainTextElement(stackedTag) && stackedTag !== "noscript") {
                            text = text.replace(/<!\--([\s\S]*?)-->/g, "$1") // #7298
                                .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, "$1");
                        }
                        if (shouldIgnoreFirstNewline(stackedTag, text)) {
                            text = text.slice(1);
                        }
                        if (options.chars) {
                            options.chars(text);
                        }
                        return "";
                    });
                    index += html.length - rest$1.length;
                    html = rest$1;
                    parseEndTag(stackedTag, index - endTagLength, index);
                }
                if (html === last) {
                    options.chars && options.chars(html);
                    if (!stack.length && options.warn) {
                        options.warn('Mal-formatted tag at end of template: "' + html + '"', {
                            start: index + html.length,
                        });
                    }
                    break;
                }
            } // Clean up any remaining tags
            parseEndTag();
            function advance(n) {
                index += n;
                html = html.substring(n);
            }
            function parseStartTag() {
                var start = html.match(startTagOpen);
                if (start) {
                    var match = {
                        tagName: start[1],
                        attrs: [],
                        start: index,
                    };
                    advance(start[0].length);
                    var end, attr;
                    while (!(end = html.match(startTagClose)) &&
                        (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
                        attr.start = index;
                        advance(attr[0].length);
                        attr.end = index;
                        match.attrs.push(attr);
                    }
                    if (end) {
                        match.unarySlash = end[1];
                        advance(end[0].length);
                        match.end = index;
                        return match;
                    }
                }
            }
            function handleStartTag(match) {
                var tagName = match.tagName;
                var unarySlash = match.unarySlash;
                if (expectHTML) {
                    if (lastTag === "p" && isNonPhrasingTag(tagName)) {
                        parseEndTag(lastTag);
                    }
                    if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
                        parseEndTag(tagName);
                    }
                }
                var unary = isUnaryTag$$1(tagName) || !!unarySlash;
                var l = match.attrs.length;
                var attrs = new Array(l);
                for (var i = 0; i < l; i++) {
                    var args = match.attrs[i];
                    var value = args[3] || args[4] || args[5] || "";
                    var shouldDecodeNewlines = tagName === "a" && args[1] === "href"
                        ? options.shouldDecodeNewlinesForHref
                        : options.shouldDecodeNewlines;
                    attrs[i] = {
                        name: args[1],
                        value: decodeAttr(value, shouldDecodeNewlines),
                    };
                    if (options.outputSourceRange) {
                        attrs[i].start = args.start + args[0].match(/^\s*/).length;
                        attrs[i].end = args.end;
                    }
                }
                if (!unary) {
                    stack.push({
                        tag: tagName,
                        lowerCasedTag: tagName.toLowerCase(),
                        attrs: attrs,
                        start: match.start,
                        end: match.end,
                    });
                    lastTag = tagName;
                }
                if (options.start) {
                    options.start(tagName, attrs, unary, match.start, match.end);
                }
            }
            function parseEndTag(tagName, start, end) {
                var pos, lowerCasedTagName;
                if (start == null) {
                    start = index;
                }
                if (end == null) {
                    end = index;
                } // Find the closest opened tag of the same type
                if (tagName) {
                    lowerCasedTagName = tagName.toLowerCase();
                    for (pos = stack.length - 1; pos >= 0; pos--) {
                        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
                            break;
                        }
                    }
                }
                else {
                    // If no tag name is provided, clean shop
                    pos = 0;
                }
                if (pos >= 0) {
                    // Close all the open elements, up the stack
                    for (var i = stack.length - 1; i >= pos; i--) {
                        if (i > pos || !tagName && options.warn) {
                            options.warn("tag <" + stack[i].tag + "> has no matching end tag.", {
                                start: stack[i].start,
                                end: stack[i].end,
                            });
                        }
                        if (options.end) {
                            options.end(stack[i].tag, start, end);
                        }
                    } // Remove the open elements from the stack
                    stack.length = pos;
                    lastTag = pos && stack[pos - 1].tag;
                }
                else if (lowerCasedTagName === "br") {
                    if (options.start) {
                        options.start(tagName, [], true, start, end);
                    }
                }
                else if (lowerCasedTagName === "p") {
                    if (options.start) {
                        options.start(tagName, [], false, start, end);
                    }
                    if (options.end) {
                        options.end(tagName, start, end);
                    }
                }
            }
        }
        /*  */
        /**
         * Cross-platform code generation for component v-model
         */
        function genComponentModel(el, value, modifiers) {
            var ref = modifiers || {};
            var number = ref.number;
            var trim = ref.trim;
            var baseValueExpression = "$$v";
            var valueExpression = baseValueExpression;
            if (trim) {
                valueExpression = "(typeof " + baseValueExpression + " === 'string'" +
                    "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression +
                    ")";
            }
            if (number) {
                valueExpression = "_n(" + valueExpression + ")";
            }
            var assignment = genAssignmentCode(value, valueExpression);
            el.model = {
                value: "(" + value + ")",
                expression: JSON.stringify(value),
                callback: "function (" + baseValueExpression + ") {" + assignment + "}",
            };
        }
        /**
         * Cross-platform codegen helper for generating v-model value assignment code.
         */
        function genAssignmentCode(value, assignment) {
            var res = parseModel(value);
            if (res.key === null) {
                return value + "=" + assignment;
            }
            else {
                return "$set(" + res.exp + ", " + res.key + ", " + assignment + ")";
            }
        }
        /**
         * Parse a v-model expression into a base path and a final key segment.
         * Handles both dot-path and possible square brackets.
         *
         * Possible cases:
         *
         * - test
         * - test[key]
         * - test[test1[key]]
         * - test["a"][key]
         * - xxx.test[a[a].test1[key]]
         * - test.xxx.a["asa"][test1[key]]
         *
         */
        var len, str, chr, index, expressionPos, expressionEndPos;
        function parseModel(val) {
            // Fix https://github.com/vuejs/vue/pull/7730
            // allow v-model="obj.val " (trailing whitespace)
            val = val.trim();
            len = val.length;
            if (val.indexOf("[") < 0 || val.lastIndexOf("]") < len - 1) {
                index = val.lastIndexOf(".");
                if (index > -1) {
                    return {
                        exp: val.slice(0, index),
                        key: '"' + val.slice(index + 1) + '"',
                    };
                }
                else {
                    return {
                        exp: val,
                        key: null,
                    };
                }
            }
            str = val;
            index = expressionPos = expressionEndPos = 0;
            while (!eof()) {
                chr = next();
                /* istanbul ignore if */
                if (isStringStart(chr)) {
                    parseString(chr);
                }
                else if (chr === 0x5B) {
                    parseBracket(chr);
                }
            }
            return {
                exp: val.slice(0, expressionPos),
                key: val.slice(expressionPos + 1, expressionEndPos),
            };
        }
        function next() {
            return str.charCodeAt(++index);
        }
        function eof() {
            return index >= len;
        }
        function isStringStart(chr) {
            return chr === 0x22 || chr === 0x27;
        }
        function parseBracket(chr) {
            var inBracket = 1;
            expressionPos = index;
            while (!eof()) {
                chr = next();
                if (isStringStart(chr)) {
                    parseString(chr);
                    continue;
                }
                if (chr === 0x5B) {
                    inBracket++;
                }
                if (chr === 0x5D) {
                    inBracket--;
                }
                if (inBracket === 0) {
                    expressionEndPos = index;
                    break;
                }
            }
        }
        function parseString(chr) {
            var stringQuote = chr;
            while (!eof()) {
                chr = next();
                if (chr === stringQuote) {
                    break;
                }
            }
        }
        /*  */
        var onRE = /^@|^v-on:/;
        var dirRE = /^v-|^@|^:|^#/;
        var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
        var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
        var stripParensRE = /^\(|\)$/g;
        var dynamicArgRE = /^\[.*\]$/;
        var argRE = /:(.*)$/;
        var bindRE = /^:|^\.|^v-bind:/;
        var modifierRE = /\.[^.\]]+(?=[^\]]*$)/g;
        var slotRE = /^v-slot(:|$)|^#/;
        var lineBreakRE = /[\r\n]/;
        var whitespaceRE = /\s+/g;
        var invalidAttributeRE = /[\s"'<>\/=]/;
        var decodeHTMLCached = cached(he.decode);
        var emptySlotScopeToken = "_empty_"; // configurable state
        var warn$1;
        var delimiters;
        var transforms;
        var preTransforms;
        var postTransforms;
        var platformIsPreTag;
        var platformMustUseProp;
        var platformGetTagNamespace;
        var maybeComponent;
        function createASTElement(tag, attrs, parent) {
            return {
                type: 1,
                tag: tag,
                attrsList: attrs,
                attrsMap: makeAttrsMap(attrs),
                rawAttrsMap: {},
                parent: parent,
                children: [],
            };
        }
        /**
         * Convert HTML string to AST.
         */
        function parse(template, options) {
            warn$1 = options.warn || baseWarn;
            platformIsPreTag = options.isPreTag || no;
            platformMustUseProp = options.mustUseProp || no;
            platformGetTagNamespace = options.getTagNamespace || no;
            var isReservedTag = options.isReservedTag || no;
            maybeComponent = function (el) {
                return !!el.component || !isReservedTag(el.tag);
            };
            transforms = pluckModuleFunction(options.modules, "transformNode");
            preTransforms = pluckModuleFunction(options.modules, "preTransformNode");
            postTransforms = pluckModuleFunction(options.modules, "postTransformNode");
            delimiters = options.delimiters;
            var stack = [];
            var preserveWhitespace = options.preserveWhitespace !== false;
            var whitespaceOption = options.whitespace;
            var root;
            var currentParent;
            var inVPre = false;
            var inPre = false;
            var warned = false;
            function warnOnce(msg, range) {
                if (!warned) {
                    warned = true;
                    warn$1(msg, range);
                }
            }
            function closeElement(element) {
                trimEndingWhitespace(element);
                if (!inVPre && !element.processed) {
                    element = processElement(element, options);
                } // tree management
                if (!stack.length && element !== root) {
                    // allow root elements with v-if, v-else-if and v-else
                    if (root.if && (element.elseif || element.else)) {
                        {
                            checkRootConstraints(element);
                        }
                        addIfCondition(root, {
                            exp: element.elseif,
                            block: element,
                        });
                    }
                    else {
                        warnOnce("Component template should contain exactly one root element. " +
                            "If you are using v-if on multiple elements, " +
                            "use v-else-if to chain them instead.", {
                            start: element.start,
                        });
                    }
                }
                if (currentParent && !element.forbidden) {
                    if (element.elseif || element.else) {
                        processIfConditions(element, currentParent);
                    }
                    else {
                        if (element.slotScope) {
                            // scoped slot
                            // keep it in the children list so that v-else(-if) conditions can
                            // find it as the prev node.
                            var name = element.slotTarget || '"default"';
                            (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
                        }
                        currentParent.children.push(element);
                        element.parent = currentParent;
                    }
                } // final children cleanup
                // filter out scoped slots
                element.children = element.children.filter(function (c) {
                    return !c.slotScope;
                }); // remove trailing whitespace node again
                trimEndingWhitespace(element); // check pre state
                if (element.pre) {
                    inVPre = false;
                }
                if (platformIsPreTag(element.tag)) {
                    inPre = false;
                } // apply post-transforms
                for (var i = 0; i < postTransforms.length; i++) {
                    postTransforms[i](element, options);
                }
            }
            function trimEndingWhitespace(el) {
                // remove trailing whitespace node
                if (!inPre) {
                    var lastNode;
                    while ((lastNode = el.children[el.children.length - 1]) &&
                        lastNode.type === 3 && lastNode.text === " ") {
                        el.children.pop();
                    }
                }
            }
            function checkRootConstraints(el) {
                if (el.tag === "slot" || el.tag === "template") {
                    warnOnce("Cannot use <" + el.tag +
                        "> as component root element because it may " +
                        "contain multiple nodes.", {
                        start: el.start,
                    });
                }
                if (el.attrsMap.hasOwnProperty("v-for")) {
                    warnOnce("Cannot use v-for on stateful component root element because " +
                        "it renders multiple elements.", el.rawAttrsMap["v-for"]);
                }
            }
            parseHTML(template, {
                warn: warn$1,
                expectHTML: options.expectHTML,
                isUnaryTag: options.isUnaryTag,
                canBeLeftOpenTag: options.canBeLeftOpenTag,
                shouldDecodeNewlines: options.shouldDecodeNewlines,
                shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
                shouldKeepComment: options.comments,
                outputSourceRange: options.outputSourceRange,
                start: function start(tag, attrs, unary, start$1, end) {
                    // check namespace.
                    // inherit parent ns if there is one
                    var ns = currentParent && currentParent.ns ||
                        platformGetTagNamespace(tag); // handle IE svg bug
                    /* istanbul ignore if */
                    if (isIE && ns === "svg") {
                        attrs = guardIESVGBug(attrs);
                    }
                    var element = createASTElement(tag, attrs, currentParent);
                    if (ns) {
                        element.ns = ns;
                    }
                    {
                        if (options.outputSourceRange) {
                            element.start = start$1;
                            element.end = end;
                            element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {
                                cumulated[attr.name] = attr;
                                return cumulated;
                            }, {});
                        }
                        attrs.forEach(function (attr) {
                            if (invalidAttributeRE.test(attr.name)) {
                                warn$1("Invalid dynamic argument expression: attribute names cannot contain " +
                                    "spaces, quotes, <, >, / or =.", {
                                    start: attr.start + attr.name.indexOf("["),
                                    end: attr.start + attr.name.length,
                                });
                            }
                        });
                    }
                    if (isForbiddenTag(element) && !isServerRendering()) {
                        element.forbidden = true;
                        warn$1("Templates should only be responsible for mapping the state to the " +
                            "UI. Avoid placing tags with side-effects in your templates, such as " +
                            "<" + tag + ">" + ", as they will not be parsed.", {
                            start: element.start,
                        });
                    } // apply pre-transforms
                    for (var i = 0; i < preTransforms.length; i++) {
                        element = preTransforms[i](element, options) || element;
                    }
                    if (!inVPre) {
                        processPre(element);
                        if (element.pre) {
                            inVPre = true;
                        }
                    }
                    if (platformIsPreTag(element.tag)) {
                        inPre = true;
                    }
                    if (inVPre) {
                        processRawAttrs(element);
                    }
                    else if (!element.processed) {
                        // structural directives
                        processFor(element);
                        processIf(element);
                        processOnce(element);
                    }
                    if (!root) {
                        root = element;
                        {
                            checkRootConstraints(root);
                        }
                    }
                    if (!unary) {
                        currentParent = element;
                        stack.push(element);
                    }
                    else {
                        closeElement(element);
                    }
                },
                end: function end(tag, start, end$1) {
                    var element = stack[stack.length - 1]; // pop stack
                    stack.length -= 1;
                    currentParent = stack[stack.length - 1];
                    if (options.outputSourceRange) {
                        element.end = end$1;
                    }
                    closeElement(element);
                },
                chars: function chars(text, start, end) {
                    if (!currentParent) {
                        {
                            if (text === template) {
                                warnOnce("Component template requires a root element, rather than just text.", {
                                    start: start,
                                });
                            }
                            else if (text = text.trim()) {
                                warnOnce('text "' + text + '" outside root element will be ignored.', {
                                    start: start,
                                });
                            }
                        }
                        return;
                    } // IE textarea placeholder bug
                    /* istanbul ignore if */
                    if (isIE && currentParent.tag === "textarea" &&
                        currentParent.attrsMap.placeholder === text) {
                        return;
                    }
                    var children = currentParent.children;
                    if (inPre || text.trim()) {
                        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);
                    }
                    else if (!children.length) {
                        // remove the whitespace-only node right after an opening tag
                        text = "";
                    }
                    else if (whitespaceOption) {
                        if (whitespaceOption === "condense") {
                            // in condense mode, remove the whitespace node if it contains
                            // line break, otherwise condense to a single space
                            text = lineBreakRE.test(text) ? "" : " ";
                        }
                        else {
                            text = " ";
                        }
                    }
                    else {
                        text = preserveWhitespace ? " " : "";
                    }
                    if (text) {
                        if (!inPre && whitespaceOption === "condense") {
                            // condense consecutive whitespaces into single space
                            text = text.replace(whitespaceRE, " ");
                        }
                        var res;
                        var child;
                        if (!inVPre && text !== " " && (res = parseText(text, delimiters))) {
                            child = {
                                type: 2,
                                expression: res.expression,
                                tokens: res.tokens,
                                text: text,
                            };
                        }
                        else if (text !== " " || !children.length ||
                            children[children.length - 1].text !== " ") {
                            child = {
                                type: 3,
                                text: text,
                            };
                        }
                        if (child) {
                            if (options.outputSourceRange) {
                                child.start = start;
                                child.end = end;
                            }
                            children.push(child);
                        }
                    }
                },
                comment: function comment(text, start, end) {
                    // adding anyting as a sibling to the root node is forbidden
                    // comments should still be allowed, but ignored
                    if (currentParent) {
                        var child = {
                            type: 3,
                            text: text,
                            isComment: true,
                        };
                        if (options.outputSourceRange) {
                            child.start = start;
                            child.end = end;
                        }
                        currentParent.children.push(child);
                    }
                },
            });
            return root;
        }
        function processPre(el) {
            if (getAndRemoveAttr(el, "v-pre") != null) {
                el.pre = true;
            }
        }
        function processRawAttrs(el) {
            var list = el.attrsList;
            var len = list.length;
            if (len) {
                var attrs = el.attrs = new Array(len);
                for (var i = 0; i < len; i++) {
                    attrs[i] = {
                        name: list[i].name,
                        value: JSON.stringify(list[i].value),
                    };
                    if (list[i].start != null) {
                        attrs[i].start = list[i].start;
                        attrs[i].end = list[i].end;
                    }
                }
            }
            else if (!el.pre) {
                // non root node in pre blocks with no attributes
                el.plain = true;
            }
        }
        function processElement(element, options) {
            processKey(element); // determine whether this is a plain element after
            // removing structural attributes
            element.plain = !element.key && !element.scopedSlots &&
                !element.attrsList.length;
            processRef(element);
            processSlotContent(element);
            processSlotOutlet(element);
            processComponent(element);
            for (var i = 0; i < transforms.length; i++) {
                element = transforms[i](element, options) || element;
            }
            processAttrs(element);
            return element;
        }
        function processKey(el) {
            var exp = getBindingAttr(el, "key");
            if (exp) {
                {
                    if (el.tag === "template") {
                        warn$1("<template> cannot be keyed. Place the key on real elements instead.", getRawBindingAttr(el, "key"));
                    }
                    if (el.for) {
                        var iterator = el.iterator2 || el.iterator1;
                        var parent = el.parent;
                        if (iterator && iterator === exp && parent &&
                            parent.tag === "transition-group") {
                            warn$1("Do not use v-for index as key on <transition-group> children, " +
                                "this is the same as not using keys.", getRawBindingAttr(el, "key"), true);
                        }
                    }
                }
                el.key = exp;
            }
        }
        function processRef(el) {
            var ref = getBindingAttr(el, "ref");
            if (ref) {
                el.ref = ref;
                el.refInFor = checkInFor(el);
            }
        }
        function processFor(el) {
            var exp;
            if (exp = getAndRemoveAttr(el, "v-for")) {
                var res = parseFor(exp);
                if (res) {
                    extend(el, res);
                }
                else {
                    warn$1("Invalid v-for expression: " + exp, el.rawAttrsMap["v-for"]);
                }
            }
        }
        function parseFor(exp) {
            var inMatch = exp.match(forAliasRE);
            if (!inMatch) {
                return;
            }
            var res = {};
            res.for = inMatch[2].trim();
            var alias = inMatch[1].trim().replace(stripParensRE, "");
            var iteratorMatch = alias.match(forIteratorRE);
            if (iteratorMatch) {
                res.alias = alias.replace(forIteratorRE, "").trim();
                res.iterator1 = iteratorMatch[1].trim();
                if (iteratorMatch[2]) {
                    res.iterator2 = iteratorMatch[2].trim();
                }
            }
            else {
                res.alias = alias;
            }
            return res;
        }
        function processIf(el) {
            var exp = getAndRemoveAttr(el, "v-if");
            if (exp) {
                el.if = exp;
                addIfCondition(el, {
                    exp: exp,
                    block: el,
                });
            }
            else {
                if (getAndRemoveAttr(el, "v-else") != null) {
                    el.else = true;
                }
                var elseif = getAndRemoveAttr(el, "v-else-if");
                if (elseif) {
                    el.elseif = elseif;
                }
            }
        }
        function processIfConditions(el, parent) {
            var prev = findPrevElement(parent.children);
            if (prev && prev.if) {
                addIfCondition(prev, {
                    exp: el.elseif,
                    block: el,
                });
            }
            else {
                warn$1("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : "else") + " " +
                    "used on element <" + el.tag + "> without corresponding v-if.", el.rawAttrsMap[el.elseif ? "v-else-if" : "v-else"]);
            }
        }
        function findPrevElement(children) {
            var i = children.length;
            while (i--) {
                if (children[i].type === 1) {
                    return children[i];
                }
                else {
                    if (children[i].text !== " ") {
                        warn$1('text "' + children[i].text.trim() +
                            '" between v-if and v-else(-if) ' + "will be ignored.", children[i]);
                    }
                    children.pop();
                }
            }
        }
        function addIfCondition(el, condition) {
            if (!el.ifConditions) {
                el.ifConditions = [];
            }
            el.ifConditions.push(condition);
        }
        function processOnce(el) {
            var once$$1 = getAndRemoveAttr(el, "v-once");
            if (once$$1 != null) {
                el.once = true;
            }
        } // handle content being passed to a component as slot,
        // e.g. <template slot="xxx">, <div slot-scope="xxx">
        function processSlotContent(el) {
            var slotScope;
            if (el.tag === "template") {
                slotScope = getAndRemoveAttr(el, "scope");
                /* istanbul ignore if */
                if (slotScope) {
                    warn$1('the "scope" attribute for scoped slots have been deprecated and ' +
                        'replaced by "slot-scope" since 2.5. The new "slot-scope" attribute ' +
                        "can also be used on plain elements in addition to <template> to " +
                        "denote scoped slots.", el.rawAttrsMap["scope"], true);
                }
                el.slotScope = slotScope || getAndRemoveAttr(el, "slot-scope");
            }
            else if (slotScope = getAndRemoveAttr(el, "slot-scope")) {
                /* istanbul ignore if */
                if (el.attrsMap["v-for"]) {
                    warn$1("Ambiguous combined usage of slot-scope and v-for on <" + el.tag +
                        "> " +
                        "(v-for takes higher priority). Use a wrapper <template> for the " +
                        "scoped slot to make it clearer.", el.rawAttrsMap["slot-scope"], true);
                }
                el.slotScope = slotScope;
            } // slot="xxx"
            var slotTarget = getBindingAttr(el, "slot");
            if (slotTarget) {
                el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
                el.slotTargetDynamic =
                    !!(el.attrsMap[":slot"] || el.attrsMap["v-bind:slot"]); // preserve slot as an attribute for native shadow DOM compat
                // only for non-scoped slots.
                if (el.tag !== "template" && !el.slotScope) {
                    addAttr(el, "slot", slotTarget, getRawBindingAttr(el, "slot"));
                }
            } // 2.6 v-slot syntax
            {
                if (el.tag === "template") {
                    // v-slot on <template>
                    var slotBinding = getAndRemoveAttrByRegex(el, slotRE);
                    if (slotBinding) {
                        {
                            if (el.slotTarget || el.slotScope) {
                                warn$1("Unexpected mixed usage of different slot syntaxes.", el);
                            }
                            if (el.parent && !maybeComponent(el.parent)) {
                                warn$1("<template v-slot> can only appear at the root level inside " +
                                    "the receiving component", el);
                            }
                        }
                        var ref = getSlotName(slotBinding);
                        var name = ref.name;
                        var dynamic = ref.dynamic;
                        el.slotTarget = name;
                        el.slotTargetDynamic = dynamic;
                        el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf
                    }
                }
                else {
                    // v-slot on component, denotes default slot
                    var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);
                    if (slotBinding$1) {
                        {
                            if (!maybeComponent(el)) {
                                warn$1("v-slot can only be used on components or <template>.", slotBinding$1);
                            }
                            if (el.slotScope || el.slotTarget) {
                                warn$1("Unexpected mixed usage of different slot syntaxes.", el);
                            }
                            if (el.scopedSlots) {
                                warn$1("To avoid scope ambiguity, the default slot should also use " +
                                    "<template> syntax when there are other named slots.", slotBinding$1);
                            }
                        } // add the component's children to its default slot
                        var slots = el.scopedSlots || (el.scopedSlots = {});
                        var ref$1 = getSlotName(slotBinding$1);
                        var name$1 = ref$1.name;
                        var dynamic$1 = ref$1.dynamic;
                        var slotContainer = slots[name$1] = createASTElement("template", [], el);
                        slotContainer.slotTarget = name$1;
                        slotContainer.slotTargetDynamic = dynamic$1;
                        slotContainer.children = el.children.filter(function (c) {
                            if (!c.slotScope) {
                                c.parent = slotContainer;
                                return true;
                            }
                        });
                        slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken; // remove children as they are returned from scopedSlots now
                        el.children = []; // mark el non-plain so data gets generated
                        el.plain = false;
                    }
                }
            }
        }
        function getSlotName(binding) {
            var name = binding.name.replace(slotRE, "");
            if (!name) {
                if (binding.name[0] !== "#") {
                    name = "default";
                }
                else {
                    warn$1("v-slot shorthand syntax requires a slot name.", binding);
                }
            }
            return dynamicArgRE.test(name) // dynamic [name]
                ? {
                    name: name.slice(1, -1),
                    dynamic: true,
                }
                : {
                    name: '"' + name + '"',
                    dynamic: false,
                };
        } // handle <slot/> outlets
        function processSlotOutlet(el) {
            if (el.tag === "slot") {
                el.slotName = getBindingAttr(el, "name");
                if (el.key) {
                    warn$1("`key` does not work on <slot> because slots are abstract outlets " +
                        "and can possibly expand into multiple elements. " +
                        "Use the key on a wrapping element instead.", getRawBindingAttr(el, "key"));
                }
            }
        }
        function processComponent(el) {
            var binding;
            if (binding = getBindingAttr(el, "is")) {
                el.component = binding;
            }
            if (getAndRemoveAttr(el, "inline-template") != null) {
                el.inlineTemplate = true;
            }
        }
        function processAttrs(el) {
            var list = el.attrsList;
            var i, l, name, rawName, value, modifiers, syncGen, isDynamic;
            for (i = 0, l = list.length; i < l; i++) {
                name = rawName = list[i].name;
                value = list[i].value;
                if (dirRE.test(name)) {
                    // mark element as dynamic
                    el.hasBindings = true; // modifiers
                    modifiers = parseModifiers(name.replace(dirRE, "")); // support .foo shorthand syntax for the .prop modifier
                    if (modifiers) {
                        name = name.replace(modifierRE, "");
                    }
                    if (bindRE.test(name)) {
                        // v-bind
                        name = name.replace(bindRE, "");
                        value = parseFilters(value);
                        isDynamic = dynamicArgRE.test(name);
                        if (isDynamic) {
                            name = name.slice(1, -1);
                        }
                        if (value.trim().length === 0) {
                            warn$1('The value for a v-bind expression cannot be empty. Found in "v-bind:' +
                                name + '"');
                        }
                        if (modifiers) {
                            if (modifiers.prop && !isDynamic) {
                                name = camelize(name);
                                if (name === "innerHtml") {
                                    name = "innerHTML";
                                }
                            }
                            if (modifiers.camel && !isDynamic) {
                                name = camelize(name);
                            }
                            if (modifiers.sync) {
                                syncGen = genAssignmentCode(value, "$event");
                                if (!isDynamic) {
                                    addHandler(el, "update:" + camelize(name), syncGen, null, false, warn$1, list[i]);
                                    if (hyphenate(name) !== camelize(name)) {
                                        addHandler(el, "update:" + hyphenate(name), syncGen, null, false, warn$1, list[i]);
                                    }
                                }
                                else {
                                    // handler w/ dynamic event name
                                    addHandler(el, '"update:"+(' + name + ")", syncGen, null, false, warn$1, list[i], true);
                                }
                            }
                        }
                        if (modifiers && modifiers.prop ||
                            !el.component &&
                                platformMustUseProp(el.tag, el.attrsMap.type, name)) {
                            addProp(el, name, value, list[i], isDynamic);
                        }
                        else {
                            addAttr(el, name, value, list[i], isDynamic);
                        }
                    }
                    else if (onRE.test(name)) {
                        // v-on
                        name = name.replace(onRE, "");
                        isDynamic = dynamicArgRE.test(name);
                        if (isDynamic) {
                            name = name.slice(1, -1);
                        }
                        addHandler(el, name, value, modifiers, false, warn$1, list[i], isDynamic);
                    }
                    else {
                        // normal directives
                        name = name.replace(dirRE, ""); // parse arg
                        var argMatch = name.match(argRE);
                        var arg = argMatch && argMatch[1];
                        isDynamic = false;
                        if (arg) {
                            name = name.slice(0, -(arg.length + 1));
                            if (dynamicArgRE.test(arg)) {
                                arg = arg.slice(1, -1);
                                isDynamic = true;
                            }
                        }
                        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);
                        if (name === "model") {
                            checkForAliasModel(el, value);
                        }
                    }
                }
                else {
                    // literal attribute
                    {
                        var res = parseText(value, delimiters);
                        if (res) {
                            warn$1(name + '="' + value + '": ' +
                                "Interpolation inside attributes has been removed. " +
                                "Use v-bind or the colon shorthand instead. For example, " +
                                'instead of <div id="{{ val }}">, use <div :id="val">.', list[i]);
                        }
                    }
                    addAttr(el, name, JSON.stringify(value), list[i]); // #6887 firefox doesn't update muted state if set via attribute
                    // even immediately after element creation
                    if (!el.component && name === "muted" &&
                        platformMustUseProp(el.tag, el.attrsMap.type, name)) {
                        addProp(el, name, "true", list[i]);
                    }
                }
            }
        }
        function checkInFor(el) {
            var parent = el;
            while (parent) {
                if (parent.for !== undefined) {
                    return true;
                }
                parent = parent.parent;
            }
            return false;
        }
        function parseModifiers(name) {
            var match = name.match(modifierRE);
            if (match) {
                var ret = {};
                match.forEach(function (m) {
                    ret[m.slice(1)] = true;
                });
                return ret;
            }
        }
        function makeAttrsMap(attrs) {
            var map = {};
            for (var i = 0, l = attrs.length; i < l; i++) {
                if (map[attrs[i].name] && !isIE && !isEdge) {
                    warn$1("duplicate attribute: " + attrs[i].name, attrs[i]);
                }
                map[attrs[i].name] = attrs[i].value;
            }
            return map;
        } // for script (e.g. type="x/template") or style, do not decode content
        function isTextTag(el) {
            return el.tag === "script" || el.tag === "style";
        }
        function isForbiddenTag(el) {
            return el.tag === "style" ||
                el.tag === "script" &&
                    (!el.attrsMap.type || el.attrsMap.type === "text/javascript");
        }
        var ieNSBug = /^xmlns:NS\d+/;
        var ieNSPrefix = /^NS\d+:/;
        /* istanbul ignore next */
        function guardIESVGBug(attrs) {
            var res = [];
            for (var i = 0; i < attrs.length; i++) {
                var attr = attrs[i];
                if (!ieNSBug.test(attr.name)) {
                    attr.name = attr.name.replace(ieNSPrefix, "");
                    res.push(attr);
                }
            }
            return res;
        }
        function checkForAliasModel(el, value) {
            var _el = el;
            while (_el) {
                if (_el.for && _el.alias === value) {
                    warn$1("<" + el.tag + ' v-model="' + value + '">: ' +
                        "You are binding v-model directly to a v-for iteration alias. " +
                        "This will not be able to modify the v-for source array because " +
                        "writing to the alias is like modifying a function local variable. " +
                        "Consider using an array of objects and use v-model on an object property instead.", el.rawAttrsMap["v-model"]);
                }
                _el = _el.parent;
            }
        }
        /*  */
        function preTransformNode(el, options) {
            if (el.tag === "input") {
                var map = el.attrsMap;
                if (!map["v-model"]) {
                    return;
                }
                var typeBinding;
                if (map[":type"] || map["v-bind:type"]) {
                    typeBinding = getBindingAttr(el, "type");
                }
                if (!map.type && !typeBinding && map["v-bind"]) {
                    typeBinding = "(" + map["v-bind"] + ").type";
                }
                if (typeBinding) {
                    var ifCondition = getAndRemoveAttr(el, "v-if", true);
                    var ifConditionExtra = ifCondition ? "&&(" + ifCondition + ")" : "";
                    var hasElse = getAndRemoveAttr(el, "v-else", true) != null;
                    var elseIfCondition = getAndRemoveAttr(el, "v-else-if", true); // 1. checkbox
                    var branch0 = cloneASTElement(el); // process for on the main node
                    processFor(branch0);
                    addRawAttr(branch0, "type", "checkbox");
                    processElement(branch0, options);
                    branch0.processed = true; // prevent it from double-processed
                    branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
                    addIfCondition(branch0, {
                        exp: branch0.if,
                        block: branch0,
                    }); // 2. add radio else-if condition
                    var branch1 = cloneASTElement(el);
                    getAndRemoveAttr(branch1, "v-for", true);
                    addRawAttr(branch1, "type", "radio");
                    processElement(branch1, options);
                    addIfCondition(branch0, {
                        exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
                        block: branch1,
                    }); // 3. other
                    var branch2 = cloneASTElement(el);
                    getAndRemoveAttr(branch2, "v-for", true);
                    addRawAttr(branch2, ":type", typeBinding);
                    processElement(branch2, options);
                    addIfCondition(branch0, {
                        exp: ifCondition,
                        block: branch2,
                    });
                    if (hasElse) {
                        branch0.else = true;
                    }
                    else if (elseIfCondition) {
                        branch0.elseif = elseIfCondition;
                    }
                    return branch0;
                }
            }
        }
        function cloneASTElement(el) {
            return createASTElement(el.tag, el.attrsList.slice(), el.parent);
        }
        var model$1 = {
            preTransformNode: preTransformNode,
        };
        var modules$1 = [klass, style, model$1];
        /*  */
        var warn$2; // in some cases, the event used has to be determined at runtime
        // so we used some reserved tokens during compile.
        var RANGE_TOKEN = "__r";
        function model$2(el, dir, _warn) {
            warn$2 = _warn;
            var value = dir.value;
            var modifiers = dir.modifiers;
            var tag = el.tag;
            var type = el.attrsMap.type;
            {
                // inputs with type="file" are read only and setting the input's
                // value will throw an error.
                if (tag === "input" && type === "file") {
                    warn$2("<" + el.tag + ' v-model="' + value + '" type="file">:\n' +
                        "File inputs are read only. Use a v-on:change listener instead.", el.rawAttrsMap["v-model"]);
                }
            }
            if (el.component) {
                genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime
                return false;
            }
            else if (tag === "select") {
                genSelect(el, value, modifiers);
            }
            else if (tag === "input" && type === "checkbox") {
                genCheckboxModel(el, value, modifiers);
            }
            else if (tag === "input" && type === "radio") {
                genRadioModel(el, value, modifiers);
            }
            else if (tag === "input" || tag === "textarea") {
                genDefaultModel(el, value, modifiers);
            }
            else {
                genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime
                return false;
            } // ensure runtime directive metadata
            return true;
        }
        function genCheckboxModel(el, value, modifiers) {
            var number = modifiers && modifiers.number;
            var valueBinding = getBindingAttr(el, "value") || "null";
            var trueValueBinding = getBindingAttr(el, "true-value") || "true";
            var falseValueBinding = getBindingAttr(el, "false-value") || "false";
            addProp(el, "checked", "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding +
                ")>-1" +
                (trueValueBinding === "true"
                    ? ":(" + value + ")"
                    : ":_q(" + value + "," + trueValueBinding + ")"));
            addHandler(el, "change", "var $$a=" + value + "," + "$$el=$event.target," + "$$c=$$el.checked?(" +
                trueValueBinding + "):(" + falseValueBinding + ");" +
                "if(Array.isArray($$a)){" + "var $$v=" +
                (number ? "_n(" + valueBinding + ")" : valueBinding) +
                "," + "$$i=_i($$a,$$v);" + "if($$el.checked){$$i<0&&(" +
                genAssignmentCode(value, "$$a.concat([$$v])") + ")}" +
                "else{$$i>-1&&(" +
                genAssignmentCode(value, "$$a.slice(0,$$i).concat($$a.slice($$i+1))") +
                ")}" + "}else{" + genAssignmentCode(value, "$$c") + "}", null, true);
        }
        function genRadioModel(el, value, modifiers) {
            var number = modifiers && modifiers.number;
            var valueBinding = getBindingAttr(el, "value") || "null";
            valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
            addProp(el, "checked", "_q(" + value + "," + valueBinding + ")");
            addHandler(el, "change", genAssignmentCode(value, valueBinding), null, true);
        }
        function genSelect(el, value, modifiers) {
            var number = modifiers && modifiers.number;
            var selectedVal = "Array.prototype.filter" +
                ".call($event.target.options,function(o){return o.selected})" +
                '.map(function(o){var val = "_value" in o ? o._value : o.value;' +
                "return " + (number ? "_n(val)" : "val") + "})";
            var assignment = "$event.target.multiple ? $$selectedVal : $$selectedVal[0]";
            var code = "var $$selectedVal = " + selectedVal + ";";
            code = code + " " + genAssignmentCode(value, assignment);
            addHandler(el, "change", code, null, true);
        }
        function genDefaultModel(el, value, modifiers) {
            var type = el.attrsMap.type; // warn if v-bind:value conflicts with v-model
            // except for inputs with v-bind:type
            {
                var value$1 = el.attrsMap["v-bind:value"] || el.attrsMap[":value"];
                var typeBinding = el.attrsMap["v-bind:type"] || el.attrsMap[":type"];
                if (value$1 && !typeBinding) {
                    var binding = el.attrsMap["v-bind:value"] ? "v-bind:value" : ":value";
                    warn$2(binding + '="' + value$1 +
                        '" conflicts with v-model on the same element ' +
                        "because the latter already expands to a value binding internally", el.rawAttrsMap[binding]);
                }
            }
            var ref = modifiers || {};
            var lazy = ref.lazy;
            var number = ref.number;
            var trim = ref.trim;
            var needCompositionGuard = !lazy && type !== "range";
            var event = lazy ? "change" : type === "range" ? RANGE_TOKEN : "input";
            var valueExpression = "$event.target.value";
            if (trim) {
                valueExpression = "$event.target.value.trim()";
            }
            if (number) {
                valueExpression = "_n(" + valueExpression + ")";
            }
            var code = genAssignmentCode(value, valueExpression);
            if (needCompositionGuard) {
                code = "if($event.target.composing)return;" + code;
            }
            addProp(el, "value", "(" + value + ")");
            addHandler(el, event, code, null, true);
            if (trim || number) {
                addHandler(el, "blur", "$forceUpdate()");
            }
        }
        /*  */
        function text(el, dir) {
            if (dir.value) {
                addProp(el, "textContent", "_s(" + dir.value + ")", dir);
            }
        }
        /*  */
        function html(el, dir) {
            if (dir.value) {
                addProp(el, "innerHTML", "_s(" + dir.value + ")", dir);
            }
        }
        var directives = {
            model: model$2,
            text: text,
            html: html,
        };
        /*  */
        var baseOptions = {
            expectHTML: true,
            modules: modules$1,
            directives: directives,
            isPreTag: isPreTag,
            isUnaryTag: isUnaryTag,
            mustUseProp: mustUseProp,
            canBeLeftOpenTag: canBeLeftOpenTag,
            isReservedTag: isReservedTag,
            getTagNamespace: getTagNamespace,
            staticKeys: genStaticKeys(modules$1),
        };
        /*  */
        var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/;
        var fnInvokeRE = /\([^)]*?\);*$/;
        var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/; // KeyboardEvent.keyCode aliases
        var keyCodes = {
            esc: 27,
            tab: 9,
            enter: 13,
            space: 32,
            up: 38,
            left: 37,
            right: 39,
            down: 40,
            "delete": [8, 46],
        }; // KeyboardEvent.key aliases
        var keyNames = {
            // #7880: IE11 and Edge use `Esc` for Escape key name.
            esc: ["Esc", "Escape"],
            tab: "Tab",
            enter: "Enter",
            // #9112: IE11 uses `Spacebar` for Space key name.
            space: [" ", "Spacebar"],
            // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
            up: ["Up", "ArrowUp"],
            left: ["Left", "ArrowLeft"],
            right: ["Right", "ArrowRight"],
            down: ["Down", "ArrowDown"],
            // #9112: IE11 uses `Del` for Delete key name.
            "delete": ["Backspace", "Delete", "Del"],
        }; // #4868: modifiers that prevent the execution of the listener
        // need to explicitly return null so that we can determine whether to remove
        // the listener for .once
        var genGuard = function (condition) {
            return "if(" + condition + ")return null;";
        };
        var modifierCode = {
            stop: "$event.stopPropagation();",
            prevent: "$event.preventDefault();",
            self: genGuard("$event.target !== $event.currentTarget"),
            ctrl: genGuard("!$event.ctrlKey"),
            shift: genGuard("!$event.shiftKey"),
            alt: genGuard("!$event.altKey"),
            meta: genGuard("!$event.metaKey"),
            left: genGuard("'button' in $event && $event.button !== 0"),
            middle: genGuard("'button' in $event && $event.button !== 1"),
            right: genGuard("'button' in $event && $event.button !== 2"),
        };
        function genHandlers(events, isNative) {
            var prefix = isNative ? "nativeOn:" : "on:";
            var staticHandlers = "";
            var dynamicHandlers = "";
            for (var name in events) {
                var handlerCode = genHandler(events[name]);
                if (events[name] && events[name].dynamic) {
                    dynamicHandlers += name + "," + handlerCode + ",";
                }
                else {
                    staticHandlers += '"' + name + '":' + handlerCode + ",";
                }
            }
            staticHandlers = "{" + staticHandlers.slice(0, -1) + "}";
            if (dynamicHandlers) {
                return prefix + "_d(" + staticHandlers + ",[" +
                    dynamicHandlers.slice(0, -1) + "])";
            }
            else {
                return prefix + staticHandlers;
            }
        }
        function genHandler(handler) {
            if (!handler) {
                return "function(){}";
            }
            if (Array.isArray(handler)) {
                return "[" + handler.map(function (handler) {
                    return genHandler(handler);
                }).join(",") + "]";
            }
            var isMethodPath = simplePathRE.test(handler.value);
            var isFunctionExpression = fnExpRE.test(handler.value);
            var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ""));
            if (!handler.modifiers) {
                if (isMethodPath || isFunctionExpression) {
                    return handler.value;
                }
                return "function($event){" + (isFunctionInvocation
                    ? "return " + handler.value
                    : handler.value) +
                    "}"; // inline statement
            }
            else {
                var code = "";
                var genModifierCode = "";
                var keys = [];
                for (var key in handler.modifiers) {
                    if (modifierCode[key]) {
                        genModifierCode += modifierCode[key]; // left/right
                        if (keyCodes[key]) {
                            keys.push(key);
                        }
                    }
                    else if (key === "exact") {
                        var modifiers = handler.modifiers;
                        genModifierCode += genGuard(["ctrl", "shift", "alt", "meta"].filter(function (keyModifier) {
                            return !modifiers[keyModifier];
                        }).map(function (keyModifier) {
                            return "$event." + keyModifier + "Key";
                        }).join("||"));
                    }
                    else {
                        keys.push(key);
                    }
                }
                if (keys.length) {
                    code += genKeyFilter(keys);
                } // Make sure modifiers like prevent and stop get executed after key filtering
                if (genModifierCode) {
                    code += genModifierCode;
                }
                var handlerCode = isMethodPath
                    ? "return " + handler.value + "($event)"
                    : isFunctionExpression
                        ? "return (" + handler.value + ")($event)"
                        : isFunctionInvocation
                            ? "return " + handler.value
                            : handler.value;
                return "function($event){" + code + handlerCode + "}";
            }
        }
        function genKeyFilter(keys) {
            return ( // make sure the key filters only apply to KeyboardEvents
            // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake
            // key events that do not have keyCode property...
            "if(!$event.type.indexOf('key')&&" + keys.map(genFilterCode).join("&&") +
                ")return null;");
        }
        function genFilterCode(key) {
            var keyVal = parseInt(key, 10);
            if (keyVal) {
                return "$event.keyCode!==" + keyVal;
            }
            var keyCode = keyCodes[key];
            var keyName = keyNames[key];
            return "_k($event.keyCode," + JSON.stringify(key) + "," +
                JSON.stringify(keyCode) + "," + "$event.key," + "" +
                JSON.stringify(keyName) + ")";
        }
        /*  */
        function on(el, dir) {
            if (dir.modifiers) {
                warn("v-on without argument does not support modifiers.");
            }
            el.wrapListeners = function (code) {
                return "_g(" + code + "," + dir.value + ")";
            };
        }
        /*  */
        function bind$1(el, dir) {
            el.wrapData = function (code) {
                return "_b(" + code + ",'" + el.tag + "'," + dir.value + "," +
                    (dir.modifiers && dir.modifiers.prop ? "true" : "false") +
                    (dir.modifiers && dir.modifiers.sync ? ",true" : "") + ")";
            };
        }
        /*  */
        var baseDirectives$1 = {
            on: on,
            bind: bind$1,
            cloak: noop,
        };
        /*  */
        var CodegenState = function CodegenState(options) {
            this.options = options;
            this.warn = options.warn || baseWarn;
            this.transforms = pluckModuleFunction(options.modules, "transformCode");
            this.dataGenFns = pluckModuleFunction(options.modules, "genData");
            this.directives = extend(extend({}, baseDirectives$1), options.directives);
            var isReservedTag = options.isReservedTag || no;
            this.maybeComponent = function (el) {
                return !!el.component || !isReservedTag(el.tag);
            };
            this.onceId = 0;
            this.staticRenderFns = [];
            this.pre = false;
        };
        function generate(ast, options) {
            var state = new CodegenState(options);
            var code = ast ? genElement(ast, state) : '_c("div")';
            return {
                render: "with(this){return " + code + "}",
                staticRenderFns: state.staticRenderFns,
            };
        }
        function genElement(el, state) {
            if (el.parent) {
                el.pre = el.pre || el.parent.pre;
            }
            if (el.staticRoot && !el.staticProcessed) {
                return genStatic(el, state);
            }
            else if (el.once && !el.onceProcessed) {
                return genOnce(el, state);
            }
            else if (el.for && !el.forProcessed) {
                return genFor(el, state);
            }
            else if (el.if && !el.ifProcessed) {
                return genIf(el, state);
            }
            else if (el.tag === "template" && !el.slotTarget && !state.pre) {
                return genChildren(el, state) || "void 0";
            }
            else if (el.tag === "slot") {
                return genSlot(el, state);
            }
            else {
                // component or element
                var code;
                if (el.component) {
                    code = genComponent(el.component, el, state);
                }
                else {
                    var data;
                    if (!el.plain || el.pre && state.maybeComponent(el)) {
                        data = genData$2(el, state);
                    }
                    var children = el.inlineTemplate ? null : genChildren(el, state, true);
                    code = "_c('" + el.tag + "'" + (data ? "," + data : "") + (children
                        ? "," + children
                        : "") +
                        ")";
                } // module transforms
                for (var i = 0; i < state.transforms.length; i++) {
                    code = state.transforms[i](el, code);
                }
                return code;
            }
        } // hoist static sub-trees out
        function genStatic(el, state) {
            el.staticProcessed = true; // Some elements (templates) need to behave differently inside of a v-pre
            // node.  All pre nodes are static roots, so we can use this as a location to
            // wrap a state change and reset it upon exiting the pre node.
            var originalPreState = state.pre;
            if (el.pre) {
                state.pre = el.pre;
            }
            state.staticRenderFns.push("with(this){return " + genElement(el, state) + "}");
            state.pre = originalPreState;
            return "_m(" + (state.staticRenderFns.length - 1) +
                (el.staticInFor ? ",true" : "") +
                ")";
        } // v-once
        function genOnce(el, state) {
            el.onceProcessed = true;
            if (el.if && !el.ifProcessed) {
                return genIf(el, state);
            }
            else if (el.staticInFor) {
                var key = "";
                var parent = el.parent;
                while (parent) {
                    if (parent.for) {
                        key = parent.key;
                        break;
                    }
                    parent = parent.parent;
                }
                if (!key) {
                    state.warn("v-once can only be used inside v-for that is keyed. ", el.rawAttrsMap["v-once"]);
                    return genElement(el, state);
                }
                return "_o(" + genElement(el, state) + "," + state.onceId++ + "," + key +
                    ")";
            }
            else {
                return genStatic(el, state);
            }
        }
        function genIf(el, state, altGen, altEmpty) {
            el.ifProcessed = true; // avoid recursion
            return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
        }
        function genIfConditions(conditions, state, altGen, altEmpty) {
            if (!conditions.length) {
                return altEmpty || "_e()";
            }
            var condition = conditions.shift();
            if (condition.exp) {
                return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" +
                    genIfConditions(conditions, state, altGen, altEmpty);
            }
            else {
                return "" + genTernaryExp(condition.block);
            } // v-if with v-once should generate code like (a)?_m(0):_m(1)
            function genTernaryExp(el) {
                return altGen
                    ? altGen(el, state)
                    : el.once
                        ? genOnce(el, state)
                        : genElement(el, state);
            }
        }
        function genFor(el, state, altGen, altHelper) {
            var exp = el.for;
            var alias = el.alias;
            var iterator1 = el.iterator1 ? "," + el.iterator1 : "";
            var iterator2 = el.iterator2 ? "," + el.iterator2 : "";
            if (state.maybeComponent(el) && el.tag !== "slot" && el.tag !== "template" &&
                !el.key) {
                state.warn("<" + el.tag + ' v-for="' + alias + " in " + exp +
                    '">: component lists rendered with ' +
                    "v-for should have explicit keys. " +
                    "See https://vuejs.org/guide/list.html#key for more info.", el.rawAttrsMap["v-for"], true);
            }
            el.forProcessed = true; // avoid recursion
            return (altHelper || "_l") + "((" + exp + ")," + "function(" + alias +
                iterator1 + iterator2 + "){" + "return " +
                (altGen || genElement)(el, state) + "})";
        }
        function genData$2(el, state) {
            var data = "{"; // directives first.
            // directives may mutate the el's other properties before they are generated.
            var dirs = genDirectives(el, state);
            if (dirs) {
                data += dirs + ",";
            } // key
            if (el.key) {
                data += "key:" + el.key + ",";
            } // ref
            if (el.ref) {
                data += "ref:" + el.ref + ",";
            }
            if (el.refInFor) {
                data += "refInFor:true,";
            } // pre
            if (el.pre) {
                data += "pre:true,";
            } // record original tag name for components using "is" attribute
            if (el.component) {
                data += 'tag:"' + el.tag + '",';
            } // module data generation functions
            for (var i = 0; i < state.dataGenFns.length; i++) {
                data += state.dataGenFns[i](el);
            } // attributes
            if (el.attrs) {
                data += "attrs:" + genProps(el.attrs) + ",";
            } // DOM props
            if (el.props) {
                data += "domProps:" + genProps(el.props) + ",";
            } // event handlers
            if (el.events) {
                data += genHandlers(el.events, false) + ",";
            }
            if (el.nativeEvents) {
                data += genHandlers(el.nativeEvents, true) + ",";
            } // slot target
            // only for non-scoped slots
            if (el.slotTarget && !el.slotScope) {
                data += "slot:" + el.slotTarget + ",";
            } // scoped slots
            if (el.scopedSlots) {
                data += genScopedSlots(el, el.scopedSlots, state) + ",";
            } // component v-model
            if (el.model) {
                data += "model:{value:" + el.model.value + ",callback:" +
                    el.model.callback + ",expression:" + el.model.expression + "},";
            } // inline-template
            if (el.inlineTemplate) {
                var inlineTemplate = genInlineTemplate(el, state);
                if (inlineTemplate) {
                    data += inlineTemplate + ",";
                }
            }
            data = data.replace(/,$/, "") + "}"; // v-bind dynamic argument wrap
            // v-bind with dynamic arguments must be applied using the same v-bind object
            // merge helper so that class/style/mustUseProp attrs are handled correctly.
            if (el.dynamicAttrs) {
                data = "_b(" + data + ',"' + el.tag + '",' + genProps(el.dynamicAttrs) +
                    ")";
            } // v-bind data wrap
            if (el.wrapData) {
                data = el.wrapData(data);
            } // v-on data wrap
            if (el.wrapListeners) {
                data = el.wrapListeners(data);
            }
            return data;
        }
        function genDirectives(el, state) {
            var dirs = el.directives;
            if (!dirs) {
                return;
            }
            var res = "directives:[";
            var hasRuntime = false;
            var i, l, dir, needRuntime;
            for (i = 0, l = dirs.length; i < l; i++) {
                dir = dirs[i];
                needRuntime = true;
                var gen = state.directives[dir.name];
                if (gen) {
                    // compile-time directive that manipulates AST.
                    // returns true if it also needs a runtime counterpart.
                    needRuntime = !!gen(el, dir, state.warn);
                }
                if (needRuntime) {
                    hasRuntime = true;
                    res += '{name:"' + dir.name + '",rawName:"' + dir.rawName + '"' +
                        (dir.value
                            ? ",value:(" + dir.value + "),expression:" +
                                JSON.stringify(dir.value)
                            : "") +
                        (dir.arg
                            ? ",arg:" + (dir.isDynamicArg ? dir.arg : '"' + dir.arg + '"')
                            : "") +
                        (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : "") +
                        "},";
                }
            }
            if (hasRuntime) {
                return res.slice(0, -1) + "]";
            }
        }
        function genInlineTemplate(el, state) {
            var ast = el.children[0];
            if (el.children.length !== 1 || ast.type !== 1) {
                state.warn("Inline-template components must have exactly one child element.", {
                    start: el.start,
                });
            }
            if (ast && ast.type === 1) {
                var inlineRenderFns = generate(ast, state.options);
                return "inlineTemplate:{render:function(){" + inlineRenderFns.render +
                    "},staticRenderFns:[" +
                    inlineRenderFns.staticRenderFns.map(function (code) {
                        return "function(){" + code + "}";
                    }).join(",") + "]}";
            }
        }
        function genScopedSlots(el, slots, state) {
            // by default scoped slots are considered "stable", this allows child
            // components with only scoped slots to skip forced updates from parent.
            // but in some cases we have to bail-out of this optimization
            // for example if the slot contains dynamic names, has v-if or v-for on them...
            var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {
                var slot = slots[key];
                return slot.slotTargetDynamic || slot.if || slot.for ||
                    containsSlotChild(slot) // is passing down slot from parent which may be dynamic
                ;
            }); // #9534: if a component with scoped slots is inside a conditional branch,
            // it's possible for the same component to be reused but with different
            // compiled slot content. To avoid that, we generate a unique key based on
            // the generated code of all the slot contents.
            var needsKey = !!el.if; // OR when it is inside another scoped slot or v-for (the reactivity may be
            // disconnected due to the intermediate scope variable)
            // #9438, #9506
            // TODO: this can be further optimized by properly analyzing in-scope bindings
            // and skip force updating ones that do not actually use scope variables.
            if (!needsForceUpdate) {
                var parent = el.parent;
                while (parent) {
                    if (parent.slotScope && parent.slotScope !== emptySlotScopeToken ||
                        parent.for) {
                        needsForceUpdate = true;
                        break;
                    }
                    if (parent.if) {
                        needsKey = true;
                    }
                    parent = parent.parent;
                }
            }
            var generatedSlots = Object.keys(slots).map(function (key) {
                return genScopedSlot(slots[key], state);
            }).join(",");
            return "scopedSlots:_u([" + generatedSlots + "]" +
                (needsForceUpdate ? ",null,true" : "") +
                (!needsForceUpdate && needsKey
                    ? ",null,false," + hash(generatedSlots)
                    : "") +
                ")";
        }
        function hash(str) {
            var hash = 5381;
            var i = str.length;
            while (i) {
                hash = hash * 33 ^ str.charCodeAt(--i);
            }
            return hash >>> 0;
        }
        function containsSlotChild(el) {
            if (el.type === 1) {
                if (el.tag === "slot") {
                    return true;
                }
                return el.children.some(containsSlotChild);
            }
            return false;
        }
        function genScopedSlot(el, state) {
            var isLegacySyntax = el.attrsMap["slot-scope"];
            if (el.if && !el.ifProcessed && !isLegacySyntax) {
                return genIf(el, state, genScopedSlot, "null");
            }
            if (el.for && !el.forProcessed) {
                return genFor(el, state, genScopedSlot);
            }
            var slotScope = el.slotScope === emptySlotScopeToken
                ? ""
                : String(el.slotScope);
            var fn = "function(" + slotScope + "){" + "return " +
                (el.tag === "template"
                    ? el.if && isLegacySyntax
                        ? "(" + el.if + ")?" + (genChildren(el, state) || "undefined") +
                            ":undefined"
                        : genChildren(el, state) || "undefined"
                    : genElement(el, state)) +
                "}"; // reverse proxy v-slot without scope on this.$slots
            var reverseProxy = slotScope ? "" : ",proxy:true";
            return "{key:" + (el.slotTarget || '"default"') + ",fn:" + fn +
                reverseProxy + "}";
        }
        function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
            var children = el.children;
            if (children.length) {
                var el$1 = children[0]; // optimize single v-for
                if (children.length === 1 && el$1.for && el$1.tag !== "template" &&
                    el$1.tag !== "slot") {
                    var normalizationType = checkSkip
                        ? state.maybeComponent(el$1) ? ",1" : ",0"
                        : "";
                    return "" + (altGenElement || genElement)(el$1, state) +
                        normalizationType;
                }
                var normalizationType$1 = checkSkip
                    ? getNormalizationType(children, state.maybeComponent)
                    : 0;
                var gen = altGenNode || genNode;
                return "[" + children.map(function (c) {
                    return gen(c, state);
                }).join(",") + "]" + (normalizationType$1
                    ? "," + normalizationType$1
                    : "");
            }
        } // determine the normalization needed for the children array.
        // 0: no normalization needed
        // 1: simple normalization needed (possible 1-level deep nested array)
        // 2: full normalization needed
        function getNormalizationType(children, maybeComponent) {
            var res = 0;
            for (var i = 0; i < children.length; i++) {
                var el = children[i];
                if (el.type !== 1) {
                    continue;
                }
                if (needsNormalization(el) ||
                    el.ifConditions && el.ifConditions.some(function (c) {
                        return needsNormalization(c.block);
                    })) {
                    res = 2;
                    break;
                }
                if (maybeComponent(el) ||
                    el.ifConditions && el.ifConditions.some(function (c) {
                        return maybeComponent(c.block);
                    })) {
                    res = 1;
                }
            }
            return res;
        }
        function needsNormalization(el) {
            return el.for !== undefined || el.tag === "template" || el.tag === "slot";
        }
        function genNode(node, state) {
            if (node.type === 1) {
                return genElement(node, state);
            }
            else if (node.type === 3 && node.isComment) {
                return genComment(node);
            }
            else {
                return genText(node);
            }
        }
        function genText(text) {
            return "_v(" + (text.type === 2
                ? text.expression // no need for () because already wrapped in _s()
                : transformSpecialNewlines(JSON.stringify(text.text))) +
                ")";
        }
        function genComment(comment) {
            return "_e(" + JSON.stringify(comment.text) + ")";
        }
        function genSlot(el, state) {
            var slotName = el.slotName || '"default"';
            var children = genChildren(el, state);
            var res = "_t(" + slotName + (children ? "," + children : "");
            var attrs = el.attrs || el.dynamicAttrs
                ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) {
                    return {
                        // slot props are camelized
                        name: camelize(attr.name),
                        value: attr.value,
                        dynamic: attr.dynamic,
                    };
                }))
                : null;
            var bind$$1 = el.attrsMap["v-bind"];
            if ((attrs || bind$$1) && !children) {
                res += ",null";
            }
            if (attrs) {
                res += "," + attrs;
            }
            if (bind$$1) {
                res += (attrs ? "" : ",null") + "," + bind$$1;
            }
            return res + ")";
        } // componentName is el.component, take it as argument to shun flow's pessimistic refinement
        function genComponent(componentName, el, state) {
            var children = el.inlineTemplate ? null : genChildren(el, state, true);
            return "_c(" + componentName + "," + genData$2(el, state) +
                (children ? "," + children : "") +
                ")";
        }
        function genProps(props) {
            var staticProps = "";
            var dynamicProps = "";
            for (var i = 0; i < props.length; i++) {
                var prop = props[i];
                var value = transformSpecialNewlines(prop.value);
                if (prop.dynamic) {
                    dynamicProps += prop.name + "," + value + ",";
                }
                else {
                    staticProps += '"' + prop.name + '":' + value + ",";
                }
            }
            staticProps = "{" + staticProps.slice(0, -1) + "}";
            if (dynamicProps) {
                return "_d(" + staticProps + ",[" + dynamicProps.slice(0, -1) + "])";
            }
            else {
                return staticProps;
            }
        } // #3895, #4268
        function transformSpecialNewlines(text) {
            return text.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
        }
        /*  */
        var plainStringRE = /^"(?:[^"\\]|\\.)*"$|^'(?:[^'\\]|\\.)*'$/; // let the model AST transform translate v-model into appropriate
        // props bindings
        function applyModelTransform(el, state) {
            if (el.directives) {
                for (var i = 0; i < el.directives.length; i++) {
                    var dir = el.directives[i];
                    if (dir.name === "model") {
                        state.directives.model(el, dir, state.warn); // remove value for textarea as its converted to text
                        if (el.tag === "textarea" && el.props) {
                            el.props = el.props.filter(function (p) {
                                return p.name !== "value";
                            });
                        }
                        break;
                    }
                }
            }
        }
        function genAttrSegments(attrs) {
            return attrs.map(function (ref) {
                var name = ref.name;
                var value = ref.value;
                return genAttrSegment(name, value);
            });
        }
        function genDOMPropSegments(props, attrs) {
            var segments = [];
            props.forEach(function (ref) {
                var name = ref.name;
                var value = ref.value;
                name = propsToAttrMap[name] || name.toLowerCase();
                if (isRenderableAttr(name) && !(attrs && attrs.some(function (a) {
                    return a.name === name;
                }))) {
                    segments.push(genAttrSegment(name, value));
                }
            });
            return segments;
        }
        function genAttrSegment(name, value) {
            if (plainStringRE.test(value)) {
                // force double quote
                value = value.replace(/^'|'$/g, '"'); // force enumerated attr to "true"
                if (isEnumeratedAttr(name) && value !== '"false"') {
                    value = '"true"';
                }
                return {
                    type: RAW,
                    value: isBooleanAttr(name)
                        ? " " + name + '="' + name + '"'
                        : value === '""'
                            ? " " + name
                            : " " + name + '="' + JSON.parse(value) + '"',
                };
            }
            else {
                return {
                    type: EXPRESSION,
                    value: "_ssrAttr(" + JSON.stringify(name) + "," + value + ")",
                };
            }
        }
        function genClassSegments(staticClass, classBinding) {
            if (staticClass && !classBinding) {
                return [{
                        type: RAW,
                        value: ' class="' + JSON.parse(staticClass) + '"',
                    }];
            }
            else {
                return [{
                        type: EXPRESSION,
                        value: "_ssrClass(" + (staticClass || "null") + "," +
                            (classBinding || "null") + ")",
                    }];
            }
        }
        function genStyleSegments(staticStyle, parsedStaticStyle, styleBinding, vShowExpression) {
            if (staticStyle && !styleBinding && !vShowExpression) {
                return [{
                        type: RAW,
                        value: " style=" + JSON.stringify(staticStyle),
                    }];
            }
            else {
                return [{
                        type: EXPRESSION,
                        value: "_ssrStyle(" + (parsedStaticStyle || "null") + "," +
                            (styleBinding || "null") + ", " + (vShowExpression
                            ? "{ display: (" + vShowExpression + ") ? '' : 'none' }"
                            : "null") +
                            ")",
                    }];
            }
        }
        /*  */
        // optimizability constants
        var optimizability = {
            FALSE: 0,
            // whole sub tree un-optimizable
            FULL: 1,
            // whole sub tree optimizable
            SELF: 2,
            // self optimizable but has some un-optimizable children
            CHILDREN: 3,
            // self un-optimizable but have fully optimizable children
            PARTIAL: 4,
        };
        var isPlatformReservedTag;
        function optimize(root, options) {
            if (!root) {
                return;
            }
            isPlatformReservedTag = options.isReservedTag || no;
            walk(root, true);
        }
        function walk(node, isRoot) {
            if (isUnOptimizableTree(node)) {
                node.ssrOptimizability = optimizability.FALSE;
                return;
            } // root node or nodes with custom directives should always be a VNode
            var selfUnoptimizable = isRoot || hasCustomDirective(node);
            var check = function (child) {
                if (child.ssrOptimizability !== optimizability.FULL) {
                    node.ssrOptimizability = selfUnoptimizable
                        ? optimizability.PARTIAL
                        : optimizability.SELF;
                }
            };
            if (selfUnoptimizable) {
                node.ssrOptimizability = optimizability.CHILDREN;
            }
            if (node.type === 1) {
                for (var i = 0, l = node.children.length; i < l; i++) {
                    var child = node.children[i];
                    walk(child);
                    check(child);
                }
                if (node.ifConditions) {
                    for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
                        var block = node.ifConditions[i$1].block;
                        walk(block, isRoot);
                        check(block);
                    }
                }
                if (node.ssrOptimizability == null ||
                    !isRoot && (node.attrsMap["v-html"] || node.attrsMap["v-text"])) {
                    node.ssrOptimizability = optimizability.FULL;
                }
                else {
                    node.children = optimizeSiblings(node);
                }
            }
            else {
                node.ssrOptimizability = optimizability.FULL;
            }
        }
        function optimizeSiblings(el) {
            var children = el.children;
            var optimizedChildren = [];
            var currentOptimizableGroup = [];
            var pushGroup = function () {
                if (currentOptimizableGroup.length) {
                    optimizedChildren.push({
                        type: 1,
                        parent: el,
                        tag: "template",
                        attrsList: [],
                        attrsMap: {},
                        rawAttrsMap: {},
                        children: currentOptimizableGroup,
                        ssrOptimizability: optimizability.FULL,
                    });
                }
                currentOptimizableGroup = [];
            };
            for (var i = 0; i < children.length; i++) {
                var c = children[i];
                if (c.ssrOptimizability === optimizability.FULL) {
                    currentOptimizableGroup.push(c);
                }
                else {
                    // wrap fully-optimizable adjacent siblings inside a template tag
                    // so that they can be optimized into a single ssrNode by codegen
                    pushGroup();
                    optimizedChildren.push(c);
                }
            }
            pushGroup();
            return optimizedChildren;
        }
        function isUnOptimizableTree(node) {
            if (node.type === 2 || node.type === 3) {
                // text or expression
                return false;
            }
            return isBuiltInTag(node.tag) || // built-in (slot, component)
                !isPlatformReservedTag(node.tag) || // custom component
                !!node.component || // "is" component
                isSelectWithModel(node) // <select v-model> requires runtime inspection
            ;
        }
        var isBuiltInDir = makeMap("text,html,show,on,bind,model,pre,cloak,once");
        function hasCustomDirective(node) {
            return node.type === 1 && node.directives &&
                node.directives.some(function (d) {
                    return !isBuiltInDir(d.name);
                });
        } // <select v-model> cannot be optimized because it requires a runtime check
        // to determine proper selected option
        function isSelectWithModel(node) {
            return node.type === 1 && node.tag === "select" &&
                node.directives != null && node.directives.some(function (d) {
                return d.name === "model";
            });
        }
        /*  */
        // segment types
        var RAW = 0;
        var INTERPOLATION = 1;
        var EXPRESSION = 2;
        function generate$1(ast, options) {
            var state = new CodegenState(options);
            var code = ast ? genSSRElement(ast, state) : '_c("div")';
            return {
                render: "with(this){return " + code + "}",
                staticRenderFns: state.staticRenderFns,
            };
        }
        function genSSRElement(el, state) {
            if (el.for && !el.forProcessed) {
                return genFor(el, state, genSSRElement);
            }
            else if (el.if && !el.ifProcessed) {
                return genIf(el, state, genSSRElement);
            }
            else if (el.tag === "template" && !el.slotTarget) {
                return el.ssrOptimizability === optimizability.FULL
                    ? genChildrenAsStringNode(el, state)
                    : genSSRChildren(el, state) || "void 0";
            }
            switch (el.ssrOptimizability) {
                case optimizability.FULL:
                    // stringify whole tree
                    return genStringElement(el, state);
                case optimizability.SELF:
                    // stringify self and check children
                    return genStringElementWithChildren(el, state);
                case optimizability.CHILDREN:
                    // generate self as VNode and stringify children
                    return genNormalElement(el, state, true);
                case optimizability.PARTIAL:
                    // generate self as VNode and check children
                    return genNormalElement(el, state, false);
                default:
                    // bail whole tree
                    return genElement(el, state);
            }
        }
        function genNormalElement(el, state, stringifyChildren) {
            var data = el.plain ? undefined : genData$2(el, state);
            var children = stringifyChildren
                ? "[" + genChildrenAsStringNode(el, state) + "]"
                : genSSRChildren(el, state, true);
            return "_c('" + el.tag + "'" + (data ? "," + data : "") + (children
                ? "," + children
                : "") +
                ")";
        }
        function genSSRChildren(el, state, checkSkip) {
            return genChildren(el, state, checkSkip, genSSRElement, genSSRNode);
        }
        function genSSRNode(el, state) {
            return el.type === 1 ? genSSRElement(el, state) : genText(el);
        }
        function genChildrenAsStringNode(el, state) {
            return el.children.length
                ? "_ssrNode(" + flattenSegments(childrenToSegments(el, state)) + ")"
                : "";
        }
        function genStringElement(el, state) {
            return "_ssrNode(" + elementToString(el, state) + ")";
        }
        function genStringElementWithChildren(el, state) {
            var children = genSSRChildren(el, state, true);
            return "_ssrNode(" + flattenSegments(elementToOpenTagSegments(el, state)) +
                ',"</' + el.tag + '>"' + (children ? "," + children : "") + ")";
        }
        function elementToString(el, state) {
            return "(" + flattenSegments(elementToSegments(el, state)) + ")";
        }
        function elementToSegments(el, state) {
            // v-for / v-if
            if (el.for && !el.forProcessed) {
                el.forProcessed = true;
                return [{
                        type: EXPRESSION,
                        value: genFor(el, state, elementToString, "_ssrList"),
                    }];
            }
            else if (el.if && !el.ifProcessed) {
                el.ifProcessed = true;
                return [{
                        type: EXPRESSION,
                        value: genIf(el, state, elementToString, '"<!---->"'),
                    }];
            }
            else if (el.tag === "template") {
                return childrenToSegments(el, state);
            }
            var openSegments = elementToOpenTagSegments(el, state);
            var childrenSegments = childrenToSegments(el, state);
            var ref = state.options;
            var isUnaryTag = ref.isUnaryTag;
            var close = isUnaryTag && isUnaryTag(el.tag) ? [] : [{
                    type: RAW,
                    value: "</" + el.tag + ">",
                }];
            return openSegments.concat(childrenSegments, close);
        }
        function elementToOpenTagSegments(el, state) {
            applyModelTransform(el, state);
            var binding;
            var segments = [{
                    type: RAW,
                    value: "<" + el.tag,
                }]; // attrs
            if (el.attrs) {
                segments.push.apply(segments, genAttrSegments(el.attrs));
            } // domProps
            if (el.props) {
                segments.push.apply(segments, genDOMPropSegments(el.props, el.attrs));
            } // v-bind="object"
            if (binding = el.attrsMap["v-bind"]) {
                segments.push({
                    type: EXPRESSION,
                    value: "_ssrAttrs(" + binding + ")",
                });
            } // v-bind.prop="object"
            if (binding = el.attrsMap["v-bind.prop"]) {
                segments.push({
                    type: EXPRESSION,
                    value: "_ssrDOMProps(" + binding + ")",
                });
            } // class
            if (el.staticClass || el.classBinding) {
                segments.push.apply(segments, genClassSegments(el.staticClass, el.classBinding));
            } // style & v-show
            if (el.staticStyle || el.styleBinding || el.attrsMap["v-show"]) {
                segments.push.apply(segments, genStyleSegments(el.attrsMap.style, el.staticStyle, el.styleBinding, el.attrsMap["v-show"]));
            } // _scopedId
            if (state.options.scopeId) {
                segments.push({
                    type: RAW,
                    value: " " + state.options.scopeId,
                });
            }
            segments.push({
                type: RAW,
                value: ">",
            });
            return segments;
        }
        function childrenToSegments(el, state) {
            var binding;
            if (binding = el.attrsMap["v-html"]) {
                return [{
                        type: EXPRESSION,
                        value: "_s(" + binding + ")",
                    }];
            }
            if (binding = el.attrsMap["v-text"]) {
                return [{
                        type: INTERPOLATION,
                        value: "_s(" + binding + ")",
                    }];
            }
            if (el.tag === "textarea" && (binding = el.attrsMap["v-model"])) {
                return [{
                        type: INTERPOLATION,
                        value: "_s(" + binding + ")",
                    }];
            }
            return el.children ? nodesToSegments(el.children, state) : [];
        }
        function nodesToSegments(children, state) {
            var segments = [];
            for (var i = 0; i < children.length; i++) {
                var c = children[i];
                if (c.type === 1) {
                    segments.push.apply(segments, elementToSegments(c, state));
                }
                else if (c.type === 2) {
                    segments.push({
                        type: INTERPOLATION,
                        value: c.expression,
                    });
                }
                else if (c.type === 3) {
                    var text = escape(c.text);
                    if (c.isComment) {
                        text = "<!--" + text + "-->";
                    }
                    segments.push({
                        type: RAW,
                        value: text,
                    });
                }
            }
            return segments;
        }
        function flattenSegments(segments) {
            var mergedSegments = [];
            var textBuffer = "";
            var pushBuffer = function () {
                if (textBuffer) {
                    mergedSegments.push(JSON.stringify(textBuffer));
                    textBuffer = "";
                }
            };
            for (var i = 0; i < segments.length; i++) {
                var s = segments[i];
                if (s.type === RAW) {
                    textBuffer += s.value;
                }
                else if (s.type === INTERPOLATION) {
                    pushBuffer();
                    mergedSegments.push("_ssrEscape(" + s.value + ")");
                }
                else if (s.type === EXPRESSION) {
                    pushBuffer();
                    mergedSegments.push("(" + s.value + ")");
                }
            }
            pushBuffer();
            return mergedSegments.join("+");
        }
        /*  */
        // these keywords should not appear inside expressions, but operators like
        // typeof, instanceof and in are allowed
        var prohibitedKeywordRE = new RegExp("\\b" +
            ("do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const," +
                "super,throw,while,yield,delete,export,import,return,switch,default," +
                "extends,finally,continue,debugger,function,arguments").split(",").join("\\b|\\b") +
            "\\b"); // these unary operators should not be used as property/method names
        var unaryOperatorsRE = new RegExp("\\b" + "delete,typeof,void".split(",").join("\\s*\\([^\\)]*\\)|\\b") +
            "\\s*\\([^\\)]*\\)"); // strip strings in expressions
        var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g; // detect problematic expressions in a template
        function detectErrors(ast, warn) {
            if (ast) {
                checkNode(ast, warn);
            }
        }
        function checkNode(node, warn) {
            if (node.type === 1) {
                for (var name in node.attrsMap) {
                    if (dirRE.test(name)) {
                        var value = node.attrsMap[name];
                        if (value) {
                            var range = node.rawAttrsMap[name];
                            if (name === "v-for") {
                                checkFor(node, 'v-for="' + value + '"', warn, range);
                            }
                            else if (name === "v-slot" || name[0] === "#") {
                                checkFunctionParameterExpression(value, name + '="' + value + '"', warn, range);
                            }
                            else if (onRE.test(name)) {
                                checkEvent(value, name + '="' + value + '"', warn, range);
                            }
                            else {
                                checkExpression(value, name + '="' + value + '"', warn, range);
                            }
                        }
                    }
                }
                if (node.children) {
                    for (var i = 0; i < node.children.length; i++) {
                        checkNode(node.children[i], warn);
                    }
                }
            }
            else if (node.type === 2) {
                checkExpression(node.expression, node.text, warn, node);
            }
        }
        function checkEvent(exp, text, warn, range) {
            var stripped = exp.replace(stripStringRE, "");
            var keywordMatch = stripped.match(unaryOperatorsRE);
            if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== "$") {
                warn("avoid using JavaScript unary operator as property name: " + '"' +
                    keywordMatch[0] + '" in expression ' + text.trim(), range);
            }
            checkExpression(exp, text, warn, range);
        }
        function checkFor(node, text, warn, range) {
            checkExpression(node.for || "", text, warn, range);
            checkIdentifier(node.alias, "v-for alias", text, warn, range);
            checkIdentifier(node.iterator1, "v-for iterator", text, warn, range);
            checkIdentifier(node.iterator2, "v-for iterator", text, warn, range);
        }
        function checkIdentifier(ident, type, text, warn, range) {
            if (typeof ident === "string") {
                try {
                    new Function("var " + ident + "=_");
                }
                catch (e) {
                    warn("invalid " + type + ' "' + ident + '" in expression: ' + text.trim(), range);
                }
            }
        }
        function checkExpression(exp, text, warn, range) {
            try {
                new Function("return " + exp);
            }
            catch (e) {
                var keywordMatch = exp.replace(stripStringRE, "").match(prohibitedKeywordRE);
                if (keywordMatch) {
                    warn("avoid using JavaScript keyword as property name: " + '"' +
                        keywordMatch[0] + '"\n  Raw expression: ' + text.trim(), range);
                }
                else {
                    warn("invalid expression: " + e.message + " in\n\n" + "    " + exp +
                        "\n\n" + "  Raw expression: " + text.trim() + "\n", range);
                }
            }
        }
        function checkFunctionParameterExpression(exp, text, warn, range) {
            try {
                new Function(exp, "");
            }
            catch (e) {
                warn("invalid function parameter expression: " + e.message + " in\n\n" +
                    "    " + exp + "\n\n" + "  Raw expression: " + text.trim() + "\n", range);
            }
        }
        /*  */
        var range = 2;
        function generateCodeFrame(source, start, end) {
            if (start === void 0)
                start = 0;
            if (end === void 0)
                end = source.length;
            var lines = source.split(/\r?\n/);
            var count = 0;
            var res = [];
            for (var i = 0; i < lines.length; i++) {
                count += lines[i].length + 1;
                if (count >= start) {
                    for (var j = i - range; j <= i + range || end > count; j++) {
                        if (j < 0 || j >= lines.length) {
                            continue;
                        }
                        res.push("" + (j + 1) + repeat$1(" ", 3 - String(j + 1).length) + "|  " +
                            lines[j]);
                        var lineLength = lines[j].length;
                        if (j === i) {
                            // push underline
                            var pad = start - (count - lineLength) + 1;
                            var length = end > count ? lineLength - pad : end - start;
                            res.push("   |  " + repeat$1(" ", pad) + repeat$1("^", length));
                        }
                        else if (j > i) {
                            if (end > count) {
                                var length$1 = Math.min(end - count, lineLength);
                                res.push("   |  " + repeat$1("^", length$1));
                            }
                            count += lineLength + 1;
                        }
                    }
                    break;
                }
            }
            return res.join("\n");
        }
        function repeat$1(str, n) {
            var result = "";
            if (n > 0) {
                while (true) {
                    // eslint-disable-line
                    if (n & 1) {
                        result += str;
                    }
                    n >>>= 1;
                    if (n <= 0) {
                        break;
                    }
                    str += str;
                }
            }
            return result;
        }
        /*  */
        function createFunction(code, errors) {
            try {
                return new Function(code);
            }
            catch (err) {
                errors.push({
                    err: err,
                    code: code,
                });
                return noop;
            }
        }
        function createCompileToFunctionFn(compile) {
            var cache = Object.create(null);
            return function compileToFunctions(template, options, vm) {
                options = extend({}, options);
                var warn$$1 = options.warn || warn;
                delete options.warn;
                /* istanbul ignore if */
                {
                    // detect possible CSP restriction
                    try {
                        new Function("return 1");
                    }
                    catch (e) {
                        if (e.toString().match(/unsafe-eval|CSP/)) {
                            warn$$1("It seems you are using the standalone build of Vue.js in an " +
                                "environment with Content Security Policy that prohibits unsafe-eval. " +
                                "The template compiler cannot work in this environment. Consider " +
                                "relaxing the policy to allow unsafe-eval or pre-compiling your " +
                                "templates into render functions.");
                        }
                    }
                } // check cache
                var key = options.delimiters
                    ? String(options.delimiters) + template
                    : template;
                if (cache[key]) {
                    return cache[key];
                } // compile
                var compiled = compile(template, options); // check compilation errors/tips
                {
                    if (compiled.errors && compiled.errors.length) {
                        if (options.outputSourceRange) {
                            compiled.errors.forEach(function (e) {
                                warn$$1("Error compiling template:\n\n" + e.msg + "\n\n" +
                                    generateCodeFrame(template, e.start, e.end), vm);
                            });
                        }
                        else {
                            warn$$1("Error compiling template:\n\n" + template + "\n\n" +
                                compiled.errors.map(function (e) {
                                    return "- " + e;
                                }).join("\n") + "\n", vm);
                        }
                    }
                    if (compiled.tips && compiled.tips.length) {
                        if (options.outputSourceRange) {
                            compiled.tips.forEach(function (e) {
                                return tip(e.msg, vm);
                            });
                        }
                        else {
                            compiled.tips.forEach(function (msg) {
                                return tip(msg, vm);
                            });
                        }
                    }
                } // turn code into functions
                var res = {};
                var fnGenErrors = [];
                res.render = createFunction(compiled.render, fnGenErrors);
                res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
                    return createFunction(code, fnGenErrors);
                }); // check function generation errors.
                // this should only happen if there is a bug in the compiler itself.
                // mostly for codegen development use
                /* istanbul ignore if */
                {
                    if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
                        warn$$1("Failed to generate render function:\n\n" +
                            fnGenErrors.map(function (ref) {
                                var err = ref.err;
                                var code = ref.code;
                                return err.toString() + " in\n\n" + code + "\n";
                            }).join("\n"), vm);
                    }
                }
                return cache[key] = res;
            };
        }
        /*  */
        function createCompilerCreator(baseCompile) {
            return function createCompiler(baseOptions) {
                function compile(template, options) {
                    var finalOptions = Object.create(baseOptions);
                    var errors = [];
                    var tips = [];
                    var warn = function (msg, range, tip) {
                        (tip ? tips : errors).push(msg);
                    };
                    if (options) {
                        if (options.outputSourceRange) {
                            // $flow-disable-line
                            var leadingSpaceLength = template.match(/^\s*/)[0].length;
                            warn = function (msg, range, tip) {
                                var data = {
                                    msg: msg,
                                };
                                if (range) {
                                    if (range.start != null) {
                                        data.start = range.start + leadingSpaceLength;
                                    }
                                    if (range.end != null) {
                                        data.end = range.end + leadingSpaceLength;
                                    }
                                }
                                (tip ? tips : errors).push(data);
                            };
                        } // merge custom modules
                        if (options.modules) {
                            finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
                        } // merge custom directives
                        if (options.directives) {
                            finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);
                        } // copy other options
                        for (var key in options) {
                            if (key !== "modules" && key !== "directives") {
                                finalOptions[key] = options[key];
                            }
                        }
                    }
                    finalOptions.warn = warn;
                    var compiled = baseCompile(template.trim(), finalOptions);
                    {
                        detectErrors(compiled.ast, warn);
                    }
                    compiled.errors = errors;
                    compiled.tips = tips;
                    return compiled;
                }
                return {
                    compile: compile,
                    compileToFunctions: createCompileToFunctionFn(compile),
                };
            };
        }
        /*  */
        var createCompiler = createCompilerCreator(function baseCompile(template, options) {
            var ast = parse(template.trim(), options);
            optimize(ast, options);
            var code = generate$1(ast, options);
            return {
                ast: ast,
                render: code.render,
                staticRenderFns: code.staticRenderFns,
            };
        });
        /*  */
        var ref = createCompiler(baseOptions);
        var compile = ref.compile;
        var compileToFunctions = ref.compileToFunctions;
        /*  */
        // The template compiler attempts to minimize the need for normalization by
        // statically analyzing the template at compile time.
        //
        // For plain HTML markup, normalization can be completely skipped because the
        // generated render function is guaranteed to return Array<VNode>. There are
        // two cases where extra normalization is needed:
        // 1. When the children contains components - because a functional component
        // may return an Array instead of a single root. In this case, just a simple
        // normalization is needed - if any child is an Array, we flatten the whole
        // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
        // because functional components already normalize their own children.
        function simpleNormalizeChildren(children) {
            for (var i = 0; i < children.length; i++) {
                if (Array.isArray(children[i])) {
                    return Array.prototype.concat.apply([], children);
                }
            }
            return children;
        } // 2. When the children contains constructs that always generated nested Arrays,
        // e.g. <template>, <slot>, v-for, or when the children is provided by user
        // with hand-written render functions / JSX. In such cases a full normalization
        // is needed to cater to all possible types of children values.
        function normalizeChildren(children) {
            return isPrimitive(children)
                ? [createTextVNode(children)]
                : Array.isArray(children)
                    ? normalizeArrayChildren(children)
                    : undefined;
        }
        function isTextNode(node) {
            return isDef(node) && isDef(node.text) && isFalse(node.isComment);
        }
        function normalizeArrayChildren(children, nestedIndex) {
            var res = [];
            var i, c, lastIndex, last;
            for (i = 0; i < children.length; i++) {
                c = children[i];
                if (isUndef(c) || typeof c === "boolean") {
                    continue;
                }
                lastIndex = res.length - 1;
                last = res[lastIndex]; //  nested
                if (Array.isArray(c)) {
                    if (c.length > 0) {
                        c = normalizeArrayChildren(c, (nestedIndex || "") + "_" + i); // merge adjacent text nodes
                        if (isTextNode(c[0]) && isTextNode(last)) {
                            res[lastIndex] = createTextVNode(last.text + c[0].text);
                            c.shift();
                        }
                        res.push.apply(res, c);
                    }
                }
                else if (isPrimitive(c)) {
                    if (isTextNode(last)) {
                        // merge adjacent text nodes
                        // this is necessary for SSR hydration because text nodes are
                        // essentially merged when rendered to HTML strings
                        res[lastIndex] = createTextVNode(last.text + c);
                    }
                    else if (c !== "") {
                        // convert primitive to vnode
                        res.push(createTextVNode(c));
                    }
                }
                else {
                    if (isTextNode(c) && isTextNode(last)) {
                        // merge adjacent text nodes
                        res[lastIndex] = createTextVNode(last.text + c.text);
                    }
                    else {
                        // default key for nested array children (likely generated by v-for)
                        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) &&
                            isDef(nestedIndex)) {
                            c.key = "__vlist" + nestedIndex + "_" + i + "__";
                        }
                        res.push(c);
                    }
                }
            }
            return res;
        }
        /*  */
        var ssrHelpers = {
            _ssrEscape: escape,
            _ssrNode: renderStringNode,
            _ssrList: renderStringList,
            _ssrAttr: renderAttr,
            _ssrAttrs: renderAttrs$1,
            _ssrDOMProps: renderDOMProps$1,
            _ssrClass: renderSSRClass,
            _ssrStyle: renderSSRStyle,
        };
        function installSSRHelpers(vm) {
            if (vm._ssrNode) {
                return;
            }
            var Vue = vm.constructor;
            while (Vue.super) {
                Vue = Vue.super;
            }
            extend(Vue.prototype, ssrHelpers);
            if (Vue.FunctionalRenderContext) {
                extend(Vue.FunctionalRenderContext.prototype, ssrHelpers);
            }
        }
        var StringNode = function StringNode(open, close, children, normalizationType) {
            this.isString = true;
            this.open = open;
            this.close = close;
            if (children) {
                this.children = normalizationType === 1
                    ? simpleNormalizeChildren(children)
                    : normalizationType === 2
                        ? normalizeChildren(children)
                        : children;
            }
            else {
                this.children = void 0;
            }
        };
        function renderStringNode(open, close, children, normalizationType) {
            return new StringNode(open, close, children, normalizationType);
        }
        function renderStringList(val, render) {
            var ret = "";
            var i, l, keys, key;
            if (Array.isArray(val) || typeof val === "string") {
                for (i = 0, l = val.length; i < l; i++) {
                    ret += render(val[i], i);
                }
            }
            else if (typeof val === "number") {
                for (i = 0; i < val; i++) {
                    ret += render(i + 1, i);
                }
            }
            else if (isObject(val)) {
                keys = Object.keys(val);
                for (i = 0, l = keys.length; i < l; i++) {
                    key = keys[i];
                    ret += render(val[key], key, i);
                }
            }
            return ret;
        }
        function renderAttrs$1(obj) {
            var res = "";
            for (var key in obj) {
                if (isSSRUnsafeAttr(key)) {
                    continue;
                }
                res += renderAttr(key, obj[key]);
            }
            return res;
        }
        function renderDOMProps$1(obj) {
            var res = "";
            for (var key in obj) {
                var attr = propsToAttrMap[key] || key.toLowerCase();
                if (isRenderableAttr(attr)) {
                    res += renderAttr(attr, obj[key]);
                }
            }
            return res;
        }
        function renderSSRClass(staticClass, dynamic) {
            var res = renderClass(staticClass, dynamic);
            return res === "" ? res : ' class="' + escape(res) + '"';
        }
        function renderSSRStyle(staticStyle, dynamic, extra) {
            var style = {};
            if (staticStyle) {
                extend(style, staticStyle);
            }
            if (dynamic) {
                extend(style, normalizeStyleBinding(dynamic));
            }
            if (extra) {
                extend(style, extra);
            }
            var res = genStyle(style);
            return res === "" ? res : " style=" + JSON.stringify(escape(res));
        }
        /* not type checking this file because flow doesn't play well with Proxy */
        {
            var allowedGlobals = makeMap("Infinity,undefined,NaN,isFinite,isNaN," +
                "parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent," +
                "Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl," +
                "require");
            var hasProxy = typeof Proxy !== "undefined" && isNative(Proxy);
            if (hasProxy) {
                var isBuiltInModifier = makeMap("stop,prevent,self,ctrl,shift,alt,meta,exact");
                config.keyCodes = new Proxy(config.keyCodes, {
                    set: function set(target, key, value) {
                        if (isBuiltInModifier(key)) {
                            warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
                            return false;
                        }
                        else {
                            target[key] = value;
                            return true;
                        }
                    },
                });
            }
        }
        /*  */
        var seenObjects = new _Set();
        /**
         * Recursively traverse an object to evoke all converted
         * getters, so that every nested property inside the object
         * is collected as a "deep" dependency.
         */
        function traverse(val) {
            _traverse(val, seenObjects);
            seenObjects.clear();
        }
        function _traverse(val, seen) {
            var i, keys;
            var isA = Array.isArray(val);
            if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {
                return;
            }
            if (val.__ob__) {
                var depId = val.__ob__.dep.id;
                if (seen.has(depId)) {
                    return;
                }
                seen.add(depId);
            }
            if (isA) {
                i = val.length;
                while (i--) {
                    _traverse(val[i], seen);
                }
            }
            else {
                keys = Object.keys(val);
                i = keys.length;
                while (i--) {
                    _traverse(val[keys[i]], seen);
                }
            }
        }
        {
            var perf = inBrowser && window.performance;
            /* istanbul ignore if */
            if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures)
                ;
        }
        /*  */
        var normalizeEvent = cached(function (name) {
            var passive = name.charAt(0) === "&";
            name = passive ? name.slice(1) : name;
            var once$$1 = name.charAt(0) === "~"; // Prefixed last, checked first
            name = once$$1 ? name.slice(1) : name;
            var capture = name.charAt(0) === "!";
            name = capture ? name.slice(1) : name;
            return {
                name: name,
                once: once$$1,
                capture: capture,
                passive: passive,
            };
        });
        function createFnInvoker(fns, vm) {
            function invoker() {
                var arguments$1 = arguments;
                var fns = invoker.fns;
                if (Array.isArray(fns)) {
                    var cloned = fns.slice();
                    for (var i = 0; i < cloned.length; i++) {
                        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
                    }
                }
                else {
                    // return handler return value for single handlers
                    return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler");
                }
            }
            invoker.fns = fns;
            return invoker;
        }
        function updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {
            var name, def$$1, cur, old, event;
            for (name in on) {
                def$$1 = cur = on[name];
                old = oldOn[name];
                event = normalizeEvent(name);
                if (isUndef(cur)) {
                    warn('Invalid handler for event "' + event.name + '": got ' + String(cur), vm);
                }
                else if (isUndef(old)) {
                    if (isUndef(cur.fns)) {
                        cur = on[name] = createFnInvoker(cur, vm);
                    }
                    if (isTrue(event.once)) {
                        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
                    }
                    add(event.name, cur, event.capture, event.passive, event.params);
                }
                else if (cur !== old) {
                    old.fns = cur;
                    on[name] = old;
                }
            }
            for (name in oldOn) {
                if (isUndef(on[name])) {
                    event = normalizeEvent(name);
                    remove$$1(event.name, oldOn[name], event.capture);
                }
            }
        }
        /*  */
        /*  */
        function extractPropsFromVNodeData(data, Ctor, tag) {
            // we are only extracting raw values here.
            // validation and default values are handled in the child
            // component itself.
            var propOptions = Ctor.options.props;
            if (isUndef(propOptions)) {
                return;
            }
            var res = {};
            var attrs = data.attrs;
            var props = data.props;
            if (isDef(attrs) || isDef(props)) {
                for (var key in propOptions) {
                    var altKey = hyphenate(key);
                    {
                        var keyInLowerCase = key.toLowerCase();
                        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
                            tip('Prop "' + keyInLowerCase + '" is passed to component ' +
                                formatComponentName(tag || Ctor) +
                                ", but the declared prop name is" + ' "' + key + '". ' +
                                "Note that HTML attributes are case-insensitive and camelCased " +
                                "props need to use their kebab-case equivalents when using in-DOM " +
                                'templates. You should probably use "' + altKey +
                                '" instead of "' + key + '".');
                        }
                    }
                    checkProp(res, props, key, altKey, true) ||
                        checkProp(res, attrs, key, altKey, false);
                }
            }
            return res;
        }
        function checkProp(res, hash, key, altKey, preserve) {
            if (isDef(hash)) {
                if (hasOwn(hash, key)) {
                    res[key] = hash[key];
                    if (!preserve) {
                        delete hash[key];
                    }
                    return true;
                }
                else if (hasOwn(hash, altKey)) {
                    res[key] = hash[altKey];
                    if (!preserve) {
                        delete hash[altKey];
                    }
                    return true;
                }
            }
            return false;
        }
        /*  */
        var SIMPLE_NORMALIZE = 1;
        var ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface
        // without getting yelled at by flow
        function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
            if (Array.isArray(data) || isPrimitive(data)) {
                normalizationType = children;
                children = data;
                data = undefined;
            }
            if (isTrue(alwaysNormalize)) {
                normalizationType = ALWAYS_NORMALIZE;
            }
            return _createElement(context, tag, data, children, normalizationType);
        }
        function _createElement(context, tag, data, children, normalizationType) {
            if (isDef(data) && isDef(data.__ob__)) {
                warn("Avoid using observed data object as vnode data: " +
                    JSON.stringify(data) + "\n" +
                    "Always create fresh vnode data objects in each render!", context);
                return createEmptyVNode();
            } // object syntax in v-bind
            if (isDef(data) && isDef(data.is)) {
                tag = data.is;
            }
            if (!tag) {
                // in case of component :is set to falsy value
                return createEmptyVNode();
            } // warn against non-primitive key
            if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
                {
                    warn("Avoid using non-primitive value as key, " +
                        "use string/number value instead.", context);
                }
            } // support single function children as default scoped slot
            if (Array.isArray(children) && typeof children[0] === "function") {
                data = data || {};
                data.scopedSlots = {
                    default: children[0],
                };
                children.length = 0;
            }
            if (normalizationType === ALWAYS_NORMALIZE) {
                children = normalizeChildren(children);
            }
            else if (normalizationType === SIMPLE_NORMALIZE) {
                children = simpleNormalizeChildren(children);
            }
            var vnode, ns;
            if (typeof tag === "string") {
                var Ctor;
                ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);
                if ((!data || !data.pre) &&
                    isDef(Ctor = resolveAsset(context.$options, "components", tag))) {
                    // component
                    vnode = createComponent(Ctor, data, context, children, tag);
                }
                else {
                    // unknown or unlisted namespaced elements
                    // check at runtime because it may get assigned a namespace when its
                    // parent normalizes children
                    vnode = new VNode(tag, data, children, undefined, undefined, context);
                }
            }
            else {
                // direct component options / constructor
                vnode = createComponent(tag, data, context, children);
            }
            if (Array.isArray(vnode)) {
                return vnode;
            }
            else if (isDef(vnode)) {
                if (isDef(ns)) {
                    applyNS(vnode, ns);
                }
                if (isDef(data)) {
                    registerDeepBindings(data);
                }
                return vnode;
            }
            else {
                return createEmptyVNode();
            }
        }
        function applyNS(vnode, ns, force) {
            vnode.ns = ns;
            if (vnode.tag === "foreignObject") {
                // use default namespace inside foreignObject
                ns = undefined;
                force = true;
            }
            if (isDef(vnode.children)) {
                for (var i = 0, l = vnode.children.length; i < l; i++) {
                    var child = vnode.children[i];
                    if (isDef(child.tag) &&
                        (isUndef(child.ns) || isTrue(force) && child.tag !== "svg")) {
                        applyNS(child, ns, force);
                    }
                }
            }
        } // ref #5318
        // necessary to ensure parent re-render when deep bindings like :style and
        // :class are used on slot nodes
        function registerDeepBindings(data) {
            if (isObject(data.style)) {
                traverse(data.style);
            }
            if (isObject(data.class)) {
                traverse(data.class);
            }
        }
        /*  */
        /**
         * Runtime helper for rendering v-for lists.
         */
        function renderList(val, render) {
            var ret, i, l, keys, key;
            if (Array.isArray(val) || typeof val === "string") {
                ret = new Array(val.length);
                for (i = 0, l = val.length; i < l; i++) {
                    ret[i] = render(val[i], i);
                }
            }
            else if (typeof val === "number") {
                ret = new Array(val);
                for (i = 0; i < val; i++) {
                    ret[i] = render(i + 1, i);
                }
            }
            else if (isObject(val)) {
                if (hasSymbol && val[Symbol.iterator]) {
                    ret = [];
                    var iterator = val[Symbol.iterator]();
                    var result = iterator.next();
                    while (!result.done) {
                        ret.push(render(result.value, ret.length));
                        result = iterator.next();
                    }
                }
                else {
                    keys = Object.keys(val);
                    ret = new Array(keys.length);
                    for (i = 0, l = keys.length; i < l; i++) {
                        key = keys[i];
                        ret[i] = render(val[key], key, i);
                    }
                }
            }
            if (!isDef(ret)) {
                ret = [];
            }
            ret._isVList = true;
            return ret;
        }
        /*  */
        /**
         * Runtime helper for rendering <slot>
         */
        function renderSlot(name, fallback, props, bindObject) {
            var scopedSlotFn = this.$scopedSlots[name];
            var nodes;
            if (scopedSlotFn) {
                // scoped slot
                props = props || {};
                if (bindObject) {
                    if (!isObject(bindObject)) {
                        warn("slot v-bind without argument expects an Object", this);
                    }
                    props = extend(extend({}, bindObject), props);
                }
                nodes = scopedSlotFn(props) || fallback;
            }
            else {
                nodes = this.$slots[name] || fallback;
            }
            var target = props && props.slot;
            if (target) {
                return this.$createElement("template", {
                    slot: target,
                }, nodes);
            }
            else {
                return nodes;
            }
        }
        /*  */
        /**
         * Runtime helper for resolving filters
         */
        function resolveFilter(id) {
            return resolveAsset(this.$options, "filters", id, true) || identity;
        }
        /*  */
        function isKeyNotMatch(expect, actual) {
            if (Array.isArray(expect)) {
                return expect.indexOf(actual) === -1;
            }
            else {
                return expect !== actual;
            }
        }
        /**
         * Runtime helper for checking keyCodes from config.
         * exposed as Vue.prototype._k
         * passing in eventKeyName as last argument separately for backwards compat
         */
        function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
            var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
            if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
                return isKeyNotMatch(builtInKeyName, eventKeyName);
            }
            else if (mappedKeyCode) {
                return isKeyNotMatch(mappedKeyCode, eventKeyCode);
            }
            else if (eventKeyName) {
                return hyphenate(eventKeyName) !== key;
            }
        }
        /*  */
        /**
         * Runtime helper for merging v-bind="object" into a VNode's data.
         */
        function bindObjectProps(data, tag, value, asProp, isSync) {
            if (value) {
                if (!isObject(value)) {
                    warn("v-bind without argument expects an Object or Array value", this);
                }
                else {
                    if (Array.isArray(value)) {
                        value = toObject(value);
                    }
                    var hash;
                    var loop = function (key) {
                        if (key === "class" || key === "style" || isReservedAttribute(key)) {
                            hash = data;
                        }
                        else {
                            var type = data.attrs && data.attrs.type;
                            hash = asProp || config.mustUseProp(tag, type, key)
                                ? data.domProps || (data.domProps = {})
                                : data.attrs || (data.attrs = {});
                        }
                        var camelizedKey = camelize(key);
                        var hyphenatedKey = hyphenate(key);
                        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
                            hash[key] = value[key];
                            if (isSync) {
                                var on = data.on || (data.on = {});
                                on["update:" + key] = function ($event) {
                                    value[key] = $event;
                                };
                            }
                        }
                    };
                    for (var key in value)
                        loop(key);
                }
            }
            return data;
        }
        /*  */
        /**
         * Runtime helper for rendering static trees.
         */
        function renderStatic(index, isInFor) {
            var cached = this._staticTrees || (this._staticTrees = []);
            var tree = cached[index]; // if has already-rendered static tree and not inside v-for,
            // we can reuse the same tree.
            if (tree && !isInFor) {
                return tree;
            } // otherwise, render a fresh tree.
            tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this);
            markStatic(tree, "__static__" + index, false);
            return tree;
        }
        /**
         * Runtime helper for v-once.
         * Effectively it means marking the node as static with a unique key.
         */
        function markOnce(tree, index, key) {
            markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
            return tree;
        }
        function markStatic(tree, key, isOnce) {
            if (Array.isArray(tree)) {
                for (var i = 0; i < tree.length; i++) {
                    if (tree[i] && typeof tree[i] !== "string") {
                        markStaticNode(tree[i], key + "_" + i, isOnce);
                    }
                }
            }
            else {
                markStaticNode(tree, key, isOnce);
            }
        }
        function markStaticNode(node, key, isOnce) {
            node.isStatic = true;
            node.key = key;
            node.isOnce = isOnce;
        }
        /*  */
        function bindObjectListeners(data, value) {
            if (value) {
                if (!isPlainObject(value)) {
                    warn("v-on without argument expects an Object value", this);
                }
                else {
                    var on = data.on = data.on ? extend({}, data.on) : {};
                    for (var key in value) {
                        var existing = on[key];
                        var ours = value[key];
                        on[key] = existing ? [].concat(existing, ours) : ours;
                    }
                }
            }
            return data;
        }
        /*  */
        function resolveScopedSlots(fns, // see flow/vnode
        res, // the following are added in 2.6
        hasDynamicKeys, contentHashKey) {
            res = res || {
                $stable: !hasDynamicKeys,
            };
            for (var i = 0; i < fns.length; i++) {
                var slot = fns[i];
                if (Array.isArray(slot)) {
                    resolveScopedSlots(slot, res, hasDynamicKeys);
                }
                else if (slot) {
                    // marker for reverse proxying v-slot without scope on this.$slots
                    if (slot.proxy) {
                        slot.fn.proxy = true;
                    }
                    res[slot.key] = slot.fn;
                }
            }
            if (contentHashKey) {
                res.$key = contentHashKey;
            }
            return res;
        }
        /*  */
        function bindDynamicKeys(baseObj, values) {
            for (var i = 0; i < values.length; i += 2) {
                var key = values[i];
                if (typeof key === "string" && key) {
                    baseObj[values[i]] = values[i + 1];
                }
                else if (key !== "" && key !== null) {
                    // null is a special value for explicitly removing a binding
                    warn("Invalid value for dynamic directive argument (expected string or null): " +
                        key, this);
                }
            }
            return baseObj;
        } // helper to dynamically append modifier runtime markers to event names.
        // ensure only append when value is already string, otherwise it will be cast
        // to string and cause the type check to miss.
        function prependModifier(value, symbol) {
            return typeof value === "string" ? symbol + value : value;
        }
        /*  */
        function installRenderHelpers(target) {
            target._o = markOnce;
            target._n = toNumber;
            target._s = toString;
            target._l = renderList;
            target._t = renderSlot;
            target._q = looseEqual;
            target._i = looseIndexOf;
            target._m = renderStatic;
            target._f = resolveFilter;
            target._k = checkKeyCodes;
            target._b = bindObjectProps;
            target._v = createTextVNode;
            target._e = createEmptyVNode;
            target._u = resolveScopedSlots;
            target._g = bindObjectListeners;
            target._d = bindDynamicKeys;
            target._p = prependModifier;
        }
        /*  */
        /**
         * Runtime helper for resolving raw children VNodes into a slot object.
         */
        function resolveSlots(children, context) {
            if (!children || !children.length) {
                return {};
            }
            var slots = {};
            for (var i = 0, l = children.length; i < l; i++) {
                var child = children[i];
                var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node
                if (data && data.attrs && data.attrs.slot) {
                    delete data.attrs.slot;
                } // named slots should only be respected if the vnode was rendered in the
                // same context.
                if ((child.context === context || child.fnContext === context) && data &&
                    data.slot != null) {
                    var name = data.slot;
                    var slot = slots[name] || (slots[name] = []);
                    if (child.tag === "template") {
                        slot.push.apply(slot, child.children || []);
                    }
                    else {
                        slot.push(child);
                    }
                }
                else {
                    (slots.default || (slots.default = [])).push(child);
                }
            } // ignore slots that contains only whitespace
            for (var name$1 in slots) {
                if (slots[name$1].every(isWhitespace)) {
                    delete slots[name$1];
                }
            }
            return slots;
        }
        function isWhitespace(node) {
            return node.isComment && !node.asyncFactory || node.text === " ";
        }
        /*  */
        function normalizeScopedSlots(slots, normalSlots, prevSlots) {
            var res;
            var hasNormalSlots = Object.keys(normalSlots).length > 0;
            var isStable = slots ? !!slots.$stable : !hasNormalSlots;
            var key = slots && slots.$key;
            if (!slots) {
                res = {};
            }
            else if (slots._normalized) {
                // fast path 1: child component re-render only, parent did not change
                return slots._normalized;
            }
            else if (isStable && prevSlots && prevSlots !== emptyObject &&
                key === prevSlots.$key && !hasNormalSlots && !prevSlots.$hasNormal) {
                // fast path 2: stable scoped slots w/ no normal slots to proxy,
                // only need to normalize once
                return prevSlots;
            }
            else {
                res = {};
                for (var key$1 in slots) {
                    if (slots[key$1] && key$1[0] !== "$") {
                        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
                    }
                }
            } // expose normal slots on scopedSlots
            for (var key$2 in normalSlots) {
                if (!(key$2 in res)) {
                    res[key$2] = proxyNormalSlot(normalSlots, key$2);
                }
            } // avoriaz seems to mock a non-extensible $scopedSlots object
            // and when that is passed down this would cause an error
            if (slots && Object.isExtensible(slots)) {
                slots._normalized = res;
            }
            def(res, "$stable", isStable);
            def(res, "$key", key);
            def(res, "$hasNormal", hasNormalSlots);
            return res;
        }
        function normalizeScopedSlot(normalSlots, key, fn) {
            var normalized = function () {
                var res = arguments.length ? fn.apply(null, arguments) : fn({});
                res = res && typeof res === "object" && !Array.isArray(res)
                    ? [res] // single vnode
                    : normalizeChildren(res);
                return res && (res.length === 0 || res.length === 1 && res[0].isComment // #9658
                )
                    ? undefined
                    : res;
            }; // this is a slot using the new v-slot syntax without scope. although it is
            // compiled as a scoped slot, render fn users would expect it to be present
            // on this.$slots because the usage is semantically a normal slot.
            if (fn.proxy) {
                Object.defineProperty(normalSlots, key, {
                    get: normalized,
                    enumerable: true,
                    configurable: true,
                });
            }
            return normalized;
        }
        function proxyNormalSlot(slots, key) {
            return function () {
                return slots[key];
            };
        }
        /*  */
        var currentRenderingInstance = null;
        /*  */
        function ensureCtor(comp, base) {
            if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === "Module") {
                comp = comp.default;
            }
            return isObject(comp) ? base.extend(comp) : comp;
        }
        function createAsyncPlaceholder(factory, data, context, children, tag) {
            var node = createEmptyVNode();
            node.asyncFactory = factory;
            node.asyncMeta = {
                data: data,
                context: context,
                children: children,
                tag: tag,
            };
            return node;
        }
        function resolveAsyncComponent(factory, baseCtor) {
            if (isTrue(factory.error) && isDef(factory.errorComp)) {
                return factory.errorComp;
            }
            if (isDef(factory.resolved)) {
                return factory.resolved;
            }
            var owner = currentRenderingInstance;
            if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
                // already pending
                factory.owners.push(owner);
            }
            if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
                return factory.loadingComp;
            }
            if (owner && !isDef(factory.owners)) {
                var owners = factory.owners = [owner];
                var sync = true;
                var timerLoading = null;
                var timerTimeout = null;
                owner.$on("hook:destroyed", function () {
                    return remove(owners, owner);
                });
                var forceRender = function (renderCompleted) {
                    for (var i = 0, l = owners.length; i < l; i++) {
                        owners[i].$forceUpdate();
                    }
                    if (renderCompleted) {
                        owners.length = 0;
                        if (timerLoading !== null) {
                            clearTimeout(timerLoading);
                            timerLoading = null;
                        }
                        if (timerTimeout !== null) {
                            clearTimeout(timerTimeout);
                            timerTimeout = null;
                        }
                    }
                };
                var resolve = once(function (res) {
                    // cache resolved
                    factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve
                    // (async resolves are shimmed as synchronous during SSR)
                    if (!sync) {
                        forceRender(true);
                    }
                    else {
                        owners.length = 0;
                    }
                });
                var reject = once(function (reason) {
                    warn("Failed to resolve async component: " + String(factory) +
                        (reason ? "\nReason: " + reason : ""));
                    if (isDef(factory.errorComp)) {
                        factory.error = true;
                        forceRender(true);
                    }
                });
                var res = factory(resolve, reject);
                if (isObject(res)) {
                    if (isPromise(res)) {
                        // () => Promise
                        if (isUndef(factory.resolved)) {
                            res.then(resolve, reject);
                        }
                    }
                    else if (isPromise(res.component)) {
                        res.component.then(resolve, reject);
                        if (isDef(res.error)) {
                            factory.errorComp = ensureCtor(res.error, baseCtor);
                        }
                        if (isDef(res.loading)) {
                            factory.loadingComp = ensureCtor(res.loading, baseCtor);
                            if (res.delay === 0) {
                                factory.loading = true;
                            }
                            else {
                                timerLoading = setTimeout(function () {
                                    timerLoading = null;
                                    if (isUndef(factory.resolved) && isUndef(factory.error)) {
                                        factory.loading = true;
                                        forceRender(false);
                                    }
                                }, res.delay || 200);
                            }
                        }
                        if (isDef(res.timeout)) {
                            timerTimeout = setTimeout(function () {
                                timerTimeout = null;
                                if (isUndef(factory.resolved)) {
                                    reject("timeout (" + res.timeout + "ms)");
                                }
                            }, res.timeout);
                        }
                    }
                }
                sync = false; // return in case resolved synchronously
                return factory.loading ? factory.loadingComp : factory.resolved;
            }
        }
        /*  */
        /*  */
        /*  */
        /*  */
        var target;
        function add(event, fn) {
            target.$on(event, fn);
        }
        function remove$1(event, fn) {
            target.$off(event, fn);
        }
        function createOnceHandler(event, fn) {
            var _target = target;
            return function onceHandler() {
                var res = fn.apply(null, arguments);
                if (res !== null) {
                    _target.$off(event, onceHandler);
                }
            };
        }
        function updateComponentListeners(vm, listeners, oldListeners) {
            target = vm;
            updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
            target = undefined;
        }
        /*  */
        var activeInstance = null;
        function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
            // determine whether component has slot children
            // we need to do this before overwriting $options._renderChildren.
            // check if there are dynamic scopedSlots (hand-written or compiled but with
            // dynamic slot names). Static scoped slots compiled from template has the
            // "$stable" marker.
            var newScopedSlots = parentVnode.data.scopedSlots;
            var oldScopedSlots = vm.$scopedSlots;
            var hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable ||
                oldScopedSlots !== emptyObject && !oldScopedSlots.$stable ||
                newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key); // Any static slot children from the parent may have changed during parent's
            // update. Dynamic scoped slots may also have changed. In such cases, a forced
            // update is necessary to ensure correctness.
            var needsForceUpdate = !!(renderChildren || // has new static slots
                vm.$options._renderChildren || // has old static slots
                hasDynamicScopedSlot);
            vm.$options._parentVnode = parentVnode;
            vm.$vnode = parentVnode; // update vm's placeholder node without re-render
            if (vm._vnode) {
                // update child tree's parent
                vm._vnode.parent = parentVnode;
            }
            vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash
            // these are also reactive so they may trigger child update if the child
            // used them during render
            vm.$attrs = parentVnode.data.attrs || emptyObject;
            vm.$listeners = listeners || emptyObject; // update props
            if (propsData && vm.$options.props) {
                toggleObserving(false);
                var props = vm._props;
                var propKeys = vm.$options._propKeys || [];
                for (var i = 0; i < propKeys.length; i++) {
                    var key = propKeys[i];
                    var propOptions = vm.$options.props; // wtf flow?
                    props[key] = validateProp(key, propOptions, propsData, vm);
                }
                toggleObserving(true); // keep a copy of raw propsData
                vm.$options.propsData = propsData;
            } // update listeners
            listeners = listeners || emptyObject;
            var oldListeners = vm.$options._parentListeners;
            vm.$options._parentListeners = listeners;
            updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children
            if (needsForceUpdate) {
                vm.$slots = resolveSlots(renderChildren, parentVnode.context);
                vm.$forceUpdate();
            }
        }
        function isInInactiveTree(vm) {
            while (vm && (vm = vm.$parent)) {
                if (vm._inactive) {
                    return true;
                }
            }
            return false;
        }
        function activateChildComponent(vm, direct) {
            if (direct) {
                vm._directInactive = false;
                if (isInInactiveTree(vm)) {
                    return;
                }
            }
            else if (vm._directInactive) {
                return;
            }
            if (vm._inactive || vm._inactive === null) {
                vm._inactive = false;
                for (var i = 0; i < vm.$children.length; i++) {
                    activateChildComponent(vm.$children[i]);
                }
                callHook(vm, "activated");
            }
        }
        function deactivateChildComponent(vm, direct) {
            if (direct) {
                vm._directInactive = true;
                if (isInInactiveTree(vm)) {
                    return;
                }
            }
            if (!vm._inactive) {
                vm._inactive = true;
                for (var i = 0; i < vm.$children.length; i++) {
                    deactivateChildComponent(vm.$children[i]);
                }
                callHook(vm, "deactivated");
            }
        }
        function callHook(vm, hook) {
            // #7573 disable dep collection when invoking lifecycle hooks
            pushTarget();
            var handlers = vm.$options[hook];
            var info = hook + " hook";
            if (handlers) {
                for (var i = 0, j = handlers.length; i < j; i++) {
                    invokeWithErrorHandling(handlers[i], vm, null, vm, info);
                }
            }
            if (vm._hasHookEvent) {
                vm.$emit("hook:" + hook);
            }
            popTarget();
        }
        /*  */
        // Async edge case fix requires storing an event listener's attach timestamp.
        var getNow = Date.now; // Determine what event timestamp the browser is using. Annoyingly, the
        // timestamp can either be hi-res (relative to page load) or low-res
        // (relative to UNIX epoch), so in order to compare time we have to use the
        // same timestamp type when saving the flush timestamp.
        // All IE versions use low-res event timestamps, and have problematic clock
        // implementations (#9632)
        if (inBrowser && !isIE) {
            var performance = window.performance;
            if (performance && typeof performance.now === "function") {
                // if the event timestamp, although evaluated AFTER the Date.now(), is
                // smaller than it, it means the event is using a hi-res timestamp,
                // and we need to use the hi-res version for event listener timestamps as
                // well.
                getNow = function () {
                    return performance.now();
                };
            }
        }
        /**
         * Queue a kept-alive component that was activated during patch.
         * The queue will be processed after the entire tree has been patched.
         */
        function queueActivatedComponent(vm) {
            // setting _inactive to false here so that a render function can
            // rely on checking whether it's in an inactive tree (e.g. router-view)
            vm._inactive = false;
        }
        /*  */
        /*  */
        /*  */
        function resolveInject(inject, vm) {
            if (inject) {
                // inject is :any because flow is not smart enough to figure out cached
                var result = Object.create(null);
                var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i]; // #6574 in case the inject object is observed...
                    if (key === "__ob__") {
                        continue;
                    }
                    var provideKey = inject[key].from;
                    var source = vm;
                    while (source) {
                        if (source._provided && hasOwn(source._provided, provideKey)) {
                            result[key] = source._provided[provideKey];
                            break;
                        }
                        source = source.$parent;
                    }
                    if (!source) {
                        if ("default" in inject[key]) {
                            var provideDefault = inject[key].default;
                            result[key] = typeof provideDefault === "function"
                                ? provideDefault.call(vm)
                                : provideDefault;
                        }
                        else {
                            warn('Injection "' + key + '" not found', vm);
                        }
                    }
                }
                return result;
            }
        }
        /*  */
        function resolveConstructorOptions(Ctor) {
            var options = Ctor.options;
            if (Ctor.super) {
                var superOptions = resolveConstructorOptions(Ctor.super);
                var cachedSuperOptions = Ctor.superOptions;
                if (superOptions !== cachedSuperOptions) {
                    // super option changed,
                    // need to resolve new options.
                    Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)
                    var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options
                    if (modifiedOptions) {
                        extend(Ctor.extendOptions, modifiedOptions);
                    }
                    options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
                    if (options.name) {
                        options.components[options.name] = Ctor;
                    }
                }
            }
            return options;
        }
        function resolveModifiedOptions(Ctor) {
            var modified;
            var latest = Ctor.options;
            var sealed = Ctor.sealedOptions;
            for (var key in latest) {
                if (latest[key] !== sealed[key]) {
                    if (!modified) {
                        modified = {};
                    }
                    modified[key] = latest[key];
                }
            }
            return modified;
        }
        /*  */
        function FunctionalRenderContext(data, props, children, parent, Ctor) {
            var this$1 = this;
            var options = Ctor.options; // ensure the createElement function in functional components
            // gets a unique context - this is necessary for correct named slot check
            var contextVm;
            if (hasOwn(parent, "_uid")) {
                contextVm = Object.create(parent); // $flow-disable-line
                contextVm._original = parent;
            }
            else {
                // the context vm passed in is a functional context as well.
                // in this case we want to make sure we are able to get a hold to the
                // real context instance.
                contextVm = parent; // $flow-disable-line
                parent = parent._original;
            }
            var isCompiled = isTrue(options._compiled);
            var needNormalization = !isCompiled;
            this.data = data;
            this.props = props;
            this.children = children;
            this.parent = parent;
            this.listeners = data.on || emptyObject;
            this.injections = resolveInject(options.inject, parent);
            this.slots = function () {
                if (!this$1.$slots) {
                    normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));
                }
                return this$1.$slots;
            };
            Object.defineProperty(this, "scopedSlots", {
                enumerable: true,
                get: function get() {
                    return normalizeScopedSlots(data.scopedSlots, this.slots());
                },
            }); // support for compiled functional template
            if (isCompiled) {
                // exposing $options for renderStatic()
                this.$options = options; // pre-resolve slots for renderSlot()
                this.$slots = this.slots();
                this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
            }
            if (options._scopeId) {
                this._c = function (a, b, c, d) {
                    var vnode = createElement(contextVm, a, b, c, d, needNormalization);
                    if (vnode && !Array.isArray(vnode)) {
                        vnode.fnScopeId = options._scopeId;
                        vnode.fnContext = parent;
                    }
                    return vnode;
                };
            }
            else {
                this._c = function (a, b, c, d) {
                    return createElement(contextVm, a, b, c, d, needNormalization);
                };
            }
        }
        installRenderHelpers(FunctionalRenderContext.prototype);
        function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
            var options = Ctor.options;
            var props = {};
            var propOptions = options.props;
            if (isDef(propOptions)) {
                for (var key in propOptions) {
                    props[key] = validateProp(key, propOptions, propsData || emptyObject);
                }
            }
            else {
                if (isDef(data.attrs)) {
                    mergeProps(props, data.attrs);
                }
                if (isDef(data.props)) {
                    mergeProps(props, data.props);
                }
            }
            var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);
            var vnode = options.render.call(null, renderContext._c, renderContext);
            if (vnode instanceof VNode) {
                return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
            }
            else if (Array.isArray(vnode)) {
                var vnodes = normalizeChildren(vnode) || [];
                var res = new Array(vnodes.length);
                for (var i = 0; i < vnodes.length; i++) {
                    res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
                }
                return res;
            }
        }
        function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
            // #7817 clone node before setting fnContext, otherwise if the node is reused
            // (e.g. it was from a cached normal slot) the fnContext causes named slots
            // that should not be matched to match.
            var clone = cloneVNode(vnode);
            clone.fnContext = contextVm;
            clone.fnOptions = options;
            {
                (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext =
                    renderContext;
            }
            if (data.slot) {
                (clone.data || (clone.data = {})).slot = data.slot;
            }
            return clone;
        }
        function mergeProps(to, from) {
            for (var key in from) {
                to[camelize(key)] = from[key];
            }
        }
        /*  */
        /*  */
        /*  */
        /*  */
        // inline hooks to be invoked on component VNodes during patch
        var componentVNodeHooks = {
            init: function init(vnode, hydrating) {
                if (vnode.componentInstance && !vnode.componentInstance._isDestroyed &&
                    vnode.data.keepAlive) {
                    // kept-alive components, treat as a patch
                    var mountedNode = vnode; // work around flow
                    componentVNodeHooks.prepatch(mountedNode, mountedNode);
                }
                else {
                    var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);
                    child.$mount(hydrating ? vnode.elm : undefined, hydrating);
                }
            },
            prepatch: function prepatch(oldVnode, vnode) {
                var options = vnode.componentOptions;
                var child = vnode.componentInstance = oldVnode.componentInstance;
                updateChildComponent(child, options.propsData, // updated props
                options.listeners, // updated listeners
                vnode, // new parent vnode
                options.children);
            },
            insert: function insert(vnode) {
                var context = vnode.context;
                var componentInstance = vnode.componentInstance;
                if (!componentInstance._isMounted) {
                    componentInstance._isMounted = true;
                    callHook(componentInstance, "mounted");
                }
                if (vnode.data.keepAlive) {
                    if (context._isMounted) {
                        // vue-router#1212
                        // During updates, a kept-alive component's child components may
                        // change, so directly walking the tree here may call activated hooks
                        // on incorrect children. Instead we push them into a queue which will
                        // be processed after the whole patch process ended.
                        queueActivatedComponent(componentInstance);
                    }
                    else {
                        activateChildComponent(componentInstance, true /* direct */);
                    }
                }
            },
            destroy: function destroy(vnode) {
                var componentInstance = vnode.componentInstance;
                if (!componentInstance._isDestroyed) {
                    if (!vnode.data.keepAlive) {
                        componentInstance.$destroy();
                    }
                    else {
                        deactivateChildComponent(componentInstance, true /* direct */);
                    }
                }
            },
        };
        var hooksToMerge = Object.keys(componentVNodeHooks);
        function createComponent(Ctor, data, context, children, tag) {
            if (isUndef(Ctor)) {
                return;
            }
            var baseCtor = context.$options._base; // plain options object: turn it into a constructor
            if (isObject(Ctor)) {
                Ctor = baseCtor.extend(Ctor);
            } // if at this stage it's not a constructor or an async component factory,
            // reject.
            if (typeof Ctor !== "function") {
                {
                    warn("Invalid Component definition: " + String(Ctor), context);
                }
                return;
            } // async component
            var asyncFactory;
            if (isUndef(Ctor.cid)) {
                asyncFactory = Ctor;
                Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
                if (Ctor === undefined) {
                    // return a placeholder node for async component, which is rendered
                    // as a comment node but preserves all the raw information for the node.
                    // the information will be used for async server-rendering and hydration.
                    return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
                }
            }
            data = data || {}; // resolve constructor options in case global mixins are applied after
            // component constructor creation
            resolveConstructorOptions(Ctor); // transform component v-model data into props & events
            if (isDef(data.model)) {
                transformModel(Ctor.options, data);
            } // extract props
            var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component
            if (isTrue(Ctor.options.functional)) {
                return createFunctionalComponent(Ctor, propsData, data, context, children);
            } // extract listeners, since these needs to be treated as
            // child component listeners instead of DOM listeners
            var listeners = data.on; // replace with listeners with .native modifier
            // so it gets processed during parent component patch.
            data.on = data.nativeOn;
            if (isTrue(Ctor.options.abstract)) {
                // abstract components do not keep anything
                // other than props & listeners & slot
                // work around flow
                var slot = data.slot;
                data = {};
                if (slot) {
                    data.slot = slot;
                }
            } // install component management hooks onto the placeholder node
            installComponentHooks(data); // return a placeholder vnode
            var name = Ctor.options.name || tag;
            var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ""), data, undefined, undefined, undefined, context, {
                Ctor: Ctor,
                propsData: propsData,
                listeners: listeners,
                tag: tag,
                children: children,
            }, asyncFactory);
            return vnode;
        }
        function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
        parent) {
            var options = {
                _isComponent: true,
                _parentVnode: vnode,
                parent: parent,
            }; // check inline-template render functions
            var inlineTemplate = vnode.data.inlineTemplate;
            if (isDef(inlineTemplate)) {
                options.render = inlineTemplate.render;
                options.staticRenderFns = inlineTemplate.staticRenderFns;
            }
            return new vnode.componentOptions.Ctor(options);
        }
        function installComponentHooks(data) {
            var hooks = data.hook || (data.hook = {});
            for (var i = 0; i < hooksToMerge.length; i++) {
                var key = hooksToMerge[i];
                var existing = hooks[key];
                var toMerge = componentVNodeHooks[key];
                if (existing !== toMerge && !(existing && existing._merged)) {
                    hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
                }
            }
        }
        function mergeHook$1(f1, f2) {
            var merged = function (a, b) {
                // flow complains about extra args which is why we use any
                f1(a, b);
                f2(a, b);
            };
            merged._merged = true;
            return merged;
        } // transform component v-model info (value and callback) into
        // prop and event handler respectively.
        function transformModel(options, data) {
            var prop = options.model && options.model.prop || "value";
            var event = options.model && options.model.event || "input";
            (data.attrs || (data.attrs = {}))[prop] = data.model.value;
            var on = data.on || (data.on = {});
            var existing = on[event];
            var callback = data.model.callback;
            if (isDef(existing)) {
                if (Array.isArray(existing)
                    ? existing.indexOf(callback) === -1
                    : existing !== callback) {
                    on[event] = [callback].concat(existing);
                }
            }
            else {
                on[event] = callback;
            }
        }
        /*  */
        var warned = Object.create(null);
        var warnOnce = function (msg) {
            if (!warned[msg]) {
                warned[msg] = true; // eslint-disable-next-line no-console
                console.warn("\n\u001b[31m" + msg + "\u001b[39m\n");
            }
        };
        var onCompilationError = function (err, vm) {
            var trace = vm ? generateComponentTrace(vm) : "";
            throw new Error("\n\u001b[31m" + err + trace + "\u001b[39m\n");
        };
        var normalizeRender = function (vm) {
            var ref = vm.$options;
            var render = ref.render;
            var template = ref.template;
            var _scopeId = ref._scopeId;
            if (isUndef(render)) {
                if (template) {
                    var compiled = compileToFunctions(template, {
                        scopeId: _scopeId,
                        warn: onCompilationError,
                    }, vm);
                    vm.$options.render = compiled.render;
                    vm.$options.staticRenderFns = compiled.staticRenderFns;
                }
                else {
                    throw new Error("render function or template not defined in component: " +
                        (vm.$options.name || vm.$options._componentTag || "anonymous"));
                }
            }
        };
        function waitForServerPrefetch(vm, resolve, reject) {
            var handlers = vm.$options.serverPrefetch;
            if (isDef(handlers)) {
                if (!Array.isArray(handlers)) {
                    handlers = [handlers];
                }
                try {
                    var promises = [];
                    for (var i = 0, j = handlers.length; i < j; i++) {
                        var result = handlers[i].call(vm, vm);
                        if (result && typeof result.then === "function") {
                            promises.push(result);
                        }
                    }
                    Promise.all(promises).then(resolve).catch(reject);
                    return;
                }
                catch (e) {
                    reject(e);
                }
            }
            resolve();
        }
        function renderNode(node, isRoot, context) {
            if (node.isString) {
                renderStringNode$1(node, context);
            }
            else if (isDef(node.componentOptions)) {
                renderComponent(node, isRoot, context);
            }
            else if (isDef(node.tag)) {
                renderElement(node, isRoot, context);
            }
            else if (isTrue(node.isComment)) {
                if (isDef(node.asyncFactory)) {
                    // async component
                    renderAsyncComponent(node, isRoot, context);
                }
                else {
                    context.write("<!--" + node.text + "-->", context.next);
                }
            }
            else {
                context.write(node.raw ? node.text : escape(String(node.text)), context.next);
            }
        }
        function registerComponentForCache(options, write) {
            // exposed by vue-loader, need to call this if cache hit because
            // component lifecycle hooks will not be called.
            var register = options._ssrRegister;
            if (write.caching && isDef(register)) {
                write.componentBuffer[write.componentBuffer.length - 1].add(register);
            }
            return register;
        }
        function renderComponent(node, isRoot, context) {
            var write = context.write;
            var next = context.next;
            var userContext = context.userContext; // check cache hit
            var Ctor = node.componentOptions.Ctor;
            var getKey = Ctor.options.serverCacheKey;
            var name = Ctor.options.name;
            var cache = context.cache;
            var registerComponent = registerComponentForCache(Ctor.options, write);
            if (isDef(getKey) && isDef(cache) && isDef(name)) {
                var rawKey = getKey(node.componentOptions.propsData);
                if (rawKey === false) {
                    renderComponentInner(node, isRoot, context);
                    return;
                }
                var key = name + "::" + rawKey;
                var has = context.has;
                var get = context.get;
                if (isDef(has)) {
                    has(key, function (hit) {
                        if (hit === true && isDef(get)) {
                            get(key, function (res) {
                                if (isDef(registerComponent)) {
                                    registerComponent(userContext);
                                }
                                res.components.forEach(function (register) {
                                    return register(userContext);
                                });
                                write(res.html, next);
                            });
                        }
                        else {
                            renderComponentWithCache(node, isRoot, key, context);
                        }
                    });
                }
                else if (isDef(get)) {
                    get(key, function (res) {
                        if (isDef(res)) {
                            if (isDef(registerComponent)) {
                                registerComponent(userContext);
                            }
                            res.components.forEach(function (register) {
                                return register(userContext);
                            });
                            write(res.html, next);
                        }
                        else {
                            renderComponentWithCache(node, isRoot, key, context);
                        }
                    });
                }
            }
            else {
                if (isDef(getKey) && isUndef(cache)) {
                    warnOnce("[vue-server-renderer] Component " +
                        (Ctor.options.name || "(anonymous)") +
                        " implemented serverCacheKey, " +
                        "but no cache was provided to the renderer.");
                }
                if (isDef(getKey) && isUndef(name)) {
                    warnOnce('[vue-server-renderer] Components that implement "serverCacheKey" ' +
                        'must also define a unique "name" option.');
                }
                renderComponentInner(node, isRoot, context);
            }
        }
        function renderComponentWithCache(node, isRoot, key, context) {
            var write = context.write;
            write.caching = true;
            var buffer = write.cacheBuffer;
            var bufferIndex = buffer.push("") - 1;
            var componentBuffer = write.componentBuffer;
            componentBuffer.push(new Set());
            context.renderStates.push({
                type: "ComponentWithCache",
                key: key,
                buffer: buffer,
                bufferIndex: bufferIndex,
                componentBuffer: componentBuffer,
            });
            renderComponentInner(node, isRoot, context);
        }
        function renderComponentInner(node, isRoot, context) {
            var prevActive = context.activeInstance; // expose userContext on vnode
            node.ssrContext = context.userContext;
            var child = context.activeInstance = createComponentInstanceForVnode(node, context.activeInstance);
            normalizeRender(child);
            var resolve = function () {
                var childNode = child._render();
                childNode.parent = node;
                context.renderStates.push({
                    type: "Component",
                    prevActive: prevActive,
                });
                renderNode(childNode, isRoot, context);
            };
            var reject = context.done;
            waitForServerPrefetch(child, resolve, reject);
        }
        function renderAsyncComponent(node, isRoot, context) {
            var factory = node.asyncFactory;
            var resolve = function (comp) {
                if (comp.__esModule && comp.default) {
                    comp = comp.default;
                }
                var ref = node.asyncMeta;
                var data = ref.data;
                var children = ref.children;
                var tag = ref.tag;
                var nodeContext = node.asyncMeta.context;
                var resolvedNode = createComponent(comp, data, nodeContext, children, tag);
                if (resolvedNode) {
                    if (resolvedNode.componentOptions) {
                        // normal component
                        renderComponent(resolvedNode, isRoot, context);
                    }
                    else if (!Array.isArray(resolvedNode)) {
                        // single return node from functional component
                        renderNode(resolvedNode, isRoot, context);
                    }
                    else {
                        // multiple return nodes from functional component
                        context.renderStates.push({
                            type: "Fragment",
                            children: resolvedNode,
                            rendered: 0,
                            total: resolvedNode.length,
                        });
                        context.next();
                    }
                }
                else {
                    // invalid component, but this does not throw on the client
                    // so render empty comment node
                    context.write("<!---->", context.next);
                }
            };
            if (factory.resolved) {
                resolve(factory.resolved);
                return;
            }
            var reject = context.done;
            var res;
            try {
                res = factory(resolve, reject);
            }
            catch (e) {
                reject(e);
            }
            if (res) {
                if (typeof res.then === "function") {
                    res.then(resolve, reject).catch(reject);
                }
                else {
                    // new syntax in 2.3
                    var comp = res.component;
                    if (comp && typeof comp.then === "function") {
                        comp.then(resolve, reject).catch(reject);
                    }
                }
            }
        }
        function renderStringNode$1(el, context) {
            var write = context.write;
            var next = context.next;
            if (isUndef(el.children) || el.children.length === 0) {
                write(el.open + (el.close || ""), next);
            }
            else {
                var children = el.children;
                context.renderStates.push({
                    type: "Element",
                    children: children,
                    rendered: 0,
                    total: children.length,
                    endTag: el.close,
                });
                write(el.open, next);
            }
        }
        function renderElement(el, isRoot, context) {
            var write = context.write;
            var next = context.next;
            if (isTrue(isRoot)) {
                if (!el.data) {
                    el.data = {};
                }
                if (!el.data.attrs) {
                    el.data.attrs = {};
                }
                el.data.attrs[SSR_ATTR] = "true";
            }
            if (el.fnOptions) {
                registerComponentForCache(el.fnOptions, write);
            }
            var startTag = renderStartingTag(el, context);
            var endTag = "</" + el.tag + ">";
            if (context.isUnaryTag(el.tag)) {
                write(startTag, next);
            }
            else if (isUndef(el.children) || el.children.length === 0) {
                write(startTag + endTag, next);
            }
            else {
                var children = el.children;
                context.renderStates.push({
                    type: "Element",
                    children: children,
                    rendered: 0,
                    total: children.length,
                    endTag: endTag,
                });
                write(startTag, next);
            }
        }
        function hasAncestorData(node) {
            var parentNode = node.parent;
            return isDef(parentNode) &&
                (isDef(parentNode.data) || hasAncestorData(parentNode));
        }
        function getVShowDirectiveInfo(node) {
            var dir;
            var tmp;
            while (isDef(node)) {
                if (node.data && node.data.directives) {
                    tmp = node.data.directives.find(function (dir) {
                        return dir.name === "show";
                    });
                    if (tmp) {
                        dir = tmp;
                    }
                }
                node = node.parent;
            }
            return dir;
        }
        function renderStartingTag(node, context) {
            var markup = "<" + node.tag;
            var directives = context.directives;
            var modules = context.modules; // construct synthetic data for module processing
            // because modules like style also produce code by parent VNode data
            if (isUndef(node.data) && hasAncestorData(node)) {
                node.data = {};
            }
            if (isDef(node.data)) {
                // check directives
                var dirs = node.data.directives;
                if (dirs) {
                    for (var i = 0; i < dirs.length; i++) {
                        var name = dirs[i].name;
                        if (name !== "show") {
                            var dirRenderer = resolveAsset(context, "directives", name);
                            if (dirRenderer) {
                                // directives mutate the node's data
                                // which then gets rendered by modules
                                dirRenderer(node, dirs[i]);
                            }
                        }
                    }
                } // v-show directive needs to be merged from parent to child
                var vshowDirectiveInfo = getVShowDirectiveInfo(node);
                if (vshowDirectiveInfo) {
                    directives.show(node, vshowDirectiveInfo);
                } // apply other modules
                for (var i$1 = 0; i$1 < modules.length; i$1++) {
                    var res = modules[i$1](node);
                    if (res) {
                        markup += res;
                    }
                }
            } // attach scoped CSS ID
            var scopeId;
            var activeInstance = context.activeInstance;
            if (isDef(activeInstance) && activeInstance !== node.context &&
                isDef(scopeId = activeInstance.$options._scopeId)) {
                markup += " " + scopeId;
            }
            if (isDef(node.fnScopeId)) {
                markup += " " + node.fnScopeId;
            }
            else {
                while (isDef(node)) {
                    if (isDef(scopeId = node.context.$options._scopeId)) {
                        markup += " " + scopeId;
                    }
                    node = node.parent;
                }
            }
            return markup + ">";
        }
        function createRenderFunction(modules, directives, isUnaryTag, cache) {
            return function render(component, write, userContext, done) {
                warned = Object.create(null);
                var context = new RenderContext({
                    activeInstance: component,
                    userContext: userContext,
                    write: write,
                    done: done,
                    renderNode: renderNode,
                    isUnaryTag: isUnaryTag,
                    modules: modules,
                    directives: directives,
                    cache: cache,
                });
                installSSRHelpers(component);
                normalizeRender(component);
                var resolve = function () {
                    renderNode(component._render(), true, context);
                };
                waitForServerPrefetch(component, resolve, done);
            };
        }
        /*  */
        var isJS = function (file) {
            return /\.js(\?[^.]+)?$/.test(file);
        };
        var isCSS = function (file) {
            return /\.css(\?[^.]+)?$/.test(file);
        };
        function createPromiseCallback() {
            var resolve, reject;
            var promise = new Promise(function (_resolve, _reject) {
                resolve = _resolve;
                reject = _reject;
            });
            var cb = function (err, res) {
                if (err) {
                    return reject(err);
                }
                resolve(res || "");
            };
            return {
                promise: promise,
                cb: cb,
            };
        }
        /*  */
        var Transform = stream_js_2.default.Transform;
        var TemplateStream = 
        /*@__PURE__*/
        function (Transform) {
            function TemplateStream(renderer, template, context) {
                Transform.call(this);
                this.started = false;
                this.renderer = renderer;
                this.template = template;
                this.context = context || {};
                this.inject = renderer.inject;
            }
            if (Transform)
                TemplateStream.__proto__ = Transform;
            TemplateStream.prototype = Object.create(Transform && Transform.prototype);
            TemplateStream.prototype.constructor = TemplateStream;
            TemplateStream.prototype._transform = function _transform(data, encoding, done) {
                if (!this.started) {
                    this.emit("beforeStart");
                    this.start();
                }
                this.push(data);
                done();
            };
            TemplateStream.prototype.start = function start() {
                this.started = true;
                this.push(this.template.head(this.context));
                if (this.inject) {
                    // inline server-rendered head meta information
                    if (this.context.head) {
                        this.push(this.context.head);
                    } // inline preload/prefetch directives for initial/async chunks
                    var links = this.renderer.renderResourceHints(this.context);
                    if (links) {
                        this.push(links);
                    } // CSS files and inline server-rendered CSS collected by vue-style-loader
                    var styles = this.renderer.renderStyles(this.context);
                    if (styles) {
                        this.push(styles);
                    }
                }
                this.push(this.template.neck(this.context));
            };
            TemplateStream.prototype._flush = function _flush(done) {
                this.emit("beforeEnd");
                if (this.inject) {
                    // inline initial store state
                    var state = this.renderer.renderState(this.context);
                    if (state) {
                        this.push(state);
                    } // embed scripts needed
                    var scripts = this.renderer.renderScripts(this.context);
                    if (scripts) {
                        this.push(scripts);
                    }
                }
                this.push(this.template.tail(this.context));
                done();
            };
            return TemplateStream;
        }(Transform);
        /*  */
        var compile$1 = npm_lodash_template_4_dew_1.dew();
        var compileOptions = {
            escape: /{{([^{][\s\S]+?[^}])}}/g,
            interpolate: /{{{([\s\S]+?)}}}/g,
        };
        function parseTemplate(template, contentPlaceholder) {
            if (contentPlaceholder === void 0) {
                contentPlaceholder = "<!--vue-ssr-outlet-->";
            }
            if (typeof template === "object") {
                return template;
            }
            var i = template.indexOf("</head>");
            var j = template.indexOf(contentPlaceholder);
            if (j < 0) {
                throw new Error("Content placeholder not found in template.");
            }
            if (i < 0) {
                i = template.indexOf("<body>");
                if (i < 0) {
                    i = j;
                }
            }
            return {
                head: compile$1(template.slice(0, i), compileOptions),
                neck: compile$1(template.slice(i, j), compileOptions),
                tail: compile$1(template.slice(j + contentPlaceholder.length), compileOptions),
            };
        }
        /*  */
        /**
         * Creates a mapper that maps components used during a server-side render
         * to async chunk files in the client-side build, so that we can inline them
         * directly in the rendered HTML to avoid waterfall requests.
         */
        function createMapper(clientManifest) {
            var map = createMap(clientManifest); // map server-side moduleIds to client-side files
            return function mapper(moduleIds) {
                var res = new Set();
                for (var i = 0; i < moduleIds.length; i++) {
                    var mapped = map.get(moduleIds[i]);
                    if (mapped) {
                        for (var j = 0; j < mapped.length; j++) {
                            res.add(mapped[j]);
                        }
                    }
                }
                return Array.from(res);
            };
        }
        function createMap(clientManifest) {
            var map = new Map();
            Object.keys(clientManifest.modules).forEach(function (id) {
                map.set(id, mapIdToFile(id, clientManifest));
            });
            return map;
        }
        function mapIdToFile(id, clientManifest) {
            var files = [];
            var fileIndices = clientManifest.modules[id];
            if (fileIndices) {
                fileIndices.forEach(function (index) {
                    var file = clientManifest.all[index]; // only include async files or non-js, non-css assets
                    if (clientManifest.async.indexOf(file) > -1 ||
                        !/\.(js|css)($|\?)/.test(file)) {
                        files.push(file);
                    }
                });
            }
            return files;
        }
        /*  */
        var path = path_js_5.default;
        var serialize = npm_serialize_javascript_2_dew_1.dew();
        var TemplateRenderer = function TemplateRenderer(options) {
            this.options = options;
            this.inject = options.inject !== false; // if no template option is provided, the renderer is created
            // as a utility object for rendering assets like preload links and scripts.
            var template = options.template;
            this.parsedTemplate = template
                ? typeof template === "string" ? parseTemplate(template) : template
                : null; // function used to serialize initial state JSON
            this.serialize = options.serializer || function (state) {
                return serialize(state, {
                    isJSON: true,
                });
            }; // extra functionality with client manifest
            if (options.clientManifest) {
                var clientManifest = this.clientManifest = options.clientManifest; // ensure publicPath ends with /
                this.publicPath = clientManifest.publicPath === ""
                    ? ""
                    : clientManifest.publicPath.replace(/([^\/])$/, "$1/"); // preload/prefetch directives
                this.preloadFiles = (clientManifest.initial || []).map(normalizeFile);
                this.prefetchFiles = (clientManifest.async || []).map(normalizeFile); // initial async chunk mapping
                this.mapFiles = createMapper(clientManifest);
            }
        };
        TemplateRenderer.prototype.bindRenderFns = function bindRenderFns(context) {
            var renderer = this;
            ["ResourceHints", "State", "Scripts", "Styles"].forEach(function (type) {
                context["render" + type] = renderer["render" + type].bind(renderer, context);
            }); // also expose getPreloadFiles, useful for HTTP/2 push
            context.getPreloadFiles = renderer.getPreloadFiles.bind(renderer, context);
        }; // render synchronously given rendered app content and render context
        TemplateRenderer.prototype.render = function render(content, context) {
            var template = this.parsedTemplate;
            if (!template) {
                throw new Error("render cannot be called without a template.");
            }
            context = context || {};
            if (typeof template === "function") {
                return template(content, context);
            }
            if (this.inject) {
                return template.head(context) + (context.head || "") +
                    this.renderResourceHints(context) + this.renderStyles(context) +
                    template.neck(context) + content + this.renderState(context) +
                    this.renderScripts(context) + template.tail(context);
            }
            else {
                return template.head(context) + template.neck(context) + content +
                    template.tail(context);
            }
        };
        TemplateRenderer.prototype.renderStyles = function renderStyles(context) {
            var this$1 = this;
            var initial = this.preloadFiles || [];
            var async = this.getUsedAsyncFiles(context) || [];
            var cssFiles = initial.concat(async).filter(function (ref) {
                var file = ref.file;
                return isCSS(file);
            });
            return ( // render links for css files
            (cssFiles.length
                ? cssFiles.map(function (ref) {
                    var file = ref.file;
                    return '<link rel="stylesheet" href="' + this$1.publicPath + file +
                        '">';
                }).join("")
                : "") + ( // context.styles is a getter exposed by vue-style-loader which contains
            // the inline component styles collected during SSR
            context.styles || ""));
        };
        TemplateRenderer.prototype.renderResourceHints = function renderResourceHints(context) {
            return this.renderPreloadLinks(context) + this.renderPrefetchLinks(context);
        };
        TemplateRenderer.prototype.getPreloadFiles = function getPreloadFiles(context) {
            var usedAsyncFiles = this.getUsedAsyncFiles(context);
            if (this.preloadFiles || usedAsyncFiles) {
                return (this.preloadFiles || []).concat(usedAsyncFiles || []);
            }
            else {
                return [];
            }
        };
        TemplateRenderer.prototype.renderPreloadLinks = function renderPreloadLinks(context) {
            var this$1 = this;
            var files = this.getPreloadFiles(context);
            var shouldPreload = this.options.shouldPreload;
            if (files.length) {
                return files.map(function (ref) {
                    var file = ref.file;
                    var extension = ref.extension;
                    var fileWithoutQuery = ref.fileWithoutQuery;
                    var asType = ref.asType;
                    var extra = ""; // by default, we only preload scripts or css
                    if (!shouldPreload && asType !== "script" && asType !== "style") {
                        return "";
                    } // user wants to explicitly control what to preload
                    if (shouldPreload && !shouldPreload(fileWithoutQuery, asType)) {
                        return "";
                    }
                    if (asType === "font") {
                        extra = ' type="font/' + extension + '" crossorigin';
                    }
                    return '<link rel="preload" href="' + this$1.publicPath + file + '"' +
                        (asType !== "" ? ' as="' + asType + '"' : "") + extra + ">";
                }).join("");
            }
            else {
                return "";
            }
        };
        TemplateRenderer.prototype.renderPrefetchLinks = function renderPrefetchLinks(context) {
            var this$1 = this;
            var shouldPrefetch = this.options.shouldPrefetch;
            if (this.prefetchFiles) {
                var usedAsyncFiles = this.getUsedAsyncFiles(context);
                var alreadyRendered = function (file) {
                    return usedAsyncFiles && usedAsyncFiles.some(function (f) {
                        return f.file === file;
                    });
                };
                return this.prefetchFiles.map(function (ref) {
                    var file = ref.file;
                    var fileWithoutQuery = ref.fileWithoutQuery;
                    var asType = ref.asType;
                    if (shouldPrefetch && !shouldPrefetch(fileWithoutQuery, asType)) {
                        return "";
                    }
                    if (alreadyRendered(file)) {
                        return "";
                    }
                    return '<link rel="prefetch" href="' + this$1.publicPath + file + '">';
                }).join("");
            }
            else {
                return "";
            }
        };
        TemplateRenderer.prototype.renderState = function renderState(context, options) {
            var ref = options || {};
            var contextKey = ref.contextKey;
            if (contextKey === void 0)
                contextKey = "state";
            var windowKey = ref.windowKey;
            if (windowKey === void 0)
                windowKey = "__INITIAL_STATE__";
            var state = this.serialize(context[contextKey]);
            var autoRemove = "";
            var nonceAttr = context.nonce ? ' nonce="' + context.nonce + '"' : "";
            return context[contextKey]
                ? "<script" + nonceAttr + ">window." + windowKey + "=" + state +
                    autoRemove + "</script>"
                : "";
        };
        TemplateRenderer.prototype.renderScripts = function renderScripts(context) {
            var this$1 = this;
            if (this.clientManifest) {
                var initial = this.preloadFiles.filter(function (ref) {
                    var file = ref.file;
                    return isJS(file);
                });
                var async = (this.getUsedAsyncFiles(context) || []).filter(function (ref) {
                    var file = ref.file;
                    return isJS(file);
                });
                var needed = [initial[0]].concat(async, initial.slice(1));
                return needed.map(function (ref) {
                    var file = ref.file;
                    return '<script src="' + this$1.publicPath + file + '" defer></script>';
                }).join("");
            }
            else {
                return "";
            }
        };
        TemplateRenderer.prototype.getUsedAsyncFiles = function getUsedAsyncFiles(context) {
            if (!context._mappedFiles && context._registeredComponents && this.mapFiles) {
                var registered = Array.from(context._registeredComponents);
                context._mappedFiles = this.mapFiles(registered).map(normalizeFile);
            }
            return context._mappedFiles;
        }; // create a transform stream
        TemplateRenderer.prototype.createStream = function createStream(context) {
            if (!this.parsedTemplate) {
                throw new Error("createStream cannot be called without a template.");
            }
            return new TemplateStream(this, this.parsedTemplate, context || {});
        };
        function normalizeFile(file) {
            var withoutQuery = file.replace(/\?.*/, "");
            var extension = path.extname(withoutQuery).slice(1);
            return {
                file: file,
                extension: extension,
                fileWithoutQuery: withoutQuery,
                asType: getPreloadType(extension),
            };
        }
        function getPreloadType(ext) {
            if (ext === "js") {
                return "script";
            }
            else if (ext === "css") {
                return "style";
            }
            else if (/jpe?g|png|svg|gif|webp|ico/.test(ext)) {
                return "image";
            }
            else if (/woff2?|ttf|otf|eot/.test(ext)) {
                return "font";
            }
            else {
                // not exhausting all possibilities here, but above covers common cases
                return "";
            }
        }
        /*  */
        function createRenderer(ref) {
            if (ref === void 0)
                ref = {};
            var modules = ref.modules;
            if (modules === void 0)
                modules = [];
            var directives = ref.directives;
            if (directives === void 0)
                directives = {};
            var isUnaryTag = ref.isUnaryTag;
            if (isUnaryTag === void 0) {
                isUnaryTag = function () {
                    return false;
                };
            }
            var template = ref.template;
            var inject = ref.inject;
            var cache = ref.cache;
            var shouldPreload = ref.shouldPreload;
            var shouldPrefetch = ref.shouldPrefetch;
            var clientManifest = ref.clientManifest;
            var serializer = ref.serializer;
            var render = createRenderFunction(modules, directives, isUnaryTag, cache);
            var templateRenderer = new TemplateRenderer({
                template: template,
                inject: inject,
                shouldPreload: shouldPreload,
                shouldPrefetch: shouldPrefetch,
                clientManifest: clientManifest,
                serializer: serializer,
            });
            return {
                renderToString: function renderToString(component, context, cb) {
                    var assign;
                    if (typeof context === "function") {
                        cb = context;
                        context = {};
                    }
                    if (context) {
                        templateRenderer.bindRenderFns(context);
                    } // no callback, return Promise
                    var promise;
                    if (!cb) {
                        assign = createPromiseCallback(),
                            promise = assign.promise,
                            cb = assign.cb;
                    }
                    var result = "";
                    var write = createWriteFunction(function (text) {
                        result += text;
                        return false;
                    }, cb);
                    try {
                        render(component, write, context, function (err) {
                            if (err) {
                                return cb(err);
                            }
                            if (context && context.rendered) {
                                context.rendered(context);
                            }
                            if (template) {
                                try {
                                    var res = templateRenderer.render(result, context);
                                    if (typeof res !== "string") {
                                        // function template returning promise
                                        res.then(function (html) {
                                            return cb(null, html);
                                        }).catch(cb);
                                    }
                                    else {
                                        cb(null, res);
                                    }
                                }
                                catch (e) {
                                    cb(e);
                                }
                            }
                            else {
                                cb(null, result);
                            }
                        });
                    }
                    catch (e) {
                        cb(e);
                    }
                    return promise;
                },
                renderToStream: function renderToStream(component, context) {
                    if (context) {
                        templateRenderer.bindRenderFns(context);
                    }
                    var renderStream = new RenderStream(function (write, done) {
                        render(component, write, context, done);
                    });
                    if (!template) {
                        if (context && context.rendered) {
                            var rendered = context.rendered;
                            renderStream.once("beforeEnd", function () {
                                rendered(context);
                            });
                        }
                        return renderStream;
                    }
                    else if (typeof template === "function") {
                        throw new Error("function template is only supported in renderToString.");
                    }
                    else {
                        var templateStream = templateRenderer.createStream(context);
                        renderStream.on("error", function (err) {
                            templateStream.emit("error", err);
                        });
                        renderStream.pipe(templateStream);
                        if (context && context.rendered) {
                            var rendered$1 = context.rendered;
                            renderStream.once("beforeEnd", function () {
                                rendered$1(context);
                            });
                        }
                        return templateStream;
                    }
                },
            };
        }
        var vm = vm_js_2.default;
        var path$1 = path_js_5.default;
        var resolve = npm_resolve_1_dew_1.dew();
        var NativeModule = _empty_js_3.default;
        function createSandbox(context) {
            var sandbox = {
                Buffer: Buffer,
                console: console,
                process: process,
                setTimeout: setTimeout,
                setInterval: setInterval,
                setImmediate: setImmediate,
                clearTimeout: clearTimeout,
                clearInterval: clearInterval,
                clearImmediate: clearImmediate,
                __VUE_SSR_CONTEXT__: context,
            };
            sandbox.global = sandbox;
            return sandbox;
        }
        function compileModule(files, basedir, runInNewContext) {
            var compiledScripts = {};
            var resolvedModules = {};
            function getCompiledScript(filename) {
                if (compiledScripts[filename]) {
                    return compiledScripts[filename];
                }
                var code = files[filename];
                var wrapper = NativeModule.wrap(code);
                var script = new vm.Script(wrapper, {
                    filename: filename,
                    displayErrors: true,
                });
                compiledScripts[filename] = script;
                return script;
            }
            function evaluateModule(filename, sandbox, evaluatedFiles) {
                if (evaluatedFiles === void 0)
                    evaluatedFiles = {};
                if (evaluatedFiles[filename]) {
                    return evaluatedFiles[filename];
                }
                var script = getCompiledScript(filename);
                var compiledWrapper = runInNewContext === false
                    ? script.runInThisContext()
                    : script.runInNewContext(sandbox);
                var m = {
                    exports: {},
                };
                var r = function (file) {
                    file = path$1.posix.join(".", file);
                    if (files[file]) {
                        return evaluateModule(file, sandbox, evaluatedFiles);
                    }
                    else if (basedir) {
                        return _nullRequire(resolvedModules[file] ||
                            (resolvedModules[file] = resolve.sync(file, {
                                basedir: basedir,
                            })));
                    }
                    else {
                        return _nullRequire(file);
                    }
                };
                compiledWrapper.call(m.exports, m.exports, r, m);
                var res = Object.prototype.hasOwnProperty.call(m.exports, "default")
                    ? m.exports.default
                    : m.exports;
                evaluatedFiles[filename] = res;
                return res;
            }
            return evaluateModule;
        }
        function deepClone(val) {
            if (isPlainObject(val)) {
                var res = {};
                for (var key in val) {
                    res[key] = deepClone(val[key]);
                }
                return res;
            }
            else if (Array.isArray(val)) {
                return val.slice();
            }
            else {
                return val;
            }
        }
        function createBundleRunner(entry, files, basedir, runInNewContext) {
            var evaluate = compileModule(files, basedir, runInNewContext);
            if (runInNewContext !== false && runInNewContext !== "once") {
                // new context mode: creates a fresh context and re-evaluate the bundle
                // on each render. Ensures entire application state is fresh for each
                // render, but incurs extra evaluation cost.
                return function (userContext) {
                    if (userContext === void 0)
                        userContext = {};
                    return new Promise(function (resolve) {
                        userContext._registeredComponents = new Set();
                        var res = evaluate(entry, createSandbox(userContext));
                        resolve(typeof res === "function" ? res(userContext) : res);
                    });
                };
            }
            else {
                // direct mode: instead of re-evaluating the whole bundle on
                // each render, it simply calls the exported function. This avoids the
                // module evaluation costs but requires the source code to be structured
                // slightly differently.
                var runner; // lazy creation so that errors can be caught by user
                var initialContext;
                return function (userContext) {
                    if (userContext === void 0)
                        userContext = {};
                    return new Promise(function (resolve) {
                        if (!runner) {
                            var sandbox = runInNewContext === "once"
                                ? createSandbox()
                                : _global; // the initial context is only used for collecting possible non-component
                            // styles injected by vue-style-loader.
                            initialContext = sandbox.__VUE_SSR_CONTEXT__ = {};
                            runner = evaluate(entry, sandbox); // On subsequent renders, __VUE_SSR_CONTEXT__ will not be available
                            // to prevent cross-request pollution.
                            delete sandbox.__VUE_SSR_CONTEXT__;
                            if (typeof runner !== "function") {
                                throw new Error("bundle export should be a function when using " +
                                    "{ runInNewContext: false }.");
                            }
                        }
                        userContext._registeredComponents = new Set(); // vue-style-loader styles imported outside of component lifecycle hooks
                        if (initialContext._styles) {
                            userContext._styles = deepClone(initialContext._styles); // #6353 ensure "styles" is exposed even if no styles are injected
                            // in component lifecycles.
                            // the renderStyles fn is exposed by vue-style-loader >= 3.0.3
                            var renderStyles = initialContext._renderStyles;
                            if (renderStyles) {
                                Object.defineProperty(userContext, "styles", {
                                    enumerable: true,
                                    get: function get() {
                                        return renderStyles(userContext._styles);
                                    },
                                });
                            }
                        }
                        resolve(runner(userContext));
                    });
                };
            }
        }
        /*  */
        var SourceMapConsumer = npm_source_map_0_5_6_dew_1.dew().SourceMapConsumer;
        var filenameRE = /\(([^)]+\.js):(\d+):(\d+)\)$/;
        function createSourceMapConsumers(rawMaps) {
            var maps = {};
            Object.keys(rawMaps).forEach(function (file) {
                maps[file] = new SourceMapConsumer(rawMaps[file]);
            });
            return maps;
        }
        function rewriteErrorTrace(e, mapConsumers) {
            if (e && typeof e.stack === "string") {
                e.stack = e.stack.split("\n").map(function (line) {
                    return rewriteTraceLine(line, mapConsumers);
                }).join("\n");
            }
        }
        function rewriteTraceLine(trace, mapConsumers) {
            var m = trace.match(filenameRE);
            var map = m && mapConsumers[m[1]];
            if (m != null && map) {
                var originalPosition = map.originalPositionFor({
                    line: Number(m[2]),
                    column: Number(m[3]),
                });
                if (originalPosition.source != null) {
                    var source = originalPosition.source;
                    var line = originalPosition.line;
                    var column = originalPosition.column;
                    var mappedPosition = "(" + source.replace(/^webpack:\/\/\//, "") + ":" +
                        String(line) + ":" + String(column) + ")";
                    return trace.replace(filenameRE, mappedPosition);
                }
                else {
                    return trace;
                }
            }
            else {
                return trace;
            }
        }
        /*  */
        var fs = _empty_js_3.default;
        var path$2 = path_js_5.default;
        var PassThrough = stream_js_2.default.PassThrough;
        var INVALID_MSG = "Invalid server-rendering bundle format. Should be a string " +
            "or a bundle Object of type:\n\n" +
            "{\n  entry: string;\n  files: { [filename: string]: string; };\n  maps: { [filename: string]: string; };\n}\n"; // The render bundle can either be a string (single bundled file)
        // or a bundle manifest object generated by vue-ssr-webpack-plugin.
        function createBundleRendererCreator(createRenderer) {
            return function createBundleRenderer(bundle, rendererOptions) {
                if (rendererOptions === void 0)
                    rendererOptions = {};
                var files, entry, maps;
                var basedir = rendererOptions.basedir; // load bundle if given filepath
                if (typeof bundle === "string" && /\.js(on)?$/.test(bundle) &&
                    path$2.isAbsolute(bundle)) {
                    if (fs.existsSync(bundle)) {
                        var isJSON = /\.json$/.test(bundle);
                        basedir = basedir || path$2.dirname(bundle);
                        bundle = fs.readFileSync(bundle, "utf-8");
                        if (isJSON) {
                            try {
                                bundle = JSON.parse(bundle);
                            }
                            catch (e) {
                                throw new Error("Invalid JSON bundle file: " + bundle);
                            }
                        }
                    }
                    else {
                        throw new Error("Cannot locate bundle file: " + bundle);
                    }
                }
                if (typeof bundle === "object") {
                    entry = bundle.entry;
                    files = bundle.files;
                    basedir = basedir || bundle.basedir;
                    maps = createSourceMapConsumers(bundle.maps);
                    if (typeof entry !== "string" || typeof files !== "object") {
                        throw new Error(INVALID_MSG);
                    }
                }
                else if (typeof bundle === "string") {
                    entry = "__vue_ssr_bundle__";
                    files = {
                        "__vue_ssr_bundle__": bundle,
                    };
                    maps = {};
                }
                else {
                    throw new Error(INVALID_MSG);
                }
                var renderer = createRenderer(rendererOptions);
                var run = createBundleRunner(entry, files, basedir, rendererOptions.runInNewContext);
                return {
                    renderToString: function (context, cb) {
                        var assign;
                        if (typeof context === "function") {
                            cb = context;
                            context = {};
                        }
                        var promise;
                        if (!cb) {
                            assign = createPromiseCallback(),
                                promise = assign.promise,
                                cb = assign.cb;
                        }
                        run(context).catch(function (err) {
                            rewriteErrorTrace(err, maps);
                            cb(err);
                        }).then(function (app) {
                            if (app) {
                                renderer.renderToString(app, context, function (err, res) {
                                    rewriteErrorTrace(err, maps);
                                    cb(err, res);
                                });
                            }
                        });
                        return promise;
                    },
                    renderToStream: function (context) {
                        var res = new PassThrough();
                        run(context).catch(function (err) {
                            rewriteErrorTrace(err, maps); // avoid emitting synchronously before user can
                            // attach error listener
                            process.nextTick(function () {
                                res.emit("error", err);
                            });
                        }).then(function (app) {
                            if (app) {
                                var renderStream = renderer.renderToStream(app, context);
                                renderStream.on("error", function (err) {
                                    rewriteErrorTrace(err, maps);
                                    res.emit("error", err);
                                }); // relay HTMLStream special events
                                if (rendererOptions && rendererOptions.template) {
                                    renderStream.on("beforeStart", function () {
                                        res.emit("beforeStart");
                                    });
                                    renderStream.on("beforeEnd", function () {
                                        res.emit("beforeEnd");
                                    });
                                }
                                renderStream.pipe(res);
                            }
                        });
                        return res;
                    },
                };
            };
        }
        /*  */
        process.env.VUE_ENV = "server";
        function createRenderer$1(options) {
            if (options === void 0)
                options = {};
            return createRenderer(extend(extend({}, options), {
                isUnaryTag: isUnaryTag,
                canBeLeftOpenTag: canBeLeftOpenTag,
                modules: modules,
                // user can provide server-side implementations for custom directives
                // when creating the renderer.
                directives: extend(baseDirectives, options.directives),
            }));
        }
        var createBundleRenderer = createBundleRendererCreator(createRenderer$1);
        exports.createRenderer = createRenderer$1;
        exports.createBundleRenderer = createBundleRenderer;
        return exports;
    }
    exports_123("dew", dew);
    return {
        setters: [
            function (npm_he_1_dew_1_1) {
                npm_he_1_dew_1 = npm_he_1_dew_1_1;
            },
            function (stream_js_2_1) {
                stream_js_2 = stream_js_2_1;
            },
            function (npm_lodash_template_4_dew_1_1) {
                npm_lodash_template_4_dew_1 = npm_lodash_template_4_dew_1_1;
            },
            function (path_js_5_1) {
                path_js_5 = path_js_5_1;
            },
            function (npm_serialize_javascript_2_dew_1_1) {
                npm_serialize_javascript_2_dew_1 = npm_serialize_javascript_2_dew_1_1;
            },
            function (vm_js_2_1) {
                vm_js_2 = vm_js_2_1;
            },
            function (npm_resolve_1_dew_1_1) {
                npm_resolve_1_dew_1 = npm_resolve_1_dew_1_1;
            },
            function (_empty_js_3_1) {
                _empty_js_3 = _empty_js_3_1;
            },
            function (npm_source_map_0_5_6_dew_1_1) {
                npm_source_map_0_5_6_dew_1 = npm_source_map_0_5_6_dew_1_1;
            },
            function (process_js_6_1) {
                process_js_6 = process_js_6_1;
            },
            function (buffer_js_4_1) {
                buffer_js_4 = buffer_js_4_1;
            }
        ],
        execute: function () {
            exports = {}, _dewExec = false;
            _global = typeof self !== "undefined" ? self : global;
        }
    };
});
System.register("file:///Users/norbert/Documents/workspace/deno/deno-ssr/vue-server-render/index.dew", ["https://dev.jspm.io/npm:@jspm/core@1/nodelibs/@empty.dew", "https://dev.jspm.io/npm:vue-server-renderer@2.6.11/package.json.dew", "file:///Users/norbert/Documents/workspace/deno/deno-ssr/vue-server-render/build.dev.dew"], function (exports_124, context_124) {
    "use strict";
    var _empty_dew_js_2, package_json_dew_js_1, build_dev_dew_js_1, exports, _dewExec;
    var __moduleName = context_124 && context_124.id;
    function dew() {
        if (_dewExec)
            return exports;
        _dewExec = true;
        try {
            var vueVersion = _empty_dew_js_2.dew().version;
        }
        catch (e) { }
        var packageName = package_json_dew_js_1.dew().name;
        var packageVersion = package_json_dew_js_1.dew().version;
        if (vueVersion && vueVersion !== packageVersion) {
            throw new Error("\n\nVue packages version mismatch:\n\n" + "- vue@" + vueVersion + "\n" +
                "- " + packageName + "@" + packageVersion + "\n\n" +
                "This may cause things to work incorrectly. Make sure to use the same version for both.\n");
        }
        {
            exports = build_dev_dew_js_1.dew();
        }
        return exports;
    }
    exports_124("dew", dew);
    return {
        setters: [
            function (_empty_dew_js_2_1) {
                _empty_dew_js_2 = _empty_dew_js_2_1;
            },
            function (package_json_dew_js_1_1) {
                package_json_dew_js_1 = package_json_dew_js_1_1;
            },
            function (build_dev_dew_js_1_1) {
                build_dev_dew_js_1 = build_dev_dew_js_1_1;
            }
        ],
        execute: function () {
            exports = {}, _dewExec = false;
        }
    };
});
System.register("https://dev.jspm.io/npm:vue-server-renderer@2.6.11/build.dev.dew", ["https://dev.jspm.io/npm:he@1?dew", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/stream", "https://dev.jspm.io/npm:lodash.template@4?dew", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/path", "https://dev.jspm.io/npm:serialize-javascript@2?dew", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/vm", "https://dev.jspm.io/npm:resolve@1?dew", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/@empty", "https://dev.jspm.io/npm:source-map@0.5.6?dew", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/process", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/buffer"], function (exports_125, context_125) {
    "use strict";
    var npm_he_1_dew_2, stream_js_3, npm_lodash_template_4_dew_2, path_js_6, npm_serialize_javascript_2_dew_2, vm_js_3, npm_resolve_1_dew_2, _empty_js_4, npm_source_map_0_5_6_dew_2, process_js_7, buffer_js_5, exports, _dewExec, _global;
    var __moduleName = context_125 && context_125.id;
    function dew() {
        if (_dewExec)
            return exports;
        _dewExec = true;
        function _nullRequire(id) {
            var e = new Error("Cannot find module '" + id + "'");
            e.code = "MODULE_NOT_FOUND";
            throw e;
        }
        var Buffer = buffer_js_5.default.Buffer;
        var process = process_js_7.default;
        Object.defineProperty(exports, '__esModule', {
            value: true
        });
        function _interopDefault(ex) {
            return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
        }
        var he = _interopDefault(npm_he_1_dew_2.dew());
        /*  */
        var emptyObject = Object.freeze({}); // These helpers produce better VM code in JS engines due to their
        // explicitness and function inlining.
        function isUndef(v) {
            return v === undefined || v === null;
        }
        function isDef(v) {
            return v !== undefined && v !== null;
        }
        function isTrue(v) {
            return v === true;
        }
        function isFalse(v) {
            return v === false;
        }
        /**
         * Check if value is primitive.
         */
        function isPrimitive(value) {
            return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line
                typeof value === 'symbol' || typeof value === 'boolean';
        }
        /**
         * Quick object check - this is primarily used to tell
         * Objects from primitive values when we know the value
         * is a JSON-compliant type.
         */
        function isObject(obj) {
            return obj !== null && typeof obj === 'object';
        }
        /**
         * Get the raw type string of a value, e.g., [object Object].
         */
        var _toString = Object.prototype.toString;
        function toRawType(value) {
            return _toString.call(value).slice(8, -1);
        }
        /**
         * Strict object type check. Only returns true
         * for plain JavaScript objects.
         */
        function isPlainObject(obj) {
            return _toString.call(obj) === '[object Object]';
        }
        /**
         * Check if val is a valid array index.
         */
        function isValidArrayIndex(val) {
            var n = parseFloat(String(val));
            return n >= 0 && Math.floor(n) === n && isFinite(val);
        }
        function isPromise(val) {
            return isDef(val) && typeof val.then === 'function' && typeof val.catch === 'function';
        }
        /**
         * Convert a value to a string that is actually rendered.
         */
        function toString(val) {
            return val == null ? '' : Array.isArray(val) || isPlainObject(val) && val.toString === _toString ? JSON.stringify(val, null, 2) : String(val);
        }
        /**
         * Convert an input value to a number for persistence.
         * If the conversion fails, return original string.
         */
        function toNumber(val) {
            var n = parseFloat(val);
            return isNaN(n) ? val : n;
        }
        /**
         * Make a map and return a function for checking if a key
         * is in that map.
         */
        function makeMap(str, expectsLowerCase) {
            var map = Object.create(null);
            var list = str.split(',');
            for (var i = 0; i < list.length; i++) {
                map[list[i]] = true;
            }
            return expectsLowerCase ? function (val) {
                return map[val.toLowerCase()];
            } : function (val) {
                return map[val];
            };
        }
        /**
         * Check if a tag is a built-in tag.
         */
        var isBuiltInTag = makeMap('slot,component', true);
        /**
         * Check if an attribute is a reserved attribute.
         */
        var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');
        /**
         * Remove an item from an array.
         */
        function remove(arr, item) {
            if (arr.length) {
                var index = arr.indexOf(item);
                if (index > -1) {
                    return arr.splice(index, 1);
                }
            }
        }
        /**
         * Check whether an object has the property.
         */
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        function hasOwn(obj, key) {
            return hasOwnProperty.call(obj, key);
        }
        /**
         * Create a cached version of a pure function.
         */
        function cached(fn) {
            var cache = Object.create(null);
            return function cachedFn(str) {
                var hit = cache[str];
                return hit || (cache[str] = fn(str));
            };
        }
        /**
         * Camelize a hyphen-delimited string.
         */
        var camelizeRE = /-(\w)/g;
        var camelize = cached(function (str) {
            return str.replace(camelizeRE, function (_, c) {
                return c ? c.toUpperCase() : '';
            });
        });
        /**
         * Capitalize a string.
         */
        var capitalize = cached(function (str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        });
        /**
         * Hyphenate a camelCase string.
         */
        var hyphenateRE = /\B([A-Z])/g;
        var hyphenate = cached(function (str) {
            return str.replace(hyphenateRE, '-$1').toLowerCase();
        });
        /**
         * Simple bind polyfill for environments that do not support it,
         * e.g., PhantomJS 1.x. Technically, we don't need this anymore
         * since native bind is now performant enough in most browsers.
         * But removing it would mean breaking code that was able to run in
         * PhantomJS 1.x, so this must be kept for backward compatibility.
         */
        /* istanbul ignore next */
        function polyfillBind(fn, ctx) {
            function boundFn(a) {
                var l = arguments.length;
                return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
            }
            boundFn._length = fn.length;
            return boundFn;
        }
        function nativeBind(fn, ctx) {
            return fn.bind(ctx);
        }
        var bind = Function.prototype.bind ? nativeBind : polyfillBind;
        /**
         * Mix properties into target object.
         */
        function extend(to, _from) {
            for (var key in _from) {
                to[key] = _from[key];
            }
            return to;
        }
        /**
         * Merge an Array of Objects into a single Object.
         */
        function toObject(arr) {
            var res = {};
            for (var i = 0; i < arr.length; i++) {
                if (arr[i]) {
                    extend(res, arr[i]);
                }
            }
            return res;
        }
        /* eslint-disable no-unused-vars */
        /**
         * Perform no operation.
         * Stubbing args to make Flow happy without leaving useless transpiled code
         * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
         */
        function noop(a, b, c) { }
        /**
         * Always return false.
         */
        var no = function (a, b, c) {
            return false;
        };
        /* eslint-enable no-unused-vars */
        /**
         * Return the same value.
         */
        var identity = function (_) {
            return _;
        };
        /**
         * Generate a string containing static keys from compiler modules.
         */
        function genStaticKeys(modules) {
            return modules.reduce(function (keys, m) {
                return keys.concat(m.staticKeys || []);
            }, []).join(',');
        }
        /**
         * Check if two values are loosely equal - that is,
         * if they are plain objects, do they have the same shape?
         */
        function looseEqual(a, b) {
            if (a === b) {
                return true;
            }
            var isObjectA = isObject(a);
            var isObjectB = isObject(b);
            if (isObjectA && isObjectB) {
                try {
                    var isArrayA = Array.isArray(a);
                    var isArrayB = Array.isArray(b);
                    if (isArrayA && isArrayB) {
                        return a.length === b.length && a.every(function (e, i) {
                            return looseEqual(e, b[i]);
                        });
                    }
                    else if (a instanceof Date && b instanceof Date) {
                        return a.getTime() === b.getTime();
                    }
                    else if (!isArrayA && !isArrayB) {
                        var keysA = Object.keys(a);
                        var keysB = Object.keys(b);
                        return keysA.length === keysB.length && keysA.every(function (key) {
                            return looseEqual(a[key], b[key]);
                        });
                    }
                    else {
                        /* istanbul ignore next */
                        return false;
                    }
                }
                catch (e) {
                    /* istanbul ignore next */
                    return false;
                }
            }
            else if (!isObjectA && !isObjectB) {
                return String(a) === String(b);
            }
            else {
                return false;
            }
        }
        /**
         * Return the first index at which a loosely equal value can be
         * found in the array (if value is a plain object, the array must
         * contain an object of the same shape), or -1 if it is not present.
         */
        function looseIndexOf(arr, val) {
            for (var i = 0; i < arr.length; i++) {
                if (looseEqual(arr[i], val)) {
                    return i;
                }
            }
            return -1;
        }
        /**
         * Ensure a function is called only once.
         */
        function once(fn) {
            var called = false;
            return function () {
                if (!called) {
                    called = true;
                    fn.apply(this, arguments);
                }
            };
        }
        /*  */
        var isAttr = makeMap('accept,accept-charset,accesskey,action,align,alt,async,autocomplete,' + 'autofocus,autoplay,autosave,bgcolor,border,buffered,challenge,charset,' + 'checked,cite,class,code,codebase,color,cols,colspan,content,http-equiv,' + 'name,contenteditable,contextmenu,controls,coords,data,datetime,default,' + 'defer,dir,dirname,disabled,download,draggable,dropzone,enctype,method,for,' + 'form,formaction,headers,height,hidden,high,href,hreflang,http-equiv,' + 'icon,id,ismap,itemprop,keytype,kind,label,lang,language,list,loop,low,' + 'manifest,max,maxlength,media,method,GET,POST,min,multiple,email,file,' + 'muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,' + 'preload,radiogroup,readonly,rel,required,reversed,rows,rowspan,sandbox,' + 'scope,scoped,seamless,selected,shape,size,type,text,password,sizes,span,' + 'spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,' + 'target,title,type,usemap,value,width,wrap');
        var unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/; // eslint-disable-line no-control-regex
        var isSSRUnsafeAttr = function (name) {
            return unsafeAttrCharRE.test(name);
        };
        /* istanbul ignore next */
        var isRenderableAttr = function (name) {
            return isAttr(name) || name.indexOf('data-') === 0 || name.indexOf('aria-') === 0;
        };
        var propsToAttrMap = {
            acceptCharset: 'accept-charset',
            className: 'class',
            htmlFor: 'for',
            httpEquiv: 'http-equiv'
        };
        var ESC = {
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            '&': '&amp;'
        };
        function escape(s) {
            return s.replace(/[<>"&]/g, escapeChar);
        }
        function escapeChar(a) {
            return ESC[a] || a;
        }
        var noUnitNumericStyleProps = {
            "animation-iteration-count": true,
            "border-image-outset": true,
            "border-image-slice": true,
            "border-image-width": true,
            "box-flex": true,
            "box-flex-group": true,
            "box-ordinal-group": true,
            "column-count": true,
            "columns": true,
            "flex": true,
            "flex-grow": true,
            "flex-positive": true,
            "flex-shrink": true,
            "flex-negative": true,
            "flex-order": true,
            "grid-row": true,
            "grid-row-end": true,
            "grid-row-span": true,
            "grid-row-start": true,
            "grid-column": true,
            "grid-column-end": true,
            "grid-column-span": true,
            "grid-column-start": true,
            "font-weight": true,
            "line-clamp": true,
            "line-height": true,
            "opacity": true,
            "order": true,
            "orphans": true,
            "tab-size": true,
            "widows": true,
            "z-index": true,
            "zoom": true,
            // SVG
            "fill-opacity": true,
            "flood-opacity": true,
            "stop-opacity": true,
            "stroke-dasharray": true,
            "stroke-dashoffset": true,
            "stroke-miterlimit": true,
            "stroke-opacity": true,
            "stroke-width": true
        };
        /*  */
        // these are reserved for web because they are directly compiled away
        // during template compilation
        var isReservedAttr = makeMap('style,class'); // attributes that should be using props for binding
        var acceptValue = makeMap('input,textarea,option,select,progress');
        var mustUseProp = function (tag, type, attr) {
            return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
        };
        var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
        var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');
        var convertEnumeratedValue = function (key, value) {
            return isFalsyAttrValue(value) || value === 'false' ? 'false' // allow arbitrary string value for contenteditable
                : key === 'contenteditable' && isValidContentEditableValue(value) ? value : 'true';
        };
        var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');
        var isFalsyAttrValue = function (val) {
            return val == null || val === false;
        };
        /*  */
        function renderAttrs(node) {
            var attrs = node.data.attrs;
            var res = '';
            var opts = node.parent && node.parent.componentOptions;
            if (isUndef(opts) || opts.Ctor.options.inheritAttrs !== false) {
                var parent = node.parent;
                while (isDef(parent)) {
                    if (isDef(parent.data) && isDef(parent.data.attrs)) {
                        attrs = extend(extend({}, attrs), parent.data.attrs);
                    }
                    parent = parent.parent;
                }
            }
            if (isUndef(attrs)) {
                return res;
            }
            for (var key in attrs) {
                if (isSSRUnsafeAttr(key)) {
                    continue;
                }
                if (key === 'style') {
                    // leave it to the style module
                    continue;
                }
                res += renderAttr(key, attrs[key]);
            }
            return res;
        }
        function renderAttr(key, value) {
            if (isBooleanAttr(key)) {
                if (!isFalsyAttrValue(value)) {
                    return " " + key + "=\"" + key + "\"";
                }
            }
            else if (isEnumeratedAttr(key)) {
                return " " + key + "=\"" + escape(convertEnumeratedValue(key, value)) + "\"";
            }
            else if (!isFalsyAttrValue(value)) {
                return " " + key + "=\"" + escape(String(value)) + "\"";
            }
            return '';
        }
        /*  */
        var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
            this.tag = tag;
            this.data = data;
            this.children = children;
            this.text = text;
            this.elm = elm;
            this.ns = undefined;
            this.context = context;
            this.fnContext = undefined;
            this.fnOptions = undefined;
            this.fnScopeId = undefined;
            this.key = data && data.key;
            this.componentOptions = componentOptions;
            this.componentInstance = undefined;
            this.parent = undefined;
            this.raw = false;
            this.isStatic = false;
            this.isRootInsert = true;
            this.isComment = false;
            this.isCloned = false;
            this.isOnce = false;
            this.asyncFactory = asyncFactory;
            this.asyncMeta = undefined;
            this.isAsyncPlaceholder = false;
        };
        var prototypeAccessors = {
            child: {
                configurable: true
            }
        }; // DEPRECATED: alias for componentInstance for backwards compat.
        /* istanbul ignore next */
        prototypeAccessors.child.get = function () {
            return this.componentInstance;
        };
        Object.defineProperties(VNode.prototype, prototypeAccessors);
        var createEmptyVNode = function (text) {
            if (text === void 0)
                text = '';
            var node = new VNode();
            node.text = text;
            node.isComment = true;
            return node;
        };
        function createTextVNode(val) {
            return new VNode(undefined, undefined, undefined, String(val));
        } // optimized shallow clone
        // used for static nodes and slot nodes because they may be reused across
        // multiple renders, cloning them avoids errors when DOM manipulations rely
        // on their elm reference.
        function cloneVNode(vnode) {
            var cloned = new VNode(vnode.tag, vnode.data, // #7975
            // clone children array to avoid mutating original in case of cloning
            // a child.
            vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
            cloned.ns = vnode.ns;
            cloned.isStatic = vnode.isStatic;
            cloned.key = vnode.key;
            cloned.isComment = vnode.isComment;
            cloned.fnContext = vnode.fnContext;
            cloned.fnOptions = vnode.fnOptions;
            cloned.fnScopeId = vnode.fnScopeId;
            cloned.asyncMeta = vnode.asyncMeta;
            cloned.isCloned = true;
            return cloned;
        }
        /*  */
        function renderDOMProps(node) {
            var props = node.data.domProps;
            var res = '';
            var parent = node.parent;
            while (isDef(parent)) {
                if (parent.data && parent.data.domProps) {
                    props = extend(extend({}, props), parent.data.domProps);
                }
                parent = parent.parent;
            }
            if (isUndef(props)) {
                return res;
            }
            var attrs = node.data.attrs;
            for (var key in props) {
                if (key === 'innerHTML') {
                    setText(node, props[key], true);
                }
                else if (key === 'textContent') {
                    setText(node, props[key], false);
                }
                else if (key === 'value' && node.tag === 'textarea') {
                    setText(node, props[key], false);
                }
                else {
                    // $flow-disable-line (WTF?)
                    var attr = propsToAttrMap[key] || key.toLowerCase();
                    if (isRenderableAttr(attr) && // avoid rendering double-bound props/attrs twice
                        !(isDef(attrs) && isDef(attrs[attr]))) {
                        res += renderAttr(attr, props[key]);
                    }
                }
            }
            return res;
        }
        function setText(node, text, raw) {
            var child = new VNode(undefined, undefined, undefined, text);
            child.raw = raw;
            node.children = [child];
        }
        /*  */
        /**
         * unicode letters used for parsing html tags, component names and property paths.
         * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
         * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
         */
        var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
        /**
         * Define a property.
         */
        function def(obj, key, val, enumerable) {
            Object.defineProperty(obj, key, {
                value: val,
                enumerable: !!enumerable,
                writable: true,
                configurable: true
            });
        }
        /*  */
        // can we use __proto__?
        var hasProto = '__proto__' in {}; // Browser environment sniffing
        var inBrowser = typeof window !== 'undefined';
        var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
        var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
        var UA = inBrowser && window.navigator.userAgent.toLowerCase();
        var isIE = UA && /msie|trident/.test(UA);
        var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
        var isEdge = UA && UA.indexOf('edge/') > 0;
        var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';
        var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';
        var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
        var isPhantomJS = UA && /phantomjs/.test(UA);
        var isFF = UA && UA.match(/firefox\/(\d+)/); // Firefox has a "watch" function on Object.prototype...
        var nativeWatch = {}.watch;
        if (inBrowser) {
            try {
                var opts = {};
                Object.defineProperty(opts, 'passive', {
                    get: function get() { }
                }); // https://github.com/facebook/flow/issues/285
                window.addEventListener('test-passive', null, opts);
            }
            catch (e) { }
        } // this needs to be lazy-evaled because vue may be required before
        // vue-server-renderer can set VUE_ENV
        var _isServer;
        var isServerRendering = function () {
            if (_isServer === undefined) {
                /* istanbul ignore if */
                if (!inBrowser && !inWeex && typeof _global !== 'undefined') {
                    // detect presence of vue-server-renderer and avoid
                    // Webpack shimming the process
                    _isServer = _global['process'] && _global['process'].env.VUE_ENV === 'server';
                }
                else {
                    _isServer = false;
                }
            }
            return _isServer;
        }; // detect devtools
        var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
        /* istanbul ignore next */
        function isNative(Ctor) {
            return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
        }
        var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);
        var _Set;
        /* istanbul ignore if */
        // $flow-disable-line
        if (typeof Set !== 'undefined' && isNative(Set)) {
            // use native Set when available.
            _Set = Set;
        }
        else {
            // a non-standard Set polyfill that only works with primitive keys.
            _Set =
                /*@__PURE__*/
                function () {
                    function Set() {
                        this.set = Object.create(null);
                    }
                    Set.prototype.has = function has(key) {
                        return this.set[key] === true;
                    };
                    Set.prototype.add = function add(key) {
                        this.set[key] = true;
                    };
                    Set.prototype.clear = function clear() {
                        this.set = Object.create(null);
                    };
                    return Set;
                }();
        }
        var SSR_ATTR = 'data-server-rendered';
        var ASSET_TYPES = ['component', 'directive', 'filter'];
        var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured', 'serverPrefetch'];
        /*  */
        var config = {
            /**
             * Option merge strategies (used in core/util/options)
             */
            // $flow-disable-line
            optionMergeStrategies: Object.create(null),
            /**
             * Whether to suppress warnings.
             */
            silent: false,
            /**
             * Show production mode tip message on boot?
             */
            productionTip: "development" !== 'production',
            /**
             * Whether to enable devtools
             */
            devtools: "development" !== 'production',
            /**
             * Whether to record perf
             */
            performance: false,
            /**
             * Error handler for watcher errors
             */
            errorHandler: null,
            /**
             * Warn handler for watcher warns
             */
            warnHandler: null,
            /**
             * Ignore certain custom elements
             */
            ignoredElements: [],
            /**
             * Custom user key aliases for v-on
             */
            // $flow-disable-line
            keyCodes: Object.create(null),
            /**
             * Check if a tag is reserved so that it cannot be registered as a
             * component. This is platform-dependent and may be overwritten.
             */
            isReservedTag: no,
            /**
             * Check if an attribute is reserved so that it cannot be used as a component
             * prop. This is platform-dependent and may be overwritten.
             */
            isReservedAttr: no,
            /**
             * Check if a tag is an unknown element.
             * Platform-dependent.
             */
            isUnknownElement: no,
            /**
             * Get the namespace of an element
             */
            getTagNamespace: noop,
            /**
             * Parse the real tag name for the specific platform.
             */
            parsePlatformTagName: identity,
            /**
             * Check if an attribute must be bound using property, e.g. value
             * Platform-dependent.
             */
            mustUseProp: no,
            /**
             * Perform updates asynchronously. Intended to be used by Vue Test Utils
             * This will significantly reduce performance if set to false.
             */
            async: true,
            /**
             * Exposed for legacy reasons
             */
            _lifecycleHooks: LIFECYCLE_HOOKS
        };
        /*  */
        var warn = noop;
        var tip = noop;
        var generateComponentTrace = noop; // work around flow check
        var formatComponentName = noop;
        {
            var hasConsole = typeof console !== 'undefined';
            var classifyRE = /(?:^|[-_])(\w)/g;
            var classify = function (str) {
                return str.replace(classifyRE, function (c) {
                    return c.toUpperCase();
                }).replace(/[-_]/g, '');
            };
            warn = function (msg, vm) {
                var trace = vm ? generateComponentTrace(vm) : '';
                if (hasConsole && !config.silent) {
                    console.error("[Vue warn]: " + msg + trace);
                }
            };
            tip = function (msg, vm) {
                if (hasConsole && !config.silent) {
                    console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
                }
            };
            formatComponentName = function (vm, includeFile) {
                if (vm.$root === vm) {
                    return '<Root>';
                }
                var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm;
                var name = options.name || options._componentTag;
                var file = options.__file;
                if (!name && file) {
                    var match = file.match(/([^/\\]+)\.vue$/);
                    name = match && match[1];
                }
                return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
            };
            var repeat = function (str, n) {
                var res = '';
                while (n) {
                    if (n % 2 === 1) {
                        res += str;
                    }
                    if (n > 1) {
                        str += str;
                    }
                    n >>= 1;
                }
                return res;
            };
            generateComponentTrace = function (vm) {
                if (vm._isVue && vm.$parent) {
                    var tree = [];
                    var currentRecursiveSequence = 0;
                    while (vm) {
                        if (tree.length > 0) {
                            var last = tree[tree.length - 1];
                            if (last.constructor === vm.constructor) {
                                currentRecursiveSequence++;
                                vm = vm.$parent;
                                continue;
                            }
                            else if (currentRecursiveSequence > 0) {
                                tree[tree.length - 1] = [last, currentRecursiveSequence];
                                currentRecursiveSequence = 0;
                            }
                        }
                        tree.push(vm);
                        vm = vm.$parent;
                    }
                    return '\n\nfound in\n\n' + tree.map(function (vm, i) {
                        return "" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
                    }).join('\n');
                }
                else {
                    return "\n\n(found in " + formatComponentName(vm) + ")";
                }
            };
        }
        /*  */
        var uid = 0;
        /**
         * A dep is an observable that can have multiple
         * directives subscribing to it.
         */
        var Dep = function Dep() {
            this.id = uid++;
            this.subs = [];
        };
        Dep.prototype.addSub = function addSub(sub) {
            this.subs.push(sub);
        };
        Dep.prototype.removeSub = function removeSub(sub) {
            remove(this.subs, sub);
        };
        Dep.prototype.depend = function depend() {
            if (Dep.target) {
                Dep.target.addDep(this);
            }
        };
        Dep.prototype.notify = function notify() {
            // stabilize the subscriber list first
            var subs = this.subs.slice();
            for (var i = 0, l = subs.length; i < l; i++) {
                subs[i].update();
            }
        }; // The current target watcher being evaluated.
        // This is globally unique because only one watcher
        // can be evaluated at a time.
        Dep.target = null;
        var targetStack = [];
        function pushTarget(target) {
            targetStack.push(target);
            Dep.target = target;
        }
        function popTarget() {
            targetStack.pop();
            Dep.target = targetStack[targetStack.length - 1];
        }
        /*
         * not type checking this file because flow doesn't play well with
         * dynamically accessing methods on Array prototype
         */
        var arrayProto = Array.prototype;
        var arrayMethods = Object.create(arrayProto);
        var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];
        /**
         * Intercept mutating methods and emit events
         */
        methodsToPatch.forEach(function (method) {
            // cache original method
            var original = arrayProto[method];
            def(arrayMethods, method, function mutator() {
                var args = [], len = arguments.length;
                while (len--)
                    args[len] = arguments[len];
                var result = original.apply(this, args);
                var ob = this.__ob__;
                var inserted;
                switch (method) {
                    case 'push':
                    case 'unshift':
                        inserted = args;
                        break;
                    case 'splice':
                        inserted = args.slice(2);
                        break;
                }
                if (inserted) {
                    ob.observeArray(inserted);
                } // notify change
                ob.dep.notify();
                return result;
            });
        });
        /*  */
        var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
        /**
         * In some cases we may want to disable observation inside a component's
         * update computation.
         */
        var shouldObserve = true;
        function toggleObserving(value) {
            shouldObserve = value;
        }
        /**
         * Observer class that is attached to each observed
         * object. Once attached, the observer converts the target
         * object's property keys into getter/setters that
         * collect dependencies and dispatch updates.
         */
        var Observer = function Observer(value) {
            this.value = value;
            this.dep = new Dep();
            this.vmCount = 0;
            def(value, '__ob__', this);
            if (Array.isArray(value)) {
                if (hasProto) {
                    protoAugment(value, arrayMethods);
                }
                else {
                    copyAugment(value, arrayMethods, arrayKeys);
                }
                this.observeArray(value);
            }
            else {
                this.walk(value);
            }
        };
        /**
         * Walk through all properties and convert them into
         * getter/setters. This method should only be called when
         * value type is Object.
         */
        Observer.prototype.walk = function walk(obj) {
            var keys = Object.keys(obj);
            for (var i = 0; i < keys.length; i++) {
                defineReactive$$1(obj, keys[i]);
            }
        };
        /**
         * Observe a list of Array items.
         */
        Observer.prototype.observeArray = function observeArray(items) {
            for (var i = 0, l = items.length; i < l; i++) {
                observe(items[i]);
            }
        }; // helpers
        /**
         * Augment a target Object or Array by intercepting
         * the prototype chain using __proto__
         */
        function protoAugment(target, src) {
            /* eslint-disable no-proto */
            target.__proto__ = src;
            /* eslint-enable no-proto */
        }
        /**
         * Augment a target Object or Array by defining
         * hidden properties.
         */
        /* istanbul ignore next */
        function copyAugment(target, src, keys) {
            for (var i = 0, l = keys.length; i < l; i++) {
                var key = keys[i];
                def(target, key, src[key]);
            }
        }
        /**
         * Attempt to create an observer instance for a value,
         * returns the new observer if successfully observed,
         * or the existing observer if the value already has one.
         */
        function observe(value, asRootData) {
            if (!isObject(value) || value instanceof VNode) {
                return;
            }
            var ob;
            if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
                ob = value.__ob__;
            }
            else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
                ob = new Observer(value);
            }
            if (asRootData && ob) {
                ob.vmCount++;
            }
            return ob;
        }
        /**
         * Define a reactive property on an Object.
         */
        function defineReactive$$1(obj, key, val, customSetter, shallow) {
            var dep = new Dep();
            var property = Object.getOwnPropertyDescriptor(obj, key);
            if (property && property.configurable === false) {
                return;
            } // cater for pre-defined getter/setters
            var getter = property && property.get;
            var setter = property && property.set;
            if ((!getter || setter) && arguments.length === 2) {
                val = obj[key];
            }
            var childOb = !shallow && observe(val);
            Object.defineProperty(obj, key, {
                enumerable: true,
                configurable: true,
                get: function reactiveGetter() {
                    var value = getter ? getter.call(obj) : val;
                    if (Dep.target) {
                        dep.depend();
                        if (childOb) {
                            childOb.dep.depend();
                            if (Array.isArray(value)) {
                                dependArray(value);
                            }
                        }
                    }
                    return value;
                },
                set: function reactiveSetter(newVal) {
                    var value = getter ? getter.call(obj) : val;
                    /* eslint-disable no-self-compare */
                    if (newVal === value || newVal !== newVal && value !== value) {
                        return;
                    }
                    /* eslint-enable no-self-compare */
                    if (customSetter) {
                        customSetter();
                    } // #7981: for accessor properties without setter
                    if (getter && !setter) {
                        return;
                    }
                    if (setter) {
                        setter.call(obj, newVal);
                    }
                    else {
                        val = newVal;
                    }
                    childOb = !shallow && observe(newVal);
                    dep.notify();
                }
            });
        }
        /**
         * Set a property on an object. Adds the new property and
         * triggers change notification if the property doesn't
         * already exist.
         */
        function set(target, key, val) {
            if (isUndef(target) || isPrimitive(target)) {
                warn("Cannot set reactive property on undefined, null, or primitive value: " + target);
            }
            if (Array.isArray(target) && isValidArrayIndex(key)) {
                target.length = Math.max(target.length, key);
                target.splice(key, 1, val);
                return val;
            }
            if (key in target && !(key in Object.prototype)) {
                target[key] = val;
                return val;
            }
            var ob = target.__ob__;
            if (target._isVue || ob && ob.vmCount) {
                warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
                return val;
            }
            if (!ob) {
                target[key] = val;
                return val;
            }
            defineReactive$$1(ob.value, key, val);
            ob.dep.notify();
            return val;
        }
        /**
         * Collect dependencies on array elements when the array is touched, since
         * we cannot intercept array element access like property getters.
         */
        function dependArray(value) {
            for (var e = void 0, i = 0, l = value.length; i < l; i++) {
                e = value[i];
                e && e.__ob__ && e.__ob__.dep.depend();
                if (Array.isArray(e)) {
                    dependArray(e);
                }
            }
        }
        /*  */
        /**
         * Option overwriting strategies are functions that handle
         * how to merge a parent option value and a child option
         * value into the final value.
         */
        var strats = config.optionMergeStrategies;
        /**
         * Options with restrictions
         */
        {
            strats.el = strats.propsData = function (parent, child, vm, key) {
                if (!vm) {
                    warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
                }
                return defaultStrat(parent, child);
            };
        }
        /**
         * Helper that recursively merges two data objects together.
         */
        function mergeData(to, from) {
            if (!from) {
                return to;
            }
            var key, toVal, fromVal;
            var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from);
            for (var i = 0; i < keys.length; i++) {
                key = keys[i]; // in case the object is already observed...
                if (key === '__ob__') {
                    continue;
                }
                toVal = to[key];
                fromVal = from[key];
                if (!hasOwn(to, key)) {
                    set(to, key, fromVal);
                }
                else if (toVal !== fromVal && isPlainObject(toVal) && isPlainObject(fromVal)) {
                    mergeData(toVal, fromVal);
                }
            }
            return to;
        }
        /**
         * Data
         */
        function mergeDataOrFn(parentVal, childVal, vm) {
            if (!vm) {
                // in a Vue.extend merge, both should be functions
                if (!childVal) {
                    return parentVal;
                }
                if (!parentVal) {
                    return childVal;
                } // when parentVal & childVal are both present,
                // we need to return a function that returns the
                // merged result of both functions... no need to
                // check if parentVal is a function here because
                // it has to be a function to pass previous merges.
                return function mergedDataFn() {
                    return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);
                };
            }
            else {
                return function mergedInstanceDataFn() {
                    // instance merge
                    var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;
                    var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;
                    if (instanceData) {
                        return mergeData(instanceData, defaultData);
                    }
                    else {
                        return defaultData;
                    }
                };
            }
        }
        strats.data = function (parentVal, childVal, vm) {
            if (!vm) {
                if (childVal && typeof childVal !== 'function') {
                    warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
                    return parentVal;
                }
                return mergeDataOrFn(parentVal, childVal);
            }
            return mergeDataOrFn(parentVal, childVal, vm);
        };
        /**
         * Hooks and props are merged as arrays.
         */
        function mergeHook(parentVal, childVal) {
            var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
            return res ? dedupeHooks(res) : res;
        }
        function dedupeHooks(hooks) {
            var res = [];
            for (var i = 0; i < hooks.length; i++) {
                if (res.indexOf(hooks[i]) === -1) {
                    res.push(hooks[i]);
                }
            }
            return res;
        }
        LIFECYCLE_HOOKS.forEach(function (hook) {
            strats[hook] = mergeHook;
        });
        /**
         * Assets
         *
         * When a vm is present (instance creation), we need to do
         * a three-way merge between constructor options, instance
         * options and parent options.
         */
        function mergeAssets(parentVal, childVal, vm, key) {
            var res = Object.create(parentVal || null);
            if (childVal) {
                assertObjectType(key, childVal, vm);
                return extend(res, childVal);
            }
            else {
                return res;
            }
        }
        ASSET_TYPES.forEach(function (type) {
            strats[type + 's'] = mergeAssets;
        });
        /**
         * Watchers.
         *
         * Watchers hashes should not overwrite one
         * another, so we merge them as arrays.
         */
        strats.watch = function (parentVal, childVal, vm, key) {
            // work around Firefox's Object.prototype.watch...
            if (parentVal === nativeWatch) {
                parentVal = undefined;
            }
            if (childVal === nativeWatch) {
                childVal = undefined;
            }
            /* istanbul ignore if */
            if (!childVal) {
                return Object.create(parentVal || null);
            }
            {
                assertObjectType(key, childVal, vm);
            }
            if (!parentVal) {
                return childVal;
            }
            var ret = {};
            extend(ret, parentVal);
            for (var key$1 in childVal) {
                var parent = ret[key$1];
                var child = childVal[key$1];
                if (parent && !Array.isArray(parent)) {
                    parent = [parent];
                }
                ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
            }
            return ret;
        };
        /**
         * Other object hashes.
         */
        strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
            if (childVal && "development" !== 'production') {
                assertObjectType(key, childVal, vm);
            }
            if (!parentVal) {
                return childVal;
            }
            var ret = Object.create(null);
            extend(ret, parentVal);
            if (childVal) {
                extend(ret, childVal);
            }
            return ret;
        };
        strats.provide = mergeDataOrFn;
        /**
         * Default strategy.
         */
        var defaultStrat = function (parentVal, childVal) {
            return childVal === undefined ? parentVal : childVal;
        };
        /**
         * Validate component names
         */
        function checkComponents(options) {
            for (var key in options.components) {
                validateComponentName(key);
            }
        }
        function validateComponentName(name) {
            if (!new RegExp("^[a-zA-Z][\\-\\.0-9_" + unicodeRegExp.source + "]*$").test(name)) {
                warn('Invalid component name: "' + name + '". Component names ' + 'should conform to valid custom element name in html5 specification.');
            }
            if (isBuiltInTag(name) || config.isReservedTag(name)) {
                warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);
            }
        }
        /**
         * Ensure all props option syntax are normalized into the
         * Object-based format.
         */
        function normalizeProps(options, vm) {
            var props = options.props;
            if (!props) {
                return;
            }
            var res = {};
            var i, val, name;
            if (Array.isArray(props)) {
                i = props.length;
                while (i--) {
                    val = props[i];
                    if (typeof val === 'string') {
                        name = camelize(val);
                        res[name] = {
                            type: null
                        };
                    }
                    else {
                        warn('props must be strings when using array syntax.');
                    }
                }
            }
            else if (isPlainObject(props)) {
                for (var key in props) {
                    val = props[key];
                    name = camelize(key);
                    res[name] = isPlainObject(val) ? val : {
                        type: val
                    };
                }
            }
            else {
                warn("Invalid value for option \"props\": expected an Array or an Object, " + "but got " + toRawType(props) + ".", vm);
            }
            options.props = res;
        }
        /**
         * Normalize all injections into Object-based format
         */
        function normalizeInject(options, vm) {
            var inject = options.inject;
            if (!inject) {
                return;
            }
            var normalized = options.inject = {};
            if (Array.isArray(inject)) {
                for (var i = 0; i < inject.length; i++) {
                    normalized[inject[i]] = {
                        from: inject[i]
                    };
                }
            }
            else if (isPlainObject(inject)) {
                for (var key in inject) {
                    var val = inject[key];
                    normalized[key] = isPlainObject(val) ? extend({
                        from: key
                    }, val) : {
                        from: val
                    };
                }
            }
            else {
                warn("Invalid value for option \"inject\": expected an Array or an Object, " + "but got " + toRawType(inject) + ".", vm);
            }
        }
        /**
         * Normalize raw function directives into object format.
         */
        function normalizeDirectives(options) {
            var dirs = options.directives;
            if (dirs) {
                for (var key in dirs) {
                    var def$$1 = dirs[key];
                    if (typeof def$$1 === 'function') {
                        dirs[key] = {
                            bind: def$$1,
                            update: def$$1
                        };
                    }
                }
            }
        }
        function assertObjectType(name, value, vm) {
            if (!isPlainObject(value)) {
                warn("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
            }
        }
        /**
         * Merge two option objects into a new one.
         * Core utility used in both instantiation and inheritance.
         */
        function mergeOptions(parent, child, vm) {
            {
                checkComponents(child);
            }
            if (typeof child === 'function') {
                child = child.options;
            }
            normalizeProps(child, vm);
            normalizeInject(child, vm);
            normalizeDirectives(child); // Apply extends and mixins on the child options,
            // but only if it is a raw options object that isn't
            // the result of another mergeOptions call.
            // Only merged options has the _base property.
            if (!child._base) {
                if (child.extends) {
                    parent = mergeOptions(parent, child.extends, vm);
                }
                if (child.mixins) {
                    for (var i = 0, l = child.mixins.length; i < l; i++) {
                        parent = mergeOptions(parent, child.mixins[i], vm);
                    }
                }
            }
            var options = {};
            var key;
            for (key in parent) {
                mergeField(key);
            }
            for (key in child) {
                if (!hasOwn(parent, key)) {
                    mergeField(key);
                }
            }
            function mergeField(key) {
                var strat = strats[key] || defaultStrat;
                options[key] = strat(parent[key], child[key], vm, key);
            }
            return options;
        }
        /**
         * Resolve an asset.
         * This function is used because child instances need access
         * to assets defined in its ancestor chain.
         */
        function resolveAsset(options, type, id, warnMissing) {
            /* istanbul ignore if */
            if (typeof id !== 'string') {
                return;
            }
            var assets = options[type]; // check local registration variations first
            if (hasOwn(assets, id)) {
                return assets[id];
            }
            var camelizedId = camelize(id);
            if (hasOwn(assets, camelizedId)) {
                return assets[camelizedId];
            }
            var PascalCaseId = capitalize(camelizedId);
            if (hasOwn(assets, PascalCaseId)) {
                return assets[PascalCaseId];
            } // fallback to prototype chain
            var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
            if (warnMissing && !res) {
                warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
            }
            return res;
        }
        /*  */
        function validateProp(key, propOptions, propsData, vm) {
            var prop = propOptions[key];
            var absent = !hasOwn(propsData, key);
            var value = propsData[key]; // boolean casting
            var booleanIndex = getTypeIndex(Boolean, prop.type);
            if (booleanIndex > -1) {
                if (absent && !hasOwn(prop, 'default')) {
                    value = false;
                }
                else if (value === '' || value === hyphenate(key)) {
                    // only cast empty string / same name to boolean if
                    // boolean has higher priority
                    var stringIndex = getTypeIndex(String, prop.type);
                    if (stringIndex < 0 || booleanIndex < stringIndex) {
                        value = true;
                    }
                }
            } // check default value
            if (value === undefined) {
                value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,
                // make sure to observe it.
                var prevShouldObserve = shouldObserve;
                toggleObserving(true);
                observe(value);
                toggleObserving(prevShouldObserve);
            }
            {
                assertProp(prop, key, value, vm, absent);
            }
            return value;
        }
        /**
         * Get the default value of a prop.
         */
        function getPropDefaultValue(vm, prop, key) {
            // no default, return undefined
            if (!hasOwn(prop, 'default')) {
                return undefined;
            }
            var def = prop.default; // warn against non-factory defaults for Object & Array
            if (isObject(def)) {
                warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
            } // the raw prop value was also undefined from previous render,
            // return previous default value to avoid unnecessary watcher trigger
            if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
                return vm._props[key];
            } // call factory function for non-Function types
            // a value is Function if its prototype is function even across different execution context
            return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
        }
        /**
         * Assert whether a prop is valid.
         */
        function assertProp(prop, name, value, vm, absent) {
            if (prop.required && absent) {
                warn('Missing required prop: "' + name + '"', vm);
                return;
            }
            if (value == null && !prop.required) {
                return;
            }
            var type = prop.type;
            var valid = !type || type === true;
            var expectedTypes = [];
            if (type) {
                if (!Array.isArray(type)) {
                    type = [type];
                }
                for (var i = 0; i < type.length && !valid; i++) {
                    var assertedType = assertType(value, type[i]);
                    expectedTypes.push(assertedType.expectedType || '');
                    valid = assertedType.valid;
                }
            }
            if (!valid) {
                warn(getInvalidTypeMessage(name, value, expectedTypes), vm);
                return;
            }
            var validator = prop.validator;
            if (validator) {
                if (!validator(value)) {
                    warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
                }
            }
        }
        var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;
        function assertType(value, type) {
            var valid;
            var expectedType = getType(type);
            if (simpleCheckRE.test(expectedType)) {
                var t = typeof value;
                valid = t === expectedType.toLowerCase(); // for primitive wrapper objects
                if (!valid && t === 'object') {
                    valid = value instanceof type;
                }
            }
            else if (expectedType === 'Object') {
                valid = isPlainObject(value);
            }
            else if (expectedType === 'Array') {
                valid = Array.isArray(value);
            }
            else {
                valid = value instanceof type;
            }
            return {
                valid: valid,
                expectedType: expectedType
            };
        }
        /**
         * Use function string name to check built-in types,
         * because a simple equality check will fail when running
         * across different vms / iframes.
         */
        function getType(fn) {
            var match = fn && fn.toString().match(/^\s*function (\w+)/);
            return match ? match[1] : '';
        }
        function isSameType(a, b) {
            return getType(a) === getType(b);
        }
        function getTypeIndex(type, expectedTypes) {
            if (!Array.isArray(expectedTypes)) {
                return isSameType(expectedTypes, type) ? 0 : -1;
            }
            for (var i = 0, len = expectedTypes.length; i < len; i++) {
                if (isSameType(expectedTypes[i], type)) {
                    return i;
                }
            }
            return -1;
        }
        function getInvalidTypeMessage(name, value, expectedTypes) {
            var message = "Invalid prop: type check failed for prop \"" + name + "\"." + " Expected " + expectedTypes.map(capitalize).join(', ');
            var expectedType = expectedTypes[0];
            var receivedType = toRawType(value);
            var expectedValue = styleValue(value, expectedType);
            var receivedValue = styleValue(value, receivedType); // check if we need to specify expected value
            if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
                message += " with value " + expectedValue;
            }
            message += ", got " + receivedType + " "; // check if we need to specify received value
            if (isExplicable(receivedType)) {
                message += "with value " + receivedValue + ".";
            }
            return message;
        }
        function styleValue(value, type) {
            if (type === 'String') {
                return "\"" + value + "\"";
            }
            else if (type === 'Number') {
                return "" + Number(value);
            }
            else {
                return "" + value;
            }
        }
        function isExplicable(value) {
            var explicitTypes = ['string', 'number', 'boolean'];
            return explicitTypes.some(function (elem) {
                return value.toLowerCase() === elem;
            });
        }
        function isBoolean() {
            var args = [], len = arguments.length;
            while (len--)
                args[len] = arguments[len];
            return args.some(function (elem) {
                return elem.toLowerCase() === 'boolean';
            });
        }
        /*  */
        function handleError(err, vm, info) {
            // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
            // See: https://github.com/vuejs/vuex/issues/1505
            pushTarget();
            try {
                if (vm) {
                    var cur = vm;
                    while (cur = cur.$parent) {
                        var hooks = cur.$options.errorCaptured;
                        if (hooks) {
                            for (var i = 0; i < hooks.length; i++) {
                                try {
                                    var capture = hooks[i].call(cur, err, vm, info) === false;
                                    if (capture) {
                                        return;
                                    }
                                }
                                catch (e) {
                                    globalHandleError(e, cur, 'errorCaptured hook');
                                }
                            }
                        }
                    }
                }
                globalHandleError(err, vm, info);
            }
            finally {
                popTarget();
            }
        }
        function invokeWithErrorHandling(handler, context, args, vm, info) {
            var res;
            try {
                res = args ? handler.apply(context, args) : handler.call(context);
                if (res && !res._isVue && isPromise(res) && !res._handled) {
                    res.catch(function (e) {
                        return handleError(e, vm, info + " (Promise/async)");
                    }); // issue #9511
                    // avoid catch triggering multiple times when nested calls
                    res._handled = true;
                }
            }
            catch (e) {
                handleError(e, vm, info);
            }
            return res;
        }
        function globalHandleError(err, vm, info) {
            logError(err, vm, info);
        }
        function logError(err, vm, info) {
            {
                warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
            }
            /* istanbul ignore else */
            if ((inBrowser || inWeex) && typeof console !== 'undefined') {
                console.error(err);
            }
            else {
                throw err;
            }
        }
        /*  */
        var callbacks = [];
        function flushCallbacks() {
            var copies = callbacks.slice(0);
            callbacks.length = 0;
            for (var i = 0; i < copies.length; i++) {
                copies[i]();
            }
        } // The nextTick behavior leverages the microtask queue, which can be accessed
        // via either native Promise.then or MutationObserver.
        // MutationObserver has wider support, however it is seriously bugged in
        // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
        // completely stops working after triggering a few times... so, if native
        // Promise is available, we will use it:
        /* istanbul ignore next, $flow-disable-line */
        if (typeof Promise !== 'undefined' && isNative(Promise))
            ;
        else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) || // PhantomJS and iOS 7.x
            MutationObserver.toString() === '[object MutationObserverConstructor]')) {
            // Use MutationObserver where native Promise is not available,
            // e.g. PhantomJS, iOS7, Android 4.4
            // (#6466 MutationObserver is unreliable in IE11)
            var counter = 1;
            var observer = new MutationObserver(flushCallbacks);
            var textNode = document.createTextNode(String(counter));
            observer.observe(textNode, {
                characterData: true
            });
        }
        else if (typeof setImmediate !== 'undefined' && isNative(setImmediate))
            ;
        /*  */
        /*  */
        function genClassForVnode(vnode) {
            var data = vnode.data;
            var parentNode = vnode;
            var childNode = vnode;
            while (isDef(childNode.componentInstance)) {
                childNode = childNode.componentInstance._vnode;
                if (childNode && childNode.data) {
                    data = mergeClassData(childNode.data, data);
                }
            }
            while (isDef(parentNode = parentNode.parent)) {
                if (parentNode && parentNode.data) {
                    data = mergeClassData(data, parentNode.data);
                }
            }
            return renderClass(data.staticClass, data.class);
        }
        function mergeClassData(child, parent) {
            return {
                staticClass: concat(child.staticClass, parent.staticClass),
                class: isDef(child.class) ? [child.class, parent.class] : parent.class
            };
        }
        function renderClass(staticClass, dynamicClass) {
            if (isDef(staticClass) || isDef(dynamicClass)) {
                return concat(staticClass, stringifyClass(dynamicClass));
            }
            /* istanbul ignore next */
            return '';
        }
        function concat(a, b) {
            return a ? b ? a + ' ' + b : a : b || '';
        }
        function stringifyClass(value) {
            if (Array.isArray(value)) {
                return stringifyArray(value);
            }
            if (isObject(value)) {
                return stringifyObject(value);
            }
            if (typeof value === 'string') {
                return value;
            }
            /* istanbul ignore next */
            return '';
        }
        function stringifyArray(value) {
            var res = '';
            var stringified;
            for (var i = 0, l = value.length; i < l; i++) {
                if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
                    if (res) {
                        res += ' ';
                    }
                    res += stringified;
                }
            }
            return res;
        }
        function stringifyObject(value) {
            var res = '';
            for (var key in value) {
                if (value[key]) {
                    if (res) {
                        res += ' ';
                    }
                    res += key;
                }
            }
            return res;
        }
        /*  */
        var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may
        // contain child elements.
        var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);
        var isPreTag = function (tag) {
            return tag === 'pre';
        };
        var isReservedTag = function (tag) {
            return isHTMLTag(tag) || isSVG(tag);
        };
        function getTagNamespace(tag) {
            if (isSVG(tag)) {
                return 'svg';
            } // basic support for MathML
            // note it doesn't support other MathML elements being component roots
            if (tag === 'math') {
                return 'math';
            }
        }
        var isTextInputType = makeMap('text,number,password,search,email,tel,url');
        /*  */
        /*  */
        function renderClass$1(node) {
            var classList = genClassForVnode(node);
            if (classList !== '') {
                return " class=\"" + escape(classList) + "\"";
            }
        }
        /*  */
        var parseStyleText = cached(function (cssText) {
            var res = {};
            var listDelimiter = /;(?![^(]*\))/g;
            var propertyDelimiter = /:(.+)/;
            cssText.split(listDelimiter).forEach(function (item) {
                if (item) {
                    var tmp = item.split(propertyDelimiter);
                    tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
                }
            });
            return res;
        }); // merge static and dynamic style data on the same vnode
        function normalizeStyleData(data) {
            var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation
            // and is always a fresh object, so it's safe to merge into it
            return data.staticStyle ? extend(data.staticStyle, style) : style;
        } // normalize possible array / string values into Object
        function normalizeStyleBinding(bindingStyle) {
            if (Array.isArray(bindingStyle)) {
                return toObject(bindingStyle);
            }
            if (typeof bindingStyle === 'string') {
                return parseStyleText(bindingStyle);
            }
            return bindingStyle;
        }
        /**
         * parent component style should be after child's
         * so that parent component's style could override it
         */
        function getStyle(vnode, checkChild) {
            var res = {};
            var styleData;
            if (checkChild) {
                var childNode = vnode;
                while (childNode.componentInstance) {
                    childNode = childNode.componentInstance._vnode;
                    if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
                        extend(res, styleData);
                    }
                }
            }
            if (styleData = normalizeStyleData(vnode.data)) {
                extend(res, styleData);
            }
            var parentNode = vnode;
            while (parentNode = parentNode.parent) {
                if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
                    extend(res, styleData);
                }
            }
            return res;
        }
        /*  */
        function genStyle(style) {
            var styleText = '';
            for (var key in style) {
                var value = style[key];
                var hyphenatedKey = hyphenate(key);
                if (Array.isArray(value)) {
                    for (var i = 0, len = value.length; i < len; i++) {
                        styleText += normalizeValue(hyphenatedKey, value[i]);
                    }
                }
                else {
                    styleText += normalizeValue(hyphenatedKey, value);
                }
            }
            return styleText;
        }
        function normalizeValue(key, value) {
            if (typeof value === 'string' || typeof value === 'number' && noUnitNumericStyleProps[key] || value === 0) {
                return key + ":" + value + ";";
            }
            else {
                // invalid values
                return "";
            }
        }
        function renderStyle(vnode) {
            var styleText = genStyle(getStyle(vnode, false));
            if (styleText !== '') {
                return " style=" + JSON.stringify(escape(styleText));
            }
        }
        var modules = [renderAttrs, renderDOMProps, renderClass$1, renderStyle];
        /*  */
        function show(node, dir) {
            if (!dir.value) {
                var style = node.data.style || (node.data.style = {});
                if (Array.isArray(style)) {
                    style.push({
                        display: 'none'
                    });
                }
                else {
                    style.display = 'none';
                }
            }
        }
        /*  */
        // this is only applied for <select v-model> because it is the only edge case
        // that must be done at runtime instead of compile time.
        function model(node, dir) {
            if (!node.children) {
                return;
            }
            var value = dir.value;
            var isMultiple = node.data.attrs && node.data.attrs.multiple;
            for (var i = 0, l = node.children.length; i < l; i++) {
                var option = node.children[i];
                if (option.tag === 'option') {
                    if (isMultiple) {
                        var selected = Array.isArray(value) && looseIndexOf(value, getValue(option)) > -1;
                        if (selected) {
                            setSelected(option);
                        }
                    }
                    else {
                        if (looseEqual(value, getValue(option))) {
                            setSelected(option);
                            return;
                        }
                    }
                }
            }
        }
        function getValue(option) {
            var data = option.data || {};
            return data.attrs && data.attrs.value || data.domProps && data.domProps.value || option.children && option.children[0] && option.children[0].text;
        }
        function setSelected(option) {
            var data = option.data || (option.data = {});
            var attrs = data.attrs || (data.attrs = {});
            attrs.selected = '';
        }
        var baseDirectives = {
            show: show,
            model: model
        };
        /*  */
        var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr'); // Elements that you can, intentionally, leave open
        // (and which close themselves)
        var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'); // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
        // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
        var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');
        /*  */
        var MAX_STACK_DEPTH = 800;
        var noop$1 = function (_) {
            return _;
        };
        var defer = typeof process !== 'undefined' && process.nextTick ? process.nextTick : typeof Promise !== 'undefined' ? function (fn) {
            return Promise.resolve().then(fn);
        } : typeof setTimeout !== 'undefined' ? setTimeout : noop$1;
        if (defer === noop$1) {
            throw new Error('Your JavaScript runtime does not support any asynchronous primitives ' + 'that are required by vue-server-renderer. Please use a polyfill for ' + 'either Promise or setTimeout.');
        }
        function createWriteFunction(write, onError) {
            var stackDepth = 0;
            var cachedWrite = function (text, next) {
                if (text && cachedWrite.caching) {
                    cachedWrite.cacheBuffer[cachedWrite.cacheBuffer.length - 1] += text;
                }
                var waitForNext = write(text, next);
                if (waitForNext !== true) {
                    if (stackDepth >= MAX_STACK_DEPTH) {
                        defer(function () {
                            try {
                                next();
                            }
                            catch (e) {
                                onError(e);
                            }
                        });
                    }
                    else {
                        stackDepth++;
                        next();
                        stackDepth--;
                    }
                }
            };
            cachedWrite.caching = false;
            cachedWrite.cacheBuffer = [];
            cachedWrite.componentBuffer = [];
            return cachedWrite;
        }
        /*  */
        /**
         * Original RenderStream implementation by Sasha Aickin (@aickin)
         * Licensed under the Apache License, Version 2.0
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Modified by Evan You (@yyx990803)
         */
        var stream = stream_js_3.default;
        var RenderStream = 
        /*@__PURE__*/
        function (superclass) {
            function RenderStream(render) {
                var this$1 = this;
                superclass.call(this);
                this.buffer = '';
                this.render = render;
                this.expectedSize = 0;
                this.write = createWriteFunction(function (text, next) {
                    var n = this$1.expectedSize;
                    this$1.buffer += text;
                    if (this$1.buffer.length >= n) {
                        this$1.next = next;
                        this$1.pushBySize(n);
                        return true; // we will decide when to call next
                    }
                    return false;
                }, function (err) {
                    this$1.emit('error', err);
                });
                this.end = function () {
                    this$1.emit('beforeEnd'); // the rendering is finished; we should push out the last of the buffer.
                    this$1.done = true;
                    this$1.push(this$1.buffer);
                };
            }
            if (superclass)
                RenderStream.__proto__ = superclass;
            RenderStream.prototype = Object.create(superclass && superclass.prototype);
            RenderStream.prototype.constructor = RenderStream;
            RenderStream.prototype.pushBySize = function pushBySize(n) {
                var bufferToPush = this.buffer.substring(0, n);
                this.buffer = this.buffer.substring(n);
                this.push(bufferToPush);
            };
            RenderStream.prototype.tryRender = function tryRender() {
                try {
                    this.render(this.write, this.end);
                }
                catch (e) {
                    this.emit('error', e);
                }
            };
            RenderStream.prototype.tryNext = function tryNext() {
                try {
                    this.next();
                }
                catch (e) {
                    this.emit('error', e);
                }
            };
            RenderStream.prototype._read = function _read(n) {
                this.expectedSize = n; // it's possible that the last chunk added bumped the buffer up to > 2 * n,
                // which means we will need to go through multiple read calls to drain it
                // down to < n.
                if (isTrue(this.done)) {
                    this.push(null);
                    return;
                }
                if (this.buffer.length >= n) {
                    this.pushBySize(n);
                    return;
                }
                if (isUndef(this.next)) {
                    // start the rendering chain.
                    this.tryRender();
                }
                else {
                    // continue with the rendering.
                    this.tryNext();
                }
            };
            return RenderStream;
        }(stream.Readable);
        /*  */
        var RenderContext = function RenderContext(options) {
            this.userContext = options.userContext;
            this.activeInstance = options.activeInstance;
            this.renderStates = [];
            this.write = options.write;
            this.done = options.done;
            this.renderNode = options.renderNode;
            this.isUnaryTag = options.isUnaryTag;
            this.modules = options.modules;
            this.directives = options.directives;
            var cache = options.cache;
            if (cache && (!cache.get || !cache.set)) {
                throw new Error('renderer cache must implement at least get & set.');
            }
            this.cache = cache;
            this.get = cache && normalizeAsync(cache, 'get');
            this.has = cache && normalizeAsync(cache, 'has');
            this.next = this.next.bind(this);
        };
        RenderContext.prototype.next = function next() {
            // eslint-disable-next-line
            while (true) {
                var lastState = this.renderStates[this.renderStates.length - 1];
                if (isUndef(lastState)) {
                    return this.done();
                }
                /* eslint-disable no-case-declarations */
                switch (lastState.type) {
                    case 'Element':
                    case 'Fragment':
                        var children = lastState.children;
                        var total = lastState.total;
                        var rendered = lastState.rendered++;
                        if (rendered < total) {
                            return this.renderNode(children[rendered], false, this);
                        }
                        else {
                            this.renderStates.pop();
                            if (lastState.type === 'Element') {
                                return this.write(lastState.endTag, this.next);
                            }
                        }
                        break;
                    case 'Component':
                        this.renderStates.pop();
                        this.activeInstance = lastState.prevActive;
                        break;
                    case 'ComponentWithCache':
                        this.renderStates.pop();
                        var buffer = lastState.buffer;
                        var bufferIndex = lastState.bufferIndex;
                        var componentBuffer = lastState.componentBuffer;
                        var key = lastState.key;
                        var result = {
                            html: buffer[bufferIndex],
                            components: componentBuffer[bufferIndex]
                        };
                        this.cache.set(key, result);
                        if (bufferIndex === 0) {
                            // this is a top-level cached component,
                            // exit caching mode.
                            this.write.caching = false;
                        }
                        else {
                            // parent component is also being cached,
                            // merge self into parent's result
                            buffer[bufferIndex - 1] += result.html;
                            var prev = componentBuffer[bufferIndex - 1];
                            result.components.forEach(function (c) {
                                return prev.add(c);
                            });
                        }
                        buffer.length = bufferIndex;
                        componentBuffer.length = bufferIndex;
                        break;
                }
            }
        };
        function normalizeAsync(cache, method) {
            var fn = cache[method];
            if (isUndef(fn)) {
                return;
            }
            else if (fn.length > 1) {
                return function (key, cb) {
                    return fn.call(cache, key, cb);
                };
            }
            else {
                return function (key, cb) {
                    return cb(fn.call(cache, key));
                };
            }
        }
        /*  */
        var validDivisionCharRE = /[\w).+\-_$\]]/;
        function parseFilters(exp) {
            var inSingle = false;
            var inDouble = false;
            var inTemplateString = false;
            var inRegex = false;
            var curly = 0;
            var square = 0;
            var paren = 0;
            var lastFilterIndex = 0;
            var c, prev, i, expression, filters;
            for (i = 0; i < exp.length; i++) {
                prev = c;
                c = exp.charCodeAt(i);
                if (inSingle) {
                    if (c === 0x27 && prev !== 0x5C) {
                        inSingle = false;
                    }
                }
                else if (inDouble) {
                    if (c === 0x22 && prev !== 0x5C) {
                        inDouble = false;
                    }
                }
                else if (inTemplateString) {
                    if (c === 0x60 && prev !== 0x5C) {
                        inTemplateString = false;
                    }
                }
                else if (inRegex) {
                    if (c === 0x2f && prev !== 0x5C) {
                        inRegex = false;
                    }
                }
                else if (c === 0x7C && // pipe
                    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
                    if (expression === undefined) {
                        // first filter, end of expression
                        lastFilterIndex = i + 1;
                        expression = exp.slice(0, i).trim();
                    }
                    else {
                        pushFilter();
                    }
                }
                else {
                    switch (c) {
                        case 0x22:
                            inDouble = true;
                            break;
                        // "
                        case 0x27:
                            inSingle = true;
                            break;
                        // '
                        case 0x60:
                            inTemplateString = true;
                            break;
                        // `
                        case 0x28:
                            paren++;
                            break;
                        // (
                        case 0x29:
                            paren--;
                            break;
                        // )
                        case 0x5B:
                            square++;
                            break;
                        // [
                        case 0x5D:
                            square--;
                            break;
                        // ]
                        case 0x7B:
                            curly++;
                            break;
                        // {
                        case 0x7D:
                            curly--;
                            break;
                        // }
                    }
                    if (c === 0x2f) {
                        // /
                        var j = i - 1;
                        var p = void 0; // find first non-whitespace prev char
                        for (; j >= 0; j--) {
                            p = exp.charAt(j);
                            if (p !== ' ') {
                                break;
                            }
                        }
                        if (!p || !validDivisionCharRE.test(p)) {
                            inRegex = true;
                        }
                    }
                }
            }
            if (expression === undefined) {
                expression = exp.slice(0, i).trim();
            }
            else if (lastFilterIndex !== 0) {
                pushFilter();
            }
            function pushFilter() {
                (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
                lastFilterIndex = i + 1;
            }
            if (filters) {
                for (i = 0; i < filters.length; i++) {
                    expression = wrapFilter(expression, filters[i]);
                }
            }
            return expression;
        }
        function wrapFilter(exp, filter) {
            var i = filter.indexOf('(');
            if (i < 0) {
                // _f: resolveFilter
                return "_f(\"" + filter + "\")(" + exp + ")";
            }
            else {
                var name = filter.slice(0, i);
                var args = filter.slice(i + 1);
                return "_f(\"" + name + "\")(" + exp + (args !== ')' ? ',' + args : args);
            }
        }
        /*  */
        var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;
        var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
        var buildRegex = cached(function (delimiters) {
            var open = delimiters[0].replace(regexEscapeRE, '\\$&');
            var close = delimiters[1].replace(regexEscapeRE, '\\$&');
            return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
        });
        function parseText(text, delimiters) {
            var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
            if (!tagRE.test(text)) {
                return;
            }
            var tokens = [];
            var rawTokens = [];
            var lastIndex = tagRE.lastIndex = 0;
            var match, index, tokenValue;
            while (match = tagRE.exec(text)) {
                index = match.index; // push text token
                if (index > lastIndex) {
                    rawTokens.push(tokenValue = text.slice(lastIndex, index));
                    tokens.push(JSON.stringify(tokenValue));
                } // tag token
                var exp = parseFilters(match[1].trim());
                tokens.push("_s(" + exp + ")");
                rawTokens.push({
                    '@binding': exp
                });
                lastIndex = index + match[0].length;
            }
            if (lastIndex < text.length) {
                rawTokens.push(tokenValue = text.slice(lastIndex));
                tokens.push(JSON.stringify(tokenValue));
            }
            return {
                expression: tokens.join('+'),
                tokens: rawTokens
            };
        }
        /*  */
        /* eslint-disable no-unused-vars */
        function baseWarn(msg, range) {
            console.error("[Vue compiler]: " + msg);
        }
        /* eslint-enable no-unused-vars */
        function pluckModuleFunction(modules, key) {
            return modules ? modules.map(function (m) {
                return m[key];
            }).filter(function (_) {
                return _;
            }) : [];
        }
        function addProp(el, name, value, range, dynamic) {
            (el.props || (el.props = [])).push(rangeSetItem({
                name: name,
                value: value,
                dynamic: dynamic
            }, range));
            el.plain = false;
        }
        function addAttr(el, name, value, range, dynamic) {
            var attrs = dynamic ? el.dynamicAttrs || (el.dynamicAttrs = []) : el.attrs || (el.attrs = []);
            attrs.push(rangeSetItem({
                name: name,
                value: value,
                dynamic: dynamic
            }, range));
            el.plain = false;
        } // add a raw attr (use this in preTransforms)
        function addRawAttr(el, name, value, range) {
            el.attrsMap[name] = value;
            el.attrsList.push(rangeSetItem({
                name: name,
                value: value
            }, range));
        }
        function addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {
            (el.directives || (el.directives = [])).push(rangeSetItem({
                name: name,
                rawName: rawName,
                value: value,
                arg: arg,
                isDynamicArg: isDynamicArg,
                modifiers: modifiers
            }, range));
            el.plain = false;
        }
        function prependModifierMarker(symbol, name, dynamic) {
            return dynamic ? "_p(" + name + ",\"" + symbol + "\")" : symbol + name; // mark the event as captured
        }
        function addHandler(el, name, value, modifiers, important, warn, range, dynamic) {
            modifiers = modifiers || emptyObject; // warn prevent and passive modifier
            /* istanbul ignore if */
            if (warn && modifiers.prevent && modifiers.passive) {
                warn('passive and prevent can\'t be used together. ' + 'Passive handler can\'t prevent default event.', range);
            } // normalize click.right and click.middle since they don't actually fire
            // this is technically browser-specific, but at least for now browsers are
            // the only target envs that have right/middle clicks.
            if (modifiers.right) {
                if (dynamic) {
                    name = "(" + name + ")==='click'?'contextmenu':(" + name + ")";
                }
                else if (name === 'click') {
                    name = 'contextmenu';
                    delete modifiers.right;
                }
            }
            else if (modifiers.middle) {
                if (dynamic) {
                    name = "(" + name + ")==='click'?'mouseup':(" + name + ")";
                }
                else if (name === 'click') {
                    name = 'mouseup';
                }
            } // check capture modifier
            if (modifiers.capture) {
                delete modifiers.capture;
                name = prependModifierMarker('!', name, dynamic);
            }
            if (modifiers.once) {
                delete modifiers.once;
                name = prependModifierMarker('~', name, dynamic);
            }
            /* istanbul ignore if */
            if (modifiers.passive) {
                delete modifiers.passive;
                name = prependModifierMarker('&', name, dynamic);
            }
            var events;
            if (modifiers.native) {
                delete modifiers.native;
                events = el.nativeEvents || (el.nativeEvents = {});
            }
            else {
                events = el.events || (el.events = {});
            }
            var newHandler = rangeSetItem({
                value: value.trim(),
                dynamic: dynamic
            }, range);
            if (modifiers !== emptyObject) {
                newHandler.modifiers = modifiers;
            }
            var handlers = events[name];
            /* istanbul ignore if */
            if (Array.isArray(handlers)) {
                important ? handlers.unshift(newHandler) : handlers.push(newHandler);
            }
            else if (handlers) {
                events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
            }
            else {
                events[name] = newHandler;
            }
            el.plain = false;
        }
        function getRawBindingAttr(el, name) {
            return el.rawAttrsMap[':' + name] || el.rawAttrsMap['v-bind:' + name] || el.rawAttrsMap[name];
        }
        function getBindingAttr(el, name, getStatic) {
            var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);
            if (dynamicValue != null) {
                return parseFilters(dynamicValue);
            }
            else if (getStatic !== false) {
                var staticValue = getAndRemoveAttr(el, name);
                if (staticValue != null) {
                    return JSON.stringify(staticValue);
                }
            }
        } // note: this only removes the attr from the Array (attrsList) so that it
        // doesn't get processed by processAttrs.
        // By default it does NOT remove it from the map (attrsMap) because the map is
        // needed during codegen.
        function getAndRemoveAttr(el, name, removeFromMap) {
            var val;
            if ((val = el.attrsMap[name]) != null) {
                var list = el.attrsList;
                for (var i = 0, l = list.length; i < l; i++) {
                    if (list[i].name === name) {
                        list.splice(i, 1);
                        break;
                    }
                }
            }
            if (removeFromMap) {
                delete el.attrsMap[name];
            }
            return val;
        }
        function getAndRemoveAttrByRegex(el, name) {
            var list = el.attrsList;
            for (var i = 0, l = list.length; i < l; i++) {
                var attr = list[i];
                if (name.test(attr.name)) {
                    list.splice(i, 1);
                    return attr;
                }
            }
        }
        function rangeSetItem(item, range) {
            if (range) {
                if (range.start != null) {
                    item.start = range.start;
                }
                if (range.end != null) {
                    item.end = range.end;
                }
            }
            return item;
        }
        /*  */
        function transformNode(el, options) {
            var warn = options.warn || baseWarn;
            var staticClass = getAndRemoveAttr(el, 'class');
            if (staticClass) {
                var res = parseText(staticClass, options.delimiters);
                if (res) {
                    warn("class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.', el.rawAttrsMap['class']);
                }
            }
            if (staticClass) {
                el.staticClass = JSON.stringify(staticClass);
            }
            var classBinding = getBindingAttr(el, 'class', false
            /* getStatic */
            );
            if (classBinding) {
                el.classBinding = classBinding;
            }
        }
        function genData(el) {
            var data = '';
            if (el.staticClass) {
                data += "staticClass:" + el.staticClass + ",";
            }
            if (el.classBinding) {
                data += "class:" + el.classBinding + ",";
            }
            return data;
        }
        var klass = {
            staticKeys: ['staticClass'],
            transformNode: transformNode,
            genData: genData
        };
        /*  */
        function transformNode$1(el, options) {
            var warn = options.warn || baseWarn;
            var staticStyle = getAndRemoveAttr(el, 'style');
            if (staticStyle) {
                /* istanbul ignore if */
                {
                    var res = parseText(staticStyle, options.delimiters);
                    if (res) {
                        warn("style=\"" + staticStyle + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style="{{ val }}">, use <div :style="val">.', el.rawAttrsMap['style']);
                    }
                }
                el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
            }
            var styleBinding = getBindingAttr(el, 'style', false
            /* getStatic */
            );
            if (styleBinding) {
                el.styleBinding = styleBinding;
            }
        }
        function genData$1(el) {
            var data = '';
            if (el.staticStyle) {
                data += "staticStyle:" + el.staticStyle + ",";
            }
            if (el.styleBinding) {
                data += "style:(" + el.styleBinding + "),";
            }
            return data;
        }
        var style = {
            staticKeys: ['staticStyle'],
            transformNode: transformNode$1,
            genData: genData$1
        };
        /**
         * Not type-checking this file because it's mostly vendor code.
         */
        // Regular Expressions for parsing tags and attributes
        var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
        var dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
        var ncname = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + unicodeRegExp.source + "]*";
        var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
        var startTagOpen = new RegExp("^<" + qnameCapture);
        var startTagClose = /^\s*(\/?)>/;
        var endTag = new RegExp("^<\\/" + qnameCapture + "[^>]*>");
        var doctype = /^<!DOCTYPE [^>]+>/i; // #7298: escape - to avoid being passed as HTML comment when inlined in page
        var comment = /^<!\--/;
        var conditionalComment = /^<!\[/; // Special Elements (can contain anything)
        var isPlainTextElement = makeMap('script,style,textarea', true);
        var reCache = {};
        var decodingMap = {
            '&lt;': '<',
            '&gt;': '>',
            '&quot;': '"',
            '&amp;': '&',
            '&#10;': '\n',
            '&#9;': '\t',
            '&#39;': "'"
        };
        var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
        var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g; // #5992
        var isIgnoreNewlineTag = makeMap('pre,textarea', true);
        var shouldIgnoreFirstNewline = function (tag, html) {
            return tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
        };
        function decodeAttr(value, shouldDecodeNewlines) {
            var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
            return value.replace(re, function (match) {
                return decodingMap[match];
            });
        }
        function parseHTML(html, options) {
            var stack = [];
            var expectHTML = options.expectHTML;
            var isUnaryTag$$1 = options.isUnaryTag || no;
            var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
            var index = 0;
            var last, lastTag;
            while (html) {
                last = html; // Make sure we're not in a plaintext content element like script/style
                if (!lastTag || !isPlainTextElement(lastTag)) {
                    var textEnd = html.indexOf('<');
                    if (textEnd === 0) {
                        // Comment:
                        if (comment.test(html)) {
                            var commentEnd = html.indexOf('-->');
                            if (commentEnd >= 0) {
                                if (options.shouldKeepComment) {
                                    options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
                                }
                                advance(commentEnd + 3);
                                continue;
                            }
                        } // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
                        if (conditionalComment.test(html)) {
                            var conditionalEnd = html.indexOf(']>');
                            if (conditionalEnd >= 0) {
                                advance(conditionalEnd + 2);
                                continue;
                            }
                        } // Doctype:
                        var doctypeMatch = html.match(doctype);
                        if (doctypeMatch) {
                            advance(doctypeMatch[0].length);
                            continue;
                        } // End tag:
                        var endTagMatch = html.match(endTag);
                        if (endTagMatch) {
                            var curIndex = index;
                            advance(endTagMatch[0].length);
                            parseEndTag(endTagMatch[1], curIndex, index);
                            continue;
                        } // Start tag:
                        var startTagMatch = parseStartTag();
                        if (startTagMatch) {
                            handleStartTag(startTagMatch);
                            if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
                                advance(1);
                            }
                            continue;
                        }
                    }
                    var text = void 0, rest = void 0, next = void 0;
                    if (textEnd >= 0) {
                        rest = html.slice(textEnd);
                        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {
                            // < in plain text, be forgiving and treat it as text
                            next = rest.indexOf('<', 1);
                            if (next < 0) {
                                break;
                            }
                            textEnd += next;
                            rest = html.slice(textEnd);
                        }
                        text = html.substring(0, textEnd);
                    }
                    if (textEnd < 0) {
                        text = html;
                    }
                    if (text) {
                        advance(text.length);
                    }
                    if (options.chars && text) {
                        options.chars(text, index - text.length, index);
                    }
                }
                else {
                    var endTagLength = 0;
                    var stackedTag = lastTag.toLowerCase();
                    var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
                    var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
                        endTagLength = endTag.length;
                        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
                            text = text.replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
                                .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
                        }
                        if (shouldIgnoreFirstNewline(stackedTag, text)) {
                            text = text.slice(1);
                        }
                        if (options.chars) {
                            options.chars(text);
                        }
                        return '';
                    });
                    index += html.length - rest$1.length;
                    html = rest$1;
                    parseEndTag(stackedTag, index - endTagLength, index);
                }
                if (html === last) {
                    options.chars && options.chars(html);
                    if (!stack.length && options.warn) {
                        options.warn("Mal-formatted tag at end of template: \"" + html + "\"", {
                            start: index + html.length
                        });
                    }
                    break;
                }
            } // Clean up any remaining tags
            parseEndTag();
            function advance(n) {
                index += n;
                html = html.substring(n);
            }
            function parseStartTag() {
                var start = html.match(startTagOpen);
                if (start) {
                    var match = {
                        tagName: start[1],
                        attrs: [],
                        start: index
                    };
                    advance(start[0].length);
                    var end, attr;
                    while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
                        attr.start = index;
                        advance(attr[0].length);
                        attr.end = index;
                        match.attrs.push(attr);
                    }
                    if (end) {
                        match.unarySlash = end[1];
                        advance(end[0].length);
                        match.end = index;
                        return match;
                    }
                }
            }
            function handleStartTag(match) {
                var tagName = match.tagName;
                var unarySlash = match.unarySlash;
                if (expectHTML) {
                    if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
                        parseEndTag(lastTag);
                    }
                    if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
                        parseEndTag(tagName);
                    }
                }
                var unary = isUnaryTag$$1(tagName) || !!unarySlash;
                var l = match.attrs.length;
                var attrs = new Array(l);
                for (var i = 0; i < l; i++) {
                    var args = match.attrs[i];
                    var value = args[3] || args[4] || args[5] || '';
                    var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;
                    attrs[i] = {
                        name: args[1],
                        value: decodeAttr(value, shouldDecodeNewlines)
                    };
                    if (options.outputSourceRange) {
                        attrs[i].start = args.start + args[0].match(/^\s*/).length;
                        attrs[i].end = args.end;
                    }
                }
                if (!unary) {
                    stack.push({
                        tag: tagName,
                        lowerCasedTag: tagName.toLowerCase(),
                        attrs: attrs,
                        start: match.start,
                        end: match.end
                    });
                    lastTag = tagName;
                }
                if (options.start) {
                    options.start(tagName, attrs, unary, match.start, match.end);
                }
            }
            function parseEndTag(tagName, start, end) {
                var pos, lowerCasedTagName;
                if (start == null) {
                    start = index;
                }
                if (end == null) {
                    end = index;
                } // Find the closest opened tag of the same type
                if (tagName) {
                    lowerCasedTagName = tagName.toLowerCase();
                    for (pos = stack.length - 1; pos >= 0; pos--) {
                        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
                            break;
                        }
                    }
                }
                else {
                    // If no tag name is provided, clean shop
                    pos = 0;
                }
                if (pos >= 0) {
                    // Close all the open elements, up the stack
                    for (var i = stack.length - 1; i >= pos; i--) {
                        if (i > pos || !tagName && options.warn) {
                            options.warn("tag <" + stack[i].tag + "> has no matching end tag.", {
                                start: stack[i].start,
                                end: stack[i].end
                            });
                        }
                        if (options.end) {
                            options.end(stack[i].tag, start, end);
                        }
                    } // Remove the open elements from the stack
                    stack.length = pos;
                    lastTag = pos && stack[pos - 1].tag;
                }
                else if (lowerCasedTagName === 'br') {
                    if (options.start) {
                        options.start(tagName, [], true, start, end);
                    }
                }
                else if (lowerCasedTagName === 'p') {
                    if (options.start) {
                        options.start(tagName, [], false, start, end);
                    }
                    if (options.end) {
                        options.end(tagName, start, end);
                    }
                }
            }
        }
        /*  */
        /**
         * Cross-platform code generation for component v-model
         */
        function genComponentModel(el, value, modifiers) {
            var ref = modifiers || {};
            var number = ref.number;
            var trim = ref.trim;
            var baseValueExpression = '$$v';
            var valueExpression = baseValueExpression;
            if (trim) {
                valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
            }
            if (number) {
                valueExpression = "_n(" + valueExpression + ")";
            }
            var assignment = genAssignmentCode(value, valueExpression);
            el.model = {
                value: "(" + value + ")",
                expression: JSON.stringify(value),
                callback: "function (" + baseValueExpression + ") {" + assignment + "}"
            };
        }
        /**
         * Cross-platform codegen helper for generating v-model value assignment code.
         */
        function genAssignmentCode(value, assignment) {
            var res = parseModel(value);
            if (res.key === null) {
                return value + "=" + assignment;
            }
            else {
                return "$set(" + res.exp + ", " + res.key + ", " + assignment + ")";
            }
        }
        /**
         * Parse a v-model expression into a base path and a final key segment.
         * Handles both dot-path and possible square brackets.
         *
         * Possible cases:
         *
         * - test
         * - test[key]
         * - test[test1[key]]
         * - test["a"][key]
         * - xxx.test[a[a].test1[key]]
         * - test.xxx.a["asa"][test1[key]]
         *
         */
        var len, str, chr, index, expressionPos, expressionEndPos;
        function parseModel(val) {
            // Fix https://github.com/vuejs/vue/pull/7730
            // allow v-model="obj.val " (trailing whitespace)
            val = val.trim();
            len = val.length;
            if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
                index = val.lastIndexOf('.');
                if (index > -1) {
                    return {
                        exp: val.slice(0, index),
                        key: '"' + val.slice(index + 1) + '"'
                    };
                }
                else {
                    return {
                        exp: val,
                        key: null
                    };
                }
            }
            str = val;
            index = expressionPos = expressionEndPos = 0;
            while (!eof()) {
                chr = next();
                /* istanbul ignore if */
                if (isStringStart(chr)) {
                    parseString(chr);
                }
                else if (chr === 0x5B) {
                    parseBracket(chr);
                }
            }
            return {
                exp: val.slice(0, expressionPos),
                key: val.slice(expressionPos + 1, expressionEndPos)
            };
        }
        function next() {
            return str.charCodeAt(++index);
        }
        function eof() {
            return index >= len;
        }
        function isStringStart(chr) {
            return chr === 0x22 || chr === 0x27;
        }
        function parseBracket(chr) {
            var inBracket = 1;
            expressionPos = index;
            while (!eof()) {
                chr = next();
                if (isStringStart(chr)) {
                    parseString(chr);
                    continue;
                }
                if (chr === 0x5B) {
                    inBracket++;
                }
                if (chr === 0x5D) {
                    inBracket--;
                }
                if (inBracket === 0) {
                    expressionEndPos = index;
                    break;
                }
            }
        }
        function parseString(chr) {
            var stringQuote = chr;
            while (!eof()) {
                chr = next();
                if (chr === stringQuote) {
                    break;
                }
            }
        }
        /*  */
        var onRE = /^@|^v-on:/;
        var dirRE = /^v-|^@|^:|^#/;
        var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
        var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
        var stripParensRE = /^\(|\)$/g;
        var dynamicArgRE = /^\[.*\]$/;
        var argRE = /:(.*)$/;
        var bindRE = /^:|^\.|^v-bind:/;
        var modifierRE = /\.[^.\]]+(?=[^\]]*$)/g;
        var slotRE = /^v-slot(:|$)|^#/;
        var lineBreakRE = /[\r\n]/;
        var whitespaceRE = /\s+/g;
        var invalidAttributeRE = /[\s"'<>\/=]/;
        var decodeHTMLCached = cached(he.decode);
        var emptySlotScopeToken = "_empty_"; // configurable state
        var warn$1;
        var delimiters;
        var transforms;
        var preTransforms;
        var postTransforms;
        var platformIsPreTag;
        var platformMustUseProp;
        var platformGetTagNamespace;
        var maybeComponent;
        function createASTElement(tag, attrs, parent) {
            return {
                type: 1,
                tag: tag,
                attrsList: attrs,
                attrsMap: makeAttrsMap(attrs),
                rawAttrsMap: {},
                parent: parent,
                children: []
            };
        }
        /**
         * Convert HTML string to AST.
         */
        function parse(template, options) {
            warn$1 = options.warn || baseWarn;
            platformIsPreTag = options.isPreTag || no;
            platformMustUseProp = options.mustUseProp || no;
            platformGetTagNamespace = options.getTagNamespace || no;
            var isReservedTag = options.isReservedTag || no;
            maybeComponent = function (el) {
                return !!el.component || !isReservedTag(el.tag);
            };
            transforms = pluckModuleFunction(options.modules, 'transformNode');
            preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
            postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
            delimiters = options.delimiters;
            var stack = [];
            var preserveWhitespace = options.preserveWhitespace !== false;
            var whitespaceOption = options.whitespace;
            var root;
            var currentParent;
            var inVPre = false;
            var inPre = false;
            var warned = false;
            function warnOnce(msg, range) {
                if (!warned) {
                    warned = true;
                    warn$1(msg, range);
                }
            }
            function closeElement(element) {
                trimEndingWhitespace(element);
                if (!inVPre && !element.processed) {
                    element = processElement(element, options);
                } // tree management
                if (!stack.length && element !== root) {
                    // allow root elements with v-if, v-else-if and v-else
                    if (root.if && (element.elseif || element.else)) {
                        {
                            checkRootConstraints(element);
                        }
                        addIfCondition(root, {
                            exp: element.elseif,
                            block: element
                        });
                    }
                    else {
                        warnOnce("Component template should contain exactly one root element. " + "If you are using v-if on multiple elements, " + "use v-else-if to chain them instead.", {
                            start: element.start
                        });
                    }
                }
                if (currentParent && !element.forbidden) {
                    if (element.elseif || element.else) {
                        processIfConditions(element, currentParent);
                    }
                    else {
                        if (element.slotScope) {
                            // scoped slot
                            // keep it in the children list so that v-else(-if) conditions can
                            // find it as the prev node.
                            var name = element.slotTarget || '"default"';
                            (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
                        }
                        currentParent.children.push(element);
                        element.parent = currentParent;
                    }
                } // final children cleanup
                // filter out scoped slots
                element.children = element.children.filter(function (c) {
                    return !c.slotScope;
                }); // remove trailing whitespace node again
                trimEndingWhitespace(element); // check pre state
                if (element.pre) {
                    inVPre = false;
                }
                if (platformIsPreTag(element.tag)) {
                    inPre = false;
                } // apply post-transforms
                for (var i = 0; i < postTransforms.length; i++) {
                    postTransforms[i](element, options);
                }
            }
            function trimEndingWhitespace(el) {
                // remove trailing whitespace node
                if (!inPre) {
                    var lastNode;
                    while ((lastNode = el.children[el.children.length - 1]) && lastNode.type === 3 && lastNode.text === ' ') {
                        el.children.pop();
                    }
                }
            }
            function checkRootConstraints(el) {
                if (el.tag === 'slot' || el.tag === 'template') {
                    warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.', {
                        start: el.start
                    });
                }
                if (el.attrsMap.hasOwnProperty('v-for')) {
                    warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.', el.rawAttrsMap['v-for']);
                }
            }
            parseHTML(template, {
                warn: warn$1,
                expectHTML: options.expectHTML,
                isUnaryTag: options.isUnaryTag,
                canBeLeftOpenTag: options.canBeLeftOpenTag,
                shouldDecodeNewlines: options.shouldDecodeNewlines,
                shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
                shouldKeepComment: options.comments,
                outputSourceRange: options.outputSourceRange,
                start: function start(tag, attrs, unary, start$1, end) {
                    // check namespace.
                    // inherit parent ns if there is one
                    var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag); // handle IE svg bug
                    /* istanbul ignore if */
                    if (isIE && ns === 'svg') {
                        attrs = guardIESVGBug(attrs);
                    }
                    var element = createASTElement(tag, attrs, currentParent);
                    if (ns) {
                        element.ns = ns;
                    }
                    {
                        if (options.outputSourceRange) {
                            element.start = start$1;
                            element.end = end;
                            element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {
                                cumulated[attr.name] = attr;
                                return cumulated;
                            }, {});
                        }
                        attrs.forEach(function (attr) {
                            if (invalidAttributeRE.test(attr.name)) {
                                warn$1("Invalid dynamic argument expression: attribute names cannot contain " + "spaces, quotes, <, >, / or =.", {
                                    start: attr.start + attr.name.indexOf("["),
                                    end: attr.start + attr.name.length
                                });
                            }
                        });
                    }
                    if (isForbiddenTag(element) && !isServerRendering()) {
                        element.forbidden = true;
                        warn$1('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + "<" + tag + ">" + ', as they will not be parsed.', {
                            start: element.start
                        });
                    } // apply pre-transforms
                    for (var i = 0; i < preTransforms.length; i++) {
                        element = preTransforms[i](element, options) || element;
                    }
                    if (!inVPre) {
                        processPre(element);
                        if (element.pre) {
                            inVPre = true;
                        }
                    }
                    if (platformIsPreTag(element.tag)) {
                        inPre = true;
                    }
                    if (inVPre) {
                        processRawAttrs(element);
                    }
                    else if (!element.processed) {
                        // structural directives
                        processFor(element);
                        processIf(element);
                        processOnce(element);
                    }
                    if (!root) {
                        root = element;
                        {
                            checkRootConstraints(root);
                        }
                    }
                    if (!unary) {
                        currentParent = element;
                        stack.push(element);
                    }
                    else {
                        closeElement(element);
                    }
                },
                end: function end(tag, start, end$1) {
                    var element = stack[stack.length - 1]; // pop stack
                    stack.length -= 1;
                    currentParent = stack[stack.length - 1];
                    if (options.outputSourceRange) {
                        element.end = end$1;
                    }
                    closeElement(element);
                },
                chars: function chars(text, start, end) {
                    if (!currentParent) {
                        {
                            if (text === template) {
                                warnOnce('Component template requires a root element, rather than just text.', {
                                    start: start
                                });
                            }
                            else if (text = text.trim()) {
                                warnOnce("text \"" + text + "\" outside root element will be ignored.", {
                                    start: start
                                });
                            }
                        }
                        return;
                    } // IE textarea placeholder bug
                    /* istanbul ignore if */
                    if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
                        return;
                    }
                    var children = currentParent.children;
                    if (inPre || text.trim()) {
                        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);
                    }
                    else if (!children.length) {
                        // remove the whitespace-only node right after an opening tag
                        text = '';
                    }
                    else if (whitespaceOption) {
                        if (whitespaceOption === 'condense') {
                            // in condense mode, remove the whitespace node if it contains
                            // line break, otherwise condense to a single space
                            text = lineBreakRE.test(text) ? '' : ' ';
                        }
                        else {
                            text = ' ';
                        }
                    }
                    else {
                        text = preserveWhitespace ? ' ' : '';
                    }
                    if (text) {
                        if (!inPre && whitespaceOption === 'condense') {
                            // condense consecutive whitespaces into single space
                            text = text.replace(whitespaceRE, ' ');
                        }
                        var res;
                        var child;
                        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
                            child = {
                                type: 2,
                                expression: res.expression,
                                tokens: res.tokens,
                                text: text
                            };
                        }
                        else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
                            child = {
                                type: 3,
                                text: text
                            };
                        }
                        if (child) {
                            if (options.outputSourceRange) {
                                child.start = start;
                                child.end = end;
                            }
                            children.push(child);
                        }
                    }
                },
                comment: function comment(text, start, end) {
                    // adding anyting as a sibling to the root node is forbidden
                    // comments should still be allowed, but ignored
                    if (currentParent) {
                        var child = {
                            type: 3,
                            text: text,
                            isComment: true
                        };
                        if (options.outputSourceRange) {
                            child.start = start;
                            child.end = end;
                        }
                        currentParent.children.push(child);
                    }
                }
            });
            return root;
        }
        function processPre(el) {
            if (getAndRemoveAttr(el, 'v-pre') != null) {
                el.pre = true;
            }
        }
        function processRawAttrs(el) {
            var list = el.attrsList;
            var len = list.length;
            if (len) {
                var attrs = el.attrs = new Array(len);
                for (var i = 0; i < len; i++) {
                    attrs[i] = {
                        name: list[i].name,
                        value: JSON.stringify(list[i].value)
                    };
                    if (list[i].start != null) {
                        attrs[i].start = list[i].start;
                        attrs[i].end = list[i].end;
                    }
                }
            }
            else if (!el.pre) {
                // non root node in pre blocks with no attributes
                el.plain = true;
            }
        }
        function processElement(element, options) {
            processKey(element); // determine whether this is a plain element after
            // removing structural attributes
            element.plain = !element.key && !element.scopedSlots && !element.attrsList.length;
            processRef(element);
            processSlotContent(element);
            processSlotOutlet(element);
            processComponent(element);
            for (var i = 0; i < transforms.length; i++) {
                element = transforms[i](element, options) || element;
            }
            processAttrs(element);
            return element;
        }
        function processKey(el) {
            var exp = getBindingAttr(el, 'key');
            if (exp) {
                {
                    if (el.tag === 'template') {
                        warn$1("<template> cannot be keyed. Place the key on real elements instead.", getRawBindingAttr(el, 'key'));
                    }
                    if (el.for) {
                        var iterator = el.iterator2 || el.iterator1;
                        var parent = el.parent;
                        if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {
                            warn$1("Do not use v-for index as key on <transition-group> children, " + "this is the same as not using keys.", getRawBindingAttr(el, 'key'), true
                            /* tip */
                            );
                        }
                    }
                }
                el.key = exp;
            }
        }
        function processRef(el) {
            var ref = getBindingAttr(el, 'ref');
            if (ref) {
                el.ref = ref;
                el.refInFor = checkInFor(el);
            }
        }
        function processFor(el) {
            var exp;
            if (exp = getAndRemoveAttr(el, 'v-for')) {
                var res = parseFor(exp);
                if (res) {
                    extend(el, res);
                }
                else {
                    warn$1("Invalid v-for expression: " + exp, el.rawAttrsMap['v-for']);
                }
            }
        }
        function parseFor(exp) {
            var inMatch = exp.match(forAliasRE);
            if (!inMatch) {
                return;
            }
            var res = {};
            res.for = inMatch[2].trim();
            var alias = inMatch[1].trim().replace(stripParensRE, '');
            var iteratorMatch = alias.match(forIteratorRE);
            if (iteratorMatch) {
                res.alias = alias.replace(forIteratorRE, '').trim();
                res.iterator1 = iteratorMatch[1].trim();
                if (iteratorMatch[2]) {
                    res.iterator2 = iteratorMatch[2].trim();
                }
            }
            else {
                res.alias = alias;
            }
            return res;
        }
        function processIf(el) {
            var exp = getAndRemoveAttr(el, 'v-if');
            if (exp) {
                el.if = exp;
                addIfCondition(el, {
                    exp: exp,
                    block: el
                });
            }
            else {
                if (getAndRemoveAttr(el, 'v-else') != null) {
                    el.else = true;
                }
                var elseif = getAndRemoveAttr(el, 'v-else-if');
                if (elseif) {
                    el.elseif = elseif;
                }
            }
        }
        function processIfConditions(el, parent) {
            var prev = findPrevElement(parent.children);
            if (prev && prev.if) {
                addIfCondition(prev, {
                    exp: el.elseif,
                    block: el
                });
            }
            else {
                warn$1("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + " " + "used on element <" + el.tag + "> without corresponding v-if.", el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']);
            }
        }
        function findPrevElement(children) {
            var i = children.length;
            while (i--) {
                if (children[i].type === 1) {
                    return children[i];
                }
                else {
                    if (children[i].text !== ' ') {
                        warn$1("text \"" + children[i].text.trim() + "\" between v-if and v-else(-if) " + "will be ignored.", children[i]);
                    }
                    children.pop();
                }
            }
        }
        function addIfCondition(el, condition) {
            if (!el.ifConditions) {
                el.ifConditions = [];
            }
            el.ifConditions.push(condition);
        }
        function processOnce(el) {
            var once$$1 = getAndRemoveAttr(el, 'v-once');
            if (once$$1 != null) {
                el.once = true;
            }
        } // handle content being passed to a component as slot,
        // e.g. <template slot="xxx">, <div slot-scope="xxx">
        function processSlotContent(el) {
            var slotScope;
            if (el.tag === 'template') {
                slotScope = getAndRemoveAttr(el, 'scope');
                /* istanbul ignore if */
                if (slotScope) {
                    warn$1("the \"scope\" attribute for scoped slots have been deprecated and " + "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " + "can also be used on plain elements in addition to <template> to " + "denote scoped slots.", el.rawAttrsMap['scope'], true);
                }
                el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
            }
            else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {
                /* istanbul ignore if */
                if (el.attrsMap['v-for']) {
                    warn$1("Ambiguous combined usage of slot-scope and v-for on <" + el.tag + "> " + "(v-for takes higher priority). Use a wrapper <template> for the " + "scoped slot to make it clearer.", el.rawAttrsMap['slot-scope'], true);
                }
                el.slotScope = slotScope;
            } // slot="xxx"
            var slotTarget = getBindingAttr(el, 'slot');
            if (slotTarget) {
                el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
                el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']); // preserve slot as an attribute for native shadow DOM compat
                // only for non-scoped slots.
                if (el.tag !== 'template' && !el.slotScope) {
                    addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));
                }
            } // 2.6 v-slot syntax
            {
                if (el.tag === 'template') {
                    // v-slot on <template>
                    var slotBinding = getAndRemoveAttrByRegex(el, slotRE);
                    if (slotBinding) {
                        {
                            if (el.slotTarget || el.slotScope) {
                                warn$1("Unexpected mixed usage of different slot syntaxes.", el);
                            }
                            if (el.parent && !maybeComponent(el.parent)) {
                                warn$1("<template v-slot> can only appear at the root level inside " + "the receiving component", el);
                            }
                        }
                        var ref = getSlotName(slotBinding);
                        var name = ref.name;
                        var dynamic = ref.dynamic;
                        el.slotTarget = name;
                        el.slotTargetDynamic = dynamic;
                        el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf
                    }
                }
                else {
                    // v-slot on component, denotes default slot
                    var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);
                    if (slotBinding$1) {
                        {
                            if (!maybeComponent(el)) {
                                warn$1("v-slot can only be used on components or <template>.", slotBinding$1);
                            }
                            if (el.slotScope || el.slotTarget) {
                                warn$1("Unexpected mixed usage of different slot syntaxes.", el);
                            }
                            if (el.scopedSlots) {
                                warn$1("To avoid scope ambiguity, the default slot should also use " + "<template> syntax when there are other named slots.", slotBinding$1);
                            }
                        } // add the component's children to its default slot
                        var slots = el.scopedSlots || (el.scopedSlots = {});
                        var ref$1 = getSlotName(slotBinding$1);
                        var name$1 = ref$1.name;
                        var dynamic$1 = ref$1.dynamic;
                        var slotContainer = slots[name$1] = createASTElement('template', [], el);
                        slotContainer.slotTarget = name$1;
                        slotContainer.slotTargetDynamic = dynamic$1;
                        slotContainer.children = el.children.filter(function (c) {
                            if (!c.slotScope) {
                                c.parent = slotContainer;
                                return true;
                            }
                        });
                        slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken; // remove children as they are returned from scopedSlots now
                        el.children = []; // mark el non-plain so data gets generated
                        el.plain = false;
                    }
                }
            }
        }
        function getSlotName(binding) {
            var name = binding.name.replace(slotRE, '');
            if (!name) {
                if (binding.name[0] !== '#') {
                    name = 'default';
                }
                else {
                    warn$1("v-slot shorthand syntax requires a slot name.", binding);
                }
            }
            return dynamicArgRE.test(name) // dynamic [name]
                ? {
                    name: name.slice(1, -1),
                    dynamic: true // static name
                } : {
                name: "\"" + name + "\"",
                dynamic: false
            };
        } // handle <slot/> outlets
        function processSlotOutlet(el) {
            if (el.tag === 'slot') {
                el.slotName = getBindingAttr(el, 'name');
                if (el.key) {
                    warn$1("`key` does not work on <slot> because slots are abstract outlets " + "and can possibly expand into multiple elements. " + "Use the key on a wrapping element instead.", getRawBindingAttr(el, 'key'));
                }
            }
        }
        function processComponent(el) {
            var binding;
            if (binding = getBindingAttr(el, 'is')) {
                el.component = binding;
            }
            if (getAndRemoveAttr(el, 'inline-template') != null) {
                el.inlineTemplate = true;
            }
        }
        function processAttrs(el) {
            var list = el.attrsList;
            var i, l, name, rawName, value, modifiers, syncGen, isDynamic;
            for (i = 0, l = list.length; i < l; i++) {
                name = rawName = list[i].name;
                value = list[i].value;
                if (dirRE.test(name)) {
                    // mark element as dynamic
                    el.hasBindings = true; // modifiers
                    modifiers = parseModifiers(name.replace(dirRE, '')); // support .foo shorthand syntax for the .prop modifier
                    if (modifiers) {
                        name = name.replace(modifierRE, '');
                    }
                    if (bindRE.test(name)) {
                        // v-bind
                        name = name.replace(bindRE, '');
                        value = parseFilters(value);
                        isDynamic = dynamicArgRE.test(name);
                        if (isDynamic) {
                            name = name.slice(1, -1);
                        }
                        if (value.trim().length === 0) {
                            warn$1("The value for a v-bind expression cannot be empty. Found in \"v-bind:" + name + "\"");
                        }
                        if (modifiers) {
                            if (modifiers.prop && !isDynamic) {
                                name = camelize(name);
                                if (name === 'innerHtml') {
                                    name = 'innerHTML';
                                }
                            }
                            if (modifiers.camel && !isDynamic) {
                                name = camelize(name);
                            }
                            if (modifiers.sync) {
                                syncGen = genAssignmentCode(value, "$event");
                                if (!isDynamic) {
                                    addHandler(el, "update:" + camelize(name), syncGen, null, false, warn$1, list[i]);
                                    if (hyphenate(name) !== camelize(name)) {
                                        addHandler(el, "update:" + hyphenate(name), syncGen, null, false, warn$1, list[i]);
                                    }
                                }
                                else {
                                    // handler w/ dynamic event name
                                    addHandler(el, "\"update:\"+(" + name + ")", syncGen, null, false, warn$1, list[i], true // dynamic
                                    );
                                }
                            }
                        }
                        if (modifiers && modifiers.prop || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
                            addProp(el, name, value, list[i], isDynamic);
                        }
                        else {
                            addAttr(el, name, value, list[i], isDynamic);
                        }
                    }
                    else if (onRE.test(name)) {
                        // v-on
                        name = name.replace(onRE, '');
                        isDynamic = dynamicArgRE.test(name);
                        if (isDynamic) {
                            name = name.slice(1, -1);
                        }
                        addHandler(el, name, value, modifiers, false, warn$1, list[i], isDynamic);
                    }
                    else {
                        // normal directives
                        name = name.replace(dirRE, ''); // parse arg
                        var argMatch = name.match(argRE);
                        var arg = argMatch && argMatch[1];
                        isDynamic = false;
                        if (arg) {
                            name = name.slice(0, -(arg.length + 1));
                            if (dynamicArgRE.test(arg)) {
                                arg = arg.slice(1, -1);
                                isDynamic = true;
                            }
                        }
                        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);
                        if (name === 'model') {
                            checkForAliasModel(el, value);
                        }
                    }
                }
                else {
                    // literal attribute
                    {
                        var res = parseText(value, delimiters);
                        if (res) {
                            warn$1(name + "=\"" + value + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.', list[i]);
                        }
                    }
                    addAttr(el, name, JSON.stringify(value), list[i]); // #6887 firefox doesn't update muted state if set via attribute
                    // even immediately after element creation
                    if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
                        addProp(el, name, 'true', list[i]);
                    }
                }
            }
        }
        function checkInFor(el) {
            var parent = el;
            while (parent) {
                if (parent.for !== undefined) {
                    return true;
                }
                parent = parent.parent;
            }
            return false;
        }
        function parseModifiers(name) {
            var match = name.match(modifierRE);
            if (match) {
                var ret = {};
                match.forEach(function (m) {
                    ret[m.slice(1)] = true;
                });
                return ret;
            }
        }
        function makeAttrsMap(attrs) {
            var map = {};
            for (var i = 0, l = attrs.length; i < l; i++) {
                if (map[attrs[i].name] && !isIE && !isEdge) {
                    warn$1('duplicate attribute: ' + attrs[i].name, attrs[i]);
                }
                map[attrs[i].name] = attrs[i].value;
            }
            return map;
        } // for script (e.g. type="x/template") or style, do not decode content
        function isTextTag(el) {
            return el.tag === 'script' || el.tag === 'style';
        }
        function isForbiddenTag(el) {
            return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
        }
        var ieNSBug = /^xmlns:NS\d+/;
        var ieNSPrefix = /^NS\d+:/;
        /* istanbul ignore next */
        function guardIESVGBug(attrs) {
            var res = [];
            for (var i = 0; i < attrs.length; i++) {
                var attr = attrs[i];
                if (!ieNSBug.test(attr.name)) {
                    attr.name = attr.name.replace(ieNSPrefix, '');
                    res.push(attr);
                }
            }
            return res;
        }
        function checkForAliasModel(el, value) {
            var _el = el;
            while (_el) {
                if (_el.for && _el.alias === value) {
                    warn$1("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.", el.rawAttrsMap['v-model']);
                }
                _el = _el.parent;
            }
        }
        /*  */
        function preTransformNode(el, options) {
            if (el.tag === 'input') {
                var map = el.attrsMap;
                if (!map['v-model']) {
                    return;
                }
                var typeBinding;
                if (map[':type'] || map['v-bind:type']) {
                    typeBinding = getBindingAttr(el, 'type');
                }
                if (!map.type && !typeBinding && map['v-bind']) {
                    typeBinding = "(" + map['v-bind'] + ").type";
                }
                if (typeBinding) {
                    var ifCondition = getAndRemoveAttr(el, 'v-if', true);
                    var ifConditionExtra = ifCondition ? "&&(" + ifCondition + ")" : "";
                    var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
                    var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true); // 1. checkbox
                    var branch0 = cloneASTElement(el); // process for on the main node
                    processFor(branch0);
                    addRawAttr(branch0, 'type', 'checkbox');
                    processElement(branch0, options);
                    branch0.processed = true; // prevent it from double-processed
                    branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
                    addIfCondition(branch0, {
                        exp: branch0.if,
                        block: branch0
                    }); // 2. add radio else-if condition
                    var branch1 = cloneASTElement(el);
                    getAndRemoveAttr(branch1, 'v-for', true);
                    addRawAttr(branch1, 'type', 'radio');
                    processElement(branch1, options);
                    addIfCondition(branch0, {
                        exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
                        block: branch1
                    }); // 3. other
                    var branch2 = cloneASTElement(el);
                    getAndRemoveAttr(branch2, 'v-for', true);
                    addRawAttr(branch2, ':type', typeBinding);
                    processElement(branch2, options);
                    addIfCondition(branch0, {
                        exp: ifCondition,
                        block: branch2
                    });
                    if (hasElse) {
                        branch0.else = true;
                    }
                    else if (elseIfCondition) {
                        branch0.elseif = elseIfCondition;
                    }
                    return branch0;
                }
            }
        }
        function cloneASTElement(el) {
            return createASTElement(el.tag, el.attrsList.slice(), el.parent);
        }
        var model$1 = {
            preTransformNode: preTransformNode
        };
        var modules$1 = [klass, style, model$1];
        /*  */
        var warn$2; // in some cases, the event used has to be determined at runtime
        // so we used some reserved tokens during compile.
        var RANGE_TOKEN = '__r';
        function model$2(el, dir, _warn) {
            warn$2 = _warn;
            var value = dir.value;
            var modifiers = dir.modifiers;
            var tag = el.tag;
            var type = el.attrsMap.type;
            {
                // inputs with type="file" are read only and setting the input's
                // value will throw an error.
                if (tag === 'input' && type === 'file') {
                    warn$2("<" + el.tag + " v-model=\"" + value + "\" type=\"file\">:\n" + "File inputs are read only. Use a v-on:change listener instead.", el.rawAttrsMap['v-model']);
                }
            }
            if (el.component) {
                genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime
                return false;
            }
            else if (tag === 'select') {
                genSelect(el, value, modifiers);
            }
            else if (tag === 'input' && type === 'checkbox') {
                genCheckboxModel(el, value, modifiers);
            }
            else if (tag === 'input' && type === 'radio') {
                genRadioModel(el, value, modifiers);
            }
            else if (tag === 'input' || tag === 'textarea') {
                genDefaultModel(el, value, modifiers);
            }
            else {
                genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime
                return false;
            } // ensure runtime directive metadata
            return true;
        }
        function genCheckboxModel(el, value, modifiers) {
            var number = modifiers && modifiers.number;
            var valueBinding = getBindingAttr(el, 'value') || 'null';
            var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
            var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
            addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
            addHandler(el, 'change', "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$el.checked){$$i<0&&(" + genAssignmentCode(value, '$$a.concat([$$v])') + ")}" + "else{$$i>-1&&(" + genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))') + ")}" + "}else{" + genAssignmentCode(value, '$$c') + "}", null, true);
        }
        function genRadioModel(el, value, modifiers) {
            var number = modifiers && modifiers.number;
            var valueBinding = getBindingAttr(el, 'value') || 'null';
            valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
            addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
            addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
        }
        function genSelect(el, value, modifiers) {
            var number = modifiers && modifiers.number;
            var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";
            var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
            var code = "var $$selectedVal = " + selectedVal + ";";
            code = code + " " + genAssignmentCode(value, assignment);
            addHandler(el, 'change', code, null, true);
        }
        function genDefaultModel(el, value, modifiers) {
            var type = el.attrsMap.type; // warn if v-bind:value conflicts with v-model
            // except for inputs with v-bind:type
            {
                var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
                var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
                if (value$1 && !typeBinding) {
                    var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
                    warn$2(binding + "=\"" + value$1 + "\" conflicts with v-model on the same element " + 'because the latter already expands to a value binding internally', el.rawAttrsMap[binding]);
                }
            }
            var ref = modifiers || {};
            var lazy = ref.lazy;
            var number = ref.number;
            var trim = ref.trim;
            var needCompositionGuard = !lazy && type !== 'range';
            var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';
            var valueExpression = '$event.target.value';
            if (trim) {
                valueExpression = "$event.target.value.trim()";
            }
            if (number) {
                valueExpression = "_n(" + valueExpression + ")";
            }
            var code = genAssignmentCode(value, valueExpression);
            if (needCompositionGuard) {
                code = "if($event.target.composing)return;" + code;
            }
            addProp(el, 'value', "(" + value + ")");
            addHandler(el, event, code, null, true);
            if (trim || number) {
                addHandler(el, 'blur', '$forceUpdate()');
            }
        }
        /*  */
        function text(el, dir) {
            if (dir.value) {
                addProp(el, 'textContent', "_s(" + dir.value + ")", dir);
            }
        }
        /*  */
        function html(el, dir) {
            if (dir.value) {
                addProp(el, 'innerHTML', "_s(" + dir.value + ")", dir);
            }
        }
        var directives = {
            model: model$2,
            text: text,
            html: html
        };
        /*  */
        var baseOptions = {
            expectHTML: true,
            modules: modules$1,
            directives: directives,
            isPreTag: isPreTag,
            isUnaryTag: isUnaryTag,
            mustUseProp: mustUseProp,
            canBeLeftOpenTag: canBeLeftOpenTag,
            isReservedTag: isReservedTag,
            getTagNamespace: getTagNamespace,
            staticKeys: genStaticKeys(modules$1)
        };
        /*  */
        var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/;
        var fnInvokeRE = /\([^)]*?\);*$/;
        var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/; // KeyboardEvent.keyCode aliases
        var keyCodes = {
            esc: 27,
            tab: 9,
            enter: 13,
            space: 32,
            up: 38,
            left: 37,
            right: 39,
            down: 40,
            'delete': [8, 46]
        }; // KeyboardEvent.key aliases
        var keyNames = {
            // #7880: IE11 and Edge use `Esc` for Escape key name.
            esc: ['Esc', 'Escape'],
            tab: 'Tab',
            enter: 'Enter',
            // #9112: IE11 uses `Spacebar` for Space key name.
            space: [' ', 'Spacebar'],
            // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
            up: ['Up', 'ArrowUp'],
            left: ['Left', 'ArrowLeft'],
            right: ['Right', 'ArrowRight'],
            down: ['Down', 'ArrowDown'],
            // #9112: IE11 uses `Del` for Delete key name.
            'delete': ['Backspace', 'Delete', 'Del']
        }; // #4868: modifiers that prevent the execution of the listener
        // need to explicitly return null so that we can determine whether to remove
        // the listener for .once
        var genGuard = function (condition) {
            return "if(" + condition + ")return null;";
        };
        var modifierCode = {
            stop: '$event.stopPropagation();',
            prevent: '$event.preventDefault();',
            self: genGuard("$event.target !== $event.currentTarget"),
            ctrl: genGuard("!$event.ctrlKey"),
            shift: genGuard("!$event.shiftKey"),
            alt: genGuard("!$event.altKey"),
            meta: genGuard("!$event.metaKey"),
            left: genGuard("'button' in $event && $event.button !== 0"),
            middle: genGuard("'button' in $event && $event.button !== 1"),
            right: genGuard("'button' in $event && $event.button !== 2")
        };
        function genHandlers(events, isNative) {
            var prefix = isNative ? 'nativeOn:' : 'on:';
            var staticHandlers = "";
            var dynamicHandlers = "";
            for (var name in events) {
                var handlerCode = genHandler(events[name]);
                if (events[name] && events[name].dynamic) {
                    dynamicHandlers += name + "," + handlerCode + ",";
                }
                else {
                    staticHandlers += "\"" + name + "\":" + handlerCode + ",";
                }
            }
            staticHandlers = "{" + staticHandlers.slice(0, -1) + "}";
            if (dynamicHandlers) {
                return prefix + "_d(" + staticHandlers + ",[" + dynamicHandlers.slice(0, -1) + "])";
            }
            else {
                return prefix + staticHandlers;
            }
        }
        function genHandler(handler) {
            if (!handler) {
                return 'function(){}';
            }
            if (Array.isArray(handler)) {
                return "[" + handler.map(function (handler) {
                    return genHandler(handler);
                }).join(',') + "]";
            }
            var isMethodPath = simplePathRE.test(handler.value);
            var isFunctionExpression = fnExpRE.test(handler.value);
            var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));
            if (!handler.modifiers) {
                if (isMethodPath || isFunctionExpression) {
                    return handler.value;
                }
                return "function($event){" + (isFunctionInvocation ? "return " + handler.value : handler.value) + "}"; // inline statement
            }
            else {
                var code = '';
                var genModifierCode = '';
                var keys = [];
                for (var key in handler.modifiers) {
                    if (modifierCode[key]) {
                        genModifierCode += modifierCode[key]; // left/right
                        if (keyCodes[key]) {
                            keys.push(key);
                        }
                    }
                    else if (key === 'exact') {
                        var modifiers = handler.modifiers;
                        genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {
                            return !modifiers[keyModifier];
                        }).map(function (keyModifier) {
                            return "$event." + keyModifier + "Key";
                        }).join('||'));
                    }
                    else {
                        keys.push(key);
                    }
                }
                if (keys.length) {
                    code += genKeyFilter(keys);
                } // Make sure modifiers like prevent and stop get executed after key filtering
                if (genModifierCode) {
                    code += genModifierCode;
                }
                var handlerCode = isMethodPath ? "return " + handler.value + "($event)" : isFunctionExpression ? "return (" + handler.value + ")($event)" : isFunctionInvocation ? "return " + handler.value : handler.value;
                return "function($event){" + code + handlerCode + "}";
            }
        }
        function genKeyFilter(keys) {
            return ( // make sure the key filters only apply to KeyboardEvents
            // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake
            // key events that do not have keyCode property...
            "if(!$event.type.indexOf('key')&&" + keys.map(genFilterCode).join('&&') + ")return null;");
        }
        function genFilterCode(key) {
            var keyVal = parseInt(key, 10);
            if (keyVal) {
                return "$event.keyCode!==" + keyVal;
            }
            var keyCode = keyCodes[key];
            var keyName = keyNames[key];
            return "_k($event.keyCode," + JSON.stringify(key) + "," + JSON.stringify(keyCode) + "," + "$event.key," + "" + JSON.stringify(keyName) + ")";
        }
        /*  */
        function on(el, dir) {
            if (dir.modifiers) {
                warn("v-on without argument does not support modifiers.");
            }
            el.wrapListeners = function (code) {
                return "_g(" + code + "," + dir.value + ")";
            };
        }
        /*  */
        function bind$1(el, dir) {
            el.wrapData = function (code) {
                return "_b(" + code + ",'" + el.tag + "'," + dir.value + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")";
            };
        }
        /*  */
        var baseDirectives$1 = {
            on: on,
            bind: bind$1,
            cloak: noop
        };
        /*  */
        var CodegenState = function CodegenState(options) {
            this.options = options;
            this.warn = options.warn || baseWarn;
            this.transforms = pluckModuleFunction(options.modules, 'transformCode');
            this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
            this.directives = extend(extend({}, baseDirectives$1), options.directives);
            var isReservedTag = options.isReservedTag || no;
            this.maybeComponent = function (el) {
                return !!el.component || !isReservedTag(el.tag);
            };
            this.onceId = 0;
            this.staticRenderFns = [];
            this.pre = false;
        };
        function generate(ast, options) {
            var state = new CodegenState(options);
            var code = ast ? genElement(ast, state) : '_c("div")';
            return {
                render: "with(this){return " + code + "}",
                staticRenderFns: state.staticRenderFns
            };
        }
        function genElement(el, state) {
            if (el.parent) {
                el.pre = el.pre || el.parent.pre;
            }
            if (el.staticRoot && !el.staticProcessed) {
                return genStatic(el, state);
            }
            else if (el.once && !el.onceProcessed) {
                return genOnce(el, state);
            }
            else if (el.for && !el.forProcessed) {
                return genFor(el, state);
            }
            else if (el.if && !el.ifProcessed) {
                return genIf(el, state);
            }
            else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
                return genChildren(el, state) || 'void 0';
            }
            else if (el.tag === 'slot') {
                return genSlot(el, state);
            }
            else {
                // component or element
                var code;
                if (el.component) {
                    code = genComponent(el.component, el, state);
                }
                else {
                    var data;
                    if (!el.plain || el.pre && state.maybeComponent(el)) {
                        data = genData$2(el, state);
                    }
                    var children = el.inlineTemplate ? null : genChildren(el, state, true);
                    code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
                } // module transforms
                for (var i = 0; i < state.transforms.length; i++) {
                    code = state.transforms[i](el, code);
                }
                return code;
            }
        } // hoist static sub-trees out
        function genStatic(el, state) {
            el.staticProcessed = true; // Some elements (templates) need to behave differently inside of a v-pre
            // node.  All pre nodes are static roots, so we can use this as a location to
            // wrap a state change and reset it upon exiting the pre node.
            var originalPreState = state.pre;
            if (el.pre) {
                state.pre = el.pre;
            }
            state.staticRenderFns.push("with(this){return " + genElement(el, state) + "}");
            state.pre = originalPreState;
            return "_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")";
        } // v-once
        function genOnce(el, state) {
            el.onceProcessed = true;
            if (el.if && !el.ifProcessed) {
                return genIf(el, state);
            }
            else if (el.staticInFor) {
                var key = '';
                var parent = el.parent;
                while (parent) {
                    if (parent.for) {
                        key = parent.key;
                        break;
                    }
                    parent = parent.parent;
                }
                if (!key) {
                    state.warn("v-once can only be used inside v-for that is keyed. ", el.rawAttrsMap['v-once']);
                    return genElement(el, state);
                }
                return "_o(" + genElement(el, state) + "," + state.onceId++ + "," + key + ")";
            }
            else {
                return genStatic(el, state);
            }
        }
        function genIf(el, state, altGen, altEmpty) {
            el.ifProcessed = true; // avoid recursion
            return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
        }
        function genIfConditions(conditions, state, altGen, altEmpty) {
            if (!conditions.length) {
                return altEmpty || '_e()';
            }
            var condition = conditions.shift();
            if (condition.exp) {
                return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions, state, altGen, altEmpty);
            }
            else {
                return "" + genTernaryExp(condition.block);
            } // v-if with v-once should generate code like (a)?_m(0):_m(1)
            function genTernaryExp(el) {
                return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
            }
        }
        function genFor(el, state, altGen, altHelper) {
            var exp = el.for;
            var alias = el.alias;
            var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
            var iterator2 = el.iterator2 ? "," + el.iterator2 : '';
            if (state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {
                state.warn("<" + el.tag + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " + "v-for should have explicit keys. " + "See https://vuejs.org/guide/list.html#key for more info.", el.rawAttrsMap['v-for'], true
                /* tip */
                );
            }
            el.forProcessed = true; // avoid recursion
            return (altHelper || '_l') + "((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + (altGen || genElement)(el, state) + '})';
        }
        function genData$2(el, state) {
            var data = '{'; // directives first.
            // directives may mutate the el's other properties before they are generated.
            var dirs = genDirectives(el, state);
            if (dirs) {
                data += dirs + ',';
            } // key
            if (el.key) {
                data += "key:" + el.key + ",";
            } // ref
            if (el.ref) {
                data += "ref:" + el.ref + ",";
            }
            if (el.refInFor) {
                data += "refInFor:true,";
            } // pre
            if (el.pre) {
                data += "pre:true,";
            } // record original tag name for components using "is" attribute
            if (el.component) {
                data += "tag:\"" + el.tag + "\",";
            } // module data generation functions
            for (var i = 0; i < state.dataGenFns.length; i++) {
                data += state.dataGenFns[i](el);
            } // attributes
            if (el.attrs) {
                data += "attrs:" + genProps(el.attrs) + ",";
            } // DOM props
            if (el.props) {
                data += "domProps:" + genProps(el.props) + ",";
            } // event handlers
            if (el.events) {
                data += genHandlers(el.events, false) + ",";
            }
            if (el.nativeEvents) {
                data += genHandlers(el.nativeEvents, true) + ",";
            } // slot target
            // only for non-scoped slots
            if (el.slotTarget && !el.slotScope) {
                data += "slot:" + el.slotTarget + ",";
            } // scoped slots
            if (el.scopedSlots) {
                data += genScopedSlots(el, el.scopedSlots, state) + ",";
            } // component v-model
            if (el.model) {
                data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
            } // inline-template
            if (el.inlineTemplate) {
                var inlineTemplate = genInlineTemplate(el, state);
                if (inlineTemplate) {
                    data += inlineTemplate + ",";
                }
            }
            data = data.replace(/,$/, '') + '}'; // v-bind dynamic argument wrap
            // v-bind with dynamic arguments must be applied using the same v-bind object
            // merge helper so that class/style/mustUseProp attrs are handled correctly.
            if (el.dynamicAttrs) {
                data = "_b(" + data + ",\"" + el.tag + "\"," + genProps(el.dynamicAttrs) + ")";
            } // v-bind data wrap
            if (el.wrapData) {
                data = el.wrapData(data);
            } // v-on data wrap
            if (el.wrapListeners) {
                data = el.wrapListeners(data);
            }
            return data;
        }
        function genDirectives(el, state) {
            var dirs = el.directives;
            if (!dirs) {
                return;
            }
            var res = 'directives:[';
            var hasRuntime = false;
            var i, l, dir, needRuntime;
            for (i = 0, l = dirs.length; i < l; i++) {
                dir = dirs[i];
                needRuntime = true;
                var gen = state.directives[dir.name];
                if (gen) {
                    // compile-time directive that manipulates AST.
                    // returns true if it also needs a runtime counterpart.
                    needRuntime = !!gen(el, dir, state.warn);
                }
                if (needRuntime) {
                    hasRuntime = true;
                    res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:" + (dir.isDynamicArg ? dir.arg : "\"" + dir.arg + "\"") : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
                }
            }
            if (hasRuntime) {
                return res.slice(0, -1) + ']';
            }
        }
        function genInlineTemplate(el, state) {
            var ast = el.children[0];
            if (el.children.length !== 1 || ast.type !== 1) {
                state.warn('Inline-template components must have exactly one child element.', {
                    start: el.start
                });
            }
            if (ast && ast.type === 1) {
                var inlineRenderFns = generate(ast, state.options);
                return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
                    return "function(){" + code + "}";
                }).join(',') + "]}";
            }
        }
        function genScopedSlots(el, slots, state) {
            // by default scoped slots are considered "stable", this allows child
            // components with only scoped slots to skip forced updates from parent.
            // but in some cases we have to bail-out of this optimization
            // for example if the slot contains dynamic names, has v-if or v-for on them...
            var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {
                var slot = slots[key];
                return slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot) // is passing down slot from parent which may be dynamic
                ;
            }); // #9534: if a component with scoped slots is inside a conditional branch,
            // it's possible for the same component to be reused but with different
            // compiled slot content. To avoid that, we generate a unique key based on
            // the generated code of all the slot contents.
            var needsKey = !!el.if; // OR when it is inside another scoped slot or v-for (the reactivity may be
            // disconnected due to the intermediate scope variable)
            // #9438, #9506
            // TODO: this can be further optimized by properly analyzing in-scope bindings
            // and skip force updating ones that do not actually use scope variables.
            if (!needsForceUpdate) {
                var parent = el.parent;
                while (parent) {
                    if (parent.slotScope && parent.slotScope !== emptySlotScopeToken || parent.for) {
                        needsForceUpdate = true;
                        break;
                    }
                    if (parent.if) {
                        needsKey = true;
                    }
                    parent = parent.parent;
                }
            }
            var generatedSlots = Object.keys(slots).map(function (key) {
                return genScopedSlot(slots[key], state);
            }).join(',');
            return "scopedSlots:_u([" + generatedSlots + "]" + (needsForceUpdate ? ",null,true" : "") + (!needsForceUpdate && needsKey ? ",null,false," + hash(generatedSlots) : "") + ")";
        }
        function hash(str) {
            var hash = 5381;
            var i = str.length;
            while (i) {
                hash = hash * 33 ^ str.charCodeAt(--i);
            }
            return hash >>> 0;
        }
        function containsSlotChild(el) {
            if (el.type === 1) {
                if (el.tag === 'slot') {
                    return true;
                }
                return el.children.some(containsSlotChild);
            }
            return false;
        }
        function genScopedSlot(el, state) {
            var isLegacySyntax = el.attrsMap['slot-scope'];
            if (el.if && !el.ifProcessed && !isLegacySyntax) {
                return genIf(el, state, genScopedSlot, "null");
            }
            if (el.for && !el.forProcessed) {
                return genFor(el, state, genScopedSlot);
            }
            var slotScope = el.slotScope === emptySlotScopeToken ? "" : String(el.slotScope);
            var fn = "function(" + slotScope + "){" + "return " + (el.tag === 'template' ? el.if && isLegacySyntax ? "(" + el.if + ")?" + (genChildren(el, state) || 'undefined') + ":undefined" : genChildren(el, state) || 'undefined' : genElement(el, state)) + "}"; // reverse proxy v-slot without scope on this.$slots
            var reverseProxy = slotScope ? "" : ",proxy:true";
            return "{key:" + (el.slotTarget || "\"default\"") + ",fn:" + fn + reverseProxy + "}";
        }
        function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
            var children = el.children;
            if (children.length) {
                var el$1 = children[0]; // optimize single v-for
                if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
                    var normalizationType = checkSkip ? state.maybeComponent(el$1) ? ",1" : ",0" : "";
                    return "" + (altGenElement || genElement)(el$1, state) + normalizationType;
                }
                var normalizationType$1 = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;
                var gen = altGenNode || genNode;
                return "[" + children.map(function (c) {
                    return gen(c, state);
                }).join(',') + "]" + (normalizationType$1 ? "," + normalizationType$1 : '');
            }
        } // determine the normalization needed for the children array.
        // 0: no normalization needed
        // 1: simple normalization needed (possible 1-level deep nested array)
        // 2: full normalization needed
        function getNormalizationType(children, maybeComponent) {
            var res = 0;
            for (var i = 0; i < children.length; i++) {
                var el = children[i];
                if (el.type !== 1) {
                    continue;
                }
                if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
                    return needsNormalization(c.block);
                })) {
                    res = 2;
                    break;
                }
                if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
                    return maybeComponent(c.block);
                })) {
                    res = 1;
                }
            }
            return res;
        }
        function needsNormalization(el) {
            return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
        }
        function genNode(node, state) {
            if (node.type === 1) {
                return genElement(node, state);
            }
            else if (node.type === 3 && node.isComment) {
                return genComment(node);
            }
            else {
                return genText(node);
            }
        }
        function genText(text) {
            return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
                : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
        }
        function genComment(comment) {
            return "_e(" + JSON.stringify(comment.text) + ")";
        }
        function genSlot(el, state) {
            var slotName = el.slotName || '"default"';
            var children = genChildren(el, state);
            var res = "_t(" + slotName + (children ? "," + children : '');
            var attrs = el.attrs || el.dynamicAttrs ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) {
                return {
                    // slot props are camelized
                    name: camelize(attr.name),
                    value: attr.value,
                    dynamic: attr.dynamic
                };
            })) : null;
            var bind$$1 = el.attrsMap['v-bind'];
            if ((attrs || bind$$1) && !children) {
                res += ",null";
            }
            if (attrs) {
                res += "," + attrs;
            }
            if (bind$$1) {
                res += (attrs ? '' : ',null') + "," + bind$$1;
            }
            return res + ')';
        } // componentName is el.component, take it as argument to shun flow's pessimistic refinement
        function genComponent(componentName, el, state) {
            var children = el.inlineTemplate ? null : genChildren(el, state, true);
            return "_c(" + componentName + "," + genData$2(el, state) + (children ? "," + children : '') + ")";
        }
        function genProps(props) {
            var staticProps = "";
            var dynamicProps = "";
            for (var i = 0; i < props.length; i++) {
                var prop = props[i];
                var value = transformSpecialNewlines(prop.value);
                if (prop.dynamic) {
                    dynamicProps += prop.name + "," + value + ",";
                }
                else {
                    staticProps += "\"" + prop.name + "\":" + value + ",";
                }
            }
            staticProps = "{" + staticProps.slice(0, -1) + "}";
            if (dynamicProps) {
                return "_d(" + staticProps + ",[" + dynamicProps.slice(0, -1) + "])";
            }
            else {
                return staticProps;
            }
        } // #3895, #4268
        function transformSpecialNewlines(text) {
            return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
        }
        /*  */
        var plainStringRE = /^"(?:[^"\\]|\\.)*"$|^'(?:[^'\\]|\\.)*'$/; // let the model AST transform translate v-model into appropriate
        // props bindings
        function applyModelTransform(el, state) {
            if (el.directives) {
                for (var i = 0; i < el.directives.length; i++) {
                    var dir = el.directives[i];
                    if (dir.name === 'model') {
                        state.directives.model(el, dir, state.warn); // remove value for textarea as its converted to text
                        if (el.tag === 'textarea' && el.props) {
                            el.props = el.props.filter(function (p) {
                                return p.name !== 'value';
                            });
                        }
                        break;
                    }
                }
            }
        }
        function genAttrSegments(attrs) {
            return attrs.map(function (ref) {
                var name = ref.name;
                var value = ref.value;
                return genAttrSegment(name, value);
            });
        }
        function genDOMPropSegments(props, attrs) {
            var segments = [];
            props.forEach(function (ref) {
                var name = ref.name;
                var value = ref.value;
                name = propsToAttrMap[name] || name.toLowerCase();
                if (isRenderableAttr(name) && !(attrs && attrs.some(function (a) {
                    return a.name === name;
                }))) {
                    segments.push(genAttrSegment(name, value));
                }
            });
            return segments;
        }
        function genAttrSegment(name, value) {
            if (plainStringRE.test(value)) {
                // force double quote
                value = value.replace(/^'|'$/g, '"'); // force enumerated attr to "true"
                if (isEnumeratedAttr(name) && value !== "\"false\"") {
                    value = "\"true\"";
                }
                return {
                    type: RAW,
                    value: isBooleanAttr(name) ? " " + name + "=\"" + name + "\"" : value === '""' ? " " + name : " " + name + "=\"" + JSON.parse(value) + "\""
                };
            }
            else {
                return {
                    type: EXPRESSION,
                    value: "_ssrAttr(" + JSON.stringify(name) + "," + value + ")"
                };
            }
        }
        function genClassSegments(staticClass, classBinding) {
            if (staticClass && !classBinding) {
                return [{
                        type: RAW,
                        value: " class=\"" + JSON.parse(staticClass) + "\""
                    }];
            }
            else {
                return [{
                        type: EXPRESSION,
                        value: "_ssrClass(" + (staticClass || 'null') + "," + (classBinding || 'null') + ")"
                    }];
            }
        }
        function genStyleSegments(staticStyle, parsedStaticStyle, styleBinding, vShowExpression) {
            if (staticStyle && !styleBinding && !vShowExpression) {
                return [{
                        type: RAW,
                        value: " style=" + JSON.stringify(staticStyle)
                    }];
            }
            else {
                return [{
                        type: EXPRESSION,
                        value: "_ssrStyle(" + (parsedStaticStyle || 'null') + "," + (styleBinding || 'null') + ", " + (vShowExpression ? "{ display: (" + vShowExpression + ") ? '' : 'none' }" : 'null') + ")"
                    }];
            }
        }
        /*  */
        // optimizability constants
        var optimizability = {
            FALSE: 0,
            // whole sub tree un-optimizable
            FULL: 1,
            // whole sub tree optimizable
            SELF: 2,
            // self optimizable but has some un-optimizable children
            CHILDREN: 3,
            // self un-optimizable but have fully optimizable children
            PARTIAL: 4 // self un-optimizable with some un-optimizable children
        };
        var isPlatformReservedTag;
        function optimize(root, options) {
            if (!root) {
                return;
            }
            isPlatformReservedTag = options.isReservedTag || no;
            walk(root, true);
        }
        function walk(node, isRoot) {
            if (isUnOptimizableTree(node)) {
                node.ssrOptimizability = optimizability.FALSE;
                return;
            } // root node or nodes with custom directives should always be a VNode
            var selfUnoptimizable = isRoot || hasCustomDirective(node);
            var check = function (child) {
                if (child.ssrOptimizability !== optimizability.FULL) {
                    node.ssrOptimizability = selfUnoptimizable ? optimizability.PARTIAL : optimizability.SELF;
                }
            };
            if (selfUnoptimizable) {
                node.ssrOptimizability = optimizability.CHILDREN;
            }
            if (node.type === 1) {
                for (var i = 0, l = node.children.length; i < l; i++) {
                    var child = node.children[i];
                    walk(child);
                    check(child);
                }
                if (node.ifConditions) {
                    for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
                        var block = node.ifConditions[i$1].block;
                        walk(block, isRoot);
                        check(block);
                    }
                }
                if (node.ssrOptimizability == null || !isRoot && (node.attrsMap['v-html'] || node.attrsMap['v-text'])) {
                    node.ssrOptimizability = optimizability.FULL;
                }
                else {
                    node.children = optimizeSiblings(node);
                }
            }
            else {
                node.ssrOptimizability = optimizability.FULL;
            }
        }
        function optimizeSiblings(el) {
            var children = el.children;
            var optimizedChildren = [];
            var currentOptimizableGroup = [];
            var pushGroup = function () {
                if (currentOptimizableGroup.length) {
                    optimizedChildren.push({
                        type: 1,
                        parent: el,
                        tag: 'template',
                        attrsList: [],
                        attrsMap: {},
                        rawAttrsMap: {},
                        children: currentOptimizableGroup,
                        ssrOptimizability: optimizability.FULL
                    });
                }
                currentOptimizableGroup = [];
            };
            for (var i = 0; i < children.length; i++) {
                var c = children[i];
                if (c.ssrOptimizability === optimizability.FULL) {
                    currentOptimizableGroup.push(c);
                }
                else {
                    // wrap fully-optimizable adjacent siblings inside a template tag
                    // so that they can be optimized into a single ssrNode by codegen
                    pushGroup();
                    optimizedChildren.push(c);
                }
            }
            pushGroup();
            return optimizedChildren;
        }
        function isUnOptimizableTree(node) {
            if (node.type === 2 || node.type === 3) {
                // text or expression
                return false;
            }
            return isBuiltInTag(node.tag) || // built-in (slot, component)
                !isPlatformReservedTag(node.tag) || // custom component
                !!node.component || // "is" component
                isSelectWithModel(node) // <select v-model> requires runtime inspection
            ;
        }
        var isBuiltInDir = makeMap('text,html,show,on,bind,model,pre,cloak,once');
        function hasCustomDirective(node) {
            return node.type === 1 && node.directives && node.directives.some(function (d) {
                return !isBuiltInDir(d.name);
            });
        } // <select v-model> cannot be optimized because it requires a runtime check
        // to determine proper selected option
        function isSelectWithModel(node) {
            return node.type === 1 && node.tag === 'select' && node.directives != null && node.directives.some(function (d) {
                return d.name === 'model';
            });
        }
        /*  */
        // segment types
        var RAW = 0;
        var INTERPOLATION = 1;
        var EXPRESSION = 2;
        function generate$1(ast, options) {
            var state = new CodegenState(options);
            var code = ast ? genSSRElement(ast, state) : '_c("div")';
            return {
                render: "with(this){return " + code + "}",
                staticRenderFns: state.staticRenderFns
            };
        }
        function genSSRElement(el, state) {
            if (el.for && !el.forProcessed) {
                return genFor(el, state, genSSRElement);
            }
            else if (el.if && !el.ifProcessed) {
                return genIf(el, state, genSSRElement);
            }
            else if (el.tag === 'template' && !el.slotTarget) {
                return el.ssrOptimizability === optimizability.FULL ? genChildrenAsStringNode(el, state) : genSSRChildren(el, state) || 'void 0';
            }
            switch (el.ssrOptimizability) {
                case optimizability.FULL:
                    // stringify whole tree
                    return genStringElement(el, state);
                case optimizability.SELF:
                    // stringify self and check children
                    return genStringElementWithChildren(el, state);
                case optimizability.CHILDREN:
                    // generate self as VNode and stringify children
                    return genNormalElement(el, state, true);
                case optimizability.PARTIAL:
                    // generate self as VNode and check children
                    return genNormalElement(el, state, false);
                default:
                    // bail whole tree
                    return genElement(el, state);
            }
        }
        function genNormalElement(el, state, stringifyChildren) {
            var data = el.plain ? undefined : genData$2(el, state);
            var children = stringifyChildren ? "[" + genChildrenAsStringNode(el, state) + "]" : genSSRChildren(el, state, true);
            return "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
        }
        function genSSRChildren(el, state, checkSkip) {
            return genChildren(el, state, checkSkip, genSSRElement, genSSRNode);
        }
        function genSSRNode(el, state) {
            return el.type === 1 ? genSSRElement(el, state) : genText(el);
        }
        function genChildrenAsStringNode(el, state) {
            return el.children.length ? "_ssrNode(" + flattenSegments(childrenToSegments(el, state)) + ")" : '';
        }
        function genStringElement(el, state) {
            return "_ssrNode(" + elementToString(el, state) + ")";
        }
        function genStringElementWithChildren(el, state) {
            var children = genSSRChildren(el, state, true);
            return "_ssrNode(" + flattenSegments(elementToOpenTagSegments(el, state)) + ",\"</" + el.tag + ">\"" + (children ? "," + children : '') + ")";
        }
        function elementToString(el, state) {
            return "(" + flattenSegments(elementToSegments(el, state)) + ")";
        }
        function elementToSegments(el, state) {
            // v-for / v-if
            if (el.for && !el.forProcessed) {
                el.forProcessed = true;
                return [{
                        type: EXPRESSION,
                        value: genFor(el, state, elementToString, '_ssrList')
                    }];
            }
            else if (el.if && !el.ifProcessed) {
                el.ifProcessed = true;
                return [{
                        type: EXPRESSION,
                        value: genIf(el, state, elementToString, '"<!---->"')
                    }];
            }
            else if (el.tag === 'template') {
                return childrenToSegments(el, state);
            }
            var openSegments = elementToOpenTagSegments(el, state);
            var childrenSegments = childrenToSegments(el, state);
            var ref = state.options;
            var isUnaryTag = ref.isUnaryTag;
            var close = isUnaryTag && isUnaryTag(el.tag) ? [] : [{
                    type: RAW,
                    value: "</" + el.tag + ">"
                }];
            return openSegments.concat(childrenSegments, close);
        }
        function elementToOpenTagSegments(el, state) {
            applyModelTransform(el, state);
            var binding;
            var segments = [{
                    type: RAW,
                    value: "<" + el.tag
                }]; // attrs
            if (el.attrs) {
                segments.push.apply(segments, genAttrSegments(el.attrs));
            } // domProps
            if (el.props) {
                segments.push.apply(segments, genDOMPropSegments(el.props, el.attrs));
            } // v-bind="object"
            if (binding = el.attrsMap['v-bind']) {
                segments.push({
                    type: EXPRESSION,
                    value: "_ssrAttrs(" + binding + ")"
                });
            } // v-bind.prop="object"
            if (binding = el.attrsMap['v-bind.prop']) {
                segments.push({
                    type: EXPRESSION,
                    value: "_ssrDOMProps(" + binding + ")"
                });
            } // class
            if (el.staticClass || el.classBinding) {
                segments.push.apply(segments, genClassSegments(el.staticClass, el.classBinding));
            } // style & v-show
            if (el.staticStyle || el.styleBinding || el.attrsMap['v-show']) {
                segments.push.apply(segments, genStyleSegments(el.attrsMap.style, el.staticStyle, el.styleBinding, el.attrsMap['v-show']));
            } // _scopedId
            if (state.options.scopeId) {
                segments.push({
                    type: RAW,
                    value: " " + state.options.scopeId
                });
            }
            segments.push({
                type: RAW,
                value: ">"
            });
            return segments;
        }
        function childrenToSegments(el, state) {
            var binding;
            if (binding = el.attrsMap['v-html']) {
                return [{
                        type: EXPRESSION,
                        value: "_s(" + binding + ")"
                    }];
            }
            if (binding = el.attrsMap['v-text']) {
                return [{
                        type: INTERPOLATION,
                        value: "_s(" + binding + ")"
                    }];
            }
            if (el.tag === 'textarea' && (binding = el.attrsMap['v-model'])) {
                return [{
                        type: INTERPOLATION,
                        value: "_s(" + binding + ")"
                    }];
            }
            return el.children ? nodesToSegments(el.children, state) : [];
        }
        function nodesToSegments(children, state) {
            var segments = [];
            for (var i = 0; i < children.length; i++) {
                var c = children[i];
                if (c.type === 1) {
                    segments.push.apply(segments, elementToSegments(c, state));
                }
                else if (c.type === 2) {
                    segments.push({
                        type: INTERPOLATION,
                        value: c.expression
                    });
                }
                else if (c.type === 3) {
                    var text = escape(c.text);
                    if (c.isComment) {
                        text = '<!--' + text + '-->';
                    }
                    segments.push({
                        type: RAW,
                        value: text
                    });
                }
            }
            return segments;
        }
        function flattenSegments(segments) {
            var mergedSegments = [];
            var textBuffer = '';
            var pushBuffer = function () {
                if (textBuffer) {
                    mergedSegments.push(JSON.stringify(textBuffer));
                    textBuffer = '';
                }
            };
            for (var i = 0; i < segments.length; i++) {
                var s = segments[i];
                if (s.type === RAW) {
                    textBuffer += s.value;
                }
                else if (s.type === INTERPOLATION) {
                    pushBuffer();
                    mergedSegments.push("_ssrEscape(" + s.value + ")");
                }
                else if (s.type === EXPRESSION) {
                    pushBuffer();
                    mergedSegments.push("(" + s.value + ")");
                }
            }
            pushBuffer();
            return mergedSegments.join('+');
        }
        /*  */
        // these keywords should not appear inside expressions, but operators like
        // typeof, instanceof and in are allowed
        var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b'); // these unary operators should not be used as property/method names
        var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)'); // strip strings in expressions
        var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g; // detect problematic expressions in a template
        function detectErrors(ast, warn) {
            if (ast) {
                checkNode(ast, warn);
            }
        }
        function checkNode(node, warn) {
            if (node.type === 1) {
                for (var name in node.attrsMap) {
                    if (dirRE.test(name)) {
                        var value = node.attrsMap[name];
                        if (value) {
                            var range = node.rawAttrsMap[name];
                            if (name === 'v-for') {
                                checkFor(node, "v-for=\"" + value + "\"", warn, range);
                            }
                            else if (name === 'v-slot' || name[0] === '#') {
                                checkFunctionParameterExpression(value, name + "=\"" + value + "\"", warn, range);
                            }
                            else if (onRE.test(name)) {
                                checkEvent(value, name + "=\"" + value + "\"", warn, range);
                            }
                            else {
                                checkExpression(value, name + "=\"" + value + "\"", warn, range);
                            }
                        }
                    }
                }
                if (node.children) {
                    for (var i = 0; i < node.children.length; i++) {
                        checkNode(node.children[i], warn);
                    }
                }
            }
            else if (node.type === 2) {
                checkExpression(node.expression, node.text, warn, node);
            }
        }
        function checkEvent(exp, text, warn, range) {
            var stripped = exp.replace(stripStringRE, '');
            var keywordMatch = stripped.match(unaryOperatorsRE);
            if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== '$') {
                warn("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim(), range);
            }
            checkExpression(exp, text, warn, range);
        }
        function checkFor(node, text, warn, range) {
            checkExpression(node.for || '', text, warn, range);
            checkIdentifier(node.alias, 'v-for alias', text, warn, range);
            checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);
            checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);
        }
        function checkIdentifier(ident, type, text, warn, range) {
            if (typeof ident === 'string') {
                try {
                    new Function("var " + ident + "=_");
                }
                catch (e) {
                    warn("invalid " + type + " \"" + ident + "\" in expression: " + text.trim(), range);
                }
            }
        }
        function checkExpression(exp, text, warn, range) {
            try {
                new Function("return " + exp);
            }
            catch (e) {
                var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
                if (keywordMatch) {
                    warn("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\"\n  Raw expression: " + text.trim(), range);
                }
                else {
                    warn("invalid expression: " + e.message + " in\n\n" + "    " + exp + "\n\n" + "  Raw expression: " + text.trim() + "\n", range);
                }
            }
        }
        function checkFunctionParameterExpression(exp, text, warn, range) {
            try {
                new Function(exp, '');
            }
            catch (e) {
                warn("invalid function parameter expression: " + e.message + " in\n\n" + "    " + exp + "\n\n" + "  Raw expression: " + text.trim() + "\n", range);
            }
        }
        /*  */
        var range = 2;
        function generateCodeFrame(source, start, end) {
            if (start === void 0)
                start = 0;
            if (end === void 0)
                end = source.length;
            var lines = source.split(/\r?\n/);
            var count = 0;
            var res = [];
            for (var i = 0; i < lines.length; i++) {
                count += lines[i].length + 1;
                if (count >= start) {
                    for (var j = i - range; j <= i + range || end > count; j++) {
                        if (j < 0 || j >= lines.length) {
                            continue;
                        }
                        res.push("" + (j + 1) + repeat$1(" ", 3 - String(j + 1).length) + "|  " + lines[j]);
                        var lineLength = lines[j].length;
                        if (j === i) {
                            // push underline
                            var pad = start - (count - lineLength) + 1;
                            var length = end > count ? lineLength - pad : end - start;
                            res.push("   |  " + repeat$1(" ", pad) + repeat$1("^", length));
                        }
                        else if (j > i) {
                            if (end > count) {
                                var length$1 = Math.min(end - count, lineLength);
                                res.push("   |  " + repeat$1("^", length$1));
                            }
                            count += lineLength + 1;
                        }
                    }
                    break;
                }
            }
            return res.join('\n');
        }
        function repeat$1(str, n) {
            var result = '';
            if (n > 0) {
                while (true) {
                    // eslint-disable-line
                    if (n & 1) {
                        result += str;
                    }
                    n >>>= 1;
                    if (n <= 0) {
                        break;
                    }
                    str += str;
                }
            }
            return result;
        }
        /*  */
        function createFunction(code, errors) {
            try {
                return new Function(code);
            }
            catch (err) {
                errors.push({
                    err: err,
                    code: code
                });
                return noop;
            }
        }
        function createCompileToFunctionFn(compile) {
            var cache = Object.create(null);
            return function compileToFunctions(template, options, vm) {
                options = extend({}, options);
                var warn$$1 = options.warn || warn;
                delete options.warn;
                /* istanbul ignore if */
                {
                    // detect possible CSP restriction
                    try {
                        new Function('return 1');
                    }
                    catch (e) {
                        if (e.toString().match(/unsafe-eval|CSP/)) {
                            warn$$1('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');
                        }
                    }
                } // check cache
                var key = options.delimiters ? String(options.delimiters) + template : template;
                if (cache[key]) {
                    return cache[key];
                } // compile
                var compiled = compile(template, options); // check compilation errors/tips
                {
                    if (compiled.errors && compiled.errors.length) {
                        if (options.outputSourceRange) {
                            compiled.errors.forEach(function (e) {
                                warn$$1("Error compiling template:\n\n" + e.msg + "\n\n" + generateCodeFrame(template, e.start, e.end), vm);
                            });
                        }
                        else {
                            warn$$1("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function (e) {
                                return "- " + e;
                            }).join('\n') + '\n', vm);
                        }
                    }
                    if (compiled.tips && compiled.tips.length) {
                        if (options.outputSourceRange) {
                            compiled.tips.forEach(function (e) {
                                return tip(e.msg, vm);
                            });
                        }
                        else {
                            compiled.tips.forEach(function (msg) {
                                return tip(msg, vm);
                            });
                        }
                    }
                } // turn code into functions
                var res = {};
                var fnGenErrors = [];
                res.render = createFunction(compiled.render, fnGenErrors);
                res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
                    return createFunction(code, fnGenErrors);
                }); // check function generation errors.
                // this should only happen if there is a bug in the compiler itself.
                // mostly for codegen development use
                /* istanbul ignore if */
                {
                    if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
                        warn$$1("Failed to generate render function:\n\n" + fnGenErrors.map(function (ref) {
                            var err = ref.err;
                            var code = ref.code;
                            return err.toString() + " in\n\n" + code + "\n";
                        }).join('\n'), vm);
                    }
                }
                return cache[key] = res;
            };
        }
        /*  */
        function createCompilerCreator(baseCompile) {
            return function createCompiler(baseOptions) {
                function compile(template, options) {
                    var finalOptions = Object.create(baseOptions);
                    var errors = [];
                    var tips = [];
                    var warn = function (msg, range, tip) {
                        (tip ? tips : errors).push(msg);
                    };
                    if (options) {
                        if (options.outputSourceRange) {
                            // $flow-disable-line
                            var leadingSpaceLength = template.match(/^\s*/)[0].length;
                            warn = function (msg, range, tip) {
                                var data = {
                                    msg: msg
                                };
                                if (range) {
                                    if (range.start != null) {
                                        data.start = range.start + leadingSpaceLength;
                                    }
                                    if (range.end != null) {
                                        data.end = range.end + leadingSpaceLength;
                                    }
                                }
                                (tip ? tips : errors).push(data);
                            };
                        } // merge custom modules
                        if (options.modules) {
                            finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
                        } // merge custom directives
                        if (options.directives) {
                            finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);
                        } // copy other options
                        for (var key in options) {
                            if (key !== 'modules' && key !== 'directives') {
                                finalOptions[key] = options[key];
                            }
                        }
                    }
                    finalOptions.warn = warn;
                    var compiled = baseCompile(template.trim(), finalOptions);
                    {
                        detectErrors(compiled.ast, warn);
                    }
                    compiled.errors = errors;
                    compiled.tips = tips;
                    return compiled;
                }
                return {
                    compile: compile,
                    compileToFunctions: createCompileToFunctionFn(compile)
                };
            };
        }
        /*  */
        var createCompiler = createCompilerCreator(function baseCompile(template, options) {
            var ast = parse(template.trim(), options);
            optimize(ast, options);
            var code = generate$1(ast, options);
            return {
                ast: ast,
                render: code.render,
                staticRenderFns: code.staticRenderFns
            };
        });
        /*  */
        var ref = createCompiler(baseOptions);
        var compile = ref.compile;
        var compileToFunctions = ref.compileToFunctions;
        /*  */
        // The template compiler attempts to minimize the need for normalization by
        // statically analyzing the template at compile time.
        //
        // For plain HTML markup, normalization can be completely skipped because the
        // generated render function is guaranteed to return Array<VNode>. There are
        // two cases where extra normalization is needed:
        // 1. When the children contains components - because a functional component
        // may return an Array instead of a single root. In this case, just a simple
        // normalization is needed - if any child is an Array, we flatten the whole
        // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
        // because functional components already normalize their own children.
        function simpleNormalizeChildren(children) {
            for (var i = 0; i < children.length; i++) {
                if (Array.isArray(children[i])) {
                    return Array.prototype.concat.apply([], children);
                }
            }
            return children;
        } // 2. When the children contains constructs that always generated nested Arrays,
        // e.g. <template>, <slot>, v-for, or when the children is provided by user
        // with hand-written render functions / JSX. In such cases a full normalization
        // is needed to cater to all possible types of children values.
        function normalizeChildren(children) {
            return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
        }
        function isTextNode(node) {
            return isDef(node) && isDef(node.text) && isFalse(node.isComment);
        }
        function normalizeArrayChildren(children, nestedIndex) {
            var res = [];
            var i, c, lastIndex, last;
            for (i = 0; i < children.length; i++) {
                c = children[i];
                if (isUndef(c) || typeof c === 'boolean') {
                    continue;
                }
                lastIndex = res.length - 1;
                last = res[lastIndex]; //  nested
                if (Array.isArray(c)) {
                    if (c.length > 0) {
                        c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i); // merge adjacent text nodes
                        if (isTextNode(c[0]) && isTextNode(last)) {
                            res[lastIndex] = createTextVNode(last.text + c[0].text);
                            c.shift();
                        }
                        res.push.apply(res, c);
                    }
                }
                else if (isPrimitive(c)) {
                    if (isTextNode(last)) {
                        // merge adjacent text nodes
                        // this is necessary for SSR hydration because text nodes are
                        // essentially merged when rendered to HTML strings
                        res[lastIndex] = createTextVNode(last.text + c);
                    }
                    else if (c !== '') {
                        // convert primitive to vnode
                        res.push(createTextVNode(c));
                    }
                }
                else {
                    if (isTextNode(c) && isTextNode(last)) {
                        // merge adjacent text nodes
                        res[lastIndex] = createTextVNode(last.text + c.text);
                    }
                    else {
                        // default key for nested array children (likely generated by v-for)
                        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
                            c.key = "__vlist" + nestedIndex + "_" + i + "__";
                        }
                        res.push(c);
                    }
                }
            }
            return res;
        }
        /*  */
        var ssrHelpers = {
            _ssrEscape: escape,
            _ssrNode: renderStringNode,
            _ssrList: renderStringList,
            _ssrAttr: renderAttr,
            _ssrAttrs: renderAttrs$1,
            _ssrDOMProps: renderDOMProps$1,
            _ssrClass: renderSSRClass,
            _ssrStyle: renderSSRStyle
        };
        function installSSRHelpers(vm) {
            if (vm._ssrNode) {
                return;
            }
            var Vue = vm.constructor;
            while (Vue.super) {
                Vue = Vue.super;
            }
            extend(Vue.prototype, ssrHelpers);
            if (Vue.FunctionalRenderContext) {
                extend(Vue.FunctionalRenderContext.prototype, ssrHelpers);
            }
        }
        var StringNode = function StringNode(open, close, children, normalizationType) {
            this.isString = true;
            this.open = open;
            this.close = close;
            if (children) {
                this.children = normalizationType === 1 ? simpleNormalizeChildren(children) : normalizationType === 2 ? normalizeChildren(children) : children;
            }
            else {
                this.children = void 0;
            }
        };
        function renderStringNode(open, close, children, normalizationType) {
            return new StringNode(open, close, children, normalizationType);
        }
        function renderStringList(val, render) {
            var ret = '';
            var i, l, keys, key;
            if (Array.isArray(val) || typeof val === 'string') {
                for (i = 0, l = val.length; i < l; i++) {
                    ret += render(val[i], i);
                }
            }
            else if (typeof val === 'number') {
                for (i = 0; i < val; i++) {
                    ret += render(i + 1, i);
                }
            }
            else if (isObject(val)) {
                keys = Object.keys(val);
                for (i = 0, l = keys.length; i < l; i++) {
                    key = keys[i];
                    ret += render(val[key], key, i);
                }
            }
            return ret;
        }
        function renderAttrs$1(obj) {
            var res = '';
            for (var key in obj) {
                if (isSSRUnsafeAttr(key)) {
                    continue;
                }
                res += renderAttr(key, obj[key]);
            }
            return res;
        }
        function renderDOMProps$1(obj) {
            var res = '';
            for (var key in obj) {
                var attr = propsToAttrMap[key] || key.toLowerCase();
                if (isRenderableAttr(attr)) {
                    res += renderAttr(attr, obj[key]);
                }
            }
            return res;
        }
        function renderSSRClass(staticClass, dynamic) {
            var res = renderClass(staticClass, dynamic);
            return res === '' ? res : " class=\"" + escape(res) + "\"";
        }
        function renderSSRStyle(staticStyle, dynamic, extra) {
            var style = {};
            if (staticStyle) {
                extend(style, staticStyle);
            }
            if (dynamic) {
                extend(style, normalizeStyleBinding(dynamic));
            }
            if (extra) {
                extend(style, extra);
            }
            var res = genStyle(style);
            return res === '' ? res : " style=" + JSON.stringify(escape(res));
        }
        /* not type checking this file because flow doesn't play well with Proxy */
        {
            var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
            );
            var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);
            if (hasProxy) {
                var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
                config.keyCodes = new Proxy(config.keyCodes, {
                    set: function set(target, key, value) {
                        if (isBuiltInModifier(key)) {
                            warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
                            return false;
                        }
                        else {
                            target[key] = value;
                            return true;
                        }
                    }
                });
            }
        }
        /*  */
        var seenObjects = new _Set();
        /**
         * Recursively traverse an object to evoke all converted
         * getters, so that every nested property inside the object
         * is collected as a "deep" dependency.
         */
        function traverse(val) {
            _traverse(val, seenObjects);
            seenObjects.clear();
        }
        function _traverse(val, seen) {
            var i, keys;
            var isA = Array.isArray(val);
            if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {
                return;
            }
            if (val.__ob__) {
                var depId = val.__ob__.dep.id;
                if (seen.has(depId)) {
                    return;
                }
                seen.add(depId);
            }
            if (isA) {
                i = val.length;
                while (i--) {
                    _traverse(val[i], seen);
                }
            }
            else {
                keys = Object.keys(val);
                i = keys.length;
                while (i--) {
                    _traverse(val[keys[i]], seen);
                }
            }
        }
        {
            var perf = inBrowser && window.performance;
            /* istanbul ignore if */
            if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures)
                ;
        }
        /*  */
        var normalizeEvent = cached(function (name) {
            var passive = name.charAt(0) === '&';
            name = passive ? name.slice(1) : name;
            var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
            name = once$$1 ? name.slice(1) : name;
            var capture = name.charAt(0) === '!';
            name = capture ? name.slice(1) : name;
            return {
                name: name,
                once: once$$1,
                capture: capture,
                passive: passive
            };
        });
        function createFnInvoker(fns, vm) {
            function invoker() {
                var arguments$1 = arguments;
                var fns = invoker.fns;
                if (Array.isArray(fns)) {
                    var cloned = fns.slice();
                    for (var i = 0; i < cloned.length; i++) {
                        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
                    }
                }
                else {
                    // return handler return value for single handlers
                    return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler");
                }
            }
            invoker.fns = fns;
            return invoker;
        }
        function updateListeners(on, oldOn, add, remove$$1, createOnceHandler, vm) {
            var name, def$$1, cur, old, event;
            for (name in on) {
                def$$1 = cur = on[name];
                old = oldOn[name];
                event = normalizeEvent(name);
                if (isUndef(cur)) {
                    warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
                }
                else if (isUndef(old)) {
                    if (isUndef(cur.fns)) {
                        cur = on[name] = createFnInvoker(cur, vm);
                    }
                    if (isTrue(event.once)) {
                        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
                    }
                    add(event.name, cur, event.capture, event.passive, event.params);
                }
                else if (cur !== old) {
                    old.fns = cur;
                    on[name] = old;
                }
            }
            for (name in oldOn) {
                if (isUndef(on[name])) {
                    event = normalizeEvent(name);
                    remove$$1(event.name, oldOn[name], event.capture);
                }
            }
        }
        /*  */
        /*  */
        function extractPropsFromVNodeData(data, Ctor, tag) {
            // we are only extracting raw values here.
            // validation and default values are handled in the child
            // component itself.
            var propOptions = Ctor.options.props;
            if (isUndef(propOptions)) {
                return;
            }
            var res = {};
            var attrs = data.attrs;
            var props = data.props;
            if (isDef(attrs) || isDef(props)) {
                for (var key in propOptions) {
                    var altKey = hyphenate(key);
                    {
                        var keyInLowerCase = key.toLowerCase();
                        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
                            tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
                        }
                    }
                    checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
                }
            }
            return res;
        }
        function checkProp(res, hash, key, altKey, preserve) {
            if (isDef(hash)) {
                if (hasOwn(hash, key)) {
                    res[key] = hash[key];
                    if (!preserve) {
                        delete hash[key];
                    }
                    return true;
                }
                else if (hasOwn(hash, altKey)) {
                    res[key] = hash[altKey];
                    if (!preserve) {
                        delete hash[altKey];
                    }
                    return true;
                }
            }
            return false;
        }
        /*  */
        var SIMPLE_NORMALIZE = 1;
        var ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface
        // without getting yelled at by flow
        function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
            if (Array.isArray(data) || isPrimitive(data)) {
                normalizationType = children;
                children = data;
                data = undefined;
            }
            if (isTrue(alwaysNormalize)) {
                normalizationType = ALWAYS_NORMALIZE;
            }
            return _createElement(context, tag, data, children, normalizationType);
        }
        function _createElement(context, tag, data, children, normalizationType) {
            if (isDef(data) && isDef(data.__ob__)) {
                warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
                return createEmptyVNode();
            } // object syntax in v-bind
            if (isDef(data) && isDef(data.is)) {
                tag = data.is;
            }
            if (!tag) {
                // in case of component :is set to falsy value
                return createEmptyVNode();
            } // warn against non-primitive key
            if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
                {
                    warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
                }
            } // support single function children as default scoped slot
            if (Array.isArray(children) && typeof children[0] === 'function') {
                data = data || {};
                data.scopedSlots = {
                    default: children[0]
                };
                children.length = 0;
            }
            if (normalizationType === ALWAYS_NORMALIZE) {
                children = normalizeChildren(children);
            }
            else if (normalizationType === SIMPLE_NORMALIZE) {
                children = simpleNormalizeChildren(children);
            }
            var vnode, ns;
            if (typeof tag === 'string') {
                var Ctor;
                ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);
                if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
                    // component
                    vnode = createComponent(Ctor, data, context, children, tag);
                }
                else {
                    // unknown or unlisted namespaced elements
                    // check at runtime because it may get assigned a namespace when its
                    // parent normalizes children
                    vnode = new VNode(tag, data, children, undefined, undefined, context);
                }
            }
            else {
                // direct component options / constructor
                vnode = createComponent(tag, data, context, children);
            }
            if (Array.isArray(vnode)) {
                return vnode;
            }
            else if (isDef(vnode)) {
                if (isDef(ns)) {
                    applyNS(vnode, ns);
                }
                if (isDef(data)) {
                    registerDeepBindings(data);
                }
                return vnode;
            }
            else {
                return createEmptyVNode();
            }
        }
        function applyNS(vnode, ns, force) {
            vnode.ns = ns;
            if (vnode.tag === 'foreignObject') {
                // use default namespace inside foreignObject
                ns = undefined;
                force = true;
            }
            if (isDef(vnode.children)) {
                for (var i = 0, l = vnode.children.length; i < l; i++) {
                    var child = vnode.children[i];
                    if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {
                        applyNS(child, ns, force);
                    }
                }
            }
        } // ref #5318
        // necessary to ensure parent re-render when deep bindings like :style and
        // :class are used on slot nodes
        function registerDeepBindings(data) {
            if (isObject(data.style)) {
                traverse(data.style);
            }
            if (isObject(data.class)) {
                traverse(data.class);
            }
        }
        /*  */
        /**
         * Runtime helper for rendering v-for lists.
         */
        function renderList(val, render) {
            var ret, i, l, keys, key;
            if (Array.isArray(val) || typeof val === 'string') {
                ret = new Array(val.length);
                for (i = 0, l = val.length; i < l; i++) {
                    ret[i] = render(val[i], i);
                }
            }
            else if (typeof val === 'number') {
                ret = new Array(val);
                for (i = 0; i < val; i++) {
                    ret[i] = render(i + 1, i);
                }
            }
            else if (isObject(val)) {
                if (hasSymbol && val[Symbol.iterator]) {
                    ret = [];
                    var iterator = val[Symbol.iterator]();
                    var result = iterator.next();
                    while (!result.done) {
                        ret.push(render(result.value, ret.length));
                        result = iterator.next();
                    }
                }
                else {
                    keys = Object.keys(val);
                    ret = new Array(keys.length);
                    for (i = 0, l = keys.length; i < l; i++) {
                        key = keys[i];
                        ret[i] = render(val[key], key, i);
                    }
                }
            }
            if (!isDef(ret)) {
                ret = [];
            }
            ret._isVList = true;
            return ret;
        }
        /*  */
        /**
         * Runtime helper for rendering <slot>
         */
        function renderSlot(name, fallback, props, bindObject) {
            var scopedSlotFn = this.$scopedSlots[name];
            var nodes;
            if (scopedSlotFn) {
                // scoped slot
                props = props || {};
                if (bindObject) {
                    if (!isObject(bindObject)) {
                        warn('slot v-bind without argument expects an Object', this);
                    }
                    props = extend(extend({}, bindObject), props);
                }
                nodes = scopedSlotFn(props) || fallback;
            }
            else {
                nodes = this.$slots[name] || fallback;
            }
            var target = props && props.slot;
            if (target) {
                return this.$createElement('template', {
                    slot: target
                }, nodes);
            }
            else {
                return nodes;
            }
        }
        /*  */
        /**
         * Runtime helper for resolving filters
         */
        function resolveFilter(id) {
            return resolveAsset(this.$options, 'filters', id, true) || identity;
        }
        /*  */
        function isKeyNotMatch(expect, actual) {
            if (Array.isArray(expect)) {
                return expect.indexOf(actual) === -1;
            }
            else {
                return expect !== actual;
            }
        }
        /**
         * Runtime helper for checking keyCodes from config.
         * exposed as Vue.prototype._k
         * passing in eventKeyName as last argument separately for backwards compat
         */
        function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
            var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
            if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
                return isKeyNotMatch(builtInKeyName, eventKeyName);
            }
            else if (mappedKeyCode) {
                return isKeyNotMatch(mappedKeyCode, eventKeyCode);
            }
            else if (eventKeyName) {
                return hyphenate(eventKeyName) !== key;
            }
        }
        /*  */
        /**
         * Runtime helper for merging v-bind="object" into a VNode's data.
         */
        function bindObjectProps(data, tag, value, asProp, isSync) {
            if (value) {
                if (!isObject(value)) {
                    warn('v-bind without argument expects an Object or Array value', this);
                }
                else {
                    if (Array.isArray(value)) {
                        value = toObject(value);
                    }
                    var hash;
                    var loop = function (key) {
                        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
                            hash = data;
                        }
                        else {
                            var type = data.attrs && data.attrs.type;
                            hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
                        }
                        var camelizedKey = camelize(key);
                        var hyphenatedKey = hyphenate(key);
                        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
                            hash[key] = value[key];
                            if (isSync) {
                                var on = data.on || (data.on = {});
                                on["update:" + key] = function ($event) {
                                    value[key] = $event;
                                };
                            }
                        }
                    };
                    for (var key in value)
                        loop(key);
                }
            }
            return data;
        }
        /*  */
        /**
         * Runtime helper for rendering static trees.
         */
        function renderStatic(index, isInFor) {
            var cached = this._staticTrees || (this._staticTrees = []);
            var tree = cached[index]; // if has already-rendered static tree and not inside v-for,
            // we can reuse the same tree.
            if (tree && !isInFor) {
                return tree;
            } // otherwise, render a fresh tree.
            tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates
            );
            markStatic(tree, "__static__" + index, false);
            return tree;
        }
        /**
         * Runtime helper for v-once.
         * Effectively it means marking the node as static with a unique key.
         */
        function markOnce(tree, index, key) {
            markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
            return tree;
        }
        function markStatic(tree, key, isOnce) {
            if (Array.isArray(tree)) {
                for (var i = 0; i < tree.length; i++) {
                    if (tree[i] && typeof tree[i] !== 'string') {
                        markStaticNode(tree[i], key + "_" + i, isOnce);
                    }
                }
            }
            else {
                markStaticNode(tree, key, isOnce);
            }
        }
        function markStaticNode(node, key, isOnce) {
            node.isStatic = true;
            node.key = key;
            node.isOnce = isOnce;
        }
        /*  */
        function bindObjectListeners(data, value) {
            if (value) {
                if (!isPlainObject(value)) {
                    warn('v-on without argument expects an Object value', this);
                }
                else {
                    var on = data.on = data.on ? extend({}, data.on) : {};
                    for (var key in value) {
                        var existing = on[key];
                        var ours = value[key];
                        on[key] = existing ? [].concat(existing, ours) : ours;
                    }
                }
            }
            return data;
        }
        /*  */
        function resolveScopedSlots(fns, // see flow/vnode
        res, // the following are added in 2.6
        hasDynamicKeys, contentHashKey) {
            res = res || {
                $stable: !hasDynamicKeys
            };
            for (var i = 0; i < fns.length; i++) {
                var slot = fns[i];
                if (Array.isArray(slot)) {
                    resolveScopedSlots(slot, res, hasDynamicKeys);
                }
                else if (slot) {
                    // marker for reverse proxying v-slot without scope on this.$slots
                    if (slot.proxy) {
                        slot.fn.proxy = true;
                    }
                    res[slot.key] = slot.fn;
                }
            }
            if (contentHashKey) {
                res.$key = contentHashKey;
            }
            return res;
        }
        /*  */
        function bindDynamicKeys(baseObj, values) {
            for (var i = 0; i < values.length; i += 2) {
                var key = values[i];
                if (typeof key === 'string' && key) {
                    baseObj[values[i]] = values[i + 1];
                }
                else if (key !== '' && key !== null) {
                    // null is a special value for explicitly removing a binding
                    warn("Invalid value for dynamic directive argument (expected string or null): " + key, this);
                }
            }
            return baseObj;
        } // helper to dynamically append modifier runtime markers to event names.
        // ensure only append when value is already string, otherwise it will be cast
        // to string and cause the type check to miss.
        function prependModifier(value, symbol) {
            return typeof value === 'string' ? symbol + value : value;
        }
        /*  */
        function installRenderHelpers(target) {
            target._o = markOnce;
            target._n = toNumber;
            target._s = toString;
            target._l = renderList;
            target._t = renderSlot;
            target._q = looseEqual;
            target._i = looseIndexOf;
            target._m = renderStatic;
            target._f = resolveFilter;
            target._k = checkKeyCodes;
            target._b = bindObjectProps;
            target._v = createTextVNode;
            target._e = createEmptyVNode;
            target._u = resolveScopedSlots;
            target._g = bindObjectListeners;
            target._d = bindDynamicKeys;
            target._p = prependModifier;
        }
        /*  */
        /**
         * Runtime helper for resolving raw children VNodes into a slot object.
         */
        function resolveSlots(children, context) {
            if (!children || !children.length) {
                return {};
            }
            var slots = {};
            for (var i = 0, l = children.length; i < l; i++) {
                var child = children[i];
                var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node
                if (data && data.attrs && data.attrs.slot) {
                    delete data.attrs.slot;
                } // named slots should only be respected if the vnode was rendered in the
                // same context.
                if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
                    var name = data.slot;
                    var slot = slots[name] || (slots[name] = []);
                    if (child.tag === 'template') {
                        slot.push.apply(slot, child.children || []);
                    }
                    else {
                        slot.push(child);
                    }
                }
                else {
                    (slots.default || (slots.default = [])).push(child);
                }
            } // ignore slots that contains only whitespace
            for (var name$1 in slots) {
                if (slots[name$1].every(isWhitespace)) {
                    delete slots[name$1];
                }
            }
            return slots;
        }
        function isWhitespace(node) {
            return node.isComment && !node.asyncFactory || node.text === ' ';
        }
        /*  */
        function normalizeScopedSlots(slots, normalSlots, prevSlots) {
            var res;
            var hasNormalSlots = Object.keys(normalSlots).length > 0;
            var isStable = slots ? !!slots.$stable : !hasNormalSlots;
            var key = slots && slots.$key;
            if (!slots) {
                res = {};
            }
            else if (slots._normalized) {
                // fast path 1: child component re-render only, parent did not change
                return slots._normalized;
            }
            else if (isStable && prevSlots && prevSlots !== emptyObject && key === prevSlots.$key && !hasNormalSlots && !prevSlots.$hasNormal) {
                // fast path 2: stable scoped slots w/ no normal slots to proxy,
                // only need to normalize once
                return prevSlots;
            }
            else {
                res = {};
                for (var key$1 in slots) {
                    if (slots[key$1] && key$1[0] !== '$') {
                        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
                    }
                }
            } // expose normal slots on scopedSlots
            for (var key$2 in normalSlots) {
                if (!(key$2 in res)) {
                    res[key$2] = proxyNormalSlot(normalSlots, key$2);
                }
            } // avoriaz seems to mock a non-extensible $scopedSlots object
            // and when that is passed down this would cause an error
            if (slots && Object.isExtensible(slots)) {
                slots._normalized = res;
            }
            def(res, '$stable', isStable);
            def(res, '$key', key);
            def(res, '$hasNormal', hasNormalSlots);
            return res;
        }
        function normalizeScopedSlot(normalSlots, key, fn) {
            var normalized = function () {
                var res = arguments.length ? fn.apply(null, arguments) : fn({});
                res = res && typeof res === 'object' && !Array.isArray(res) ? [res] // single vnode
                    : normalizeChildren(res);
                return res && (res.length === 0 || res.length === 1 && res[0].isComment // #9658
                ) ? undefined : res;
            }; // this is a slot using the new v-slot syntax without scope. although it is
            // compiled as a scoped slot, render fn users would expect it to be present
            // on this.$slots because the usage is semantically a normal slot.
            if (fn.proxy) {
                Object.defineProperty(normalSlots, key, {
                    get: normalized,
                    enumerable: true,
                    configurable: true
                });
            }
            return normalized;
        }
        function proxyNormalSlot(slots, key) {
            return function () {
                return slots[key];
            };
        }
        /*  */
        var currentRenderingInstance = null;
        /*  */
        function ensureCtor(comp, base) {
            if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
                comp = comp.default;
            }
            return isObject(comp) ? base.extend(comp) : comp;
        }
        function createAsyncPlaceholder(factory, data, context, children, tag) {
            var node = createEmptyVNode();
            node.asyncFactory = factory;
            node.asyncMeta = {
                data: data,
                context: context,
                children: children,
                tag: tag
            };
            return node;
        }
        function resolveAsyncComponent(factory, baseCtor) {
            if (isTrue(factory.error) && isDef(factory.errorComp)) {
                return factory.errorComp;
            }
            if (isDef(factory.resolved)) {
                return factory.resolved;
            }
            var owner = currentRenderingInstance;
            if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
                // already pending
                factory.owners.push(owner);
            }
            if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
                return factory.loadingComp;
            }
            if (owner && !isDef(factory.owners)) {
                var owners = factory.owners = [owner];
                var sync = true;
                var timerLoading = null;
                var timerTimeout = null;
                owner.$on('hook:destroyed', function () {
                    return remove(owners, owner);
                });
                var forceRender = function (renderCompleted) {
                    for (var i = 0, l = owners.length; i < l; i++) {
                        owners[i].$forceUpdate();
                    }
                    if (renderCompleted) {
                        owners.length = 0;
                        if (timerLoading !== null) {
                            clearTimeout(timerLoading);
                            timerLoading = null;
                        }
                        if (timerTimeout !== null) {
                            clearTimeout(timerTimeout);
                            timerTimeout = null;
                        }
                    }
                };
                var resolve = once(function (res) {
                    // cache resolved
                    factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve
                    // (async resolves are shimmed as synchronous during SSR)
                    if (!sync) {
                        forceRender(true);
                    }
                    else {
                        owners.length = 0;
                    }
                });
                var reject = once(function (reason) {
                    warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));
                    if (isDef(factory.errorComp)) {
                        factory.error = true;
                        forceRender(true);
                    }
                });
                var res = factory(resolve, reject);
                if (isObject(res)) {
                    if (isPromise(res)) {
                        // () => Promise
                        if (isUndef(factory.resolved)) {
                            res.then(resolve, reject);
                        }
                    }
                    else if (isPromise(res.component)) {
                        res.component.then(resolve, reject);
                        if (isDef(res.error)) {
                            factory.errorComp = ensureCtor(res.error, baseCtor);
                        }
                        if (isDef(res.loading)) {
                            factory.loadingComp = ensureCtor(res.loading, baseCtor);
                            if (res.delay === 0) {
                                factory.loading = true;
                            }
                            else {
                                timerLoading = setTimeout(function () {
                                    timerLoading = null;
                                    if (isUndef(factory.resolved) && isUndef(factory.error)) {
                                        factory.loading = true;
                                        forceRender(false);
                                    }
                                }, res.delay || 200);
                            }
                        }
                        if (isDef(res.timeout)) {
                            timerTimeout = setTimeout(function () {
                                timerTimeout = null;
                                if (isUndef(factory.resolved)) {
                                    reject("timeout (" + res.timeout + "ms)");
                                }
                            }, res.timeout);
                        }
                    }
                }
                sync = false; // return in case resolved synchronously
                return factory.loading ? factory.loadingComp : factory.resolved;
            }
        }
        /*  */
        /*  */
        /*  */
        /*  */
        var target;
        function add(event, fn) {
            target.$on(event, fn);
        }
        function remove$1(event, fn) {
            target.$off(event, fn);
        }
        function createOnceHandler(event, fn) {
            var _target = target;
            return function onceHandler() {
                var res = fn.apply(null, arguments);
                if (res !== null) {
                    _target.$off(event, onceHandler);
                }
            };
        }
        function updateComponentListeners(vm, listeners, oldListeners) {
            target = vm;
            updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
            target = undefined;
        }
        /*  */
        var activeInstance = null;
        function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
            // determine whether component has slot children
            // we need to do this before overwriting $options._renderChildren.
            // check if there are dynamic scopedSlots (hand-written or compiled but with
            // dynamic slot names). Static scoped slots compiled from template has the
            // "$stable" marker.
            var newScopedSlots = parentVnode.data.scopedSlots;
            var oldScopedSlots = vm.$scopedSlots;
            var hasDynamicScopedSlot = !!(newScopedSlots && !newScopedSlots.$stable || oldScopedSlots !== emptyObject && !oldScopedSlots.$stable || newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key); // Any static slot children from the parent may have changed during parent's
            // update. Dynamic scoped slots may also have changed. In such cases, a forced
            // update is necessary to ensure correctness.
            var needsForceUpdate = !!(renderChildren || // has new static slots
                vm.$options._renderChildren || // has old static slots
                hasDynamicScopedSlot);
            vm.$options._parentVnode = parentVnode;
            vm.$vnode = parentVnode; // update vm's placeholder node without re-render
            if (vm._vnode) {
                // update child tree's parent
                vm._vnode.parent = parentVnode;
            }
            vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash
            // these are also reactive so they may trigger child update if the child
            // used them during render
            vm.$attrs = parentVnode.data.attrs || emptyObject;
            vm.$listeners = listeners || emptyObject; // update props
            if (propsData && vm.$options.props) {
                toggleObserving(false);
                var props = vm._props;
                var propKeys = vm.$options._propKeys || [];
                for (var i = 0; i < propKeys.length; i++) {
                    var key = propKeys[i];
                    var propOptions = vm.$options.props; // wtf flow?
                    props[key] = validateProp(key, propOptions, propsData, vm);
                }
                toggleObserving(true); // keep a copy of raw propsData
                vm.$options.propsData = propsData;
            } // update listeners
            listeners = listeners || emptyObject;
            var oldListeners = vm.$options._parentListeners;
            vm.$options._parentListeners = listeners;
            updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children
            if (needsForceUpdate) {
                vm.$slots = resolveSlots(renderChildren, parentVnode.context);
                vm.$forceUpdate();
            }
        }
        function isInInactiveTree(vm) {
            while (vm && (vm = vm.$parent)) {
                if (vm._inactive) {
                    return true;
                }
            }
            return false;
        }
        function activateChildComponent(vm, direct) {
            if (direct) {
                vm._directInactive = false;
                if (isInInactiveTree(vm)) {
                    return;
                }
            }
            else if (vm._directInactive) {
                return;
            }
            if (vm._inactive || vm._inactive === null) {
                vm._inactive = false;
                for (var i = 0; i < vm.$children.length; i++) {
                    activateChildComponent(vm.$children[i]);
                }
                callHook(vm, 'activated');
            }
        }
        function deactivateChildComponent(vm, direct) {
            if (direct) {
                vm._directInactive = true;
                if (isInInactiveTree(vm)) {
                    return;
                }
            }
            if (!vm._inactive) {
                vm._inactive = true;
                for (var i = 0; i < vm.$children.length; i++) {
                    deactivateChildComponent(vm.$children[i]);
                }
                callHook(vm, 'deactivated');
            }
        }
        function callHook(vm, hook) {
            // #7573 disable dep collection when invoking lifecycle hooks
            pushTarget();
            var handlers = vm.$options[hook];
            var info = hook + " hook";
            if (handlers) {
                for (var i = 0, j = handlers.length; i < j; i++) {
                    invokeWithErrorHandling(handlers[i], vm, null, vm, info);
                }
            }
            if (vm._hasHookEvent) {
                vm.$emit('hook:' + hook);
            }
            popTarget();
        }
        /*  */
        // Async edge case fix requires storing an event listener's attach timestamp.
        var getNow = Date.now; // Determine what event timestamp the browser is using. Annoyingly, the
        // timestamp can either be hi-res (relative to page load) or low-res
        // (relative to UNIX epoch), so in order to compare time we have to use the
        // same timestamp type when saving the flush timestamp.
        // All IE versions use low-res event timestamps, and have problematic clock
        // implementations (#9632)
        if (inBrowser && !isIE) {
            var performance = window.performance;
            if (performance && typeof performance.now === 'function' && getNow() > document.createEvent('Event').timeStamp) {
                // if the event timestamp, although evaluated AFTER the Date.now(), is
                // smaller than it, it means the event is using a hi-res timestamp,
                // and we need to use the hi-res version for event listener timestamps as
                // well.
                getNow = function () {
                    return performance.now();
                };
            }
        }
        /**
         * Queue a kept-alive component that was activated during patch.
         * The queue will be processed after the entire tree has been patched.
         */
        function queueActivatedComponent(vm) {
            // setting _inactive to false here so that a render function can
            // rely on checking whether it's in an inactive tree (e.g. router-view)
            vm._inactive = false;
        }
        /*  */
        /*  */
        /*  */
        function resolveInject(inject, vm) {
            if (inject) {
                // inject is :any because flow is not smart enough to figure out cached
                var result = Object.create(null);
                var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i]; // #6574 in case the inject object is observed...
                    if (key === '__ob__') {
                        continue;
                    }
                    var provideKey = inject[key].from;
                    var source = vm;
                    while (source) {
                        if (source._provided && hasOwn(source._provided, provideKey)) {
                            result[key] = source._provided[provideKey];
                            break;
                        }
                        source = source.$parent;
                    }
                    if (!source) {
                        if ('default' in inject[key]) {
                            var provideDefault = inject[key].default;
                            result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
                        }
                        else {
                            warn("Injection \"" + key + "\" not found", vm);
                        }
                    }
                }
                return result;
            }
        }
        /*  */
        function resolveConstructorOptions(Ctor) {
            var options = Ctor.options;
            if (Ctor.super) {
                var superOptions = resolveConstructorOptions(Ctor.super);
                var cachedSuperOptions = Ctor.superOptions;
                if (superOptions !== cachedSuperOptions) {
                    // super option changed,
                    // need to resolve new options.
                    Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)
                    var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options
                    if (modifiedOptions) {
                        extend(Ctor.extendOptions, modifiedOptions);
                    }
                    options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
                    if (options.name) {
                        options.components[options.name] = Ctor;
                    }
                }
            }
            return options;
        }
        function resolveModifiedOptions(Ctor) {
            var modified;
            var latest = Ctor.options;
            var sealed = Ctor.sealedOptions;
            for (var key in latest) {
                if (latest[key] !== sealed[key]) {
                    if (!modified) {
                        modified = {};
                    }
                    modified[key] = latest[key];
                }
            }
            return modified;
        }
        /*  */
        function FunctionalRenderContext(data, props, children, parent, Ctor) {
            var this$1 = this;
            var options = Ctor.options; // ensure the createElement function in functional components
            // gets a unique context - this is necessary for correct named slot check
            var contextVm;
            if (hasOwn(parent, '_uid')) {
                contextVm = Object.create(parent); // $flow-disable-line
                contextVm._original = parent;
            }
            else {
                // the context vm passed in is a functional context as well.
                // in this case we want to make sure we are able to get a hold to the
                // real context instance.
                contextVm = parent; // $flow-disable-line
                parent = parent._original;
            }
            var isCompiled = isTrue(options._compiled);
            var needNormalization = !isCompiled;
            this.data = data;
            this.props = props;
            this.children = children;
            this.parent = parent;
            this.listeners = data.on || emptyObject;
            this.injections = resolveInject(options.inject, parent);
            this.slots = function () {
                if (!this$1.$slots) {
                    normalizeScopedSlots(data.scopedSlots, this$1.$slots = resolveSlots(children, parent));
                }
                return this$1.$slots;
            };
            Object.defineProperty(this, 'scopedSlots', {
                enumerable: true,
                get: function get() {
                    return normalizeScopedSlots(data.scopedSlots, this.slots());
                }
            }); // support for compiled functional template
            if (isCompiled) {
                // exposing $options for renderStatic()
                this.$options = options; // pre-resolve slots for renderSlot()
                this.$slots = this.slots();
                this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
            }
            if (options._scopeId) {
                this._c = function (a, b, c, d) {
                    var vnode = createElement(contextVm, a, b, c, d, needNormalization);
                    if (vnode && !Array.isArray(vnode)) {
                        vnode.fnScopeId = options._scopeId;
                        vnode.fnContext = parent;
                    }
                    return vnode;
                };
            }
            else {
                this._c = function (a, b, c, d) {
                    return createElement(contextVm, a, b, c, d, needNormalization);
                };
            }
        }
        installRenderHelpers(FunctionalRenderContext.prototype);
        function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
            var options = Ctor.options;
            var props = {};
            var propOptions = options.props;
            if (isDef(propOptions)) {
                for (var key in propOptions) {
                    props[key] = validateProp(key, propOptions, propsData || emptyObject);
                }
            }
            else {
                if (isDef(data.attrs)) {
                    mergeProps(props, data.attrs);
                }
                if (isDef(data.props)) {
                    mergeProps(props, data.props);
                }
            }
            var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);
            var vnode = options.render.call(null, renderContext._c, renderContext);
            if (vnode instanceof VNode) {
                return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
            }
            else if (Array.isArray(vnode)) {
                var vnodes = normalizeChildren(vnode) || [];
                var res = new Array(vnodes.length);
                for (var i = 0; i < vnodes.length; i++) {
                    res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
                }
                return res;
            }
        }
        function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
            // #7817 clone node before setting fnContext, otherwise if the node is reused
            // (e.g. it was from a cached normal slot) the fnContext causes named slots
            // that should not be matched to match.
            var clone = cloneVNode(vnode);
            clone.fnContext = contextVm;
            clone.fnOptions = options;
            {
                (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
            }
            if (data.slot) {
                (clone.data || (clone.data = {})).slot = data.slot;
            }
            return clone;
        }
        function mergeProps(to, from) {
            for (var key in from) {
                to[camelize(key)] = from[key];
            }
        }
        /*  */
        /*  */
        /*  */
        /*  */
        // inline hooks to be invoked on component VNodes during patch
        var componentVNodeHooks = {
            init: function init(vnode, hydrating) {
                if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
                    // kept-alive components, treat as a patch
                    var mountedNode = vnode; // work around flow
                    componentVNodeHooks.prepatch(mountedNode, mountedNode);
                }
                else {
                    var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance);
                    child.$mount(hydrating ? vnode.elm : undefined, hydrating);
                }
            },
            prepatch: function prepatch(oldVnode, vnode) {
                var options = vnode.componentOptions;
                var child = vnode.componentInstance = oldVnode.componentInstance;
                updateChildComponent(child, options.propsData, // updated props
                options.listeners, // updated listeners
                vnode, // new parent vnode
                options.children // new children
                );
            },
            insert: function insert(vnode) {
                var context = vnode.context;
                var componentInstance = vnode.componentInstance;
                if (!componentInstance._isMounted) {
                    componentInstance._isMounted = true;
                    callHook(componentInstance, 'mounted');
                }
                if (vnode.data.keepAlive) {
                    if (context._isMounted) {
                        // vue-router#1212
                        // During updates, a kept-alive component's child components may
                        // change, so directly walking the tree here may call activated hooks
                        // on incorrect children. Instead we push them into a queue which will
                        // be processed after the whole patch process ended.
                        queueActivatedComponent(componentInstance);
                    }
                    else {
                        activateChildComponent(componentInstance, true
                        /* direct */
                        );
                    }
                }
            },
            destroy: function destroy(vnode) {
                var componentInstance = vnode.componentInstance;
                if (!componentInstance._isDestroyed) {
                    if (!vnode.data.keepAlive) {
                        componentInstance.$destroy();
                    }
                    else {
                        deactivateChildComponent(componentInstance, true
                        /* direct */
                        );
                    }
                }
            }
        };
        var hooksToMerge = Object.keys(componentVNodeHooks);
        function createComponent(Ctor, data, context, children, tag) {
            if (isUndef(Ctor)) {
                return;
            }
            var baseCtor = context.$options._base; // plain options object: turn it into a constructor
            if (isObject(Ctor)) {
                Ctor = baseCtor.extend(Ctor);
            } // if at this stage it's not a constructor or an async component factory,
            // reject.
            if (typeof Ctor !== 'function') {
                {
                    warn("Invalid Component definition: " + String(Ctor), context);
                }
                return;
            } // async component
            var asyncFactory;
            if (isUndef(Ctor.cid)) {
                asyncFactory = Ctor;
                Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
                if (Ctor === undefined) {
                    // return a placeholder node for async component, which is rendered
                    // as a comment node but preserves all the raw information for the node.
                    // the information will be used for async server-rendering and hydration.
                    return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
                }
            }
            data = data || {}; // resolve constructor options in case global mixins are applied after
            // component constructor creation
            resolveConstructorOptions(Ctor); // transform component v-model data into props & events
            if (isDef(data.model)) {
                transformModel(Ctor.options, data);
            } // extract props
            var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component
            if (isTrue(Ctor.options.functional)) {
                return createFunctionalComponent(Ctor, propsData, data, context, children);
            } // extract listeners, since these needs to be treated as
            // child component listeners instead of DOM listeners
            var listeners = data.on; // replace with listeners with .native modifier
            // so it gets processed during parent component patch.
            data.on = data.nativeOn;
            if (isTrue(Ctor.options.abstract)) {
                // abstract components do not keep anything
                // other than props & listeners & slot
                // work around flow
                var slot = data.slot;
                data = {};
                if (slot) {
                    data.slot = slot;
                }
            } // install component management hooks onto the placeholder node
            installComponentHooks(data); // return a placeholder vnode
            var name = Ctor.options.name || tag;
            var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, {
                Ctor: Ctor,
                propsData: propsData,
                listeners: listeners,
                tag: tag,
                children: children
            }, asyncFactory);
            return vnode;
        }
        function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
        parent // activeInstance in lifecycle state
        ) {
            var options = {
                _isComponent: true,
                _parentVnode: vnode,
                parent: parent
            }; // check inline-template render functions
            var inlineTemplate = vnode.data.inlineTemplate;
            if (isDef(inlineTemplate)) {
                options.render = inlineTemplate.render;
                options.staticRenderFns = inlineTemplate.staticRenderFns;
            }
            return new vnode.componentOptions.Ctor(options);
        }
        function installComponentHooks(data) {
            var hooks = data.hook || (data.hook = {});
            for (var i = 0; i < hooksToMerge.length; i++) {
                var key = hooksToMerge[i];
                var existing = hooks[key];
                var toMerge = componentVNodeHooks[key];
                if (existing !== toMerge && !(existing && existing._merged)) {
                    hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
                }
            }
        }
        function mergeHook$1(f1, f2) {
            var merged = function (a, b) {
                // flow complains about extra args which is why we use any
                f1(a, b);
                f2(a, b);
            };
            merged._merged = true;
            return merged;
        } // transform component v-model info (value and callback) into
        // prop and event handler respectively.
        function transformModel(options, data) {
            var prop = options.model && options.model.prop || 'value';
            var event = options.model && options.model.event || 'input';
            (data.attrs || (data.attrs = {}))[prop] = data.model.value;
            var on = data.on || (data.on = {});
            var existing = on[event];
            var callback = data.model.callback;
            if (isDef(existing)) {
                if (Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback) {
                    on[event] = [callback].concat(existing);
                }
            }
            else {
                on[event] = callback;
            }
        }
        /*  */
        var warned = Object.create(null);
        var warnOnce = function (msg) {
            if (!warned[msg]) {
                warned[msg] = true; // eslint-disable-next-line no-console
                console.warn("\n\u001b[31m" + msg + "\u001b[39m\n");
            }
        };
        var onCompilationError = function (err, vm) {
            var trace = vm ? generateComponentTrace(vm) : '';
            throw new Error("\n\u001b[31m" + err + trace + "\u001b[39m\n");
        };
        var normalizeRender = function (vm) {
            var ref = vm.$options;
            var render = ref.render;
            var template = ref.template;
            var _scopeId = ref._scopeId;
            if (isUndef(render)) {
                if (template) {
                    var compiled = compileToFunctions(template, {
                        scopeId: _scopeId,
                        warn: onCompilationError
                    }, vm);
                    vm.$options.render = compiled.render;
                    vm.$options.staticRenderFns = compiled.staticRenderFns;
                }
                else {
                    throw new Error("render function or template not defined in component: " + (vm.$options.name || vm.$options._componentTag || 'anonymous'));
                }
            }
        };
        function waitForServerPrefetch(vm, resolve, reject) {
            var handlers = vm.$options.serverPrefetch;
            if (isDef(handlers)) {
                if (!Array.isArray(handlers)) {
                    handlers = [handlers];
                }
                try {
                    var promises = [];
                    for (var i = 0, j = handlers.length; i < j; i++) {
                        var result = handlers[i].call(vm, vm);
                        if (result && typeof result.then === 'function') {
                            promises.push(result);
                        }
                    }
                    Promise.all(promises).then(resolve).catch(reject);
                    return;
                }
                catch (e) {
                    reject(e);
                }
            }
            resolve();
        }
        function renderNode(node, isRoot, context) {
            if (node.isString) {
                renderStringNode$1(node, context);
            }
            else if (isDef(node.componentOptions)) {
                renderComponent(node, isRoot, context);
            }
            else if (isDef(node.tag)) {
                renderElement(node, isRoot, context);
            }
            else if (isTrue(node.isComment)) {
                if (isDef(node.asyncFactory)) {
                    // async component
                    renderAsyncComponent(node, isRoot, context);
                }
                else {
                    context.write("<!--" + node.text + "-->", context.next);
                }
            }
            else {
                context.write(node.raw ? node.text : escape(String(node.text)), context.next);
            }
        }
        function registerComponentForCache(options, write) {
            // exposed by vue-loader, need to call this if cache hit because
            // component lifecycle hooks will not be called.
            var register = options._ssrRegister;
            if (write.caching && isDef(register)) {
                write.componentBuffer[write.componentBuffer.length - 1].add(register);
            }
            return register;
        }
        function renderComponent(node, isRoot, context) {
            var write = context.write;
            var next = context.next;
            var userContext = context.userContext; // check cache hit
            var Ctor = node.componentOptions.Ctor;
            var getKey = Ctor.options.serverCacheKey;
            var name = Ctor.options.name;
            var cache = context.cache;
            var registerComponent = registerComponentForCache(Ctor.options, write);
            if (isDef(getKey) && isDef(cache) && isDef(name)) {
                var rawKey = getKey(node.componentOptions.propsData);
                if (rawKey === false) {
                    renderComponentInner(node, isRoot, context);
                    return;
                }
                var key = name + '::' + rawKey;
                var has = context.has;
                var get = context.get;
                if (isDef(has)) {
                    has(key, function (hit) {
                        if (hit === true && isDef(get)) {
                            get(key, function (res) {
                                if (isDef(registerComponent)) {
                                    registerComponent(userContext);
                                }
                                res.components.forEach(function (register) {
                                    return register(userContext);
                                });
                                write(res.html, next);
                            });
                        }
                        else {
                            renderComponentWithCache(node, isRoot, key, context);
                        }
                    });
                }
                else if (isDef(get)) {
                    get(key, function (res) {
                        if (isDef(res)) {
                            if (isDef(registerComponent)) {
                                registerComponent(userContext);
                            }
                            res.components.forEach(function (register) {
                                return register(userContext);
                            });
                            write(res.html, next);
                        }
                        else {
                            renderComponentWithCache(node, isRoot, key, context);
                        }
                    });
                }
            }
            else {
                if (isDef(getKey) && isUndef(cache)) {
                    warnOnce("[vue-server-renderer] Component " + (Ctor.options.name || '(anonymous)') + " implemented serverCacheKey, " + 'but no cache was provided to the renderer.');
                }
                if (isDef(getKey) && isUndef(name)) {
                    warnOnce("[vue-server-renderer] Components that implement \"serverCacheKey\" " + "must also define a unique \"name\" option.");
                }
                renderComponentInner(node, isRoot, context);
            }
        }
        function renderComponentWithCache(node, isRoot, key, context) {
            var write = context.write;
            write.caching = true;
            var buffer = write.cacheBuffer;
            var bufferIndex = buffer.push('') - 1;
            var componentBuffer = write.componentBuffer;
            componentBuffer.push(new Set());
            context.renderStates.push({
                type: 'ComponentWithCache',
                key: key,
                buffer: buffer,
                bufferIndex: bufferIndex,
                componentBuffer: componentBuffer
            });
            renderComponentInner(node, isRoot, context);
        }
        function renderComponentInner(node, isRoot, context) {
            var prevActive = context.activeInstance; // expose userContext on vnode
            node.ssrContext = context.userContext;
            var child = context.activeInstance = createComponentInstanceForVnode(node, context.activeInstance);
            normalizeRender(child);
            var resolve = function () {
                var childNode = child._render();
                childNode.parent = node;
                context.renderStates.push({
                    type: 'Component',
                    prevActive: prevActive
                });
                renderNode(childNode, isRoot, context);
            };
            var reject = context.done;
            waitForServerPrefetch(child, resolve, reject);
        }
        function renderAsyncComponent(node, isRoot, context) {
            var factory = node.asyncFactory;
            var resolve = function (comp) {
                if (comp.__esModule && comp.default) {
                    comp = comp.default;
                }
                var ref = node.asyncMeta;
                var data = ref.data;
                var children = ref.children;
                var tag = ref.tag;
                var nodeContext = node.asyncMeta.context;
                var resolvedNode = createComponent(comp, data, nodeContext, children, tag);
                if (resolvedNode) {
                    if (resolvedNode.componentOptions) {
                        // normal component
                        renderComponent(resolvedNode, isRoot, context);
                    }
                    else if (!Array.isArray(resolvedNode)) {
                        // single return node from functional component
                        renderNode(resolvedNode, isRoot, context);
                    }
                    else {
                        // multiple return nodes from functional component
                        context.renderStates.push({
                            type: 'Fragment',
                            children: resolvedNode,
                            rendered: 0,
                            total: resolvedNode.length
                        });
                        context.next();
                    }
                }
                else {
                    // invalid component, but this does not throw on the client
                    // so render empty comment node
                    context.write("<!---->", context.next);
                }
            };
            if (factory.resolved) {
                resolve(factory.resolved);
                return;
            }
            var reject = context.done;
            var res;
            try {
                res = factory(resolve, reject);
            }
            catch (e) {
                reject(e);
            }
            if (res) {
                if (typeof res.then === 'function') {
                    res.then(resolve, reject).catch(reject);
                }
                else {
                    // new syntax in 2.3
                    var comp = res.component;
                    if (comp && typeof comp.then === 'function') {
                        comp.then(resolve, reject).catch(reject);
                    }
                }
            }
        }
        function renderStringNode$1(el, context) {
            var write = context.write;
            var next = context.next;
            if (isUndef(el.children) || el.children.length === 0) {
                write(el.open + (el.close || ''), next);
            }
            else {
                var children = el.children;
                context.renderStates.push({
                    type: 'Element',
                    children: children,
                    rendered: 0,
                    total: children.length,
                    endTag: el.close
                });
                write(el.open, next);
            }
        }
        function renderElement(el, isRoot, context) {
            var write = context.write;
            var next = context.next;
            if (isTrue(isRoot)) {
                if (!el.data) {
                    el.data = {};
                }
                if (!el.data.attrs) {
                    el.data.attrs = {};
                }
                el.data.attrs[SSR_ATTR] = 'true';
            }
            if (el.fnOptions) {
                registerComponentForCache(el.fnOptions, write);
            }
            var startTag = renderStartingTag(el, context);
            var endTag = "</" + el.tag + ">";
            if (context.isUnaryTag(el.tag)) {
                write(startTag, next);
            }
            else if (isUndef(el.children) || el.children.length === 0) {
                write(startTag + endTag, next);
            }
            else {
                var children = el.children;
                context.renderStates.push({
                    type: 'Element',
                    children: children,
                    rendered: 0,
                    total: children.length,
                    endTag: endTag
                });
                write(startTag, next);
            }
        }
        function hasAncestorData(node) {
            var parentNode = node.parent;
            return isDef(parentNode) && (isDef(parentNode.data) || hasAncestorData(parentNode));
        }
        function getVShowDirectiveInfo(node) {
            var dir;
            var tmp;
            while (isDef(node)) {
                if (node.data && node.data.directives) {
                    tmp = node.data.directives.find(function (dir) {
                        return dir.name === 'show';
                    });
                    if (tmp) {
                        dir = tmp;
                    }
                }
                node = node.parent;
            }
            return dir;
        }
        function renderStartingTag(node, context) {
            var markup = "<" + node.tag;
            var directives = context.directives;
            var modules = context.modules; // construct synthetic data for module processing
            // because modules like style also produce code by parent VNode data
            if (isUndef(node.data) && hasAncestorData(node)) {
                node.data = {};
            }
            if (isDef(node.data)) {
                // check directives
                var dirs = node.data.directives;
                if (dirs) {
                    for (var i = 0; i < dirs.length; i++) {
                        var name = dirs[i].name;
                        if (name !== 'show') {
                            var dirRenderer = resolveAsset(context, 'directives', name);
                            if (dirRenderer) {
                                // directives mutate the node's data
                                // which then gets rendered by modules
                                dirRenderer(node, dirs[i]);
                            }
                        }
                    }
                } // v-show directive needs to be merged from parent to child
                var vshowDirectiveInfo = getVShowDirectiveInfo(node);
                if (vshowDirectiveInfo) {
                    directives.show(node, vshowDirectiveInfo);
                } // apply other modules
                for (var i$1 = 0; i$1 < modules.length; i$1++) {
                    var res = modules[i$1](node);
                    if (res) {
                        markup += res;
                    }
                }
            } // attach scoped CSS ID
            var scopeId;
            var activeInstance = context.activeInstance;
            if (isDef(activeInstance) && activeInstance !== node.context && isDef(scopeId = activeInstance.$options._scopeId)) {
                markup += " " + scopeId;
            }
            if (isDef(node.fnScopeId)) {
                markup += " " + node.fnScopeId;
            }
            else {
                while (isDef(node)) {
                    if (isDef(scopeId = node.context.$options._scopeId)) {
                        markup += " " + scopeId;
                    }
                    node = node.parent;
                }
            }
            return markup + '>';
        }
        function createRenderFunction(modules, directives, isUnaryTag, cache) {
            return function render(component, write, userContext, done) {
                warned = Object.create(null);
                var context = new RenderContext({
                    activeInstance: component,
                    userContext: userContext,
                    write: write,
                    done: done,
                    renderNode: renderNode,
                    isUnaryTag: isUnaryTag,
                    modules: modules,
                    directives: directives,
                    cache: cache
                });
                installSSRHelpers(component);
                normalizeRender(component);
                var resolve = function () {
                    renderNode(component._render(), true, context);
                };
                waitForServerPrefetch(component, resolve, done);
            };
        }
        /*  */
        var isJS = function (file) {
            return /\.js(\?[^.]+)?$/.test(file);
        };
        var isCSS = function (file) {
            return /\.css(\?[^.]+)?$/.test(file);
        };
        function createPromiseCallback() {
            var resolve, reject;
            var promise = new Promise(function (_resolve, _reject) {
                resolve = _resolve;
                reject = _reject;
            });
            var cb = function (err, res) {
                if (err) {
                    return reject(err);
                }
                resolve(res || '');
            };
            return {
                promise: promise,
                cb: cb
            };
        }
        /*  */
        var Transform = stream_js_3.default.Transform;
        var TemplateStream = 
        /*@__PURE__*/
        function (Transform) {
            function TemplateStream(renderer, template, context) {
                Transform.call(this);
                this.started = false;
                this.renderer = renderer;
                this.template = template;
                this.context = context || {};
                this.inject = renderer.inject;
            }
            if (Transform)
                TemplateStream.__proto__ = Transform;
            TemplateStream.prototype = Object.create(Transform && Transform.prototype);
            TemplateStream.prototype.constructor = TemplateStream;
            TemplateStream.prototype._transform = function _transform(data, encoding, done) {
                if (!this.started) {
                    this.emit('beforeStart');
                    this.start();
                }
                this.push(data);
                done();
            };
            TemplateStream.prototype.start = function start() {
                this.started = true;
                this.push(this.template.head(this.context));
                if (this.inject) {
                    // inline server-rendered head meta information
                    if (this.context.head) {
                        this.push(this.context.head);
                    } // inline preload/prefetch directives for initial/async chunks
                    var links = this.renderer.renderResourceHints(this.context);
                    if (links) {
                        this.push(links);
                    } // CSS files and inline server-rendered CSS collected by vue-style-loader
                    var styles = this.renderer.renderStyles(this.context);
                    if (styles) {
                        this.push(styles);
                    }
                }
                this.push(this.template.neck(this.context));
            };
            TemplateStream.prototype._flush = function _flush(done) {
                this.emit('beforeEnd');
                if (this.inject) {
                    // inline initial store state
                    var state = this.renderer.renderState(this.context);
                    if (state) {
                        this.push(state);
                    } // embed scripts needed
                    var scripts = this.renderer.renderScripts(this.context);
                    if (scripts) {
                        this.push(scripts);
                    }
                }
                this.push(this.template.tail(this.context));
                done();
            };
            return TemplateStream;
        }(Transform);
        /*  */
        var compile$1 = npm_lodash_template_4_dew_2.dew();
        var compileOptions = {
            escape: /{{([^{][\s\S]+?[^}])}}/g,
            interpolate: /{{{([\s\S]+?)}}}/g
        };
        function parseTemplate(template, contentPlaceholder) {
            if (contentPlaceholder === void 0)
                contentPlaceholder = '<!--vue-ssr-outlet-->';
            if (typeof template === 'object') {
                return template;
            }
            var i = template.indexOf('</head>');
            var j = template.indexOf(contentPlaceholder);
            if (j < 0) {
                throw new Error("Content placeholder not found in template.");
            }
            if (i < 0) {
                i = template.indexOf('<body>');
                if (i < 0) {
                    i = j;
                }
            }
            return {
                head: compile$1(template.slice(0, i), compileOptions),
                neck: compile$1(template.slice(i, j), compileOptions),
                tail: compile$1(template.slice(j + contentPlaceholder.length), compileOptions)
            };
        }
        /*  */
        /**
         * Creates a mapper that maps components used during a server-side render
         * to async chunk files in the client-side build, so that we can inline them
         * directly in the rendered HTML to avoid waterfall requests.
         */
        function createMapper(clientManifest) {
            var map = createMap(clientManifest); // map server-side moduleIds to client-side files
            return function mapper(moduleIds) {
                var res = new Set();
                for (var i = 0; i < moduleIds.length; i++) {
                    var mapped = map.get(moduleIds[i]);
                    if (mapped) {
                        for (var j = 0; j < mapped.length; j++) {
                            res.add(mapped[j]);
                        }
                    }
                }
                return Array.from(res);
            };
        }
        function createMap(clientManifest) {
            var map = new Map();
            Object.keys(clientManifest.modules).forEach(function (id) {
                map.set(id, mapIdToFile(id, clientManifest));
            });
            return map;
        }
        function mapIdToFile(id, clientManifest) {
            var files = [];
            var fileIndices = clientManifest.modules[id];
            if (fileIndices) {
                fileIndices.forEach(function (index) {
                    var file = clientManifest.all[index]; // only include async files or non-js, non-css assets
                    if (clientManifest.async.indexOf(file) > -1 || !/\.(js|css)($|\?)/.test(file)) {
                        files.push(file);
                    }
                });
            }
            return files;
        }
        /*  */
        var path = path_js_6.default;
        var serialize = npm_serialize_javascript_2_dew_2.dew();
        var TemplateRenderer = function TemplateRenderer(options) {
            this.options = options;
            this.inject = options.inject !== false; // if no template option is provided, the renderer is created
            // as a utility object for rendering assets like preload links and scripts.
            var template = options.template;
            this.parsedTemplate = template ? typeof template === 'string' ? parseTemplate(template) : template : null; // function used to serialize initial state JSON
            this.serialize = options.serializer || function (state) {
                return serialize(state, {
                    isJSON: true
                });
            }; // extra functionality with client manifest
            if (options.clientManifest) {
                var clientManifest = this.clientManifest = options.clientManifest; // ensure publicPath ends with /
                this.publicPath = clientManifest.publicPath === '' ? '' : clientManifest.publicPath.replace(/([^\/])$/, '$1/'); // preload/prefetch directives
                this.preloadFiles = (clientManifest.initial || []).map(normalizeFile);
                this.prefetchFiles = (clientManifest.async || []).map(normalizeFile); // initial async chunk mapping
                this.mapFiles = createMapper(clientManifest);
            }
        };
        TemplateRenderer.prototype.bindRenderFns = function bindRenderFns(context) {
            var renderer = this;
            ['ResourceHints', 'State', 'Scripts', 'Styles'].forEach(function (type) {
                context["render" + type] = renderer["render" + type].bind(renderer, context);
            }); // also expose getPreloadFiles, useful for HTTP/2 push
            context.getPreloadFiles = renderer.getPreloadFiles.bind(renderer, context);
        }; // render synchronously given rendered app content and render context
        TemplateRenderer.prototype.render = function render(content, context) {
            var template = this.parsedTemplate;
            if (!template) {
                throw new Error('render cannot be called without a template.');
            }
            context = context || {};
            if (typeof template === 'function') {
                return template(content, context);
            }
            if (this.inject) {
                return template.head(context) + (context.head || '') + this.renderResourceHints(context) + this.renderStyles(context) + template.neck(context) + content + this.renderState(context) + this.renderScripts(context) + template.tail(context);
            }
            else {
                return template.head(context) + template.neck(context) + content + template.tail(context);
            }
        };
        TemplateRenderer.prototype.renderStyles = function renderStyles(context) {
            var this$1 = this;
            var initial = this.preloadFiles || [];
            var async = this.getUsedAsyncFiles(context) || [];
            var cssFiles = initial.concat(async).filter(function (ref) {
                var file = ref.file;
                return isCSS(file);
            });
            return ( // render links for css files
            (cssFiles.length ? cssFiles.map(function (ref) {
                var file = ref.file;
                return "<link rel=\"stylesheet\" href=\"" + this$1.publicPath + file + "\">";
            }).join('') : '') + ( // context.styles is a getter exposed by vue-style-loader which contains
            // the inline component styles collected during SSR
            context.styles || ''));
        };
        TemplateRenderer.prototype.renderResourceHints = function renderResourceHints(context) {
            return this.renderPreloadLinks(context) + this.renderPrefetchLinks(context);
        };
        TemplateRenderer.prototype.getPreloadFiles = function getPreloadFiles(context) {
            var usedAsyncFiles = this.getUsedAsyncFiles(context);
            if (this.preloadFiles || usedAsyncFiles) {
                return (this.preloadFiles || []).concat(usedAsyncFiles || []);
            }
            else {
                return [];
            }
        };
        TemplateRenderer.prototype.renderPreloadLinks = function renderPreloadLinks(context) {
            var this$1 = this;
            var files = this.getPreloadFiles(context);
            var shouldPreload = this.options.shouldPreload;
            if (files.length) {
                return files.map(function (ref) {
                    var file = ref.file;
                    var extension = ref.extension;
                    var fileWithoutQuery = ref.fileWithoutQuery;
                    var asType = ref.asType;
                    var extra = ''; // by default, we only preload scripts or css
                    if (!shouldPreload && asType !== 'script' && asType !== 'style') {
                        return '';
                    } // user wants to explicitly control what to preload
                    if (shouldPreload && !shouldPreload(fileWithoutQuery, asType)) {
                        return '';
                    }
                    if (asType === 'font') {
                        extra = " type=\"font/" + extension + "\" crossorigin";
                    }
                    return "<link rel=\"preload\" href=\"" + this$1.publicPath + file + "\"" + (asType !== '' ? " as=\"" + asType + "\"" : '') + extra + ">";
                }).join('');
            }
            else {
                return '';
            }
        };
        TemplateRenderer.prototype.renderPrefetchLinks = function renderPrefetchLinks(context) {
            var this$1 = this;
            var shouldPrefetch = this.options.shouldPrefetch;
            if (this.prefetchFiles) {
                var usedAsyncFiles = this.getUsedAsyncFiles(context);
                var alreadyRendered = function (file) {
                    return usedAsyncFiles && usedAsyncFiles.some(function (f) {
                        return f.file === file;
                    });
                };
                return this.prefetchFiles.map(function (ref) {
                    var file = ref.file;
                    var fileWithoutQuery = ref.fileWithoutQuery;
                    var asType = ref.asType;
                    if (shouldPrefetch && !shouldPrefetch(fileWithoutQuery, asType)) {
                        return '';
                    }
                    if (alreadyRendered(file)) {
                        return '';
                    }
                    return "<link rel=\"prefetch\" href=\"" + this$1.publicPath + file + "\">";
                }).join('');
            }
            else {
                return '';
            }
        };
        TemplateRenderer.prototype.renderState = function renderState(context, options) {
            var ref = options || {};
            var contextKey = ref.contextKey;
            if (contextKey === void 0)
                contextKey = 'state';
            var windowKey = ref.windowKey;
            if (windowKey === void 0)
                windowKey = '__INITIAL_STATE__';
            var state = this.serialize(context[contextKey]);
            var autoRemove = '';
            var nonceAttr = context.nonce ? " nonce=\"" + context.nonce + "\"" : '';
            return context[contextKey] ? "<script" + nonceAttr + ">window." + windowKey + "=" + state + autoRemove + "</script>" : '';
        };
        TemplateRenderer.prototype.renderScripts = function renderScripts(context) {
            var this$1 = this;
            if (this.clientManifest) {
                var initial = this.preloadFiles.filter(function (ref) {
                    var file = ref.file;
                    return isJS(file);
                });
                var async = (this.getUsedAsyncFiles(context) || []).filter(function (ref) {
                    var file = ref.file;
                    return isJS(file);
                });
                var needed = [initial[0]].concat(async, initial.slice(1));
                return needed.map(function (ref) {
                    var file = ref.file;
                    return "<script src=\"" + this$1.publicPath + file + "\" defer></script>";
                }).join('');
            }
            else {
                return '';
            }
        };
        TemplateRenderer.prototype.getUsedAsyncFiles = function getUsedAsyncFiles(context) {
            if (!context._mappedFiles && context._registeredComponents && this.mapFiles) {
                var registered = Array.from(context._registeredComponents);
                context._mappedFiles = this.mapFiles(registered).map(normalizeFile);
            }
            return context._mappedFiles;
        }; // create a transform stream
        TemplateRenderer.prototype.createStream = function createStream(context) {
            if (!this.parsedTemplate) {
                throw new Error('createStream cannot be called without a template.');
            }
            return new TemplateStream(this, this.parsedTemplate, context || {});
        };
        function normalizeFile(file) {
            var withoutQuery = file.replace(/\?.*/, '');
            var extension = path.extname(withoutQuery).slice(1);
            return {
                file: file,
                extension: extension,
                fileWithoutQuery: withoutQuery,
                asType: getPreloadType(extension)
            };
        }
        function getPreloadType(ext) {
            if (ext === 'js') {
                return 'script';
            }
            else if (ext === 'css') {
                return 'style';
            }
            else if (/jpe?g|png|svg|gif|webp|ico/.test(ext)) {
                return 'image';
            }
            else if (/woff2?|ttf|otf|eot/.test(ext)) {
                return 'font';
            }
            else {
                // not exhausting all possibilities here, but above covers common cases
                return '';
            }
        }
        /*  */
        function createRenderer(ref) {
            if (ref === void 0)
                ref = {};
            var modules = ref.modules;
            if (modules === void 0)
                modules = [];
            var directives = ref.directives;
            if (directives === void 0)
                directives = {};
            var isUnaryTag = ref.isUnaryTag;
            if (isUnaryTag === void 0)
                isUnaryTag = function () {
                    return false;
                };
            var template = ref.template;
            var inject = ref.inject;
            var cache = ref.cache;
            var shouldPreload = ref.shouldPreload;
            var shouldPrefetch = ref.shouldPrefetch;
            var clientManifest = ref.clientManifest;
            var serializer = ref.serializer;
            var render = createRenderFunction(modules, directives, isUnaryTag, cache);
            var templateRenderer = new TemplateRenderer({
                template: template,
                inject: inject,
                shouldPreload: shouldPreload,
                shouldPrefetch: shouldPrefetch,
                clientManifest: clientManifest,
                serializer: serializer
            });
            return {
                renderToString: function renderToString(component, context, cb) {
                    var assign;
                    if (typeof context === 'function') {
                        cb = context;
                        context = {};
                    }
                    if (context) {
                        templateRenderer.bindRenderFns(context);
                    } // no callback, return Promise
                    var promise;
                    if (!cb) {
                        assign = createPromiseCallback(), promise = assign.promise, cb = assign.cb;
                    }
                    var result = '';
                    var write = createWriteFunction(function (text) {
                        result += text;
                        return false;
                    }, cb);
                    try {
                        render(component, write, context, function (err) {
                            if (err) {
                                return cb(err);
                            }
                            if (context && context.rendered) {
                                context.rendered(context);
                            }
                            if (template) {
                                try {
                                    var res = templateRenderer.render(result, context);
                                    if (typeof res !== 'string') {
                                        // function template returning promise
                                        res.then(function (html) {
                                            return cb(null, html);
                                        }).catch(cb);
                                    }
                                    else {
                                        cb(null, res);
                                    }
                                }
                                catch (e) {
                                    cb(e);
                                }
                            }
                            else {
                                cb(null, result);
                            }
                        });
                    }
                    catch (e) {
                        cb(e);
                    }
                    return promise;
                },
                renderToStream: function renderToStream(component, context) {
                    if (context) {
                        templateRenderer.bindRenderFns(context);
                    }
                    var renderStream = new RenderStream(function (write, done) {
                        render(component, write, context, done);
                    });
                    if (!template) {
                        if (context && context.rendered) {
                            var rendered = context.rendered;
                            renderStream.once('beforeEnd', function () {
                                rendered(context);
                            });
                        }
                        return renderStream;
                    }
                    else if (typeof template === 'function') {
                        throw new Error("function template is only supported in renderToString.");
                    }
                    else {
                        var templateStream = templateRenderer.createStream(context);
                        renderStream.on('error', function (err) {
                            templateStream.emit('error', err);
                        });
                        renderStream.pipe(templateStream);
                        if (context && context.rendered) {
                            var rendered$1 = context.rendered;
                            renderStream.once('beforeEnd', function () {
                                rendered$1(context);
                            });
                        }
                        return templateStream;
                    }
                }
            };
        }
        var vm = vm_js_3.default;
        var path$1 = path_js_6.default;
        var resolve = npm_resolve_1_dew_2.dew();
        var NativeModule = _empty_js_4.default;
        function createSandbox(context) {
            var sandbox = {
                Buffer: Buffer,
                console: console,
                process: process,
                setTimeout: setTimeout,
                setInterval: setInterval,
                setImmediate: setImmediate,
                clearTimeout: clearTimeout,
                clearInterval: clearInterval,
                clearImmediate: clearImmediate,
                __VUE_SSR_CONTEXT__: context
            };
            sandbox.global = sandbox;
            return sandbox;
        }
        function compileModule(files, basedir, runInNewContext) {
            var compiledScripts = {};
            var resolvedModules = {};
            function getCompiledScript(filename) {
                if (compiledScripts[filename]) {
                    return compiledScripts[filename];
                }
                var code = files[filename];
                var wrapper = NativeModule.wrap(code);
                var script = new vm.Script(wrapper, {
                    filename: filename,
                    displayErrors: true
                });
                compiledScripts[filename] = script;
                return script;
            }
            function evaluateModule(filename, sandbox, evaluatedFiles) {
                if (evaluatedFiles === void 0)
                    evaluatedFiles = {};
                if (evaluatedFiles[filename]) {
                    return evaluatedFiles[filename];
                }
                var script = getCompiledScript(filename);
                var compiledWrapper = runInNewContext === false ? script.runInThisContext() : script.runInNewContext(sandbox);
                var m = {
                    exports: {}
                };
                var r = function (file) {
                    file = path$1.posix.join('.', file);
                    if (files[file]) {
                        return evaluateModule(file, sandbox, evaluatedFiles);
                    }
                    else if (basedir) {
                        return _nullRequire(resolvedModules[file] || (resolvedModules[file] = resolve.sync(file, {
                            basedir: basedir
                        })));
                    }
                    else {
                        return _nullRequire(file);
                    }
                };
                compiledWrapper.call(m.exports, m.exports, r, m);
                var res = Object.prototype.hasOwnProperty.call(m.exports, 'default') ? m.exports.default : m.exports;
                evaluatedFiles[filename] = res;
                return res;
            }
            return evaluateModule;
        }
        function deepClone(val) {
            if (isPlainObject(val)) {
                var res = {};
                for (var key in val) {
                    res[key] = deepClone(val[key]);
                }
                return res;
            }
            else if (Array.isArray(val)) {
                return val.slice();
            }
            else {
                return val;
            }
        }
        function createBundleRunner(entry, files, basedir, runInNewContext) {
            var evaluate = compileModule(files, basedir, runInNewContext);
            if (runInNewContext !== false && runInNewContext !== 'once') {
                // new context mode: creates a fresh context and re-evaluate the bundle
                // on each render. Ensures entire application state is fresh for each
                // render, but incurs extra evaluation cost.
                return function (userContext) {
                    if (userContext === void 0)
                        userContext = {};
                    return new Promise(function (resolve) {
                        userContext._registeredComponents = new Set();
                        var res = evaluate(entry, createSandbox(userContext));
                        resolve(typeof res === 'function' ? res(userContext) : res);
                    });
                };
            }
            else {
                // direct mode: instead of re-evaluating the whole bundle on
                // each render, it simply calls the exported function. This avoids the
                // module evaluation costs but requires the source code to be structured
                // slightly differently.
                var runner; // lazy creation so that errors can be caught by user
                var initialContext;
                return function (userContext) {
                    if (userContext === void 0)
                        userContext = {};
                    return new Promise(function (resolve) {
                        if (!runner) {
                            var sandbox = runInNewContext === 'once' ? createSandbox() : _global; // the initial context is only used for collecting possible non-component
                            // styles injected by vue-style-loader.
                            initialContext = sandbox.__VUE_SSR_CONTEXT__ = {};
                            runner = evaluate(entry, sandbox); // On subsequent renders, __VUE_SSR_CONTEXT__ will not be available
                            // to prevent cross-request pollution.
                            delete sandbox.__VUE_SSR_CONTEXT__;
                            if (typeof runner !== 'function') {
                                throw new Error('bundle export should be a function when using ' + '{ runInNewContext: false }.');
                            }
                        }
                        userContext._registeredComponents = new Set(); // vue-style-loader styles imported outside of component lifecycle hooks
                        if (initialContext._styles) {
                            userContext._styles = deepClone(initialContext._styles); // #6353 ensure "styles" is exposed even if no styles are injected
                            // in component lifecycles.
                            // the renderStyles fn is exposed by vue-style-loader >= 3.0.3
                            var renderStyles = initialContext._renderStyles;
                            if (renderStyles) {
                                Object.defineProperty(userContext, 'styles', {
                                    enumerable: true,
                                    get: function get() {
                                        return renderStyles(userContext._styles);
                                    }
                                });
                            }
                        }
                        resolve(runner(userContext));
                    });
                };
            }
        }
        /*  */
        var SourceMapConsumer = npm_source_map_0_5_6_dew_2.dew().SourceMapConsumer;
        var filenameRE = /\(([^)]+\.js):(\d+):(\d+)\)$/;
        function createSourceMapConsumers(rawMaps) {
            var maps = {};
            Object.keys(rawMaps).forEach(function (file) {
                maps[file] = new SourceMapConsumer(rawMaps[file]);
            });
            return maps;
        }
        function rewriteErrorTrace(e, mapConsumers) {
            if (e && typeof e.stack === 'string') {
                e.stack = e.stack.split('\n').map(function (line) {
                    return rewriteTraceLine(line, mapConsumers);
                }).join('\n');
            }
        }
        function rewriteTraceLine(trace, mapConsumers) {
            var m = trace.match(filenameRE);
            var map = m && mapConsumers[m[1]];
            if (m != null && map) {
                var originalPosition = map.originalPositionFor({
                    line: Number(m[2]),
                    column: Number(m[3])
                });
                if (originalPosition.source != null) {
                    var source = originalPosition.source;
                    var line = originalPosition.line;
                    var column = originalPosition.column;
                    var mappedPosition = "(" + source.replace(/^webpack:\/\/\//, '') + ":" + String(line) + ":" + String(column) + ")";
                    return trace.replace(filenameRE, mappedPosition);
                }
                else {
                    return trace;
                }
            }
            else {
                return trace;
            }
        }
        /*  */
        var fs = _empty_js_4.default;
        var path$2 = path_js_6.default;
        var PassThrough = stream_js_3.default.PassThrough;
        var INVALID_MSG = 'Invalid server-rendering bundle format. Should be a string ' + 'or a bundle Object of type:\n\n' + "{\n  entry: string;\n  files: { [filename: string]: string; };\n  maps: { [filename: string]: string; };\n}\n"; // The render bundle can either be a string (single bundled file)
        // or a bundle manifest object generated by vue-ssr-webpack-plugin.
        function createBundleRendererCreator(createRenderer) {
            return function createBundleRenderer(bundle, rendererOptions) {
                if (rendererOptions === void 0)
                    rendererOptions = {};
                var files, entry, maps;
                var basedir = rendererOptions.basedir; // load bundle if given filepath
                if (typeof bundle === 'string' && /\.js(on)?$/.test(bundle) && path$2.isAbsolute(bundle)) {
                    if (fs.existsSync(bundle)) {
                        var isJSON = /\.json$/.test(bundle);
                        basedir = basedir || path$2.dirname(bundle);
                        bundle = fs.readFileSync(bundle, 'utf-8');
                        if (isJSON) {
                            try {
                                bundle = JSON.parse(bundle);
                            }
                            catch (e) {
                                throw new Error("Invalid JSON bundle file: " + bundle);
                            }
                        }
                    }
                    else {
                        throw new Error("Cannot locate bundle file: " + bundle);
                    }
                }
                if (typeof bundle === 'object') {
                    entry = bundle.entry;
                    files = bundle.files;
                    basedir = basedir || bundle.basedir;
                    maps = createSourceMapConsumers(bundle.maps);
                    if (typeof entry !== 'string' || typeof files !== 'object') {
                        throw new Error(INVALID_MSG);
                    }
                }
                else if (typeof bundle === 'string') {
                    entry = '__vue_ssr_bundle__';
                    files = {
                        '__vue_ssr_bundle__': bundle
                    };
                    maps = {};
                }
                else {
                    throw new Error(INVALID_MSG);
                }
                var renderer = createRenderer(rendererOptions);
                var run = createBundleRunner(entry, files, basedir, rendererOptions.runInNewContext);
                return {
                    renderToString: function (context, cb) {
                        var assign;
                        if (typeof context === 'function') {
                            cb = context;
                            context = {};
                        }
                        var promise;
                        if (!cb) {
                            assign = createPromiseCallback(), promise = assign.promise, cb = assign.cb;
                        }
                        run(context).catch(function (err) {
                            rewriteErrorTrace(err, maps);
                            cb(err);
                        }).then(function (app) {
                            if (app) {
                                renderer.renderToString(app, context, function (err, res) {
                                    rewriteErrorTrace(err, maps);
                                    cb(err, res);
                                });
                            }
                        });
                        return promise;
                    },
                    renderToStream: function (context) {
                        var res = new PassThrough();
                        run(context).catch(function (err) {
                            rewriteErrorTrace(err, maps); // avoid emitting synchronously before user can
                            // attach error listener
                            process.nextTick(function () {
                                res.emit('error', err);
                            });
                        }).then(function (app) {
                            if (app) {
                                var renderStream = renderer.renderToStream(app, context);
                                renderStream.on('error', function (err) {
                                    rewriteErrorTrace(err, maps);
                                    res.emit('error', err);
                                }); // relay HTMLStream special events
                                if (rendererOptions && rendererOptions.template) {
                                    renderStream.on('beforeStart', function () {
                                        res.emit('beforeStart');
                                    });
                                    renderStream.on('beforeEnd', function () {
                                        res.emit('beforeEnd');
                                    });
                                }
                                renderStream.pipe(res);
                            }
                        });
                        return res;
                    }
                };
            };
        }
        /*  */
        process.env.VUE_ENV = 'server';
        function createRenderer$1(options) {
            if (options === void 0)
                options = {};
            return createRenderer(extend(extend({}, options), {
                isUnaryTag: isUnaryTag,
                canBeLeftOpenTag: canBeLeftOpenTag,
                modules: modules,
                // user can provide server-side implementations for custom directives
                // when creating the renderer.
                directives: extend(baseDirectives, options.directives)
            }));
        }
        var createBundleRenderer = createBundleRendererCreator(createRenderer$1);
        exports.createRenderer = createRenderer$1;
        exports.createBundleRenderer = createBundleRenderer;
        return exports;
    }
    exports_125("dew", dew);
    return {
        setters: [
            function (npm_he_1_dew_2_1) {
                npm_he_1_dew_2 = npm_he_1_dew_2_1;
            },
            function (stream_js_3_1) {
                stream_js_3 = stream_js_3_1;
            },
            function (npm_lodash_template_4_dew_2_1) {
                npm_lodash_template_4_dew_2 = npm_lodash_template_4_dew_2_1;
            },
            function (path_js_6_1) {
                path_js_6 = path_js_6_1;
            },
            function (npm_serialize_javascript_2_dew_2_1) {
                npm_serialize_javascript_2_dew_2 = npm_serialize_javascript_2_dew_2_1;
            },
            function (vm_js_3_1) {
                vm_js_3 = vm_js_3_1;
            },
            function (npm_resolve_1_dew_2_1) {
                npm_resolve_1_dew_2 = npm_resolve_1_dew_2_1;
            },
            function (_empty_js_4_1) {
                _empty_js_4 = _empty_js_4_1;
            },
            function (npm_source_map_0_5_6_dew_2_1) {
                npm_source_map_0_5_6_dew_2 = npm_source_map_0_5_6_dew_2_1;
            },
            function (process_js_7_1) {
                process_js_7 = process_js_7_1;
            },
            function (buffer_js_5_1) {
                buffer_js_5 = buffer_js_5_1;
            }
        ],
        execute: function () {
            exports = {}, _dewExec = false;
            _global = typeof self !== "undefined" ? self : global;
        }
    };
});
System.register("file:///Users/norbert/Documents/workspace/deno/deno-ssr/vue-server-render/index", ["file:///Users/norbert/Documents/workspace/deno/deno-ssr/vue-server-render/index.dew", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/@empty.dew", "https://dev.jspm.io/npm:vue-server-renderer@2.6.11/package.json.dew", "https://dev.jspm.io/npm:vue-server-renderer@2.6.11/build.dev.dew", "https://dev.jspm.io/npm:he@1?dew", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/stream", "https://dev.jspm.io/npm:lodash.template@4?dew", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/path", "https://dev.jspm.io/npm:serialize-javascript@2?dew", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/vm", "https://dev.jspm.io/npm:resolve@1?dew", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/@empty", "https://dev.jspm.io/npm:source-map@0.5.6?dew", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/process", "https://dev.jspm.io/npm:@jspm/core@1/nodelibs/buffer"], function (exports_126, context_126) {
    "use strict";
    var index_dew_js_7;
    var __moduleName = context_126 && context_126.id;
    return {
        setters: [
            function (index_dew_js_7_1) {
                index_dew_js_7 = index_dew_js_7_1;
            },
            function (_42) {
            },
            function (_43) {
            },
            function (_44) {
            },
            function (_45) {
            },
            function (_46) {
            },
            function (_47) {
            },
            function (_48) {
            },
            function (_49) {
            },
            function (_50) {
            },
            function (_51) {
            },
            function (_52) {
            },
            function (_53) {
            },
            function (_54) {
            },
            function (_55) {
            }
        ],
        execute: function () {
            exports_126("default", index_dew_js_7.dew());
        }
    };
});
System.register("file:///Users/norbert/Documents/workspace/deno/deno-ssr/deps", ["file:///Users/norbert/Documents/workspace/deno/deno-ssr/vue/vue", "file:///Users/norbert/Documents/workspace/deno/deno-ssr/vue-server-render/index"], function (exports_127, context_127) {
    "use strict";
    var __moduleName = context_127 && context_127.id;
    return {
        setters: [
            function (vue_js_1_1) {
                exports_127({
                    "Vue": vue_js_1_1["default"]
                });
            },
            function (index_js_1_1) {
                exports_127({
                    "VueServerRenderer": index_js_1_1["default"]
                });
            }
        ],
        execute: function () {
        }
    };
});
System.register("file:///Users/norbert/Documents/workspace/deno/deno-ssr/app", ["file:///Users/norbert/Documents/workspace/deno/deno-ssr/deps"], function (exports_128, context_128) {
    "use strict";
    var deps_ts_16, App;
    var __moduleName = context_128 && context_128.id;
    return {
        setters: [
            function (deps_ts_16_1) {
                deps_ts_16 = deps_ts_16_1;
            }
        ],
        execute: function () {
            // @ts-ignore
            App = new deps_ts_16.Vue({
                template: `<div id="app">
    <h1>{{count}}</h1>
    <button v-on:click="inCrease">inCrease</button>
    <ol>
      <li v-for="todo in todos">
        {{ todo.text }}
      </li>
    </ol>
  </div>`,
                data: {
                    count: 0,
                    todos: [{ text: ' JavaScript' }, { text: ' Vue' }, { text: '' }],
                },
                methods: {
                    inCrease: function () {
                        // @ts-ignore
                        this.count++;
                    },
                },
            });
            exports_128("default", App);
        }
    };
});
System.register("file:///Users/norbert/Documents/workspace/deno/deno-ssr/router", ["file:///Users/norbert/Documents/workspace/deno/deno-ssr/deps", "file:///Users/norbert/Documents/workspace/deno/deno-ssr/app"], function (exports_129, context_129) {
    "use strict";
    var deps_ts_17, app_tsx_1;
    var __moduleName = context_129 && context_129.id;
    async function init(router) {
        const browserBundlePath = '/browser.js';
        // @ts-ignore
        const renderer = deps_ts_17.VueServerRenderer.createRenderer();
        const js = `
	import "https://cdn.jsdelivr.net/npm/vue/dist/vue.js";
	const App = new Vue({
		template: \`<div id="app-4">
		<h1>{{count}}</h1>
		<button v-on:click="inCrease">inCrease</button>
		<ol>
		  <li v-for="todo in todos">
			{{ todo.text }}
		  </li>
		</ol>
	  </div>\`,
		el: '#app',
		data: {
			count: 0,
			todos: [{ text: ' JavaScript' }, { text: ' Vue' }, { text: '' }],
		},
		methods: {
			inCrease: function () {
				// @ts-ignore
				this.count++;
			},
		},
	});`;
        const content = await renderer.renderToString(app_tsx_1.default);
        const html = `<html><head><style>* { font-family: Helvetica; }</style><script type="module" src="${browserBundlePath}"></script></head><body>${content}</body></html>`;
        router.get(browserBundlePath, async ({ request, response }) => {
            response.body = js;
            response.type = 'application/javascript';
        });
        router.get('/home', async ({ request, response }) => {
            response.body = html;
        });
    }
    exports_129("init", init);
    return {
        setters: [
            function (deps_ts_17_1) {
                deps_ts_17 = deps_ts_17_1;
            },
            function (app_tsx_1_1) {
                app_tsx_1 = app_tsx_1_1;
            }
        ],
        execute: function () {
        }
    };
});
System.register("file:///Users/norbert/Documents/workspace/deno/deno-ssr/server", ["https://linweiwei123.github.io/aok/mod", "file:///Users/norbert/Documents/workspace/deno/deno-ssr/router"], function (exports_130, context_130) {
    "use strict";
    var mod_ts_12, router_tsx_1, env, PORT, HOST, router, app;
    var __moduleName = context_130 && context_130.id;
    return {
        setters: [
            function (mod_ts_12_1) {
                mod_ts_12 = mod_ts_12_1;
            },
            function (router_tsx_1_1) {
                router_tsx_1 = router_tsx_1_1;
            }
        ],
        execute: async function () {
            env = Deno.env.toObject();
            PORT = env.PORT || 4000;
            HOST = env.HOST || "127.0.0.1";
            router = new mod_ts_12.Router();
            router_tsx_1.init(router);
            app = new mod_ts_12.Application();
            app.use(router.routes());
            app.use(router.allowedMethods());
            console.log(`Listening on port ${PORT}...`);
            await app.listen(`${HOST}:${PORT}`);
            console.log("React SSR App listening on port 3000");
        }
    };
});

await __instantiateAsync("file:///Users/norbert/Documents/workspace/deno/deno-ssr/server");
